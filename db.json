{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/images/logo.gif","path":"images/logo.gif","modified":0,"renderable":0},{"_id":"source/images/my_head.jpeg","path":"images/my_head.jpeg","modified":0,"renderable":0},{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":0,"renderable":0},{"_id":"source/images/git_icon.jpg","path":"images/git_icon.jpg","modified":0,"renderable":0},{"_id":"source/images/浏览器缓存.png","path":"images/浏览器缓存.png","modified":0,"renderable":0},{"_id":"themes/git_them/source/css/base.styl","path":"css/base.styl","modified":0,"renderable":1},{"_id":"themes/git_them/source/css/calendar.styl","path":"css/calendar.styl","modified":0,"renderable":1},{"_id":"themes/git_them/source/css/code.styl","path":"css/code.styl","modified":0,"renderable":1},{"_id":"themes/git_them/source/css/footer.styl","path":"css/footer.styl","modified":0,"renderable":1},{"_id":"themes/git_them/source/css/header.styl","path":"css/header.styl","modified":0,"renderable":1},{"_id":"themes/git_them/source/css/main.css","path":"css/main.css","modified":0,"renderable":1},{"_id":"themes/git_them/source/js/main.js","path":"js/main.js","modified":0,"renderable":1},{"_id":"themes/git_them/source/css/navbar.styl","path":"css/navbar.styl","modified":0,"renderable":1},{"_id":"themes/git_them/source/css/post.styl","path":"css/post.styl","modified":0,"renderable":1},{"_id":"themes/git_them/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1}],"Cache":[{"_id":"themes/git_them/.gitignore","hash":"ffe69ab56d287f7d1a2b18a8a7640a5efbd5f9e0","modified":1598181853474},{"_id":"themes/git_them/LICENSE","hash":"a1cf5f06cb8d77978388bddfbbcc9ab9b5017fb0","modified":1598181853474},{"_id":"themes/git_them/README.md","hash":"69ec66dbd50d4e73663a4476cf83d02e24b54442","modified":1598181853475},{"_id":"themes/git_them/_config.yml","hash":"d174e6b3354b122c148ec0bf3afb0e7825bf44a0","modified":1615820150753},{"_id":"source/_posts/[ES6]Set&Map.md","hash":"f3784c9dff10ffc4847602c3ec3a13c183d84ed3","modified":1615819040260},{"_id":"source/_posts/[ES6]Symbol.md","hash":"0f13700453ad014cedd0df718e397260e0fe4a8e","modified":1615819046306},{"_id":"source/_posts/[ES6]async-await.md","hash":"a184946ebb3e359f3ad07492ce93cd9437eee009","modified":1615819021927},{"_id":"source/_posts/[ES6]class.md","hash":"74b0ebc99e0198ab702f7dd29c79ed9767d5d3c2","modified":1615819028242},{"_id":"source/_posts/[ES6]promise.md","hash":"b1a64ec39f41c19286906d6028512b696f5fe7af","modified":1615819034281},{"_id":"source/_posts/[ES6]代理-Proxy-与反射-Reflection.md","hash":"f978ed37b788fb7b9945e49ed13d6e59e9f3e4dd","modified":1615818975759},{"_id":"source/_posts/[ES6]函数.md","hash":"d44fafd15b9518b40b923ff42978c287a038a86c","modified":1615818994777},{"_id":"source/_posts/[ES6]扩展对象属性.md","hash":"4d3a654d3a01a13e4daf997007d3965993192948","modified":1615819009088},{"_id":"source/_posts/[ES6]模块化.md","hash":"c26cd454b73f820ed84ea929bd5feae0d6811d05","modified":1615819015378},{"_id":"source/_posts/[ES6]改进数组功能.md","hash":"46b57049dbed600a214f5d127e7882e3f9baaf63","modified":1615818987281},{"_id":"source/_posts/[ES6]迭代器iterator&生成器generator.md","hash":"1a5ba8d4ea0124147411ef98c24224ac114f86e4","modified":1615818981633},{"_id":"source/_posts/[ES6]解构.md","hash":"d5a7b9d8bb3959ebee6f89206671e3657b2cfbe1","modified":1615819000988},{"_id":"source/_posts/[css]flexible布局以及1px边框解决方案.md","hash":"4e6142beed53996a0a3aca2b37693744264c249d","modified":1598181853460},{"_id":"source/_posts/[css]postcss相关.md","hash":"77662a819cae10e6e80bc2931e961b1e39338cd2","modified":1598181853463},{"_id":"source/_posts/[css]translateY-实现列表hover的box-shadow动画.md","hash":"bd45cf34481e101cde881bd423fc3b1ef42607de","modified":1615818969545},{"_id":"source/_posts/[css]动画相关.md","hash":"94439d94589a07ebafdefbbfc92ce45978c6c6ca","modified":1598181853460},{"_id":"source/_posts/[css]视口概念.md","hash":"b74223c9d40ad0d26942e6943a3c61711e984e72","modified":1615818945582},{"_id":"source/_posts/[css]选择器.md","hash":"345fd7cc03854962ae34c30b25544816172fe4ea","modified":1615818951436},{"_id":"source/_posts/[js]eventLoop.md","hash":"736714212ad2a190677ae4c91a58f48acfb0da69","modified":1615819169261},{"_id":"source/_posts/[js]decimal处理数字问题.md","hash":"1957b38fd4726e4453f372aed4b3e94e6e61b50b","modified":1615819161377},{"_id":"source/_posts/[js]file相关.md","hash":"53a3e3a0b5199a1993cf3affb4faa084048bf382","modified":1615819175080},{"_id":"source/_posts/[js]scroll相关.md","hash":"7c2cd05db845372cd57ca1f8b2f58457ef890730","modified":1615819206537},{"_id":"source/_posts/[js]你不知道的js学习笔记.md","hash":"48228b2dad91350c57df8ed2fb2f617431fe5136","modified":1598181853467},{"_id":"source/_posts/[js]一些前端dom取值.md","hash":"bab8ef1cdfcb04fc65a4f90b28854ea0c780aee3","modified":1615819134402},{"_id":"source/_posts/[js]平滑生成大量div方法.md","hash":"2ae758bcaf666c9d3c3d450a4ad05761892e3f6b","modified":1598181853467},{"_id":"source/_posts/[js]数据类型.md","hash":"6bedc530ada0c31f789d6dd471ee9d790ea7e8cb","modified":1615819123132},{"_id":"source/_posts/[js]深浅拷贝.md","hash":"045e0950bfe66e82cfcea7b340bf7d99aa8e1e77","modified":1615819116320},{"_id":"source/_posts/[js]正则表达式.md","hash":"2b8ae8d3f98f939a282d7f7b55094da138c3f1b8","modified":1615819140455},{"_id":"source/_posts/[js]节流与防抖.md","hash":"43268702f46715eb2e08c7e72d445b875808ee98","modified":1615819058505},{"_id":"source/_posts/[js]类型.md","hash":"60d24e96eb62aa3dfc183bc3211fd91b501f49d0","modified":1615819064651},{"_id":"source/_posts/[react]react-router实现原理.md","hash":"bd20c039c8ffc880fb1c0eb34c49ea297d658910","modified":1615819236018},{"_id":"source/_posts/[react]redux实现原理.md","hash":"cc7ccee98c91277bd1f20a7c8e87009e400028a1","modified":1615819247204},{"_id":"source/_posts/[react]学习笔记.md","hash":"c4c5e3c57a568ed33b0c9e06d56307f99c830544","modified":1615819230419},{"_id":"source/_posts/[webpack]CommonsChunkPlugin与optimization-splitChunks.md","hash":"fbdf3e7f728406fbab404542fda8cbf024a3949e","modified":1615819273384},{"_id":"source/_posts/[webpack]搭建环境以及相关优化.md","hash":"8bb7f5158b36c2152693daecb4bda13616109a1d","modified":1615819252497},{"_id":"source/_posts/[webpack]打包文件相关.md","hash":"405f8bbea580ff263e7341419a7bfe49931cd4fc","modified":1615819257629},{"_id":"source/_posts/[webpack]简介以及相关概念.md","hash":"085b85a46c662220ee2eb031a5043c0b82df2ede","modified":1615819262946},{"_id":"source/_posts/[webpack]配置全局常量.md","hash":"e130a866dce95b204510373f96f6c92d3ae40fc6","modified":1615819268185},{"_id":"source/_posts/[浏览器]浏览器缓存.md","hash":"b26015691fceabe81bd96c1bc255bd80903e9f78","modified":1615818895420},{"_id":"source/_posts/[算法]一些算法.md","hash":"2b3486d49f6605b86fcbb5efbd1f0b581a83dd80","modified":1598181853466},{"_id":"source/_posts/babel生态.md","hash":"adbe3ba5a768835deaf615e1b5c5b51cf6ad9747","modified":1615253224817},{"_id":"source/_posts/docker常用命令.md","hash":"1268b63fbd39c647458d7e4225235ef777af7acd","modified":1615252294659},{"_id":"source/_posts/git-使用.md","hash":"762f79a35a373ba25a514bdf3519586b3f21c1e2","modified":1615253243538},{"_id":"source/_posts/linux基础操作.md","hash":"db016dceda5437f72ff166f2e8d0aad8998fbafc","modified":1598228121585},{"_id":"source/_posts/npm使用.md","hash":"2ba30e1b9821841057ef80343d6808c454d47769","modified":1615252099253},{"_id":"source/_posts/pm2使用.md","hash":"0f287f02f9d43f7e745683a2d43a613a22a3e926","modified":1615252577625},{"_id":"source/_posts/yarn使用.md","hash":"29ebeca2841b0b418982ca0382f3ce9f78ce45d1","modified":1615252140996},{"_id":"source/categories/index.md","hash":"acbfb7450f60d2a9c61d2f4c106c92fd0ba86aa6","modified":1598181853469},{"_id":"source/_posts/创建Hexo-github博客流程.md","hash":"e0521f07678b89dbc8742d6a86694538b07fb9ca","modified":1615817399713},{"_id":"source/_posts/性能优化.md","hash":"be5f8f2e5fe3eb1299c9701b578e97370e358c94","modified":1598181853468},{"_id":"source/images/logo.gif","hash":"10572efb24a57b3818a2cd6004c9b8e6e8223bbc","modified":1598181853471},{"_id":"source/images/my_head.jpeg","hash":"d390c0b494a9dda39f25540bf08e5cf021b244f7","modified":1598181853472},{"_id":"source/tags/index.md","hash":"360f558f5f67ea3e7527f595d0145e4145d4032c","modified":1598181853473},{"_id":"themes/git_them/layout/archive.ejs","hash":"601baefd1b873ab34d5d91ebe5b44ffeb06e996e","modified":1598181853480},{"_id":"themes/git_them/layout/index.ejs","hash":"e78bc215749df2ec7aea1335585c8841d980ac90","modified":1598181853480},{"_id":"themes/git_them/layout/layout.ejs","hash":"8db3ebfe3e96f31e81a8f548f7e480a09c9bdb2f","modified":1598181853480},{"_id":"themes/git_them/layout/page.ejs","hash":"0c4ef00c7bf1e6ed484c1737968b7873c0ddd4b5","modified":1598181853480},{"_id":"source/search/index.md","hash":"56574617d665cc968a27792bc319479b2b2f530f","modified":1598181853473},{"_id":"themes/git_them/layout/post.ejs","hash":"0e8ace79c58c7dd61aa6bfda144f30fb4a41e195","modified":1598181853480},{"_id":"themes/git_them/test/main.test.js","hash":"46c199b8d73f9b9b0989be5f91440379213f73f4","modified":1598181853486},{"_id":"source/images/favicon.ico","hash":"2f09f7d3759d6aa21960878df30abc43ade67814","modified":1598181853470},{"_id":"source/images/git_icon.jpg","hash":"eec74bf82b2d730da0f3abd6bfa804e47cdbc4e1","modified":1598181853471},{"_id":"source/images/浏览器缓存.png","hash":"b10df7f3685800a6f53e98b7c0d404df98565bb8","modified":1598181853472},{"_id":"themes/git_them/layout/_partial/calendar.ejs","hash":"771a298eb762b8fbb2088e89c0252fc274e3b33b","modified":1598181853476},{"_id":"themes/git_them/layout/_partial/footer.ejs","hash":"968f3e77dde792c1e200d8e1c6c5fb7b311f3053","modified":1598181853476},{"_id":"themes/git_them/layout/_partial/article.ejs","hash":"6460bb34dacef596e5f703c1c9fcd672b0ead590","modified":1598181853476},{"_id":"themes/git_them/layout/_partial/head.ejs","hash":"6e45abc7c1fe44d4589ab2b0628de16f6b6fe872","modified":1598181853476},{"_id":"themes/git_them/layout/_partial/header.ejs","hash":"fd914611f174230972ae0848a363cf6ce2a23f3b","modified":1598181853477},{"_id":"themes/git_them/layout/_partial/intro.ejs","hash":"5f1278593f6720db796c70c8ed95cff30934d896","modified":1598181853477},{"_id":"themes/git_them/layout/_partial/navbar-secondary.ejs","hash":"34079704639e4492cd0d28b69d13a9a0b8722203","modified":1615820406661},{"_id":"themes/git_them/layout/_widget/baidutongji.ejs","hash":"6918080f6fa6f9729e6820bc0173e6d6e8629016","modified":1598181853479},{"_id":"themes/git_them/layout/_partial/navbar.ejs","hash":"c78dd30dafabdf81855b0f32ce8dd4dc39a0ace3","modified":1598181853478},{"_id":"themes/git_them/layout/_partial/script.ejs","hash":"c04b4df00b1eb03ed28ea0395a0caa295c86f6f7","modified":1598181853478},{"_id":"themes/git_them/layout/_partial/toc.ejs","hash":"14cb3f310ac4a612c85c81deddcaf977f96aa318","modified":1598181853478},{"_id":"themes/git_them/layout/_widget/disqus.ejs","hash":"d9e7e3751c29477ad9e8e02e56002f67cd866746","modified":1598181853479},{"_id":"themes/git_them/layout/_widget/gitalk.ejs","hash":"4d868363c1b73bf5955922f8e21b2b6ed07ac7d8","modified":1598181853479},{"_id":"themes/git_them/layout/_widget/google-custom-search.ejs","hash":"c89949b1c69b0eecddaf17cb3426ce71d925c24f","modified":1598181853480},{"_id":"themes/git_them/layout/_widget/google-analytics.ejs","hash":"b7e0ac2354921bddfd878afee2bf6c370a85cb92","modified":1598181853479},{"_id":"themes/git_them/source/css/_reset.styl","hash":"79dfac4710a21f53177135ac599a09cb7961f10a","modified":1598181853481},{"_id":"themes/git_them/source/css/_variables.styl","hash":"5673284a37b7a3420e5882d1a5c0f18eadcdf2b9","modified":1598181853481},{"_id":"themes/git_them/source/css/base.styl","hash":"a7dd1a9e038c194fde3981b490b1780d1c46bfa1","modified":1598181853481},{"_id":"themes/git_them/source/css/calendar.styl","hash":"ae53212c78c7acd879b29877333b01b694f03bc8","modified":1598181853482},{"_id":"themes/git_them/source/css/code.styl","hash":"075d9d62a241b1f07a9b66bce566ba6b68ee2b5d","modified":1598181853482},{"_id":"themes/git_them/source/css/footer.styl","hash":"cf30229884bf65c5fbc58b07c4e2415c342f0b72","modified":1598181853482},{"_id":"themes/git_them/source/css/header.styl","hash":"c42698cf9dd930e77c39bc24bd6b4160a2da6e85","modified":1598181853483},{"_id":"themes/git_them/source/css/main.css","hash":"70d30f40eb8c25dcf8888bf1025a15cd99bcec05","modified":1598181853483},{"_id":"themes/git_them/source/js/main.js","hash":"082bdf2dca4815433be2a5131ce67d528f7ffdea","modified":1598181853484},{"_id":"themes/git_them/source/css/navbar.styl","hash":"e8f5de83d3c699eeee836a05a104a0f886c48a36","modified":1598181853484},{"_id":"themes/git_them/source/css/post.styl","hash":"dae60ea7f1d8c98c75f822d9772692bf1101bd7b","modified":1598181853484},{"_id":"themes/git_them/source/css/main.styl","hash":"819bfbba6f6b76af16ec27fa74bea9b239432007","modified":1615263917141},{"_id":"public/categories/index.html","hash":"3b0e21e20099e17ee993d4b971d8a0531371a832","modified":1615820473075},{"_id":"public/search/index.html","hash":"a6e30df7c644a61cd99883c14c1717a110e0e7b7","modified":1615820473075},{"_id":"public/2019/04/20/[css]选择器/index.html","hash":"0083eba88b3c6d78c4ffb808b8267ca31fd6a6b0","modified":1615819348909},{"_id":"public/archives/page/4/index.html","hash":"ad3bc113a6dfba4b6fc66ec25bf214c3c8426e78","modified":1615820473075},{"_id":"public/archives/2017/index.html","hash":"1c0f1205c8b580eb5d1280e2ec6e9b72ff3add93","modified":1615820473075},{"_id":"public/archives/2017/08/index.html","hash":"1c0f1205c8b580eb5d1280e2ec6e9b72ff3add93","modified":1615820473075},{"_id":"public/archives/2018/09/index.html","hash":"f795e1116060b69ee4b68b401b1f520a617190a9","modified":1615820473075},{"_id":"public/archives/2018/10/index.html","hash":"6522d44eeb00fdd6987d4215a8b1d18a5def727c","modified":1615820473075},{"_id":"public/archives/2020/07/index.html","hash":"8ac2307015962db65f512b44e8623861bd76f643","modified":1615820473075},{"_id":"public/archives/2020/08/index.html","hash":"4b05ee976a7fbd9189301c0e4d42fbf5dd5be068","modified":1615820473075},{"_id":"public/archives/2020/09/index.html","hash":"ead088d2aa820df48567b16f3eb5ec1b4ef5423e","modified":1615820473075},{"_id":"public/archives/2020/10/index.html","hash":"20750e1aa5641692ebef6b60eede14727d6ca752","modified":1615820473075},{"_id":"public/archives/2020/12/index.html","hash":"4dadbe5162b298268c26f8dc673fb57301ae7ce2","modified":1615820473075},{"_id":"public/archives/2021/index.html","hash":"91e1293a608f377907225908217bbf4ef3e51710","modified":1615820473075},{"_id":"public/archives/2021/03/index.html","hash":"e18800b9f9d040c9725a5b714ab368f3916ab805","modified":1615820473075},{"_id":"public/categories/flexible/index.html","hash":"20c21987e136cd8bc66992bcd780cc9bfeeb12bf","modified":1615820473075},{"_id":"public/categories/postcss/index.html","hash":"1f9b72b6d0ff9636bbfb06d709c3411b3676c5fc","modified":1615820473075},{"_id":"public/categories/视口/index.html","hash":"d64a143b2376220b2c5b9849619d54aab4380175","modified":1615820473075},{"_id":"public/categories/decimal/index.html","hash":"5c4e4cc665b3cc16e0ab0a0d9b66f61017bd4791","modified":1615820473075},{"_id":"public/categories/file/index.html","hash":"9ffa1ddfe94a99c4c9d8605d36e862c5c99f5102","modified":1615820473075},{"_id":"public/categories/scroll/index.html","hash":"5d2d19aa6bca9c5d96bf2c5ace371d2f7cda7982","modified":1615820473075},{"_id":"public/categories/DOM取值/index.html","hash":"9498346a96d625e356ed1a0f2bfa9651ad6f680e","modified":1615820473075},{"_id":"public/categories/算法/index.html","hash":"f3c6c2e4471bfdec27f8110d0780c6a26ff7aa59","modified":1615820473075},{"_id":"public/categories/缓存/index.html","hash":"06ad1f29cfe289405d36f027ce763845b67755b7","modified":1615820473075},{"_id":"public/categories/docker/index.html","hash":"f1f4da1da42cc94a15b75d4a15c0f63970e2f7d4","modified":1615820473075},{"_id":"public/categories/git/index.html","hash":"2844b9f1d917e5ae66cf32ca59fae1eb0de89c1f","modified":1615820473075},{"_id":"public/categories/linux/index.html","hash":"82adafa0feddfeb864dace7d71d820aceb3810db","modified":1615820473075},{"_id":"public/categories/npm/index.html","hash":"af090a7a080ad285437d66fa74b4def0cc786404","modified":1615820473075},{"_id":"public/categories/yarn/index.html","hash":"f621efddf8948ed8f515ec9ecdd39f35eaa51903","modified":1615820473075},{"_id":"public/categories/node/index.html","hash":"f25b1b4ecdaef9ff24d55cde2edabec85364484b","modified":1615820473075},{"_id":"public/categories/hexo/index.html","hash":"190838702cd10bb6b41dd38f9da35c9b7b4b91ff","modified":1615820473075},{"_id":"public/categories/性能优化/index.html","hash":"cde8b153675ddd545c1aa19660113cedc9f2b335","modified":1615820473075},{"_id":"public/tags/async-await/index.html","hash":"d8d1ebcefd45868f3307c8ee61a8cbcc24d1c23d","modified":1615820473075},{"_id":"public/tags/Array/index.html","hash":"be8ace5cd1306e2ad17608c09f1a606c6636136a","modified":1615820473075},{"_id":"public/tags/flexible/index.html","hash":"769340a0e2195cbc6ec0a68954492b768c931db8","modified":1615820473075},{"_id":"public/tags/h5/index.html","hash":"54909454dde764ae32264e79c6f63c7007f51c7d","modified":1615820473075},{"_id":"public/tags/动画/index.html","hash":"2d363f38318ced809c1ec4da3bd0e4d7f1c7a987","modified":1615820473075},{"_id":"public/tags/css动画/index.html","hash":"fb9d125eb1fd92ece6b16ae8100b7f1f9a5edeab","modified":1615820473075},{"_id":"public/tags/postcss/index.html","hash":"c2f1a6163f748141a5cc9ef7cb9c6997e1fdb669","modified":1615820473075},{"_id":"public/tags/视口/index.html","hash":"f62b8d087a25f2f354163e2155a29e02736e58fa","modified":1615820473075},{"_id":"public/tags/大数/index.html","hash":"798ec5ef3768690c250817b037306fd05c83a3b9","modified":1615820473075},{"_id":"public/tags/小数/index.html","hash":"798ec5ef3768690c250817b037306fd05c83a3b9","modified":1615820473075},{"_id":"public/tags/文件/index.html","hash":"389351f2c300280cdf623edadc6c26579c00235a","modified":1615820473075},{"_id":"public/tags/file/index.html","hash":"389351f2c300280cdf623edadc6c26579c00235a","modified":1615820473075},{"_id":"public/tags/scroll/index.html","hash":"3dc918c01927c1920a3883e7198af2f85557fd2a","modified":1615820473075},{"_id":"public/tags/DOM/index.html","hash":"8b311a3702a7d41e6bb6cfd23b3a713184135e37","modified":1615820473075},{"_id":"public/tags/js类型/index.html","hash":"70556d88c0babfcc31867b3a629c597c1d213546","modified":1615820473075},{"_id":"public/tags/深拷贝/index.html","hash":"6972a6a2a4e2319748270caef5b23f46b702b8da","modified":1615820473075},{"_id":"public/tags/节流与防抖/index.html","hash":"3b12aaa0f0f24eec4fcc8dcfe5f83d4a7159ba36","modified":1615820473075},{"_id":"public/tags/正则表达式/index.html","hash":"54e6652f5db2786b7639c60b6491e25a2f0d53e6","modified":1615820473075},{"_id":"public/tags/redux/index.html","hash":"6b0f1d00713aee4d03d3dbf85afb4d9a53844948","modified":1615820473075},{"_id":"public/tags/算法/index.html","hash":"a17576acf23339e9db2848c0d336848d3fa9b6d4","modified":1615820473075},{"_id":"public/tags/缓存/index.html","hash":"7778ca87baa3fdf6238c83695f2c481047dbd056","modified":1615820473075},{"_id":"public/tags/浏览器/index.html","hash":"f24ce733d2026e293b31c14f610228d02e98aca8","modified":1615820473075},{"_id":"public/tags/Babel/index.html","hash":"827408cd3da2f907b81887d924c75a392acf3c22","modified":1615820473075},{"_id":"public/tags/docker/index.html","hash":"c21e5399825533b6385be45e9cf0c98ee1dba8bd","modified":1615820473075},{"_id":"public/tags/git/index.html","hash":"d52045f312397cbeb061088224667d5ffce53f46","modified":1615820473075},{"_id":"public/tags/linux/index.html","hash":"379bbbc0cebd74e1856c2fce305cb04476bf1dce","modified":1615820473075},{"_id":"public/tags/npm/index.html","hash":"450ff77149da37845d686ae829fa6edd4eb3823d","modified":1615820473075},{"_id":"public/tags/yarn/index.html","hash":"f5c3c7aa4c7a338a5d0380d10b0b770ac68d8985","modified":1615820473075},{"_id":"public/tags/pm2/index.html","hash":"5cc968a0d1c5044dcb6a87e7b382ae368539aec8","modified":1615820473075},{"_id":"public/tags/node/index.html","hash":"f293dcd391b8abce4c584aadfe0c881d6c317835","modified":1615820473075},{"_id":"public/tags/hexo/index.html","hash":"4d539e01295e3bced4b1afdf38d5630dfba98dea","modified":1615820473075},{"_id":"public/tags/性能优化/index.html","hash":"36e03d796eb4c1f47e7c9574cfde85fa355ce6bd","modified":1615820473075},{"_id":"public/tags/index.html","hash":"7806004ab1907679975d7f21c83ad92c9538b35c","modified":1615820473075},{"_id":"public/2021/03/03/[js]数据类型/index.html","hash":"0a09016f44328299606f917e4c8ab990a3fcc27c","modified":1615819348909},{"_id":"public/2020/12/22/npm使用/index.html","hash":"b901c096db7a8a0b43e91a9ef39b0ce74f8c7f97","modified":1615266323157},{"_id":"public/2020/10/06/git-使用/index.html","hash":"f205c99ec06bf4696c109fe6415f969b4e7d85f0","modified":1615266323157},{"_id":"public/2020/09/11/pm2使用/index.html","hash":"c00bc428bcd9703769e918ed23fc68a879b27e88","modified":1615266323157},{"_id":"public/2020/08/24/linux基础操作/index.html","hash":"a1b0017f33350a78d7c5dcfef187f8aa372bb3fd","modified":1615266323157},{"_id":"public/2020/07/20/yarn使用/index.html","hash":"f59718a95827db1bdf4946bfdab683882d16f145","modified":1615266323157},{"_id":"public/2020/06/11/[react]react-router实现原理/index.html","hash":"ef406db680ee254adc49dca99e298e692f83d0db","modified":1615819348909},{"_id":"public/2020/06/11/[react]redux实现原理/index.html","hash":"0fee45e9ec9e9a59449be8f98c66482904083923","modified":1615819348909},{"_id":"public/2020/06/11/docker常用命令/index.html","hash":"bc5357383f5f32df564c686566b50696cba1a3ef","modified":1615266323157},{"_id":"public/2019/04/18/[js]平滑生成大量div方法/index.html","hash":"eb7c7735f9401c863f28247b6bf1e7618cac32a6","modified":1615266323157},{"_id":"public/2019/04/17/[js]scroll相关/index.html","hash":"d6aa0f10fe83ebfe6b9871b171cbf3f42df3db04","modified":1615819348909},{"_id":"public/2019/04/15/[js]一些前端dom取值/index.html","hash":"943efb9b29d71f89e6376ccd5edda16d9ce86287","modified":1615819348909},{"_id":"public/2019/03/27/[react]学习笔记/index.html","hash":"ef0eefcf1e873b382d517da7bb53eb3f27278246","modified":1615819348909},{"_id":"public/2019/03/20/[js]正则表达式/index.html","hash":"a35ac6696257d1e1b2a9b8814c2911946cbe4e13","modified":1615819348909},{"_id":"public/2019/03/03/[算法]一些算法/index.html","hash":"fb629bf31aa1eb9640813377d6b3b30a587be1ad","modified":1615266323157},{"_id":"public/2019/03/03/[js]类型/index.html","hash":"ca355c0a6f96f03d3c44c44965783b21401554bc","modified":1615819348909},{"_id":"public/2019/02/16/[css]动画相关/index.html","hash":"a626c33173fe241708d14f264a80a405595ec1e5","modified":1615266323157},{"_id":"public/2019/02/15/[ES6]代理-Proxy-与反射-Reflection/index.html","hash":"2ce86b21c8e14b525210902c5e8e0ccff52ce351","modified":1615819348909},{"_id":"public/2019/02/13/性能优化/index.html","hash":"0bde404df70538f22fb50168dfb9518cdd94f7b6","modified":1615266323157},{"_id":"public/2019/02/13/[ES6]Symbol/index.html","hash":"0be320a1eff172ca07bfb81a0ea35fc9c1e018dc","modified":1615819348909},{"_id":"public/2019/02/11/[ES6]模块化/index.html","hash":"e4cb6fcaf0ea3f9686792b79c39d1e6bb9bb61f8","modified":1615819348909},{"_id":"public/2019/01/31/[js]decimal处理数字问题/index.html","hash":"949e8e02fb872df15feb2e72ef9cddb06d24c733","modified":1615819348909},{"_id":"public/2019/01/31/[css]postcss相关/index.html","hash":"56660230b82f3d1705d8af9700e216f2143e5389","modified":1615266323157},{"_id":"public/2019/01/31/[js]file相关/index.html","hash":"5ce334208848adaad3fdfffbdf8c34c5b80a196c","modified":1615819348909},{"_id":"public/2019/01/20/[css]flexible布局以及1px边框解决方案/index.html","hash":"eb994629ad01d26db64d850b4ac14d630b612ea7","modified":1615266323157},{"_id":"public/2019/01/20/[css]视口概念/index.html","hash":"dba6dda9b385938fe9d33898d17c9675bbce5a6c","modified":1615819348909},{"_id":"public/2019/01/15/[webpack]CommonsChunkPlugin与optimization-splitChunks/index.html","hash":"29b59d18d6506b18748e8ae62f7b73c61e696bb9","modified":1615819348909},{"_id":"public/2019/01/06/[js]深浅拷贝/index.html","hash":"e9f48a5956375b4958a7ffffa38feaaaaaa4fe17","modified":1615819348909},{"_id":"public/2018/12/21/[webpack]搭建环境以及相关优化/index.html","hash":"a391e1e2ba76f33c35cbfad04744e92a2481503a","modified":1615819348909},{"_id":"public/2018/12/21/[webpack]打包文件相关/index.html","hash":"c387f2f2a59776bc0a82c3833356b6ad73bfe448","modified":1615819348909},{"_id":"public/2018/12/19/[webpack]简介以及相关概念/index.html","hash":"73a252a41f20ab99730a062cb37ea3e68f9cdbaa","modified":1615819348909},{"_id":"public/2018/12/10/[ES6]async-await/index.html","hash":"56b389a9202b56d2467f07461b19873fcc266bb5","modified":1615819348909},{"_id":"public/2018/11/27/[js]你不知道的js学习笔记/index.html","hash":"1344a9d3aaa9e019b18f7da7a136d2e0bcd44410","modified":1615266323157},{"_id":"public/2018/11/15/[js]节流与防抖/index.html","hash":"cbb69a3af51f1b39404eca2477b1af47e25ddd3d","modified":1615819348909},{"_id":"public/2018/11/14/babel生态/index.html","hash":"ad9ae466a1d4b543dfc0acd3574181f07cea1c96","modified":1615266323157},{"_id":"public/2018/11/10/[ES6]改进数组功能/index.html","hash":"4d0c76b89c5acb07ff44af0201d5114c41c2a226","modified":1615819348909},{"_id":"public/2018/10/20/[js]eventLoop/index.html","hash":"939baba0dc5fca6cc9796922cd0d207515793ca5","modified":1615819348909},{"_id":"public/2018/10/02/[css]translateY-实现列表hover的box-shadow动画/index.html","hash":"a6e10067d6f97088a41ad41a2c5ed6cb18c4666f","modified":1615819348909},{"_id":"public/2018/09/26/[webpack]配置全局常量/index.html","hash":"51cf874de8b99c2f68df669258a429b7d7db0415","modified":1615819348909},{"_id":"public/2018/09/06/[浏览器]浏览器缓存/index.html","hash":"db12381bef25606dd90d5c0d7a3b86af515ed701","modified":1615819348909},{"_id":"public/2018/08/22/[ES6]Set&Map/index.html","hash":"8331daef63f6e79faa554ece983fb62b9e9b0795","modified":1615819348909},{"_id":"public/2018/08/22/[ES6]promise/index.html","hash":"66caba9e7223b610abee1bb41aa352df0e6ddad3","modified":1615819348909},{"_id":"public/2018/08/22/[ES6]迭代器iterator&生成器generator/index.html","hash":"ede575720b9cb13900e7492d2f87f774ea01d89c","modified":1615819348909},{"_id":"public/2018/08/22/[ES6]class/index.html","hash":"692329157566d066c097d5b09fb679818ea5b917","modified":1615819348909},{"_id":"public/2018/08/21/[ES6]函数/index.html","hash":"202fb57c2ad7a0545ebb44681c8998f91c30bbc4","modified":1615819348909},{"_id":"public/2018/08/21/[ES6]扩展对象属性/index.html","hash":"40657d89232ac99e2d0f136609850bec8cb3d0cc","modified":1615819348909},{"_id":"public/2018/08/20/创建Hexo-github博客流程/index.html","hash":"6bf5d9325829a99197b07893c497afe737c9c11e","modified":1615818390863},{"_id":"public/2017/08/17/[ES6]解构/index.html","hash":"cdbf09d1c22b9079ee20271112bd3ee05de2c9f7","modified":1615819348909},{"_id":"public/archives/index.html","hash":"fa4a42f327ab17f61c471e7bc438a7ad67ceaf1c","modified":1615820473075},{"_id":"public/archives/page/2/index.html","hash":"0ea0fb1a7af601093dc7c3884e23741c69333734","modified":1615820473075},{"_id":"public/archives/page/3/index.html","hash":"dc9ee645cbfbdb0c7d9c9e0b89aae73d7719c627","modified":1615820473075},{"_id":"public/archives/2018/index.html","hash":"1e540dbdcb540fa3fe9d072f78443012f91874a6","modified":1615820473075},{"_id":"public/archives/2018/page/2/index.html","hash":"27f8de6973b086358ebf11cbcfcece625e7502a7","modified":1615820473075},{"_id":"public/archives/2018/08/index.html","hash":"eebba3fb22a063fdd8c57b4fdfc03ee8fc4e55df","modified":1615820473075},{"_id":"public/archives/2018/11/index.html","hash":"50b119679721e58903f4c9778d6133491e1f0963","modified":1615820473075},{"_id":"public/archives/2018/12/index.html","hash":"945e1d5ff9eec0385172ff62c957d48889b66f4e","modified":1615820473075},{"_id":"public/archives/2019/index.html","hash":"440337e88ce380b9e2c65047ce1a5e503f9b4db2","modified":1615820473075},{"_id":"public/archives/2019/page/2/index.html","hash":"e0efc93cad3970d056d11731c082a764c2194d02","modified":1615820473075},{"_id":"public/archives/2019/01/index.html","hash":"7e18e1dc8e3921bd353a77fd5552542f20445b68","modified":1615820473075},{"_id":"public/archives/2019/02/index.html","hash":"c0ffc31801094c62000cd4b62efa1bd549f448f5","modified":1615820473075},{"_id":"public/archives/2019/03/index.html","hash":"7bce2e7eadefe4b017ba485b508049019195649a","modified":1615820473075},{"_id":"public/archives/2019/04/index.html","hash":"c56af92cb2108547b112dc357bf6a3aa05528bcb","modified":1615820473075},{"_id":"public/archives/2020/index.html","hash":"2d214b4f4a8f6a52f4ac3483df673509dfd1aeaf","modified":1615820473075},{"_id":"public/archives/2020/06/index.html","hash":"17d003e6ea1bb5234c2b4be84ad4aa151f42ca33","modified":1615820473075},{"_id":"public/categories/ES6/index.html","hash":"ab45ac8b62d858ce3b47ac989e54784c99d19b54","modified":1615820473075},{"_id":"public/categories/js/index.html","hash":"1eec7f435c04969a2aa6cc2b0aa16accdc3dc295","modified":1615820473075},{"_id":"public/categories/css/index.html","hash":"82cf42417898af92ddd28a5ee4d22bb07545ad6f","modified":1615820473075},{"_id":"public/categories/react/index.html","hash":"04d579c3fde63204d332b417acadd2fe19557184","modified":1615820473075},{"_id":"public/categories/webpack/index.html","hash":"002ddf48ba44c75391b623e348208dd25c20392c","modified":1615820473075},{"_id":"public/tags/ES6/index.html","hash":"037981b5025f5bc7bc40f16b79f7dad64bab10c2","modified":1615820473075},{"_id":"public/tags/js/index.html","hash":"8f6beb79084b984c25bb3622c8983f783f24241b","modified":1615820473075},{"_id":"public/tags/js/page/2/index.html","hash":"8085bd8c0a44423f9121891ec1ee00571a35d7af","modified":1615820473075},{"_id":"public/tags/css/index.html","hash":"c7069e8bba97c5084d4b272365a2e915f2a554c8","modified":1615820473075},{"_id":"public/tags/react/index.html","hash":"a83cd52bc879e052873a56baf4cc1bba8086e340","modified":1615820473075},{"_id":"public/tags/webpack/index.html","hash":"682ae193da301f8c6780f3dc5ba4750bb3bf1742","modified":1615820473075},{"_id":"public/page/2/index.html","hash":"618cc10b94a1415d33ce4fec2b3ef0cedf1d210f","modified":1615820473075},{"_id":"public/index.html","hash":"535edd3ce8dd4260f0382f7d1a381b7d23b28a92","modified":1615820473075},{"_id":"public/page/3/index.html","hash":"9192cc2c0a49009e6bf6e366c39150b7d48dfebc","modified":1615820473075},{"_id":"public/page/4/index.html","hash":"0073ec2a08c7b42351a7ed6666f0e68776b07e4b","modified":1615820473075},{"_id":"public/images/my_head.jpeg","hash":"d390c0b494a9dda39f25540bf08e5cf021b244f7","modified":1615819348909},{"_id":"public/images/logo.gif","hash":"10572efb24a57b3818a2cd6004c9b8e6e8223bbc","modified":1615819348909},{"_id":"public/images/浏览器缓存.png","hash":"b10df7f3685800a6f53e98b7c0d404df98565bb8","modified":1615819348909},{"_id":"public/css/base.css","hash":"2cfca48555fc0c63c85174a80dc14226aedd9057","modified":1615819348909},{"_id":"public/css/code.css","hash":"6baa5ad3fd4989a2aba6bd845b1a2e082a2105d9","modified":1615819348909},{"_id":"public/css/calendar.css","hash":"7a7631065237b046550b885dd1f9b77f6f6997c1","modified":1615819348909},{"_id":"public/css/footer.css","hash":"7df1b3fc06147cccfedeb9bf2dccd1b68b2eff39","modified":1615819348909},{"_id":"public/js/main.js","hash":"1cc23de812297dfef373b9bab39c85c913dc1471","modified":1615819348909},{"_id":"public/css/header.css","hash":"94db4946462f6638405c74f075dce73a8577f7d2","modified":1615819348909},{"_id":"public/images/git_icon.jpg","hash":"eec74bf82b2d730da0f3abd6bfa804e47cdbc4e1","modified":1615819348909},{"_id":"public/images/favicon.ico","hash":"2f09f7d3759d6aa21960878df30abc43ade67814","modified":1615819348909},{"_id":"public/css/post.css","hash":"94218ae01ac5fd1466beded710664cf0b281c58c","modified":1615819348909},{"_id":"public/css/navbar.css","hash":"96124b536541ef4331cc893b0475ec41c0858ecd","modified":1615819348909},{"_id":"public/css/main.css","hash":"0279efdde441a451a4ce51826034b20618b21eff","modified":1615819348909},{"_id":"source/_posts/[css]flexible布局&1px解决方案.md","hash":"fd9beef22489b28cb2a4ac5640aef1ea438db44a","modified":1615818957505},{"_id":"source/_posts/[css]postcss相关配置.md","hash":"b00515dfdbea99a4cfd2c4d6a1fc6adaba6b6406","modified":1615818963517},{"_id":"source/_posts/[css]动画相关概念.md","hash":"49da6dd76ed935974ebb8cbe2822a7202fad9df4","modified":1615818939633},{"_id":"source/_posts/[js]babel生态.md","hash":"aebd292cc811a9a00b002ddd173c0c091a25ac28","modified":1615819152869},{"_id":"source/_posts/[js]new、call、、apply、bind实现.md","hash":"19f06f7961da812ab980d4c0adbc3aea79113879","modified":1615817264809},{"_id":"source/_posts/[js]requestAnimationFrame平滑生成大量div方法.md","hash":"84e01fad73fd888f43dfe2cb71ff2dd4c85e9d2e","modified":1615819199354},{"_id":"source/_posts/[js]你不知道的js笔记.md","hash":"a1d98f736f03aa424d9201f0d53856af20499b57","modified":1615819070732},{"_id":"source/_posts/[js]数组.md","hash":"c1b7564a447c603a6472a1b2cf75e1136b99da8d","modified":1615819128835},{"_id":"source/_posts/[js]继承.md","hash":"3fedf21c565286eec28ee0d58fb039e10e634c31","modified":1615819052383},{"_id":"source/_posts/[node]nodejs使用.md","hash":"63d50ce4dd19703a567c4533c537feed56b56767","modified":1615819218948},{"_id":"source/_posts/[linux]基础操作.md","hash":"de2f77f31135f59648e9a3a6d9d6e158f8f36033","modified":1615819213302},{"_id":"source/_posts/[node]pm2使用.md","hash":"05f1cc8eb6e7bc28198b14ab11845168c5efc94a","modified":1615819225200},{"_id":"source/_posts/[react]react相关知识.md","hash":"6f54110c1f0eb0e80bba0f5183813c68269e665e","modified":1615819241962},{"_id":"source/_posts/[前端]性能优化.md","hash":"4beaa9f3de62bd2233353a2312401f5de5d8f390","modified":1615818921752},{"_id":"source/_posts/[工程化]docker常用命令.md","hash":"be833421c8082154d46f10a339fded92b0ce8eca","modified":1615818746806},{"_id":"source/_posts/[工程化]git-使用.md","hash":"487dd39e0f199a3bfb9e6aa7cac4f023ebc8356b","modified":1615818873524},{"_id":"source/_posts/[工程化]npm使用.md","hash":"f239886464f765612a4999514d63a8036c03a049","modified":1615818882145},{"_id":"source/_posts/[工程化]yarn使用.md","hash":"701493359aefb51ea7b25a5e79727376a6c40712","modified":1615818889282},{"_id":"source/_posts/[工程化]代码检查.md","hash":"243f750cbe815d70c39a32abe3f411f1ea8a4928","modified":1615818731321},{"_id":"source/_posts/[浏览器]js执行机制.md","hash":"527c0240d5b9e564fad0497503e66c1383242603","modified":1615818902001},{"_id":"source/_posts/[浏览器]url输入执行过程.md","hash":"674fc039b700c453e382d82deb7f162134bac4d4","modified":1615818908551},{"_id":"source/_posts/[算法]一些排序算法.md","hash":"6974f218a423010262bd5f25c1a0509dfa31b20f","modified":1615818932515},{"_id":"source/_posts/[浏览器]v8工作原理.md","hash":"40dc4ac0f7b473214d0c7869c80702455e3ae383","modified":1615818915033},{"_id":"public/2018/11/14/[js]babel生态/index.html","hash":"128cbb03fd096e92b8ea082f0995d7a3285f2ac9","modified":1615819348909},{"_id":"public/2020/09/10/[工程化]代码检查/index.html","hash":"d5968186969cf51c1d7c5f468e7da77d247d8316","modified":1615819348909},{"_id":"public/2020/06/11/[工程化]docker常用命令/index.html","hash":"e0664c8fd3cbb21aebef6a876384a934e54eb2e2","modified":1615819348909},{"_id":"public/categories/工程化/index.html","hash":"299e3a29eb6eea61cb9c22d040a107d8f53fecf0","modified":1615820473075},{"_id":"public/tags/代码检查/index.html","hash":"89e4ee93b9659ab5c97b44d9d94946b375f0c6a1","modified":1615820473075},{"_id":"public/tags/工程化/index.html","hash":"8f3f55b32e4d827704232f213e05d239094d7685","modified":1615820473075},{"_id":"source/_posts/[hexo]创建Hexo-github博客流程.md","hash":"9e96e855e7741e6ed56fa6845ef253e747b85e7b","modified":1615819296045},{"_id":"source/_posts/[js]new、call、apply、bind实现.md","hash":"405d54a42984824df999721716ebf7aa6a1529ff","modified":1615819192598},{"_id":"public/archives/2019/10/index.html","hash":"1d6f6364854660cf3c531a28767ebd939b18f6f2","modified":1615820473075},{"_id":"public/archives/2020/02/index.html","hash":"c7b2358e025dfbf10f9443daf8f962cf5bf5ec0a","modified":1615820473075},{"_id":"public/archives/2021/01/index.html","hash":"668c52e72529711db2a254a65f43cd3655bb68d9","modified":1615820473075},{"_id":"public/archives/2021/02/index.html","hash":"97a10d0ec489bd14472e0874538583ee27688371","modified":1615820473075},{"_id":"public/archives/2029/index.html","hash":"7ab49272b66a6c5566129ada9327fb6d6a7cb495","modified":1615820473075},{"_id":"public/archives/2029/03/index.html","hash":"7ab49272b66a6c5566129ada9327fb6d6a7cb495","modified":1615820473075},{"_id":"public/tags/数组/index.html","hash":"a8a39c1d6a08c0d997dd2872274d030fd105cdf3","modified":1615820473075},{"_id":"public/tags/js继承/index.html","hash":"4e64ebf2695b3bfd2211069ed8f6477f847b43f0","modified":1615820473075},{"_id":"public/2029/03/03/[js]继承/index.html","hash":"93411511440c8fc08a5c02ee436f96a8f4bc77f5","modified":1615819348909},{"_id":"public/2021/02/20/[node]nodejs使用/index.html","hash":"bfa9e1a736c63b302bd6dd153b355c102452097a","modified":1615819348909},{"_id":"public/2021/01/11/[js]new、call、apply、bind实现/index.html","hash":"037a4dc8fbf178839cb37ea2efdb0730d9177e9d","modified":1615819348909},{"_id":"public/2020/12/22/[工程化]npm使用/index.html","hash":"d04fdf82c03fe39d1d7fda1adb4e019379808220","modified":1615819348909},{"_id":"public/2020/10/06/[工程化]git-使用/index.html","hash":"4829c41801892c582fc28a17f0ddced77cc4fbc8","modified":1615819348909},{"_id":"public/2020/09/12/[react]react相关知识/index.html","hash":"689a1727aed98d54759ee2221bec34c439b364fd","modified":1615819348909},{"_id":"public/2020/09/11/[node]pm2使用/index.html","hash":"af030a70a784ed1296559b24aa57e5ecfd18b261","modified":1615819348909},{"_id":"public/2020/08/24/[linux]基础操作/index.html","hash":"59a3a12350882d3079bd75fda411147441e2d64f","modified":1615819348909},{"_id":"public/2020/07/20/[工程化]yarn使用/index.html","hash":"53967c41d42386218efda04d705b99454b52beec","modified":1615819348909},{"_id":"public/2020/02/22/[浏览器]v8工作原理/index.html","hash":"90f0b037ff2f3bfeab14815e2f1d51992c8f08d6","modified":1615819348909},{"_id":"public/2020/01/30/[浏览器]url输入执行过程/index.html","hash":"5d3a320a1b2166e1eeb4f581a9a2b7122e0bd4fa","modified":1615819348909},{"_id":"public/2020/01/20/[浏览器]js执行机制/index.html","hash":"7c1b6ea3348ce9b63b081d1b574e81af8731b8b4","modified":1615819348909},{"_id":"public/2019/10/20/[js]数组/index.html","hash":"dbad830121960036e298c61d6570cc766fecc689","modified":1615819348909},{"_id":"public/2019/04/18/[js]requestAnimationFrame平滑生成大量div方法/index.html","hash":"2845db455c8f1cad8bd4633806d631f6be92b76e","modified":1615819348909},{"_id":"public/2019/03/03/[算法]一些排序算法/index.html","hash":"829d7aa8aeb7dd6f14b50fc819aa0f7cf5dc745a","modified":1615819348909},{"_id":"public/2019/02/16/[css]动画相关概念/index.html","hash":"55d5a3ac2a44201ad851a8205a5dde43d7ce9611","modified":1615819348909},{"_id":"public/2019/02/13/[前端]性能优化/index.html","hash":"d267b9adaa2b836001c5440bddf1128d3b1bb17d","modified":1615819348909},{"_id":"public/2019/01/31/[css]postcss相关配置/index.html","hash":"0cd67efd1d1b115a280d9b940395b35b07ffb187","modified":1615819348909},{"_id":"public/2019/01/20/[css]flexible布局&1px解决方案/index.html","hash":"ed06c38f12cbad4610d6d3a90dc27a2b419d2c76","modified":1615819348909},{"_id":"public/2018/11/27/[js]你不知道的js笔记/index.html","hash":"a1b44acd5ea31dc10a9ee6423633e0e1bb3cccee","modified":1615819348909},{"_id":"public/2018/08/20/[hexo]创建Hexo-github博客流程/index.html","hash":"3ded1aca21f260b79ee86b9546043e9162e1f87d","modified":1615819348909},{"_id":"public/archives/2020/01/index.html","hash":"f8258a19a95486c45b02576b3c620ce2c9a0a511","modified":1615820473075},{"_id":"public/categories/浏览器/index.html","hash":"17ef00056c234838bb0830aa1a2fe6643d647c14","modified":1615820473075},{"_id":"public/tags/js/page/3/index.html","hash":"d8d0fdc43b84a615a53f6ec5e4a43686d3727f9f","modified":1615820473075}],"Category":[{"name":"ES6","_id":"ckm1jn1fq0002rctjf6bpb4y7"},{"name":"js","_id":"ckm1jn1g4000jrctj791a1gzr"},{"name":"flexible","_id":"ckm1jn1gc0013rctjc2alb5vh"},{"name":"css","_id":"ckm1jn1gg001drctjfeh74x06"},{"name":"postcss","_id":"ckm1jn1gl001rrctjfa04e9zv"},{"name":"视口","_id":"ckm1jn1gm001xrctjcra8b0u4"},{"name":"decimal","_id":"ckm1jn1hg0031rctj9sj24gim"},{"name":"file","_id":"ckm1jn1hk0037rctj520p1zq4"},{"name":"scroll","_id":"ckm1jn1hn003drctjh90x3vjo"},{"name":"DOM取值","_id":"ckm1jn1hq003lrctj17ny7pv0"},{"name":"react","_id":"ckm1jn1hs003trctj9eigc0b2"},{"name":"webpack","_id":"ckm1jn1i0004crctj00z55wbd"},{"name":"算法","_id":"ckm1jn1ib0050rctj268vb2pc"},{"name":"缓存","_id":"ckm1jn1ih0059rctj2kry2so1"},{"name":"docker","_id":"ckm1jn1il005hrctjauj23r5z"},{"name":"git","_id":"ckm1jn1io005prctj5bbf9kus"},{"name":"linux","_id":"ckm1jn1ir005vrctj18mp78zz"},{"name":"npm","_id":"ckm1jn1is0060rctjgvspabaq"},{"name":"yarn","_id":"ckm1jn1it0063rctj32fahebi"},{"name":"node","_id":"ckm1jn1iv0068rctj4oq811jq"},{"name":"hexo","_id":"ckm1jn1ix006drctjf74o1vcz"},{"name":"性能优化","_id":"ckm1jn1iz006hrctj74f729df"},{"name":"工程化","_id":"ckmaospgk0003d0tj1kpd7r7c"},{"name":"浏览器","_id":"ckmap4dle0048wotj8ikw7j9j"}],"Data":[],"Page":[{"title":"categories","date":"2018-08-16T14:33:01.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-08-16 22:33:01\ntype: \"categories\"\n---\n","updated":"2020-08-23T11:24:13.469Z","path":"categories/index.html","comments":1,"layout":"page","_id":"ckm1jn1he002yrctje37f4iar","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-08-16T14:27:04.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-08-16 22:27:04\ntype: \"tags\"\n---\n","updated":"2020-08-23T11:24:13.473Z","path":"tags/index.html","comments":1,"layout":"page","_id":"ckm1jn1hg0030rctjfafo5ltx","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"search","date":"2018-08-16T14:33:18.000Z","type":"search","_content":"","source":"search/index.md","raw":"---\ntitle: search\ndate: 2018-08-16 22:33:18\ntype: \"search\"\n---\n","updated":"2020-08-23T11:24:13.473Z","path":"search/index.html","comments":1,"layout":"page","_id":"ckm1jn1hi0034rctjfyfedvgd","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"<工程化>docker常用命令","date":"2020-06-10T16:00:00.000Z","_content":"\n### 启动\n\n- 启动命令：sudo service docker start\n- 设置开机自启：sudo chkconfig docker on\n\n### image\n\n#### 获取镜像\n\n- sudo docker pull ubantu\n\n#### 列出本地镜像\n\n- sudo docker images\n\n#### 修改已有的镜像\n\n```\n//启动镜像容器\nsudo docker run -p 8080:8080 -t -i yxc_test:v2 /bin/bash\n//在容器中添加内容，修改完成后使用 exit 退出\ngem install json\n//使用docker commit命令 提交更新后的副本\nsudo docker commit -m \"Added json gem\" -a \"Docker Newbee\" 0b2616b0e5a8 ouruser/sinatra:v2\n```\n\n#### 进入运行中的容器\n\ndocker exec -it bb5806a80788 /bin/sh\n\n#### 使用 Dockerfile 创建镜像\n\n1. Dockerfile文件 http://www.dockerinfo.net/dockerfile%E4%BB%8B%E7%BB%8D\n2. docker build创建镜像\n\n- sudo docker build -t=\"yxc_test:v2\" .\n- -t 标记来添加 tag，指定新的镜像的用户信息。 “.” 是 Dockerfile 所在的路径（当前目录），也可以替换为一个具体的 Dockerfile 的路径\n\n3. docker tag 命令来修改镜像的标签：sudo docker tag 5db5f8471261 ouruser/sinatra:devel\n\n#### 导入本地镜像\n\n- sudo cat ubuntu-14.04-x86_64-minimal.tar.gz  |docker import - ubuntu:14.04\n\n#### 上传镜像到 Docker Hub\n\n- sudo docker push ouruser/sinatra\n\n#### 存出/载入镜像\n\n- sudo docker save -o ubuntu_14.04.tar ubuntu:14.04\n- sudo docker load --input ubuntu_14.04.tar || sudo docker load < ubuntu_14.04.tar\n\n#### 移除本地镜像\n\n- sudo docker rmi training/sinatra\n- 在删除镜像之前要先用 docker rm 删掉依赖于这个镜像的所有容器\n\n#### 批量移除镜像（需要先删除容器）\n\n- docker rmi $(docker images -q)\n\n### Docker容器\n\n#### 启动容器\n\n- sudo docker run -t -i ubuntu:14.04 /bin/bash\n- -t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开\n\n#### 启动已终止容器\n\n- docker start\n\n#### 守护态运行\n\n- 需要让 Docker 容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加 -d 参数来实现\n- 获取容器的输出信息，可以通过 docker logs 命令\n\n#### 终止容器\n\n- 使用 docker stop 来终止一个运行中的容器\n- 终止状态的容器可以用 docker ps -a 命令看到\n- docker restart 命令会将一个运行态的容器终止，然后再重新启动它\n\n#### 删除容器\n\n- 使用 docker rm 来删除一个处于终止状态的容器\n\n#### 批量删除容器\n\n- docker stop $(docker ps -q) & docker rm $(docker ps -aq)\n\n","source":"_posts/[工程化]docker常用命令.md","raw":"---\ntitle: <工程化>docker常用命令\ndate: 2020-06-11 00:00:00\ntags: [docker]\ncategories:  docker\n---\n\n### 启动\n\n- 启动命令：sudo service docker start\n- 设置开机自启：sudo chkconfig docker on\n\n### image\n\n#### 获取镜像\n\n- sudo docker pull ubantu\n\n#### 列出本地镜像\n\n- sudo docker images\n\n#### 修改已有的镜像\n\n```\n//启动镜像容器\nsudo docker run -p 8080:8080 -t -i yxc_test:v2 /bin/bash\n//在容器中添加内容，修改完成后使用 exit 退出\ngem install json\n//使用docker commit命令 提交更新后的副本\nsudo docker commit -m \"Added json gem\" -a \"Docker Newbee\" 0b2616b0e5a8 ouruser/sinatra:v2\n```\n\n#### 进入运行中的容器\n\ndocker exec -it bb5806a80788 /bin/sh\n\n#### 使用 Dockerfile 创建镜像\n\n1. Dockerfile文件 http://www.dockerinfo.net/dockerfile%E4%BB%8B%E7%BB%8D\n2. docker build创建镜像\n\n- sudo docker build -t=\"yxc_test:v2\" .\n- -t 标记来添加 tag，指定新的镜像的用户信息。 “.” 是 Dockerfile 所在的路径（当前目录），也可以替换为一个具体的 Dockerfile 的路径\n\n3. docker tag 命令来修改镜像的标签：sudo docker tag 5db5f8471261 ouruser/sinatra:devel\n\n#### 导入本地镜像\n\n- sudo cat ubuntu-14.04-x86_64-minimal.tar.gz  |docker import - ubuntu:14.04\n\n#### 上传镜像到 Docker Hub\n\n- sudo docker push ouruser/sinatra\n\n#### 存出/载入镜像\n\n- sudo docker save -o ubuntu_14.04.tar ubuntu:14.04\n- sudo docker load --input ubuntu_14.04.tar || sudo docker load < ubuntu_14.04.tar\n\n#### 移除本地镜像\n\n- sudo docker rmi training/sinatra\n- 在删除镜像之前要先用 docker rm 删掉依赖于这个镜像的所有容器\n\n#### 批量移除镜像（需要先删除容器）\n\n- docker rmi $(docker images -q)\n\n### Docker容器\n\n#### 启动容器\n\n- sudo docker run -t -i ubuntu:14.04 /bin/bash\n- -t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开\n\n#### 启动已终止容器\n\n- docker start\n\n#### 守护态运行\n\n- 需要让 Docker 容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加 -d 参数来实现\n- 获取容器的输出信息，可以通过 docker logs 命令\n\n#### 终止容器\n\n- 使用 docker stop 来终止一个运行中的容器\n- 终止状态的容器可以用 docker ps -a 命令看到\n- docker restart 命令会将一个运行态的容器终止，然后再重新启动它\n\n#### 删除容器\n\n- 使用 docker rm 来删除一个处于终止状态的容器\n\n#### 批量删除容器\n\n- docker stop $(docker ps -q) & docker rm $(docker ps -aq)\n\n","slug":"[工程化]docker常用命令","published":1,"updated":"2021-03-15T14:32:26.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmaospgc0000d0tja6n3hcvl","content":"<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><ul>\n<li>启动命令：sudo service docker start</li>\n<li>设置开机自启：sudo chkconfig docker on</li>\n</ul>\n<h3 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a>image</h3><h4 id=\"获取镜像\"><a href=\"#获取镜像\" class=\"headerlink\" title=\"获取镜像\"></a>获取镜像</h4><ul>\n<li>sudo docker pull ubantu</li>\n</ul>\n<h4 id=\"列出本地镜像\"><a href=\"#列出本地镜像\" class=\"headerlink\" title=\"列出本地镜像\"></a>列出本地镜像</h4><ul>\n<li>sudo docker images</li>\n</ul>\n<h4 id=\"修改已有的镜像\"><a href=\"#修改已有的镜像\" class=\"headerlink\" title=\"修改已有的镜像\"></a>修改已有的镜像</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;启动镜像容器</span><br><span class=\"line\">sudo docker run -p 8080:8080 -t -i yxc_test:v2 &#x2F;bin&#x2F;bash</span><br><span class=\"line\">&#x2F;&#x2F;在容器中添加内容，修改完成后使用 exit 退出</span><br><span class=\"line\">gem install json</span><br><span class=\"line\">&#x2F;&#x2F;使用docker commit命令 提交更新后的副本</span><br><span class=\"line\">sudo docker commit -m &quot;Added json gem&quot; -a &quot;Docker Newbee&quot; 0b2616b0e5a8 ouruser&#x2F;sinatra:v2</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"进入运行中的容器\"><a href=\"#进入运行中的容器\" class=\"headerlink\" title=\"进入运行中的容器\"></a>进入运行中的容器</h4><p>docker exec -it bb5806a80788 /bin/sh</p>\n<h4 id=\"使用-Dockerfile-创建镜像\"><a href=\"#使用-Dockerfile-创建镜像\" class=\"headerlink\" title=\"使用 Dockerfile 创建镜像\"></a>使用 Dockerfile 创建镜像</h4><ol>\n<li>Dockerfile文件 <a href=\"http://www.dockerinfo.net/dockerfile%E4%BB%8B%E7%BB%8D\">http://www.dockerinfo.net/dockerfile%E4%BB%8B%E7%BB%8D</a></li>\n<li>docker build创建镜像</li>\n</ol>\n<ul>\n<li>sudo docker build -t=”yxc_test:v2” .</li>\n<li>-t 标记来添加 tag，指定新的镜像的用户信息。 “.” 是 Dockerfile 所在的路径（当前目录），也可以替换为一个具体的 Dockerfile 的路径</li>\n</ul>\n<ol start=\"3\">\n<li>docker tag 命令来修改镜像的标签：sudo docker tag 5db5f8471261 ouruser/sinatra:devel</li>\n</ol>\n<h4 id=\"导入本地镜像\"><a href=\"#导入本地镜像\" class=\"headerlink\" title=\"导入本地镜像\"></a>导入本地镜像</h4><ul>\n<li>sudo cat ubuntu-14.04-x86_64-minimal.tar.gz  |docker import - ubuntu:14.04</li>\n</ul>\n<h4 id=\"上传镜像到-Docker-Hub\"><a href=\"#上传镜像到-Docker-Hub\" class=\"headerlink\" title=\"上传镜像到 Docker Hub\"></a>上传镜像到 Docker Hub</h4><ul>\n<li>sudo docker push ouruser/sinatra</li>\n</ul>\n<h4 id=\"存出-载入镜像\"><a href=\"#存出-载入镜像\" class=\"headerlink\" title=\"存出/载入镜像\"></a>存出/载入镜像</h4><ul>\n<li>sudo docker save -o ubuntu_14.04.tar ubuntu:14.04</li>\n<li>sudo docker load –input ubuntu_14.04.tar || sudo docker load &lt; ubuntu_14.04.tar</li>\n</ul>\n<h4 id=\"移除本地镜像\"><a href=\"#移除本地镜像\" class=\"headerlink\" title=\"移除本地镜像\"></a>移除本地镜像</h4><ul>\n<li>sudo docker rmi training/sinatra</li>\n<li>在删除镜像之前要先用 docker rm 删掉依赖于这个镜像的所有容器</li>\n</ul>\n<h4 id=\"批量移除镜像（需要先删除容器）\"><a href=\"#批量移除镜像（需要先删除容器）\" class=\"headerlink\" title=\"批量移除镜像（需要先删除容器）\"></a>批量移除镜像（需要先删除容器）</h4><ul>\n<li>docker rmi $(docker images -q)</li>\n</ul>\n<h3 id=\"Docker容器\"><a href=\"#Docker容器\" class=\"headerlink\" title=\"Docker容器\"></a>Docker容器</h3><h4 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h4><ul>\n<li>sudo docker run -t -i ubuntu:14.04 /bin/bash</li>\n<li>-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开</li>\n</ul>\n<h4 id=\"启动已终止容器\"><a href=\"#启动已终止容器\" class=\"headerlink\" title=\"启动已终止容器\"></a>启动已终止容器</h4><ul>\n<li>docker start</li>\n</ul>\n<h4 id=\"守护态运行\"><a href=\"#守护态运行\" class=\"headerlink\" title=\"守护态运行\"></a>守护态运行</h4><ul>\n<li>需要让 Docker 容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加 -d 参数来实现</li>\n<li>获取容器的输出信息，可以通过 docker logs 命令</li>\n</ul>\n<h4 id=\"终止容器\"><a href=\"#终止容器\" class=\"headerlink\" title=\"终止容器\"></a>终止容器</h4><ul>\n<li>使用 docker stop 来终止一个运行中的容器</li>\n<li>终止状态的容器可以用 docker ps -a 命令看到</li>\n<li>docker restart 命令会将一个运行态的容器终止，然后再重新启动它</li>\n</ul>\n<h4 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h4><ul>\n<li>使用 docker rm 来删除一个处于终止状态的容器</li>\n</ul>\n<h4 id=\"批量删除容器\"><a href=\"#批量删除容器\" class=\"headerlink\" title=\"批量删除容器\"></a>批量删除容器</h4><ul>\n<li>docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h3><ul>\n<li>启动命令：sudo service docker start</li>\n<li>设置开机自启：sudo chkconfig docker on</li>\n</ul>\n<h3 id=\"image\"><a href=\"#image\" class=\"headerlink\" title=\"image\"></a>image</h3><h4 id=\"获取镜像\"><a href=\"#获取镜像\" class=\"headerlink\" title=\"获取镜像\"></a>获取镜像</h4><ul>\n<li>sudo docker pull ubantu</li>\n</ul>\n<h4 id=\"列出本地镜像\"><a href=\"#列出本地镜像\" class=\"headerlink\" title=\"列出本地镜像\"></a>列出本地镜像</h4><ul>\n<li>sudo docker images</li>\n</ul>\n<h4 id=\"修改已有的镜像\"><a href=\"#修改已有的镜像\" class=\"headerlink\" title=\"修改已有的镜像\"></a>修改已有的镜像</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;启动镜像容器</span><br><span class=\"line\">sudo docker run -p 8080:8080 -t -i yxc_test:v2 &#x2F;bin&#x2F;bash</span><br><span class=\"line\">&#x2F;&#x2F;在容器中添加内容，修改完成后使用 exit 退出</span><br><span class=\"line\">gem install json</span><br><span class=\"line\">&#x2F;&#x2F;使用docker commit命令 提交更新后的副本</span><br><span class=\"line\">sudo docker commit -m &quot;Added json gem&quot; -a &quot;Docker Newbee&quot; 0b2616b0e5a8 ouruser&#x2F;sinatra:v2</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"进入运行中的容器\"><a href=\"#进入运行中的容器\" class=\"headerlink\" title=\"进入运行中的容器\"></a>进入运行中的容器</h4><p>docker exec -it bb5806a80788 /bin/sh</p>\n<h4 id=\"使用-Dockerfile-创建镜像\"><a href=\"#使用-Dockerfile-创建镜像\" class=\"headerlink\" title=\"使用 Dockerfile 创建镜像\"></a>使用 Dockerfile 创建镜像</h4><ol>\n<li>Dockerfile文件 <a href=\"http://www.dockerinfo.net/dockerfile%E4%BB%8B%E7%BB%8D\">http://www.dockerinfo.net/dockerfile%E4%BB%8B%E7%BB%8D</a></li>\n<li>docker build创建镜像</li>\n</ol>\n<ul>\n<li>sudo docker build -t=”yxc_test:v2” .</li>\n<li>-t 标记来添加 tag，指定新的镜像的用户信息。 “.” 是 Dockerfile 所在的路径（当前目录），也可以替换为一个具体的 Dockerfile 的路径</li>\n</ul>\n<ol start=\"3\">\n<li>docker tag 命令来修改镜像的标签：sudo docker tag 5db5f8471261 ouruser/sinatra:devel</li>\n</ol>\n<h4 id=\"导入本地镜像\"><a href=\"#导入本地镜像\" class=\"headerlink\" title=\"导入本地镜像\"></a>导入本地镜像</h4><ul>\n<li>sudo cat ubuntu-14.04-x86_64-minimal.tar.gz  |docker import - ubuntu:14.04</li>\n</ul>\n<h4 id=\"上传镜像到-Docker-Hub\"><a href=\"#上传镜像到-Docker-Hub\" class=\"headerlink\" title=\"上传镜像到 Docker Hub\"></a>上传镜像到 Docker Hub</h4><ul>\n<li>sudo docker push ouruser/sinatra</li>\n</ul>\n<h4 id=\"存出-载入镜像\"><a href=\"#存出-载入镜像\" class=\"headerlink\" title=\"存出/载入镜像\"></a>存出/载入镜像</h4><ul>\n<li>sudo docker save -o ubuntu_14.04.tar ubuntu:14.04</li>\n<li>sudo docker load –input ubuntu_14.04.tar || sudo docker load &lt; ubuntu_14.04.tar</li>\n</ul>\n<h4 id=\"移除本地镜像\"><a href=\"#移除本地镜像\" class=\"headerlink\" title=\"移除本地镜像\"></a>移除本地镜像</h4><ul>\n<li>sudo docker rmi training/sinatra</li>\n<li>在删除镜像之前要先用 docker rm 删掉依赖于这个镜像的所有容器</li>\n</ul>\n<h4 id=\"批量移除镜像（需要先删除容器）\"><a href=\"#批量移除镜像（需要先删除容器）\" class=\"headerlink\" title=\"批量移除镜像（需要先删除容器）\"></a>批量移除镜像（需要先删除容器）</h4><ul>\n<li>docker rmi $(docker images -q)</li>\n</ul>\n<h3 id=\"Docker容器\"><a href=\"#Docker容器\" class=\"headerlink\" title=\"Docker容器\"></a>Docker容器</h3><h4 id=\"启动容器\"><a href=\"#启动容器\" class=\"headerlink\" title=\"启动容器\"></a>启动容器</h4><ul>\n<li>sudo docker run -t -i ubuntu:14.04 /bin/bash</li>\n<li>-t 选项让Docker分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上， -i 则让容器的标准输入保持打开</li>\n</ul>\n<h4 id=\"启动已终止容器\"><a href=\"#启动已终止容器\" class=\"headerlink\" title=\"启动已终止容器\"></a>启动已终止容器</h4><ul>\n<li>docker start</li>\n</ul>\n<h4 id=\"守护态运行\"><a href=\"#守护态运行\" class=\"headerlink\" title=\"守护态运行\"></a>守护态运行</h4><ul>\n<li>需要让 Docker 容器在后台以守护态（Daemonized）形式运行。此时，可以通过添加 -d 参数来实现</li>\n<li>获取容器的输出信息，可以通过 docker logs 命令</li>\n</ul>\n<h4 id=\"终止容器\"><a href=\"#终止容器\" class=\"headerlink\" title=\"终止容器\"></a>终止容器</h4><ul>\n<li>使用 docker stop 来终止一个运行中的容器</li>\n<li>终止状态的容器可以用 docker ps -a 命令看到</li>\n<li>docker restart 命令会将一个运行态的容器终止，然后再重新启动它</li>\n</ul>\n<h4 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h4><ul>\n<li>使用 docker rm 来删除一个处于终止状态的容器</li>\n</ul>\n<h4 id=\"批量删除容器\"><a href=\"#批量删除容器\" class=\"headerlink\" title=\"批量删除容器\"></a>批量删除容器</h4><ul>\n<li>docker stop $(docker ps -q) &amp; docker rm $(docker ps -aq)</li>\n</ul>\n"},{"title":"<工程化>代码检查","date":"2020-09-09T16:00:00.000Z","_content":"\n### Prettier\n\n- https://prettier.io/\n- 用于构建统一的编码风格\n- Prettier 是一个 Opinionated 的代码格式化工具\n- 使用 prettier-quick 格式化代码\n\n```\nnpm install --save-dev prettier pretty-quick\n// package.json 配合 husky 在提交阶段格式化代码\n\"husky\": {\n  \"hooks\": {\n    \"pre-commit\": \"pretty-quick --staged\"\n  }\n}\n```\n\n- 配置文件\n\n```\n// .prettierrc\n{\n  \"trailingComma\": \"es5\",\n  \"tabWidth\": 4,\n  \"semi\": false,\n  \"singleQuote\": true\n}\n// prettier.config.js or .prettierrc.js\nmodule.exports = {\n  trailingComma: \"es5\",\n  tabWidth: 4,\n  semi: false,\n  singleQuote: true,\n};\n```\n\n- 配置 .prettierignore 忽略文件\n\n### EsLint\n\n- https://cn.eslint.org/\n- 除了编码风格检查，还可以允许开发者在执行前发现代码错误或不合理的写法\n- 规则插件化，可插拔（随时开关），使用 Espree 解析 js，使用 AST 分析语法\n- 配置：\n\tenv：表示指定想启用的环境。\n\textends：指定额外配置的选项，如 ['airbnb'] 表示使用 Airbnb 的 Linting 规则。\n\tplugins：设置规则插件。\n\tparser：默认情况下 ESLint 使用 Espree 进行解析。\n\tparserOptions：如果将默认解析器更改，需要制定 parserOptions。\n\trules：定义拓展并通过插件添加的所有规则。\n\n```javascript\n// .eslintrc.js 文件\nmodule.exports = { \n   env: {}, \n   extends: ['eslint-config-prettier'], \n   plugins: {}, \n   parser: {}, \n   parserOptions: {}, \n   rules: {},\n}\n```\n\n- 与 prettier 一起使用，安装 eslint-config-prettier 在 extends 中配置\n- package.json 中配置：结合 husky、lint-staged\n\n```json\n{\n  \"scripts\": {\n    \"lint-staged\": \"lint-staged\"\n  },\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"npm run lint-staged\"\n    }\n  },\n  \"lint-staged\": {\n    \"**/*.less\": [\n      \"stylelint --fix\",\n      \"git add\"\n    ],\n    \"**/*.{js,jsx,tsx,ts,less,md,json}\": [\n      \"prettier --write\",\n      \"git add\"\n    ],\n    \"**/*.{js,jsx}\": \"npm run lint-staged:js\",\n    \"**/*.{js,ts,tsx}\": \"npm run lint-staged:js\"\n  }\n}\n```\n\n- 通过 .eslintignore 配置 esLint 忽略文件\n\n### styleLint\n\n- https://stylelint.io/\n- 检测样式文件格式、语法错误\n- 配置：https://www.cnblogs.com/jiaoshou/p/11284204.html\n\n### husky\n\n- husky 是 Git 的一个钩子，在 Git 进行到某一时段时，可以交给开发者完成某些特定的操作\n\n### lint-staged\n\n- 在 git 暂存文件上运行 linters 的工具\n- 整个项目运营 lint 会很慢，使用 lint-staged 可以只针对更改的文件进行检查\n\n### 参考\n\n- https://www.cnblogs.com/jserhub/p/11924289.html\n- https://zhuanlan.zhihu.com/p/81764012\n- https://www.yuque.com/runarale/tg28dt/pss8x9\n\n\n","source":"_posts/[工程化]代码检查.md","raw":"---\ntitle: <工程化>代码检查\ndate: 2020-09-10 00:00:00\ntags: [工程化,代码检查]\ncategories: 工程化\n---\n\n### Prettier\n\n- https://prettier.io/\n- 用于构建统一的编码风格\n- Prettier 是一个 Opinionated 的代码格式化工具\n- 使用 prettier-quick 格式化代码\n\n```\nnpm install --save-dev prettier pretty-quick\n// package.json 配合 husky 在提交阶段格式化代码\n\"husky\": {\n  \"hooks\": {\n    \"pre-commit\": \"pretty-quick --staged\"\n  }\n}\n```\n\n- 配置文件\n\n```\n// .prettierrc\n{\n  \"trailingComma\": \"es5\",\n  \"tabWidth\": 4,\n  \"semi\": false,\n  \"singleQuote\": true\n}\n// prettier.config.js or .prettierrc.js\nmodule.exports = {\n  trailingComma: \"es5\",\n  tabWidth: 4,\n  semi: false,\n  singleQuote: true,\n};\n```\n\n- 配置 .prettierignore 忽略文件\n\n### EsLint\n\n- https://cn.eslint.org/\n- 除了编码风格检查，还可以允许开发者在执行前发现代码错误或不合理的写法\n- 规则插件化，可插拔（随时开关），使用 Espree 解析 js，使用 AST 分析语法\n- 配置：\n\tenv：表示指定想启用的环境。\n\textends：指定额外配置的选项，如 ['airbnb'] 表示使用 Airbnb 的 Linting 规则。\n\tplugins：设置规则插件。\n\tparser：默认情况下 ESLint 使用 Espree 进行解析。\n\tparserOptions：如果将默认解析器更改，需要制定 parserOptions。\n\trules：定义拓展并通过插件添加的所有规则。\n\n```javascript\n// .eslintrc.js 文件\nmodule.exports = { \n   env: {}, \n   extends: ['eslint-config-prettier'], \n   plugins: {}, \n   parser: {}, \n   parserOptions: {}, \n   rules: {},\n}\n```\n\n- 与 prettier 一起使用，安装 eslint-config-prettier 在 extends 中配置\n- package.json 中配置：结合 husky、lint-staged\n\n```json\n{\n  \"scripts\": {\n    \"lint-staged\": \"lint-staged\"\n  },\n  \"husky\": {\n    \"hooks\": {\n      \"pre-commit\": \"npm run lint-staged\"\n    }\n  },\n  \"lint-staged\": {\n    \"**/*.less\": [\n      \"stylelint --fix\",\n      \"git add\"\n    ],\n    \"**/*.{js,jsx,tsx,ts,less,md,json}\": [\n      \"prettier --write\",\n      \"git add\"\n    ],\n    \"**/*.{js,jsx}\": \"npm run lint-staged:js\",\n    \"**/*.{js,ts,tsx}\": \"npm run lint-staged:js\"\n  }\n}\n```\n\n- 通过 .eslintignore 配置 esLint 忽略文件\n\n### styleLint\n\n- https://stylelint.io/\n- 检测样式文件格式、语法错误\n- 配置：https://www.cnblogs.com/jiaoshou/p/11284204.html\n\n### husky\n\n- husky 是 Git 的一个钩子，在 Git 进行到某一时段时，可以交给开发者完成某些特定的操作\n\n### lint-staged\n\n- 在 git 暂存文件上运行 linters 的工具\n- 整个项目运营 lint 会很慢，使用 lint-staged 可以只针对更改的文件进行检查\n\n### 参考\n\n- https://www.cnblogs.com/jserhub/p/11924289.html\n- https://zhuanlan.zhihu.com/p/81764012\n- https://www.yuque.com/runarale/tg28dt/pss8x9\n\n\n","slug":"[工程化]代码检查","published":1,"updated":"2021-03-15T14:32:11.321Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmaospgh0001d0tj638k3601","content":"<h3 id=\"Prettier\"><a href=\"#Prettier\" class=\"headerlink\" title=\"Prettier\"></a>Prettier</h3><ul>\n<li><a href=\"https://prettier.io/\">https://prettier.io/</a></li>\n<li>用于构建统一的编码风格</li>\n<li>Prettier 是一个 Opinionated 的代码格式化工具</li>\n<li>使用 prettier-quick 格式化代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev prettier pretty-quick</span><br><span class=\"line\">&#x2F;&#x2F; package.json 配合 husky 在提交阶段格式化代码</span><br><span class=\"line\">&quot;husky&quot;: &#123;</span><br><span class=\"line\">  &quot;hooks&quot;: &#123;</span><br><span class=\"line\">    &quot;pre-commit&quot;: &quot;pretty-quick --staged&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>配置文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; .prettierrc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;trailingComma&quot;: &quot;es5&quot;,</span><br><span class=\"line\">  &quot;tabWidth&quot;: 4,</span><br><span class=\"line\">  &quot;semi&quot;: false,</span><br><span class=\"line\">  &quot;singleQuote&quot;: true</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; prettier.config.js or .prettierrc.js</span><br><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">  trailingComma: &quot;es5&quot;,</span><br><span class=\"line\">  tabWidth: 4,</span><br><span class=\"line\">  semi: false,</span><br><span class=\"line\">  singleQuote: true,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>配置 .prettierignore 忽略文件</li>\n</ul>\n<h3 id=\"EsLint\"><a href=\"#EsLint\" class=\"headerlink\" title=\"EsLint\"></a>EsLint</h3><ul>\n<li><a href=\"https://cn.eslint.org/\">https://cn.eslint.org/</a></li>\n<li>除了编码风格检查，还可以允许开发者在执行前发现代码错误或不合理的写法</li>\n<li>规则插件化，可插拔（随时开关），使用 Espree 解析 js，使用 AST 分析语法</li>\n<li>配置：<br>  env：表示指定想启用的环境。<br>  extends：指定额外配置的选项，如 [‘airbnb’] 表示使用 Airbnb 的 Linting 规则。<br>  plugins：设置规则插件。<br>  parser：默认情况下 ESLint 使用 Espree 进行解析。<br>  parserOptions：如果将默认解析器更改，需要制定 parserOptions。<br>  rules：定义拓展并通过插件添加的所有规则。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .eslintrc.js 文件</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123; </span><br><span class=\"line\">   env: &#123;&#125;, </span><br><span class=\"line\">   <span class=\"keyword\">extends</span>: [<span class=\"string\">&#x27;eslint-config-prettier&#x27;</span>], </span><br><span class=\"line\">   plugins: &#123;&#125;, </span><br><span class=\"line\">   parser: &#123;&#125;, </span><br><span class=\"line\">   parserOptions: &#123;&#125;, </span><br><span class=\"line\">   rules: &#123;&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>与 prettier 一起使用，安装 eslint-config-prettier 在 extends 中配置</li>\n<li>package.json 中配置：结合 husky、lint-staged</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;lint-staged&quot;</span>: <span class=\"string\">&quot;lint-staged&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;husky&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;hooks&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;pre-commit&quot;</span>: <span class=\"string\">&quot;npm run lint-staged&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;lint-staged&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;**/*.less&quot;</span>: [</span><br><span class=\"line\">      <span class=\"string\">&quot;stylelint --fix&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;git add&quot;</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">&quot;**/*.&#123;js,jsx,tsx,ts,less,md,json&#125;&quot;</span>: [</span><br><span class=\"line\">      <span class=\"string\">&quot;prettier --write&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;git add&quot;</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">&quot;**/*.&#123;js,jsx&#125;&quot;</span>: <span class=\"string\">&quot;npm run lint-staged:js&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;**/*.&#123;js,ts,tsx&#125;&quot;</span>: <span class=\"string\">&quot;npm run lint-staged:js&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通过 .eslintignore 配置 esLint 忽略文件</li>\n</ul>\n<h3 id=\"styleLint\"><a href=\"#styleLint\" class=\"headerlink\" title=\"styleLint\"></a>styleLint</h3><ul>\n<li><a href=\"https://stylelint.io/\">https://stylelint.io/</a></li>\n<li>检测样式文件格式、语法错误</li>\n<li>配置：<a href=\"https://www.cnblogs.com/jiaoshou/p/11284204.html\">https://www.cnblogs.com/jiaoshou/p/11284204.html</a></li>\n</ul>\n<h3 id=\"husky\"><a href=\"#husky\" class=\"headerlink\" title=\"husky\"></a>husky</h3><ul>\n<li>husky 是 Git 的一个钩子，在 Git 进行到某一时段时，可以交给开发者完成某些特定的操作</li>\n</ul>\n<h3 id=\"lint-staged\"><a href=\"#lint-staged\" class=\"headerlink\" title=\"lint-staged\"></a>lint-staged</h3><ul>\n<li>在 git 暂存文件上运行 linters 的工具</li>\n<li>整个项目运营 lint 会很慢，使用 lint-staged 可以只针对更改的文件进行检查</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://www.cnblogs.com/jserhub/p/11924289.html\">https://www.cnblogs.com/jserhub/p/11924289.html</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/81764012\">https://zhuanlan.zhihu.com/p/81764012</a></li>\n<li><a href=\"https://www.yuque.com/runarale/tg28dt/pss8x9\">https://www.yuque.com/runarale/tg28dt/pss8x9</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Prettier\"><a href=\"#Prettier\" class=\"headerlink\" title=\"Prettier\"></a>Prettier</h3><ul>\n<li><a href=\"https://prettier.io/\">https://prettier.io/</a></li>\n<li>用于构建统一的编码风格</li>\n<li>Prettier 是一个 Opinionated 的代码格式化工具</li>\n<li>使用 prettier-quick 格式化代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev prettier pretty-quick</span><br><span class=\"line\">&#x2F;&#x2F; package.json 配合 husky 在提交阶段格式化代码</span><br><span class=\"line\">&quot;husky&quot;: &#123;</span><br><span class=\"line\">  &quot;hooks&quot;: &#123;</span><br><span class=\"line\">    &quot;pre-commit&quot;: &quot;pretty-quick --staged&quot;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>配置文件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; .prettierrc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;trailingComma&quot;: &quot;es5&quot;,</span><br><span class=\"line\">  &quot;tabWidth&quot;: 4,</span><br><span class=\"line\">  &quot;semi&quot;: false,</span><br><span class=\"line\">  &quot;singleQuote&quot;: true</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F; prettier.config.js or .prettierrc.js</span><br><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">  trailingComma: &quot;es5&quot;,</span><br><span class=\"line\">  tabWidth: 4,</span><br><span class=\"line\">  semi: false,</span><br><span class=\"line\">  singleQuote: true,</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>配置 .prettierignore 忽略文件</li>\n</ul>\n<h3 id=\"EsLint\"><a href=\"#EsLint\" class=\"headerlink\" title=\"EsLint\"></a>EsLint</h3><ul>\n<li><a href=\"https://cn.eslint.org/\">https://cn.eslint.org/</a></li>\n<li>除了编码风格检查，还可以允许开发者在执行前发现代码错误或不合理的写法</li>\n<li>规则插件化，可插拔（随时开关），使用 Espree 解析 js，使用 AST 分析语法</li>\n<li>配置：<br>  env：表示指定想启用的环境。<br>  extends：指定额外配置的选项，如 [‘airbnb’] 表示使用 Airbnb 的 Linting 规则。<br>  plugins：设置规则插件。<br>  parser：默认情况下 ESLint 使用 Espree 进行解析。<br>  parserOptions：如果将默认解析器更改，需要制定 parserOptions。<br>  rules：定义拓展并通过插件添加的所有规则。</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// .eslintrc.js 文件</span></span><br><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123; </span><br><span class=\"line\">   env: &#123;&#125;, </span><br><span class=\"line\">   <span class=\"keyword\">extends</span>: [<span class=\"string\">&#x27;eslint-config-prettier&#x27;</span>], </span><br><span class=\"line\">   plugins: &#123;&#125;, </span><br><span class=\"line\">   parser: &#123;&#125;, </span><br><span class=\"line\">   parserOptions: &#123;&#125;, </span><br><span class=\"line\">   rules: &#123;&#125;,</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>与 prettier 一起使用，安装 eslint-config-prettier 在 extends 中配置</li>\n<li>package.json 中配置：结合 husky、lint-staged</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;lint-staged&quot;</span>: <span class=\"string\">&quot;lint-staged&quot;</span></span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;husky&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;hooks&quot;</span>: &#123;</span><br><span class=\"line\">      <span class=\"attr\">&quot;pre-commit&quot;</span>: <span class=\"string\">&quot;npm run lint-staged&quot;</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  <span class=\"attr\">&quot;lint-staged&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;**/*.less&quot;</span>: [</span><br><span class=\"line\">      <span class=\"string\">&quot;stylelint --fix&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;git add&quot;</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">&quot;**/*.&#123;js,jsx,tsx,ts,less,md,json&#125;&quot;</span>: [</span><br><span class=\"line\">      <span class=\"string\">&quot;prettier --write&quot;</span>,</span><br><span class=\"line\">      <span class=\"string\">&quot;git add&quot;</span></span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"attr\">&quot;**/*.&#123;js,jsx&#125;&quot;</span>: <span class=\"string\">&quot;npm run lint-staged:js&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;**/*.&#123;js,ts,tsx&#125;&quot;</span>: <span class=\"string\">&quot;npm run lint-staged:js&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>通过 .eslintignore 配置 esLint 忽略文件</li>\n</ul>\n<h3 id=\"styleLint\"><a href=\"#styleLint\" class=\"headerlink\" title=\"styleLint\"></a>styleLint</h3><ul>\n<li><a href=\"https://stylelint.io/\">https://stylelint.io/</a></li>\n<li>检测样式文件格式、语法错误</li>\n<li>配置：<a href=\"https://www.cnblogs.com/jiaoshou/p/11284204.html\">https://www.cnblogs.com/jiaoshou/p/11284204.html</a></li>\n</ul>\n<h3 id=\"husky\"><a href=\"#husky\" class=\"headerlink\" title=\"husky\"></a>husky</h3><ul>\n<li>husky 是 Git 的一个钩子，在 Git 进行到某一时段时，可以交给开发者完成某些特定的操作</li>\n</ul>\n<h3 id=\"lint-staged\"><a href=\"#lint-staged\" class=\"headerlink\" title=\"lint-staged\"></a>lint-staged</h3><ul>\n<li>在 git 暂存文件上运行 linters 的工具</li>\n<li>整个项目运营 lint 会很慢，使用 lint-staged 可以只针对更改的文件进行检查</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://www.cnblogs.com/jserhub/p/11924289.html\">https://www.cnblogs.com/jserhub/p/11924289.html</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/81764012\">https://zhuanlan.zhihu.com/p/81764012</a></li>\n<li><a href=\"https://www.yuque.com/runarale/tg28dt/pss8x9\">https://www.yuque.com/runarale/tg28dt/pss8x9</a></li>\n</ul>\n"},{"title":"<ES6>Set&Map","date":"2018-08-21T16:00:00.000Z","_content":"### 简介\n\n- 如果开发者想使用非数值型索引，就会使用数组对象创建数据结构，这是Set&Map早期实现\n\n#### 对象属性的限制\n\n1. map[5]与map['5']是同一个\n2. let k1 = {},k2 = {};map[k1]与map[k2]是同一个，因为对象会被转换为默认的字符换表达式\n3. map['count'] = 1,检查map.count是否存在很困难\n4. in运算符会检索对象原型，只有当原型为null时这个方法才比较稳妥\n\n### Set集合\n\n1. 不会对所存储的值进行强制的类型转换，数字5和字符串'5'可作为两个元素存在（内部使用Object.is()检测），但是-0和+0被认为相等\n2. 如果多次调用add()传入相同的参数，后续的调用会被忽略\n3. 通过has()方法检测是否含有某个值\n4. 使用delete()移除元素\n5. 使用clear()清空Set集合\n\n```\nlet set = new Set([1,1,1,2,2,3])//使用含重复元素的数组初始化Set集合\nconsole.log(set.size)//3\nset.add(5)\nset.add('5')\nset.add(5)//被忽略\nconsole.log(set.has(5))//true\nconsole.log(set.has(6))//false\n\nset.delete(5)\nconsole.log(set.has(5))//false\nset.clear()\nconsole.log(set.size)//0\n```\n\n#### set的forEach方法\n\n- set的forEach方法（回调参数：1、下一次索引位置，2、与第一次相同的值（为了和数组forEach参数统一），3、Set集合本身）\n\n```\nlet set2 = new Set([1,2,3])\nset2.forEach(function (val,k,set) {\n    console.log(val)\n    console.log(k)\n    console.log(set===set2)//true\n},this)//如果不是箭头函数，可以从这里传入this\n```\n\n- 不能通过访问数组元素那样直接通过索引访问Set集合元素，需要转换成数组\n\n```\nlet set3 = new Set([1,1,1,2,2,3,3])\nlet arr = [...set]//复制数组并且创建一个无重复元素的新数组\n```\n\n#### Weak Set\n\n- 只存储对象的弱引用，并且不可以存储原始值，如果集合中弱引用是对象的唯一引用，则回收释放相应内存\n- 两种Set的主要区别：\n- 1、WeakSet实例中，如果传入非对象参数会报错\n- 2、WeakSet对象不可迭代，不能用for-of循环\n- 3、WeakSet不暴露任何迭代器（keys()\\values()）不能通过程序检测其中内容\n- 4、WeakSet不支持forEach方法\n- 5、WeakSize不支持size属性\n\n```\nlet wset4 = new WeakSet()\nlet k = {}\nwset4.add(k)\nconsole.log(wset4.has(k))//true\nwset4.delete(k)\nconsole.log(wset4.has(k))//false\n```\n\n### Map集合\n\n- Map类型是一种存储许多键值对的有序列表\n- 其中键名和对应的值支持所有类型，键名的等价性判断是通过Object.is()判断的\n- 添加set(),获取get()\n\n```\nlet map = new Map()\nmap.set('aaa','123')\nconsole.log(map.get('aaa'))//123\nconsole.log(map.get(111))//undefined（不存在）\n\n//map总可以使用对象作为键名,对象键名不会强制转换为其他类型，所以这两个键名独立存在\nlet key1 = {},key2 = {}\nmap.set(key1,5)\nmap.set(key2,6)\nconsole.log(map.get(key1))//5\nconsole.log(map.get(key2))//6\n```\n\n- has()判断键名是否存在\n- delete()删除\n- clear()清空\n- Map集合中的size属性和Set中的类似，为集合中键值对的数量\n\n#### Map的初始化方法\n\n```\nlet map1 = new Map([['name',1],['age',2]])\nconsole.log(map1.has('name'))\n```\n\n#### Map集合的forEach\n\n- Map集合的forEach方法，三个参数，1、下一次索引位置2、值对应的键名3、Map集合本身 (可以指定forEach的第二个参数作为回调的this)\n\n```\nmap1.forEach((value,key,ownerMap)=>{\n    console.log(value)\n    console.log(key)\n    console.log(ownerMap === map1)\n})\n```\n\n#### Weak Map\n- 最大用途是保存Web页面中的DOM元素\n- ES6中Weak Map是一种存储许多键值对的无序列表，列表的键名必须是非null类型的对象\n- has()\\delete()\n- 不支持键名枚举、不支持clear()方法\n\n```\nlet wmap = new WeakMap()\n\nlet element = document.getElementById('aaa')\nwmap.set(element,'123')//element不能为null\nconsole.log(wmap.get(element))\n```\n\n#### 私有对象数据\n\n- 尽管Weak Map大多被用来存储DOM元素，但也有其他用处,ES5一般使用_C下划线属性作为私有属性，但是没有任何标准规定如何使用，也会被更改\n\n```\n//ES5处理私有变量,缺点无法获知对象何时被摧毁，obj中的数据永远不会消失\nvar Person = (function () {\n    var obj = {}\n    var idNum = 0\n    function Person(name) {\n        Object.defineProperty(this,'_id',{value: idNum++})\n        obj[this._id] = {\n            name: name\n        }\n    }\n    Person.prototype.getName = function () {\n        return obj[this._id].name\n    }\n    return Person\n})()\nconsole.log(new Person(111).getName())\n```\n```\n//使用WeakMap解决此问题,只要对象被摧毁，相关信息也会摧毁\nlet WPerson = (function () {\n    let wmap = new WeakMap()\n    function Person(name) {\n        wmap.set(this,{name: name})\n    }\n    Person.prototype.getName = function () {\n        return wmap.get(this).name\n    }\n    return Person\n})()\nconsole.log(new WPerson(222).getName())\n```\n\n- 如果只使用对象作为键名，那么WeakMap是最好的选择，可以有效避免内存泄漏问题\n","source":"_posts/[ES6]Set&Map.md","raw":"---\ntitle: <ES6>Set&Map\ndate: 2018-08-22 00:00:00\ntags: [ES6,js]\ncategories: ES6\n---\n### 简介\n\n- 如果开发者想使用非数值型索引，就会使用数组对象创建数据结构，这是Set&Map早期实现\n\n#### 对象属性的限制\n\n1. map[5]与map['5']是同一个\n2. let k1 = {},k2 = {};map[k1]与map[k2]是同一个，因为对象会被转换为默认的字符换表达式\n3. map['count'] = 1,检查map.count是否存在很困难\n4. in运算符会检索对象原型，只有当原型为null时这个方法才比较稳妥\n\n### Set集合\n\n1. 不会对所存储的值进行强制的类型转换，数字5和字符串'5'可作为两个元素存在（内部使用Object.is()检测），但是-0和+0被认为相等\n2. 如果多次调用add()传入相同的参数，后续的调用会被忽略\n3. 通过has()方法检测是否含有某个值\n4. 使用delete()移除元素\n5. 使用clear()清空Set集合\n\n```\nlet set = new Set([1,1,1,2,2,3])//使用含重复元素的数组初始化Set集合\nconsole.log(set.size)//3\nset.add(5)\nset.add('5')\nset.add(5)//被忽略\nconsole.log(set.has(5))//true\nconsole.log(set.has(6))//false\n\nset.delete(5)\nconsole.log(set.has(5))//false\nset.clear()\nconsole.log(set.size)//0\n```\n\n#### set的forEach方法\n\n- set的forEach方法（回调参数：1、下一次索引位置，2、与第一次相同的值（为了和数组forEach参数统一），3、Set集合本身）\n\n```\nlet set2 = new Set([1,2,3])\nset2.forEach(function (val,k,set) {\n    console.log(val)\n    console.log(k)\n    console.log(set===set2)//true\n},this)//如果不是箭头函数，可以从这里传入this\n```\n\n- 不能通过访问数组元素那样直接通过索引访问Set集合元素，需要转换成数组\n\n```\nlet set3 = new Set([1,1,1,2,2,3,3])\nlet arr = [...set]//复制数组并且创建一个无重复元素的新数组\n```\n\n#### Weak Set\n\n- 只存储对象的弱引用，并且不可以存储原始值，如果集合中弱引用是对象的唯一引用，则回收释放相应内存\n- 两种Set的主要区别：\n- 1、WeakSet实例中，如果传入非对象参数会报错\n- 2、WeakSet对象不可迭代，不能用for-of循环\n- 3、WeakSet不暴露任何迭代器（keys()\\values()）不能通过程序检测其中内容\n- 4、WeakSet不支持forEach方法\n- 5、WeakSize不支持size属性\n\n```\nlet wset4 = new WeakSet()\nlet k = {}\nwset4.add(k)\nconsole.log(wset4.has(k))//true\nwset4.delete(k)\nconsole.log(wset4.has(k))//false\n```\n\n### Map集合\n\n- Map类型是一种存储许多键值对的有序列表\n- 其中键名和对应的值支持所有类型，键名的等价性判断是通过Object.is()判断的\n- 添加set(),获取get()\n\n```\nlet map = new Map()\nmap.set('aaa','123')\nconsole.log(map.get('aaa'))//123\nconsole.log(map.get(111))//undefined（不存在）\n\n//map总可以使用对象作为键名,对象键名不会强制转换为其他类型，所以这两个键名独立存在\nlet key1 = {},key2 = {}\nmap.set(key1,5)\nmap.set(key2,6)\nconsole.log(map.get(key1))//5\nconsole.log(map.get(key2))//6\n```\n\n- has()判断键名是否存在\n- delete()删除\n- clear()清空\n- Map集合中的size属性和Set中的类似，为集合中键值对的数量\n\n#### Map的初始化方法\n\n```\nlet map1 = new Map([['name',1],['age',2]])\nconsole.log(map1.has('name'))\n```\n\n#### Map集合的forEach\n\n- Map集合的forEach方法，三个参数，1、下一次索引位置2、值对应的键名3、Map集合本身 (可以指定forEach的第二个参数作为回调的this)\n\n```\nmap1.forEach((value,key,ownerMap)=>{\n    console.log(value)\n    console.log(key)\n    console.log(ownerMap === map1)\n})\n```\n\n#### Weak Map\n- 最大用途是保存Web页面中的DOM元素\n- ES6中Weak Map是一种存储许多键值对的无序列表，列表的键名必须是非null类型的对象\n- has()\\delete()\n- 不支持键名枚举、不支持clear()方法\n\n```\nlet wmap = new WeakMap()\n\nlet element = document.getElementById('aaa')\nwmap.set(element,'123')//element不能为null\nconsole.log(wmap.get(element))\n```\n\n#### 私有对象数据\n\n- 尽管Weak Map大多被用来存储DOM元素，但也有其他用处,ES5一般使用_C下划线属性作为私有属性，但是没有任何标准规定如何使用，也会被更改\n\n```\n//ES5处理私有变量,缺点无法获知对象何时被摧毁，obj中的数据永远不会消失\nvar Person = (function () {\n    var obj = {}\n    var idNum = 0\n    function Person(name) {\n        Object.defineProperty(this,'_id',{value: idNum++})\n        obj[this._id] = {\n            name: name\n        }\n    }\n    Person.prototype.getName = function () {\n        return obj[this._id].name\n    }\n    return Person\n})()\nconsole.log(new Person(111).getName())\n```\n```\n//使用WeakMap解决此问题,只要对象被摧毁，相关信息也会摧毁\nlet WPerson = (function () {\n    let wmap = new WeakMap()\n    function Person(name) {\n        wmap.set(this,{name: name})\n    }\n    Person.prototype.getName = function () {\n        return wmap.get(this).name\n    }\n    return Person\n})()\nconsole.log(new WPerson(222).getName())\n```\n\n- 如果只使用对象作为键名，那么WeakMap是最好的选择，可以有效避免内存泄漏问题\n","slug":"[ES6]Set&Map","published":1,"updated":"2021-03-15T14:37:20.260Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4djr0000wotjerg0d3vy","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>如果开发者想使用非数值型索引，就会使用数组对象创建数据结构，这是Set&amp;Map早期实现</li>\n</ul>\n<h4 id=\"对象属性的限制\"><a href=\"#对象属性的限制\" class=\"headerlink\" title=\"对象属性的限制\"></a>对象属性的限制</h4><ol>\n<li>map[5]与map[‘5’]是同一个</li>\n<li>let k1 = {},k2 = {};map[k1]与map[k2]是同一个，因为对象会被转换为默认的字符换表达式</li>\n<li>map[‘count’] = 1,检查map.count是否存在很困难</li>\n<li>in运算符会检索对象原型，只有当原型为null时这个方法才比较稳妥</li>\n</ol>\n<h3 id=\"Set集合\"><a href=\"#Set集合\" class=\"headerlink\" title=\"Set集合\"></a>Set集合</h3><ol>\n<li>不会对所存储的值进行强制的类型转换，数字5和字符串’5’可作为两个元素存在（内部使用Object.is()检测），但是-0和+0被认为相等</li>\n<li>如果多次调用add()传入相同的参数，后续的调用会被忽略</li>\n<li>通过has()方法检测是否含有某个值</li>\n<li>使用delete()移除元素</li>\n<li>使用clear()清空Set集合</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set &#x3D; new Set([1,1,1,2,2,3])&#x2F;&#x2F;使用含重复元素的数组初始化Set集合</span><br><span class=\"line\">console.log(set.size)&#x2F;&#x2F;3</span><br><span class=\"line\">set.add(5)</span><br><span class=\"line\">set.add(&#39;5&#39;)</span><br><span class=\"line\">set.add(5)&#x2F;&#x2F;被忽略</span><br><span class=\"line\">console.log(set.has(5))&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(set.has(6))&#x2F;&#x2F;false</span><br><span class=\"line\"></span><br><span class=\"line\">set.delete(5)</span><br><span class=\"line\">console.log(set.has(5))&#x2F;&#x2F;false</span><br><span class=\"line\">set.clear()</span><br><span class=\"line\">console.log(set.size)&#x2F;&#x2F;0</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"set的forEach方法\"><a href=\"#set的forEach方法\" class=\"headerlink\" title=\"set的forEach方法\"></a>set的forEach方法</h4><ul>\n<li>set的forEach方法（回调参数：1、下一次索引位置，2、与第一次相同的值（为了和数组forEach参数统一），3、Set集合本身）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set2 &#x3D; new Set([1,2,3])</span><br><span class=\"line\">set2.forEach(function (val,k,set) &#123;</span><br><span class=\"line\">    console.log(val)</span><br><span class=\"line\">    console.log(k)</span><br><span class=\"line\">    console.log(set&#x3D;&#x3D;&#x3D;set2)&#x2F;&#x2F;true</span><br><span class=\"line\">&#125;,this)&#x2F;&#x2F;如果不是箭头函数，可以从这里传入this</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>不能通过访问数组元素那样直接通过索引访问Set集合元素，需要转换成数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set3 &#x3D; new Set([1,1,1,2,2,3,3])</span><br><span class=\"line\">let arr &#x3D; [...set]&#x2F;&#x2F;复制数组并且创建一个无重复元素的新数组</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Weak-Set\"><a href=\"#Weak-Set\" class=\"headerlink\" title=\"Weak Set\"></a>Weak Set</h4><ul>\n<li>只存储对象的弱引用，并且不可以存储原始值，如果集合中弱引用是对象的唯一引用，则回收释放相应内存</li>\n<li>两种Set的主要区别：</li>\n<li>1、WeakSet实例中，如果传入非对象参数会报错</li>\n<li>2、WeakSet对象不可迭代，不能用for-of循环</li>\n<li>3、WeakSet不暴露任何迭代器（keys()\\values()）不能通过程序检测其中内容</li>\n<li>4、WeakSet不支持forEach方法</li>\n<li>5、WeakSize不支持size属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let wset4 &#x3D; new WeakSet()</span><br><span class=\"line\">let k &#x3D; &#123;&#125;</span><br><span class=\"line\">wset4.add(k)</span><br><span class=\"line\">console.log(wset4.has(k))&#x2F;&#x2F;true</span><br><span class=\"line\">wset4.delete(k)</span><br><span class=\"line\">console.log(wset4.has(k))&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Map集合\"><a href=\"#Map集合\" class=\"headerlink\" title=\"Map集合\"></a>Map集合</h3><ul>\n<li>Map类型是一种存储许多键值对的有序列表</li>\n<li>其中键名和对应的值支持所有类型，键名的等价性判断是通过Object.is()判断的</li>\n<li>添加set(),获取get()</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map &#x3D; new Map()</span><br><span class=\"line\">map.set(&#39;aaa&#39;,&#39;123&#39;)</span><br><span class=\"line\">console.log(map.get(&#39;aaa&#39;))&#x2F;&#x2F;123</span><br><span class=\"line\">console.log(map.get(111))&#x2F;&#x2F;undefined（不存在）</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;map总可以使用对象作为键名,对象键名不会强制转换为其他类型，所以这两个键名独立存在</span><br><span class=\"line\">let key1 &#x3D; &#123;&#125;,key2 &#x3D; &#123;&#125;</span><br><span class=\"line\">map.set(key1,5)</span><br><span class=\"line\">map.set(key2,6)</span><br><span class=\"line\">console.log(map.get(key1))&#x2F;&#x2F;5</span><br><span class=\"line\">console.log(map.get(key2))&#x2F;&#x2F;6</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>has()判断键名是否存在</li>\n<li>delete()删除</li>\n<li>clear()清空</li>\n<li>Map集合中的size属性和Set中的类似，为集合中键值对的数量</li>\n</ul>\n<h4 id=\"Map的初始化方法\"><a href=\"#Map的初始化方法\" class=\"headerlink\" title=\"Map的初始化方法\"></a>Map的初始化方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map1 &#x3D; new Map([[&#39;name&#39;,1],[&#39;age&#39;,2]])</span><br><span class=\"line\">console.log(map1.has(&#39;name&#39;))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Map集合的forEach\"><a href=\"#Map集合的forEach\" class=\"headerlink\" title=\"Map集合的forEach\"></a>Map集合的forEach</h4><ul>\n<li>Map集合的forEach方法，三个参数，1、下一次索引位置2、值对应的键名3、Map集合本身 (可以指定forEach的第二个参数作为回调的this)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map1.forEach((value,key,ownerMap)&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">    console.log(key)</span><br><span class=\"line\">    console.log(ownerMap &#x3D;&#x3D;&#x3D; map1)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Weak-Map\"><a href=\"#Weak-Map\" class=\"headerlink\" title=\"Weak Map\"></a>Weak Map</h4><ul>\n<li>最大用途是保存Web页面中的DOM元素</li>\n<li>ES6中Weak Map是一种存储许多键值对的无序列表，列表的键名必须是非null类型的对象</li>\n<li>has()\\delete()</li>\n<li>不支持键名枚举、不支持clear()方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let wmap &#x3D; new WeakMap()</span><br><span class=\"line\"></span><br><span class=\"line\">let element &#x3D; document.getElementById(&#39;aaa&#39;)</span><br><span class=\"line\">wmap.set(element,&#39;123&#39;)&#x2F;&#x2F;element不能为null</span><br><span class=\"line\">console.log(wmap.get(element))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"私有对象数据\"><a href=\"#私有对象数据\" class=\"headerlink\" title=\"私有对象数据\"></a>私有对象数据</h4><ul>\n<li>尽管Weak Map大多被用来存储DOM元素，但也有其他用处,ES5一般使用_C下划线属性作为私有属性，但是没有任何标准规定如何使用，也会被更改</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ES5处理私有变量,缺点无法获知对象何时被摧毁，obj中的数据永远不会消失</span><br><span class=\"line\">var Person &#x3D; (function () &#123;</span><br><span class=\"line\">    var obj &#x3D; &#123;&#125;</span><br><span class=\"line\">    var idNum &#x3D; 0</span><br><span class=\"line\">    function Person(name) &#123;</span><br><span class=\"line\">        Object.defineProperty(this,&#39;_id&#39;,&#123;value: idNum++&#125;)</span><br><span class=\"line\">        obj[this._id] &#x3D; &#123;</span><br><span class=\"line\">            name: name</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Person.prototype.getName &#x3D; function () &#123;</span><br><span class=\"line\">        return obj[this._id].name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Person</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">console.log(new Person(111).getName())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;使用WeakMap解决此问题,只要对象被摧毁，相关信息也会摧毁</span><br><span class=\"line\">let WPerson &#x3D; (function () &#123;</span><br><span class=\"line\">    let wmap &#x3D; new WeakMap()</span><br><span class=\"line\">    function Person(name) &#123;</span><br><span class=\"line\">        wmap.set(this,&#123;name: name&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Person.prototype.getName &#x3D; function () &#123;</span><br><span class=\"line\">        return wmap.get(this).name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Person</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">console.log(new WPerson(222).getName())</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果只使用对象作为键名，那么WeakMap是最好的选择，可以有效避免内存泄漏问题</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>如果开发者想使用非数值型索引，就会使用数组对象创建数据结构，这是Set&amp;Map早期实现</li>\n</ul>\n<h4 id=\"对象属性的限制\"><a href=\"#对象属性的限制\" class=\"headerlink\" title=\"对象属性的限制\"></a>对象属性的限制</h4><ol>\n<li>map[5]与map[‘5’]是同一个</li>\n<li>let k1 = {},k2 = {};map[k1]与map[k2]是同一个，因为对象会被转换为默认的字符换表达式</li>\n<li>map[‘count’] = 1,检查map.count是否存在很困难</li>\n<li>in运算符会检索对象原型，只有当原型为null时这个方法才比较稳妥</li>\n</ol>\n<h3 id=\"Set集合\"><a href=\"#Set集合\" class=\"headerlink\" title=\"Set集合\"></a>Set集合</h3><ol>\n<li>不会对所存储的值进行强制的类型转换，数字5和字符串’5’可作为两个元素存在（内部使用Object.is()检测），但是-0和+0被认为相等</li>\n<li>如果多次调用add()传入相同的参数，后续的调用会被忽略</li>\n<li>通过has()方法检测是否含有某个值</li>\n<li>使用delete()移除元素</li>\n<li>使用clear()清空Set集合</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set &#x3D; new Set([1,1,1,2,2,3])&#x2F;&#x2F;使用含重复元素的数组初始化Set集合</span><br><span class=\"line\">console.log(set.size)&#x2F;&#x2F;3</span><br><span class=\"line\">set.add(5)</span><br><span class=\"line\">set.add(&#39;5&#39;)</span><br><span class=\"line\">set.add(5)&#x2F;&#x2F;被忽略</span><br><span class=\"line\">console.log(set.has(5))&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(set.has(6))&#x2F;&#x2F;false</span><br><span class=\"line\"></span><br><span class=\"line\">set.delete(5)</span><br><span class=\"line\">console.log(set.has(5))&#x2F;&#x2F;false</span><br><span class=\"line\">set.clear()</span><br><span class=\"line\">console.log(set.size)&#x2F;&#x2F;0</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"set的forEach方法\"><a href=\"#set的forEach方法\" class=\"headerlink\" title=\"set的forEach方法\"></a>set的forEach方法</h4><ul>\n<li>set的forEach方法（回调参数：1、下一次索引位置，2、与第一次相同的值（为了和数组forEach参数统一），3、Set集合本身）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set2 &#x3D; new Set([1,2,3])</span><br><span class=\"line\">set2.forEach(function (val,k,set) &#123;</span><br><span class=\"line\">    console.log(val)</span><br><span class=\"line\">    console.log(k)</span><br><span class=\"line\">    console.log(set&#x3D;&#x3D;&#x3D;set2)&#x2F;&#x2F;true</span><br><span class=\"line\">&#125;,this)&#x2F;&#x2F;如果不是箭头函数，可以从这里传入this</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>不能通过访问数组元素那样直接通过索引访问Set集合元素，需要转换成数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set3 &#x3D; new Set([1,1,1,2,2,3,3])</span><br><span class=\"line\">let arr &#x3D; [...set]&#x2F;&#x2F;复制数组并且创建一个无重复元素的新数组</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Weak-Set\"><a href=\"#Weak-Set\" class=\"headerlink\" title=\"Weak Set\"></a>Weak Set</h4><ul>\n<li>只存储对象的弱引用，并且不可以存储原始值，如果集合中弱引用是对象的唯一引用，则回收释放相应内存</li>\n<li>两种Set的主要区别：</li>\n<li>1、WeakSet实例中，如果传入非对象参数会报错</li>\n<li>2、WeakSet对象不可迭代，不能用for-of循环</li>\n<li>3、WeakSet不暴露任何迭代器（keys()\\values()）不能通过程序检测其中内容</li>\n<li>4、WeakSet不支持forEach方法</li>\n<li>5、WeakSize不支持size属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let wset4 &#x3D; new WeakSet()</span><br><span class=\"line\">let k &#x3D; &#123;&#125;</span><br><span class=\"line\">wset4.add(k)</span><br><span class=\"line\">console.log(wset4.has(k))&#x2F;&#x2F;true</span><br><span class=\"line\">wset4.delete(k)</span><br><span class=\"line\">console.log(wset4.has(k))&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Map集合\"><a href=\"#Map集合\" class=\"headerlink\" title=\"Map集合\"></a>Map集合</h3><ul>\n<li>Map类型是一种存储许多键值对的有序列表</li>\n<li>其中键名和对应的值支持所有类型，键名的等价性判断是通过Object.is()判断的</li>\n<li>添加set(),获取get()</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map &#x3D; new Map()</span><br><span class=\"line\">map.set(&#39;aaa&#39;,&#39;123&#39;)</span><br><span class=\"line\">console.log(map.get(&#39;aaa&#39;))&#x2F;&#x2F;123</span><br><span class=\"line\">console.log(map.get(111))&#x2F;&#x2F;undefined（不存在）</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;map总可以使用对象作为键名,对象键名不会强制转换为其他类型，所以这两个键名独立存在</span><br><span class=\"line\">let key1 &#x3D; &#123;&#125;,key2 &#x3D; &#123;&#125;</span><br><span class=\"line\">map.set(key1,5)</span><br><span class=\"line\">map.set(key2,6)</span><br><span class=\"line\">console.log(map.get(key1))&#x2F;&#x2F;5</span><br><span class=\"line\">console.log(map.get(key2))&#x2F;&#x2F;6</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>has()判断键名是否存在</li>\n<li>delete()删除</li>\n<li>clear()清空</li>\n<li>Map集合中的size属性和Set中的类似，为集合中键值对的数量</li>\n</ul>\n<h4 id=\"Map的初始化方法\"><a href=\"#Map的初始化方法\" class=\"headerlink\" title=\"Map的初始化方法\"></a>Map的初始化方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map1 &#x3D; new Map([[&#39;name&#39;,1],[&#39;age&#39;,2]])</span><br><span class=\"line\">console.log(map1.has(&#39;name&#39;))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Map集合的forEach\"><a href=\"#Map集合的forEach\" class=\"headerlink\" title=\"Map集合的forEach\"></a>Map集合的forEach</h4><ul>\n<li>Map集合的forEach方法，三个参数，1、下一次索引位置2、值对应的键名3、Map集合本身 (可以指定forEach的第二个参数作为回调的this)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map1.forEach((value,key,ownerMap)&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">    console.log(key)</span><br><span class=\"line\">    console.log(ownerMap &#x3D;&#x3D;&#x3D; map1)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Weak-Map\"><a href=\"#Weak-Map\" class=\"headerlink\" title=\"Weak Map\"></a>Weak Map</h4><ul>\n<li>最大用途是保存Web页面中的DOM元素</li>\n<li>ES6中Weak Map是一种存储许多键值对的无序列表，列表的键名必须是非null类型的对象</li>\n<li>has()\\delete()</li>\n<li>不支持键名枚举、不支持clear()方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let wmap &#x3D; new WeakMap()</span><br><span class=\"line\"></span><br><span class=\"line\">let element &#x3D; document.getElementById(&#39;aaa&#39;)</span><br><span class=\"line\">wmap.set(element,&#39;123&#39;)&#x2F;&#x2F;element不能为null</span><br><span class=\"line\">console.log(wmap.get(element))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"私有对象数据\"><a href=\"#私有对象数据\" class=\"headerlink\" title=\"私有对象数据\"></a>私有对象数据</h4><ul>\n<li>尽管Weak Map大多被用来存储DOM元素，但也有其他用处,ES5一般使用_C下划线属性作为私有属性，但是没有任何标准规定如何使用，也会被更改</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;ES5处理私有变量,缺点无法获知对象何时被摧毁，obj中的数据永远不会消失</span><br><span class=\"line\">var Person &#x3D; (function () &#123;</span><br><span class=\"line\">    var obj &#x3D; &#123;&#125;</span><br><span class=\"line\">    var idNum &#x3D; 0</span><br><span class=\"line\">    function Person(name) &#123;</span><br><span class=\"line\">        Object.defineProperty(this,&#39;_id&#39;,&#123;value: idNum++&#125;)</span><br><span class=\"line\">        obj[this._id] &#x3D; &#123;</span><br><span class=\"line\">            name: name</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Person.prototype.getName &#x3D; function () &#123;</span><br><span class=\"line\">        return obj[this._id].name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Person</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">console.log(new Person(111).getName())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;使用WeakMap解决此问题,只要对象被摧毁，相关信息也会摧毁</span><br><span class=\"line\">let WPerson &#x3D; (function () &#123;</span><br><span class=\"line\">    let wmap &#x3D; new WeakMap()</span><br><span class=\"line\">    function Person(name) &#123;</span><br><span class=\"line\">        wmap.set(this,&#123;name: name&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Person.prototype.getName &#x3D; function () &#123;</span><br><span class=\"line\">        return wmap.get(this).name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Person</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">console.log(new WPerson(222).getName())</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果只使用对象作为键名，那么WeakMap是最好的选择，可以有效避免内存泄漏问题</li>\n</ul>\n"},{"title":"<ES6>Symbol","date":"2019-02-12T16:00:00.000Z","_content":"### 简介\n\n-  ES6引入了第六种原始类型Symbol\n\n#### 私有名称\n\n- 为了创建非字符串属性名称设计的，Symbol出现之前一直通过属性名称来访问所有属性，全部通过一个字符串来访问。\n\n### Symbol相关\n\n#### 创建Symbol\n\n```\nlet name = Symbol()\nlet obj = {}\nobj[name] = 'yxc'\n```\n\n- 由于Symbol是原始值，因此调用new Symbol()会报错，\n- Symbol函数接收一个可选参数，让你添加文本描述，建议每次创建都添加。\n\n```\nlet name = Symbol('name')\n```\n\n- Symbol的描述被存储在内部的[[Description]]属性中，只有当调用Symbol的toString()方法时才会读取这个属性。\n\n#### 检测Symbol\n\n- 使用typeof\n\n```\nlet name = Symbol('name')\nname.toString()//\"Symbol(name)\"\ntypeof name//\"symbol\"\n```\n\n#### Symbol的使用\n\n- 所有使用可计算属性名的地方都可以使用Symbol\n\n```\nlet name = Symbol('name')\nlet obj = {\n    [name]: 'yxc'\n}\n\n```\n\n- 用于Object.defineProperty()\\Object.defineProperties()方法中\n\n```\nlet name = Symbol('name')\nlet obj = {}\nObject.defineProperty(obj,name,{writable:false})\n```\n\n#### Symbol共享体系\n\n- ES6创建了一个可以随时访问的全局Symbol注册表，如果想创建一个可共享Symbol，使用Symbol.for()方法\n\n```\nlet id = Symbol.for('id')\nlet id2 = Symbol.for('id')\nconsole.log(id===id2)//true\n```\n\n- 使用Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的关键字\n\n```\nlet id = Symbol.for('id')\nconsole.log(Symbol.keyFor(id))//id\n```\n\n- Symbol全局注册表是一个类似全局作用域的共享环境，其他第三方库也有可能使用。\n\n#### Symbol与强制类型转换\n\n- 其他类型没有与Symbol逻辑等价的值，因此Symbol使用不是很灵活，尤其不能将Symbol强制转换为字符串和数字类型\n- 将Symbol强制转换为字符串会被错\n\n```\nlet name = Symbol('name')\nlet a = name + ''//VM1175:1 Uncaught TypeError: Cannot convert a Symbol value to a string\n```\n\n- Symbol与JS中的非空值类似，其等价布尔值为true\n\n```\nlet name = Symbol('name')\nlet a = name/1//VM1299:2 Uncaught TypeError: Cannot convert a Symbol value to a number\n```\n\n#### Symbol属性的检索\n\n- 为了保持ES5函数原有功能，Object.keys(),Object.getOwnPropertyNames()都不支持Symbol属性，ES6添加Object.getOwnPropertySymbols()返回包含所有Symbol属性的数组。\n\n```\nlet name = Symbol('name')\nlet obj = {\n    [name]: 'yxc'\n}\nconsole.log(Object.getOwnPropertySymbols(obj))//[Symbol(name)]\n```\n\n#### well-known Symbol\n\n- 对象可以从原型链中继承Symbol属性，ES6通过一些well-known Symbol预定义这些属性\n\n1. Symbol.hasInstance方法\n\n- 用于确认对象是否为函数的实例，该方法在Function.prototype中定义，所有函数都继承了instanceof属性的默认行为\n\n```\nlet obj = []\nconsole.log(obj instanceof Array)//true\nArray[Symbol.hasInstance](obj)//true\n```\n\n#### 参考\n\n- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol#\n","source":"_posts/[ES6]Symbol.md","raw":"---\ntitle: <ES6>Symbol\ndate: 2019-02-13 00:00:00\ntags: [ES6,js]\ncategories: ES6\n---\n### 简介\n\n-  ES6引入了第六种原始类型Symbol\n\n#### 私有名称\n\n- 为了创建非字符串属性名称设计的，Symbol出现之前一直通过属性名称来访问所有属性，全部通过一个字符串来访问。\n\n### Symbol相关\n\n#### 创建Symbol\n\n```\nlet name = Symbol()\nlet obj = {}\nobj[name] = 'yxc'\n```\n\n- 由于Symbol是原始值，因此调用new Symbol()会报错，\n- Symbol函数接收一个可选参数，让你添加文本描述，建议每次创建都添加。\n\n```\nlet name = Symbol('name')\n```\n\n- Symbol的描述被存储在内部的[[Description]]属性中，只有当调用Symbol的toString()方法时才会读取这个属性。\n\n#### 检测Symbol\n\n- 使用typeof\n\n```\nlet name = Symbol('name')\nname.toString()//\"Symbol(name)\"\ntypeof name//\"symbol\"\n```\n\n#### Symbol的使用\n\n- 所有使用可计算属性名的地方都可以使用Symbol\n\n```\nlet name = Symbol('name')\nlet obj = {\n    [name]: 'yxc'\n}\n\n```\n\n- 用于Object.defineProperty()\\Object.defineProperties()方法中\n\n```\nlet name = Symbol('name')\nlet obj = {}\nObject.defineProperty(obj,name,{writable:false})\n```\n\n#### Symbol共享体系\n\n- ES6创建了一个可以随时访问的全局Symbol注册表，如果想创建一个可共享Symbol，使用Symbol.for()方法\n\n```\nlet id = Symbol.for('id')\nlet id2 = Symbol.for('id')\nconsole.log(id===id2)//true\n```\n\n- 使用Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的关键字\n\n```\nlet id = Symbol.for('id')\nconsole.log(Symbol.keyFor(id))//id\n```\n\n- Symbol全局注册表是一个类似全局作用域的共享环境，其他第三方库也有可能使用。\n\n#### Symbol与强制类型转换\n\n- 其他类型没有与Symbol逻辑等价的值，因此Symbol使用不是很灵活，尤其不能将Symbol强制转换为字符串和数字类型\n- 将Symbol强制转换为字符串会被错\n\n```\nlet name = Symbol('name')\nlet a = name + ''//VM1175:1 Uncaught TypeError: Cannot convert a Symbol value to a string\n```\n\n- Symbol与JS中的非空值类似，其等价布尔值为true\n\n```\nlet name = Symbol('name')\nlet a = name/1//VM1299:2 Uncaught TypeError: Cannot convert a Symbol value to a number\n```\n\n#### Symbol属性的检索\n\n- 为了保持ES5函数原有功能，Object.keys(),Object.getOwnPropertyNames()都不支持Symbol属性，ES6添加Object.getOwnPropertySymbols()返回包含所有Symbol属性的数组。\n\n```\nlet name = Symbol('name')\nlet obj = {\n    [name]: 'yxc'\n}\nconsole.log(Object.getOwnPropertySymbols(obj))//[Symbol(name)]\n```\n\n#### well-known Symbol\n\n- 对象可以从原型链中继承Symbol属性，ES6通过一些well-known Symbol预定义这些属性\n\n1. Symbol.hasInstance方法\n\n- 用于确认对象是否为函数的实例，该方法在Function.prototype中定义，所有函数都继承了instanceof属性的默认行为\n\n```\nlet obj = []\nconsole.log(obj instanceof Array)//true\nArray[Symbol.hasInstance](obj)//true\n```\n\n#### 参考\n\n- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol#\n","slug":"[ES6]Symbol","published":1,"updated":"2021-03-15T14:37:26.306Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4djv0001wotj49g08sx6","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li> ES6引入了第六种原始类型Symbol</li>\n</ul>\n<h4 id=\"私有名称\"><a href=\"#私有名称\" class=\"headerlink\" title=\"私有名称\"></a>私有名称</h4><ul>\n<li>为了创建非字符串属性名称设计的，Symbol出现之前一直通过属性名称来访问所有属性，全部通过一个字符串来访问。</li>\n</ul>\n<h3 id=\"Symbol相关\"><a href=\"#Symbol相关\" class=\"headerlink\" title=\"Symbol相关\"></a>Symbol相关</h3><h4 id=\"创建Symbol\"><a href=\"#创建Symbol\" class=\"headerlink\" title=\"创建Symbol\"></a>创建Symbol</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol()</span><br><span class=\"line\">let obj &#x3D; &#123;&#125;</span><br><span class=\"line\">obj[name] &#x3D; &#39;yxc&#39;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>由于Symbol是原始值，因此调用new Symbol()会报错，</li>\n<li>Symbol函数接收一个可选参数，让你添加文本描述，建议每次创建都添加。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol(&#39;name&#39;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Symbol的描述被存储在内部的[[Description]]属性中，只有当调用Symbol的toString()方法时才会读取这个属性。</li>\n</ul>\n<h4 id=\"检测Symbol\"><a href=\"#检测Symbol\" class=\"headerlink\" title=\"检测Symbol\"></a>检测Symbol</h4><ul>\n<li>使用typeof</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol(&#39;name&#39;)</span><br><span class=\"line\">name.toString()&#x2F;&#x2F;&quot;Symbol(name)&quot;</span><br><span class=\"line\">typeof name&#x2F;&#x2F;&quot;symbol&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Symbol的使用\"><a href=\"#Symbol的使用\" class=\"headerlink\" title=\"Symbol的使用\"></a>Symbol的使用</h4><ul>\n<li>所有使用可计算属性名的地方都可以使用Symbol</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol(&#39;name&#39;)</span><br><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    [name]: &#39;yxc&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>用于Object.defineProperty()\\Object.defineProperties()方法中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol(&#39;name&#39;)</span><br><span class=\"line\">let obj &#x3D; &#123;&#125;</span><br><span class=\"line\">Object.defineProperty(obj,name,&#123;writable:false&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Symbol共享体系\"><a href=\"#Symbol共享体系\" class=\"headerlink\" title=\"Symbol共享体系\"></a>Symbol共享体系</h4><ul>\n<li>ES6创建了一个可以随时访问的全局Symbol注册表，如果想创建一个可共享Symbol，使用Symbol.for()方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let id &#x3D; Symbol.for(&#39;id&#39;)</span><br><span class=\"line\">let id2 &#x3D; Symbol.for(&#39;id&#39;)</span><br><span class=\"line\">console.log(id&#x3D;&#x3D;&#x3D;id2)&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的关键字</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let id &#x3D; Symbol.for(&#39;id&#39;)</span><br><span class=\"line\">console.log(Symbol.keyFor(id))&#x2F;&#x2F;id</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Symbol全局注册表是一个类似全局作用域的共享环境，其他第三方库也有可能使用。</li>\n</ul>\n<h4 id=\"Symbol与强制类型转换\"><a href=\"#Symbol与强制类型转换\" class=\"headerlink\" title=\"Symbol与强制类型转换\"></a>Symbol与强制类型转换</h4><ul>\n<li>其他类型没有与Symbol逻辑等价的值，因此Symbol使用不是很灵活，尤其不能将Symbol强制转换为字符串和数字类型</li>\n<li>将Symbol强制转换为字符串会被错</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol(&#39;name&#39;)</span><br><span class=\"line\">let a &#x3D; name + &#39;&#39;&#x2F;&#x2F;VM1175:1 Uncaught TypeError: Cannot convert a Symbol value to a string</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Symbol与JS中的非空值类似，其等价布尔值为true</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol(&#39;name&#39;)</span><br><span class=\"line\">let a &#x3D; name&#x2F;1&#x2F;&#x2F;VM1299:2 Uncaught TypeError: Cannot convert a Symbol value to a number</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Symbol属性的检索\"><a href=\"#Symbol属性的检索\" class=\"headerlink\" title=\"Symbol属性的检索\"></a>Symbol属性的检索</h4><ul>\n<li>为了保持ES5函数原有功能，Object.keys(),Object.getOwnPropertyNames()都不支持Symbol属性，ES6添加Object.getOwnPropertySymbols()返回包含所有Symbol属性的数组。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol(&#39;name&#39;)</span><br><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    [name]: &#39;yxc&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Object.getOwnPropertySymbols(obj))&#x2F;&#x2F;[Symbol(name)]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"well-known-Symbol\"><a href=\"#well-known-Symbol\" class=\"headerlink\" title=\"well-known Symbol\"></a>well-known Symbol</h4><ul>\n<li>对象可以从原型链中继承Symbol属性，ES6通过一些well-known Symbol预定义这些属性</li>\n</ul>\n<ol>\n<li>Symbol.hasInstance方法</li>\n</ol>\n<ul>\n<li>用于确认对象是否为函数的实例，该方法在Function.prototype中定义，所有函数都继承了instanceof属性的默认行为</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; []</span><br><span class=\"line\">console.log(obj instanceof Array)&#x2F;&#x2F;true</span><br><span class=\"line\">Array[Symbol.hasInstance](obj)&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol#\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol#</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li> ES6引入了第六种原始类型Symbol</li>\n</ul>\n<h4 id=\"私有名称\"><a href=\"#私有名称\" class=\"headerlink\" title=\"私有名称\"></a>私有名称</h4><ul>\n<li>为了创建非字符串属性名称设计的，Symbol出现之前一直通过属性名称来访问所有属性，全部通过一个字符串来访问。</li>\n</ul>\n<h3 id=\"Symbol相关\"><a href=\"#Symbol相关\" class=\"headerlink\" title=\"Symbol相关\"></a>Symbol相关</h3><h4 id=\"创建Symbol\"><a href=\"#创建Symbol\" class=\"headerlink\" title=\"创建Symbol\"></a>创建Symbol</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol()</span><br><span class=\"line\">let obj &#x3D; &#123;&#125;</span><br><span class=\"line\">obj[name] &#x3D; &#39;yxc&#39;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>由于Symbol是原始值，因此调用new Symbol()会报错，</li>\n<li>Symbol函数接收一个可选参数，让你添加文本描述，建议每次创建都添加。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol(&#39;name&#39;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Symbol的描述被存储在内部的[[Description]]属性中，只有当调用Symbol的toString()方法时才会读取这个属性。</li>\n</ul>\n<h4 id=\"检测Symbol\"><a href=\"#检测Symbol\" class=\"headerlink\" title=\"检测Symbol\"></a>检测Symbol</h4><ul>\n<li>使用typeof</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol(&#39;name&#39;)</span><br><span class=\"line\">name.toString()&#x2F;&#x2F;&quot;Symbol(name)&quot;</span><br><span class=\"line\">typeof name&#x2F;&#x2F;&quot;symbol&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Symbol的使用\"><a href=\"#Symbol的使用\" class=\"headerlink\" title=\"Symbol的使用\"></a>Symbol的使用</h4><ul>\n<li>所有使用可计算属性名的地方都可以使用Symbol</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol(&#39;name&#39;)</span><br><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    [name]: &#39;yxc&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>用于Object.defineProperty()\\Object.defineProperties()方法中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol(&#39;name&#39;)</span><br><span class=\"line\">let obj &#x3D; &#123;&#125;</span><br><span class=\"line\">Object.defineProperty(obj,name,&#123;writable:false&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Symbol共享体系\"><a href=\"#Symbol共享体系\" class=\"headerlink\" title=\"Symbol共享体系\"></a>Symbol共享体系</h4><ul>\n<li>ES6创建了一个可以随时访问的全局Symbol注册表，如果想创建一个可共享Symbol，使用Symbol.for()方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let id &#x3D; Symbol.for(&#39;id&#39;)</span><br><span class=\"line\">let id2 &#x3D; Symbol.for(&#39;id&#39;)</span><br><span class=\"line\">console.log(id&#x3D;&#x3D;&#x3D;id2)&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的关键字</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let id &#x3D; Symbol.for(&#39;id&#39;)</span><br><span class=\"line\">console.log(Symbol.keyFor(id))&#x2F;&#x2F;id</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Symbol全局注册表是一个类似全局作用域的共享环境，其他第三方库也有可能使用。</li>\n</ul>\n<h4 id=\"Symbol与强制类型转换\"><a href=\"#Symbol与强制类型转换\" class=\"headerlink\" title=\"Symbol与强制类型转换\"></a>Symbol与强制类型转换</h4><ul>\n<li>其他类型没有与Symbol逻辑等价的值，因此Symbol使用不是很灵活，尤其不能将Symbol强制转换为字符串和数字类型</li>\n<li>将Symbol强制转换为字符串会被错</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol(&#39;name&#39;)</span><br><span class=\"line\">let a &#x3D; name + &#39;&#39;&#x2F;&#x2F;VM1175:1 Uncaught TypeError: Cannot convert a Symbol value to a string</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Symbol与JS中的非空值类似，其等价布尔值为true</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol(&#39;name&#39;)</span><br><span class=\"line\">let a &#x3D; name&#x2F;1&#x2F;&#x2F;VM1299:2 Uncaught TypeError: Cannot convert a Symbol value to a number</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Symbol属性的检索\"><a href=\"#Symbol属性的检索\" class=\"headerlink\" title=\"Symbol属性的检索\"></a>Symbol属性的检索</h4><ul>\n<li>为了保持ES5函数原有功能，Object.keys(),Object.getOwnPropertyNames()都不支持Symbol属性，ES6添加Object.getOwnPropertySymbols()返回包含所有Symbol属性的数组。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; Symbol(&#39;name&#39;)</span><br><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    [name]: &#39;yxc&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Object.getOwnPropertySymbols(obj))&#x2F;&#x2F;[Symbol(name)]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"well-known-Symbol\"><a href=\"#well-known-Symbol\" class=\"headerlink\" title=\"well-known Symbol\"></a>well-known Symbol</h4><ul>\n<li>对象可以从原型链中继承Symbol属性，ES6通过一些well-known Symbol预定义这些属性</li>\n</ul>\n<ol>\n<li>Symbol.hasInstance方法</li>\n</ol>\n<ul>\n<li>用于确认对象是否为函数的实例，该方法在Function.prototype中定义，所有函数都继承了instanceof属性的默认行为</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; []</span><br><span class=\"line\">console.log(obj instanceof Array)&#x2F;&#x2F;true</span><br><span class=\"line\">Array[Symbol.hasInstance](obj)&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol#\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol#</a></li>\n</ul>\n"},{"title":"<ES6>async-await","date":"2018-12-09T16:00:00.000Z","_content":"\n### async 做一件什么事情?\n\n- 带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象\n- 如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装\n- 如果async关键字函数显式地返回promise，那就以你返回的promise为准\n- 在语义上要理解，async表示函数内部有异步操作\n- 另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错\n\n### await 在等什么？\n\n- await等的是右侧「表达式」的结果\n\n```\nasync function async1() {\n    console.log( 'async1 start' )\n    await async2()\n    console.log( 'async1 end' )\n}\nasync function async2() {\n    console.log( 'async2' )\n}\nasync1()\nconsole.log( 'script start' )\n//async1 start\n//async2\n//script start\n//async1 end\n```\n\n### await 等到之后，做了一件什么事情？\n\n- 如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果\n- 如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果\n\n### 参考\n1. https://segmentfault.com/a/1190000007535316\n2. https://segmentfault.com/a/1190000017224799\n","source":"_posts/[ES6]async-await.md","raw":"---\ntitle: <ES6>async-await\ndate: 2018-12-10 00:00:00\ntags: [js,async&await]\ncategories: js\n---\n\n### async 做一件什么事情?\n\n- 带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象\n- 如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装\n- 如果async关键字函数显式地返回promise，那就以你返回的promise为准\n- 在语义上要理解，async表示函数内部有异步操作\n- 另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错\n\n### await 在等什么？\n\n- await等的是右侧「表达式」的结果\n\n```\nasync function async1() {\n    console.log( 'async1 start' )\n    await async2()\n    console.log( 'async1 end' )\n}\nasync function async2() {\n    console.log( 'async2' )\n}\nasync1()\nconsole.log( 'script start' )\n//async1 start\n//async2\n//script start\n//async1 end\n```\n\n### await 等到之后，做了一件什么事情？\n\n- 如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果\n- 如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果\n\n### 参考\n1. https://segmentfault.com/a/1190000007535316\n2. https://segmentfault.com/a/1190000017224799\n","slug":"[ES6]async-await","published":1,"updated":"2021-03-15T14:37:01.927Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4djx0003wotjglx0emzt","content":"<h3 id=\"async-做一件什么事情\"><a href=\"#async-做一件什么事情\" class=\"headerlink\" title=\"async 做一件什么事情?\"></a>async 做一件什么事情?</h3><ul>\n<li>带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象</li>\n<li>如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装</li>\n<li>如果async关键字函数显式地返回promise，那就以你返回的promise为准</li>\n<li>在语义上要理解，async表示函数内部有异步操作</li>\n<li>另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错</li>\n</ul>\n<h3 id=\"await-在等什么？\"><a href=\"#await-在等什么？\" class=\"headerlink\" title=\"await 在等什么？\"></a>await 在等什么？</h3><ul>\n<li>await等的是右侧「表达式」的结果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">    console.log( &#39;async1 start&#39; )</span><br><span class=\"line\">    await async2()</span><br><span class=\"line\">    console.log( &#39;async1 end&#39; )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function async2() &#123;</span><br><span class=\"line\">    console.log( &#39;async2&#39; )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async1()</span><br><span class=\"line\">console.log( &#39;script start&#39; )</span><br><span class=\"line\">&#x2F;&#x2F;async1 start</span><br><span class=\"line\">&#x2F;&#x2F;async2</span><br><span class=\"line\">&#x2F;&#x2F;script start</span><br><span class=\"line\">&#x2F;&#x2F;async1 end</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"await-等到之后，做了一件什么事情？\"><a href=\"#await-等到之后，做了一件什么事情？\" class=\"headerlink\" title=\"await 等到之后，做了一件什么事情？\"></a>await 等到之后，做了一件什么事情？</h3><ul>\n<li>如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果</li>\n<li>如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000007535316\">https://segmentfault.com/a/1190000007535316</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017224799\">https://segmentfault.com/a/1190000017224799</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"async-做一件什么事情\"><a href=\"#async-做一件什么事情\" class=\"headerlink\" title=\"async 做一件什么事情?\"></a>async 做一件什么事情?</h3><ul>\n<li>带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象</li>\n<li>如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装</li>\n<li>如果async关键字函数显式地返回promise，那就以你返回的promise为准</li>\n<li>在语义上要理解，async表示函数内部有异步操作</li>\n<li>另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错</li>\n</ul>\n<h3 id=\"await-在等什么？\"><a href=\"#await-在等什么？\" class=\"headerlink\" title=\"await 在等什么？\"></a>await 在等什么？</h3><ul>\n<li>await等的是右侧「表达式」的结果</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">    console.log( &#39;async1 start&#39; )</span><br><span class=\"line\">    await async2()</span><br><span class=\"line\">    console.log( &#39;async1 end&#39; )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function async2() &#123;</span><br><span class=\"line\">    console.log( &#39;async2&#39; )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async1()</span><br><span class=\"line\">console.log( &#39;script start&#39; )</span><br><span class=\"line\">&#x2F;&#x2F;async1 start</span><br><span class=\"line\">&#x2F;&#x2F;async2</span><br><span class=\"line\">&#x2F;&#x2F;script start</span><br><span class=\"line\">&#x2F;&#x2F;async1 end</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"await-等到之后，做了一件什么事情？\"><a href=\"#await-等到之后，做了一件什么事情？\" class=\"headerlink\" title=\"await 等到之后，做了一件什么事情？\"></a>await 等到之后，做了一件什么事情？</h3><ul>\n<li>如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果</li>\n<li>如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li><a href=\"https://segmentfault.com/a/1190000007535316\">https://segmentfault.com/a/1190000007535316</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017224799\">https://segmentfault.com/a/1190000017224799</a></li>\n</ol>\n"},{"title":"<ES6>class","date":"2018-08-21T16:00:00.000Z","_content":"\n### 基本的类声明语法\n\n- 注意：类的属性不可以被赋予新值\n\n1. 类声明与let声明类似，不能被提升\n2. 类声明所有代码都将自动运行在严格模式下\n3. 在类中所有方法都不可被枚举，无需通过Object.defineProperty指定\n4. 每个类都有一个[[Construct]]方法,通过new关键字调用不含[[Construct]]方法会报错\n5. 使用除关键字new之外的方式调用类的构造函数会导致程序报错\n\n```\nclass personalClass {\n    constructor(name){\n        //自有属性，不会出现在原型上\n        this.name = name\n    }\n    //等价于personClass.prototype.sayName\n    sayName(){\n        console.log(this.name)\n    }\n}\n```\n\n#### 类的名称\n\n- 类的名称在类中为常量，不能再类的方法中更改但是可以再外部更改\n\n```\nclass Foo {\n    constructor(){\n        Foo = 'bar'//执行时会报错\n    }\n}\nFoo = 'bar'//外部执行不会\n\n// 等价于\nlet Foo1 = (function () {\n    const Foo1 = function (name) {\n        Foo1 = 'bar'\n        this.name = name\n    }\n    Object.defineProperty(Foo1,prototype,'sayName',{\n        value: function () {\n            console.log(this.name)\n        }\n    })\n})()\n\n```\n#### 类表达式\n\n- 类表达式,不需要标识符在类后，除了语法类表达式功能上等价于类声明\n\n```\nlet perClass = class {\n    constructor(){\n    }\n}\n\n```\n\n- 命名类表达式,此时p1Class是const定义，不可更改\n\n```\nlet pClass = class p1Class{\n    constructor(){\n\n    }\n}\n```\n\n- 类可以传入函数，可以从函数返回、并且可以赋值给变量\n\n#### 类立即调用（创建单例）\n\n```\nlet person = new class {\n    constructor(name){\n        this.name = name\n    }\n}('aa')\n```\n\n#### 访问器属性\n\n- 访问器属性，类支持在原型上定义访问器属性\n\n```\nclass getSetClass{\n    constructor(name){\n        this.name = name\n    }\n    get age(){\n\n    }\n    set age(val){\n\n    }\n}\n\n//等价于\nObject.defineProperty(getSetClass.prototype,'age',{\n     get:function () {\n\n     },\n     set:function (val) {\n\n    }\n})\n```\n\n#### 可计算成员名称\n\n```\nlet name = 'aaa'\nclass pp{\n    constructor(){\n\n    }\n    [name](){\n\n    }\n}\n\n```\n\n#### 生成器方法\n\n```\nclass MyClass {\n    *myGenerator(){\n        yield 1\n        yield 2\n    }\n    //定义默认迭代器\n    *[symbol.iterator](){\n        yield 1\n    }\n}\n\n```\n\n#### 静态成员\n\n```\nclass staticClass{\n    constructor(){\n\n    }\n    static create(){\n        return new staticClass()\n    }\n}\n//等价于\nfunction aa() {\n\n}\naa.create = function () {\n    return new aa()\n}\n```\n\n### 继承与派生类\n\n- 继承自其他类的类被称为派生类，如果在派生类中指定了构造函数必须使用super()\n- 如果不使用构造函数，则会自动调用super()并传入所有参数\n- 注意：\n\n1. 只可以在派生类的构造函数中使用super()\n2. 在构造函数访问this之前一定要使用super()，它负责初始化this\n3. 如果不想调用super()唯一的方法是让类的构造函数返回一个对象\n\n```\nclass father {\n    constructor(){\n\n    }\n}\nclass child extends father {\n    constructor(){\n        //等价于father.call(this)\n        super()\n    }\n}\n```\n\n- 类方法遮蔽，派生类中的方法总会覆盖基类的同名方法\n\n```\nclass Super{\n    Fun(){\n\n    }\n}\n\nclass Square extends Super{\n    constructor(){\n        super()\n    }\n    //覆盖并遮蔽基类方法\n    Fun(){\n        //调用基类中的方法，this会被自动正确设置\n        super.Fun()\n    }\n}\n```\n\n- 静态成员继承，如果基类有静态成员，在派生类中也可以使用\n\n#### 派生自表达式的类\n\n```\nfunction bb() {\n\n}\n//bb是一个ES5的构造函数，cc是一个类，由于bb具有[[Construct]]属性和原型，因此可以作为基类\nclass cc extends bb{\n    constructor(){\n        super()\n    }\n}\n```\n\n### mixin\n\n- 首先创建一个base函数，再将每一个mixin的对象属性赋值给base原型\n\n```\nlet m1 = {\n    Fun(){}\n}\nlet m2 = {\n    Fun1(){}\n}\nfunction mixin(...mixins) {\n    var base = function () {\n\n    }\n    Object.assign(base.prototype,...mixins)\n    return base\n}\nclass x extends mixin(m1,m2,){\n\n}\n```\n\n### 内建对象的继承\n\n- ES5,MyArray实际行为与内建Array不一样，因为通过传统JS继承实现的数组继承没有从Array.apply()中活原型中继承相关功能\n\n```\nfunction MyArray() {\n    Array.apply(this,arguments)\n}\nMyArray.prototype = Object.create(Array.prototype,{\n    constructor: {\n        value: MyArray,\n        writable: true,\n        enumerable: false,\n        configurable: true\n    }\n})\nvar colors = new MyArray()\ncolors.push('red')\ncolors.length = 0\nconsole.log(colors)//['red']\n```\n\n#### ES6Class中继承与ES5不同\n\n1. ES5先由派生类创建this，然后调用基类的构造函数，this开始指向的是MyArray的实例，之后被来自Array的其他属性修饰\n2. ES6中继承相反，先由基类创建this值，然后派生类的构造函数再去修改这个值，所以一开始可以通过this调用基类所有的内建功能\n\n```\nclass MyArrayClass extends Array{\n    constructor(){\n        super()\n    }\n}\n```\n\n#### Symbol.species属性\n\n- 如果有一个派生类MyArray继承Array，那么slice()这样的方法返回的数组会继承自MyArray\n- 这是引擎通过Symbol.species属性实现的\n- Symbol.species定义返回函数的静态访问器属性\n- Array\\ArrayBuffer\\Map\\Promise\\RegExp\\Set\\Type arrays都有默认的Symbol.species属性，该属性的返回值为this,也就是总会返回构造函数\n\n```\n//在自定义类中实现Symbol.species\nclass speciesClass {\n    static get [Symbol.species](){\n        return this\n    }\n}\n```\n```\n//在类方法中使用constructor以及Symbol.species\nclass Funnnn{\n    static get [Symbol.species](){\n        //这里返回构造函数,通过定义返回的构造函数，可以改变继承时clone的实例类型\n        return this\n    }\n    constructor(value){\n        this.value = value\n    }\n    clone(){\n        //this.constructor指向Funnn构造函数（类）\n        return new this.constructor[Symbol.species](this.value)\n    }\n}\nlet ff = new Funnnn(11)\nff.clone()\n```\n\n#### new.target\n\n- 在构造函数中使用new.target\n- 简单情况下new.target等于构造函数\n- 类构造函数必须通过new关键字调用\n- 可以使用new.target创造一个抽象基类（不能被直接实例化的类）\n\n```\nclass baseClass {\n    constructor(){\n        if(new.target === baseClass){\n            throw new Error('不能被直接实例化')\n        }\n    }\n}\n```\n","source":"_posts/[ES6]class.md","raw":"---\ntitle: <ES6>class\ndate: 2018-08-22 00:00:00\ntags: [ES6,js]\ncategories: ES6\n---\n\n### 基本的类声明语法\n\n- 注意：类的属性不可以被赋予新值\n\n1. 类声明与let声明类似，不能被提升\n2. 类声明所有代码都将自动运行在严格模式下\n3. 在类中所有方法都不可被枚举，无需通过Object.defineProperty指定\n4. 每个类都有一个[[Construct]]方法,通过new关键字调用不含[[Construct]]方法会报错\n5. 使用除关键字new之外的方式调用类的构造函数会导致程序报错\n\n```\nclass personalClass {\n    constructor(name){\n        //自有属性，不会出现在原型上\n        this.name = name\n    }\n    //等价于personClass.prototype.sayName\n    sayName(){\n        console.log(this.name)\n    }\n}\n```\n\n#### 类的名称\n\n- 类的名称在类中为常量，不能再类的方法中更改但是可以再外部更改\n\n```\nclass Foo {\n    constructor(){\n        Foo = 'bar'//执行时会报错\n    }\n}\nFoo = 'bar'//外部执行不会\n\n// 等价于\nlet Foo1 = (function () {\n    const Foo1 = function (name) {\n        Foo1 = 'bar'\n        this.name = name\n    }\n    Object.defineProperty(Foo1,prototype,'sayName',{\n        value: function () {\n            console.log(this.name)\n        }\n    })\n})()\n\n```\n#### 类表达式\n\n- 类表达式,不需要标识符在类后，除了语法类表达式功能上等价于类声明\n\n```\nlet perClass = class {\n    constructor(){\n    }\n}\n\n```\n\n- 命名类表达式,此时p1Class是const定义，不可更改\n\n```\nlet pClass = class p1Class{\n    constructor(){\n\n    }\n}\n```\n\n- 类可以传入函数，可以从函数返回、并且可以赋值给变量\n\n#### 类立即调用（创建单例）\n\n```\nlet person = new class {\n    constructor(name){\n        this.name = name\n    }\n}('aa')\n```\n\n#### 访问器属性\n\n- 访问器属性，类支持在原型上定义访问器属性\n\n```\nclass getSetClass{\n    constructor(name){\n        this.name = name\n    }\n    get age(){\n\n    }\n    set age(val){\n\n    }\n}\n\n//等价于\nObject.defineProperty(getSetClass.prototype,'age',{\n     get:function () {\n\n     },\n     set:function (val) {\n\n    }\n})\n```\n\n#### 可计算成员名称\n\n```\nlet name = 'aaa'\nclass pp{\n    constructor(){\n\n    }\n    [name](){\n\n    }\n}\n\n```\n\n#### 生成器方法\n\n```\nclass MyClass {\n    *myGenerator(){\n        yield 1\n        yield 2\n    }\n    //定义默认迭代器\n    *[symbol.iterator](){\n        yield 1\n    }\n}\n\n```\n\n#### 静态成员\n\n```\nclass staticClass{\n    constructor(){\n\n    }\n    static create(){\n        return new staticClass()\n    }\n}\n//等价于\nfunction aa() {\n\n}\naa.create = function () {\n    return new aa()\n}\n```\n\n### 继承与派生类\n\n- 继承自其他类的类被称为派生类，如果在派生类中指定了构造函数必须使用super()\n- 如果不使用构造函数，则会自动调用super()并传入所有参数\n- 注意：\n\n1. 只可以在派生类的构造函数中使用super()\n2. 在构造函数访问this之前一定要使用super()，它负责初始化this\n3. 如果不想调用super()唯一的方法是让类的构造函数返回一个对象\n\n```\nclass father {\n    constructor(){\n\n    }\n}\nclass child extends father {\n    constructor(){\n        //等价于father.call(this)\n        super()\n    }\n}\n```\n\n- 类方法遮蔽，派生类中的方法总会覆盖基类的同名方法\n\n```\nclass Super{\n    Fun(){\n\n    }\n}\n\nclass Square extends Super{\n    constructor(){\n        super()\n    }\n    //覆盖并遮蔽基类方法\n    Fun(){\n        //调用基类中的方法，this会被自动正确设置\n        super.Fun()\n    }\n}\n```\n\n- 静态成员继承，如果基类有静态成员，在派生类中也可以使用\n\n#### 派生自表达式的类\n\n```\nfunction bb() {\n\n}\n//bb是一个ES5的构造函数，cc是一个类，由于bb具有[[Construct]]属性和原型，因此可以作为基类\nclass cc extends bb{\n    constructor(){\n        super()\n    }\n}\n```\n\n### mixin\n\n- 首先创建一个base函数，再将每一个mixin的对象属性赋值给base原型\n\n```\nlet m1 = {\n    Fun(){}\n}\nlet m2 = {\n    Fun1(){}\n}\nfunction mixin(...mixins) {\n    var base = function () {\n\n    }\n    Object.assign(base.prototype,...mixins)\n    return base\n}\nclass x extends mixin(m1,m2,){\n\n}\n```\n\n### 内建对象的继承\n\n- ES5,MyArray实际行为与内建Array不一样，因为通过传统JS继承实现的数组继承没有从Array.apply()中活原型中继承相关功能\n\n```\nfunction MyArray() {\n    Array.apply(this,arguments)\n}\nMyArray.prototype = Object.create(Array.prototype,{\n    constructor: {\n        value: MyArray,\n        writable: true,\n        enumerable: false,\n        configurable: true\n    }\n})\nvar colors = new MyArray()\ncolors.push('red')\ncolors.length = 0\nconsole.log(colors)//['red']\n```\n\n#### ES6Class中继承与ES5不同\n\n1. ES5先由派生类创建this，然后调用基类的构造函数，this开始指向的是MyArray的实例，之后被来自Array的其他属性修饰\n2. ES6中继承相反，先由基类创建this值，然后派生类的构造函数再去修改这个值，所以一开始可以通过this调用基类所有的内建功能\n\n```\nclass MyArrayClass extends Array{\n    constructor(){\n        super()\n    }\n}\n```\n\n#### Symbol.species属性\n\n- 如果有一个派生类MyArray继承Array，那么slice()这样的方法返回的数组会继承自MyArray\n- 这是引擎通过Symbol.species属性实现的\n- Symbol.species定义返回函数的静态访问器属性\n- Array\\ArrayBuffer\\Map\\Promise\\RegExp\\Set\\Type arrays都有默认的Symbol.species属性，该属性的返回值为this,也就是总会返回构造函数\n\n```\n//在自定义类中实现Symbol.species\nclass speciesClass {\n    static get [Symbol.species](){\n        return this\n    }\n}\n```\n```\n//在类方法中使用constructor以及Symbol.species\nclass Funnnn{\n    static get [Symbol.species](){\n        //这里返回构造函数,通过定义返回的构造函数，可以改变继承时clone的实例类型\n        return this\n    }\n    constructor(value){\n        this.value = value\n    }\n    clone(){\n        //this.constructor指向Funnn构造函数（类）\n        return new this.constructor[Symbol.species](this.value)\n    }\n}\nlet ff = new Funnnn(11)\nff.clone()\n```\n\n#### new.target\n\n- 在构造函数中使用new.target\n- 简单情况下new.target等于构造函数\n- 类构造函数必须通过new关键字调用\n- 可以使用new.target创造一个抽象基类（不能被直接实例化的类）\n\n```\nclass baseClass {\n    constructor(){\n        if(new.target === baseClass){\n            throw new Error('不能被直接实例化')\n        }\n    }\n}\n```\n","slug":"[ES6]class","published":1,"updated":"2021-03-15T14:37:08.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4djy0005wotj9t490jyb","content":"<h3 id=\"基本的类声明语法\"><a href=\"#基本的类声明语法\" class=\"headerlink\" title=\"基本的类声明语法\"></a>基本的类声明语法</h3><ul>\n<li>注意：类的属性不可以被赋予新值</li>\n</ul>\n<ol>\n<li>类声明与let声明类似，不能被提升</li>\n<li>类声明所有代码都将自动运行在严格模式下</li>\n<li>在类中所有方法都不可被枚举，无需通过Object.defineProperty指定</li>\n<li>每个类都有一个[[Construct]]方法,通过new关键字调用不含[[Construct]]方法会报错</li>\n<li>使用除关键字new之外的方式调用类的构造函数会导致程序报错</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class personalClass &#123;</span><br><span class=\"line\">    constructor(name)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;自有属性，不会出现在原型上</span><br><span class=\"line\">        this.name &#x3D; name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;等价于personClass.prototype.sayName</span><br><span class=\"line\">    sayName()&#123;</span><br><span class=\"line\">        console.log(this.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"类的名称\"><a href=\"#类的名称\" class=\"headerlink\" title=\"类的名称\"></a>类的名称</h4><ul>\n<li>类的名称在类中为常量，不能再类的方法中更改但是可以再外部更改</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        Foo &#x3D; &#39;bar&#39;&#x2F;&#x2F;执行时会报错</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo &#x3D; &#39;bar&#39;&#x2F;&#x2F;外部执行不会</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 等价于</span><br><span class=\"line\">let Foo1 &#x3D; (function () &#123;</span><br><span class=\"line\">    const Foo1 &#x3D; function (name) &#123;</span><br><span class=\"line\">        Foo1 &#x3D; &#39;bar&#39;</span><br><span class=\"line\">        this.name &#x3D; name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Object.defineProperty(Foo1,prototype,&#39;sayName&#39;,&#123;</span><br><span class=\"line\">        value: function () &#123;</span><br><span class=\"line\">            console.log(this.name)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"类表达式\"><a href=\"#类表达式\" class=\"headerlink\" title=\"类表达式\"></a>类表达式</h4><ul>\n<li>类表达式,不需要标识符在类后，除了语法类表达式功能上等价于类声明</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let perClass &#x3D; class &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>命名类表达式,此时p1Class是const定义，不可更改</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let pClass &#x3D; class p1Class&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>类可以传入函数，可以从函数返回、并且可以赋值给变量</li>\n</ul>\n<h4 id=\"类立即调用（创建单例）\"><a href=\"#类立即调用（创建单例）\" class=\"headerlink\" title=\"类立即调用（创建单例）\"></a>类立即调用（创建单例）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let person &#x3D; new class &#123;</span><br><span class=\"line\">    constructor(name)&#123;</span><br><span class=\"line\">        this.name &#x3D; name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(&#39;aa&#39;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"访问器属性\"><a href=\"#访问器属性\" class=\"headerlink\" title=\"访问器属性\"></a>访问器属性</h4><ul>\n<li>访问器属性，类支持在原型上定义访问器属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class getSetClass&#123;</span><br><span class=\"line\">    constructor(name)&#123;</span><br><span class=\"line\">        this.name &#x3D; name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    get age()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    set age(val)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;等价于</span><br><span class=\"line\">Object.defineProperty(getSetClass.prototype,&#39;age&#39;,&#123;</span><br><span class=\"line\">     get:function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     set:function (val) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可计算成员名称\"><a href=\"#可计算成员名称\" class=\"headerlink\" title=\"可计算成员名称\"></a>可计算成员名称</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; &#39;aaa&#39;</span><br><span class=\"line\">class pp&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [name]()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生成器方法\"><a href=\"#生成器方法\" class=\"headerlink\" title=\"生成器方法\"></a>生成器方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyClass &#123;</span><br><span class=\"line\">    *myGenerator()&#123;</span><br><span class=\"line\">        yield 1</span><br><span class=\"line\">        yield 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;定义默认迭代器</span><br><span class=\"line\">    *[symbol.iterator]()&#123;</span><br><span class=\"line\">        yield 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"静态成员\"><a href=\"#静态成员\" class=\"headerlink\" title=\"静态成员\"></a>静态成员</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class staticClass&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static create()&#123;</span><br><span class=\"line\">        return new staticClass()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;等价于</span><br><span class=\"line\">function aa() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">aa.create &#x3D; function () &#123;</span><br><span class=\"line\">    return new aa()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承与派生类\"><a href=\"#继承与派生类\" class=\"headerlink\" title=\"继承与派生类\"></a>继承与派生类</h3><ul>\n<li>继承自其他类的类被称为派生类，如果在派生类中指定了构造函数必须使用super()</li>\n<li>如果不使用构造函数，则会自动调用super()并传入所有参数</li>\n<li>注意：</li>\n</ul>\n<ol>\n<li>只可以在派生类的构造函数中使用super()</li>\n<li>在构造函数访问this之前一定要使用super()，它负责初始化this</li>\n<li>如果不想调用super()唯一的方法是让类的构造函数返回一个对象</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class father &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class child extends father &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;等价于father.call(this)</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>类方法遮蔽，派生类中的方法总会覆盖基类的同名方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Super&#123;</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Square extends Super&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;覆盖并遮蔽基类方法</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;调用基类中的方法，this会被自动正确设置</span><br><span class=\"line\">        super.Fun()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>静态成员继承，如果基类有静态成员，在派生类中也可以使用</li>\n</ul>\n<h4 id=\"派生自表达式的类\"><a href=\"#派生自表达式的类\" class=\"headerlink\" title=\"派生自表达式的类\"></a>派生自表达式的类</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bb() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;bb是一个ES5的构造函数，cc是一个类，由于bb具有[[Construct]]属性和原型，因此可以作为基类</span><br><span class=\"line\">class cc extends bb&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mixin\"><a href=\"#mixin\" class=\"headerlink\" title=\"mixin\"></a>mixin</h3><ul>\n<li>首先创建一个base函数，再将每一个mixin的对象属性赋值给base原型</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let m1 &#x3D; &#123;</span><br><span class=\"line\">    Fun()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let m2 &#x3D; &#123;</span><br><span class=\"line\">    Fun1()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function mixin(...mixins) &#123;</span><br><span class=\"line\">    var base &#x3D; function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Object.assign(base.prototype,...mixins)</span><br><span class=\"line\">    return base</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class x extends mixin(m1,m2,)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内建对象的继承\"><a href=\"#内建对象的继承\" class=\"headerlink\" title=\"内建对象的继承\"></a>内建对象的继承</h3><ul>\n<li>ES5,MyArray实际行为与内建Array不一样，因为通过传统JS继承实现的数组继承没有从Array.apply()中活原型中继承相关功能</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MyArray() &#123;</span><br><span class=\"line\">    Array.apply(this,arguments)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyArray.prototype &#x3D; Object.create(Array.prototype,&#123;</span><br><span class=\"line\">    constructor: &#123;</span><br><span class=\"line\">        value: MyArray,</span><br><span class=\"line\">        writable: true,</span><br><span class=\"line\">        enumerable: false,</span><br><span class=\"line\">        configurable: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">var colors &#x3D; new MyArray()</span><br><span class=\"line\">colors.push(&#39;red&#39;)</span><br><span class=\"line\">colors.length &#x3D; 0</span><br><span class=\"line\">console.log(colors)&#x2F;&#x2F;[&#39;red&#39;]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ES6Class中继承与ES5不同\"><a href=\"#ES6Class中继承与ES5不同\" class=\"headerlink\" title=\"ES6Class中继承与ES5不同\"></a>ES6Class中继承与ES5不同</h4><ol>\n<li>ES5先由派生类创建this，然后调用基类的构造函数，this开始指向的是MyArray的实例，之后被来自Array的其他属性修饰</li>\n<li>ES6中继承相反，先由基类创建this值，然后派生类的构造函数再去修改这个值，所以一开始可以通过this调用基类所有的内建功能</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyArrayClass extends Array&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Symbol-species属性\"><a href=\"#Symbol-species属性\" class=\"headerlink\" title=\"Symbol.species属性\"></a>Symbol.species属性</h4><ul>\n<li>如果有一个派生类MyArray继承Array，那么slice()这样的方法返回的数组会继承自MyArray</li>\n<li>这是引擎通过Symbol.species属性实现的</li>\n<li>Symbol.species定义返回函数的静态访问器属性</li>\n<li>Array\\ArrayBuffer\\Map\\Promise\\RegExp\\Set\\Type arrays都有默认的Symbol.species属性，该属性的返回值为this,也就是总会返回构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;在自定义类中实现Symbol.species</span><br><span class=\"line\">class speciesClass &#123;</span><br><span class=\"line\">    static get [Symbol.species]()&#123;</span><br><span class=\"line\">        return this</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;在类方法中使用constructor以及Symbol.species</span><br><span class=\"line\">class Funnnn&#123;</span><br><span class=\"line\">    static get [Symbol.species]()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;这里返回构造函数,通过定义返回的构造函数，可以改变继承时clone的实例类型</span><br><span class=\"line\">        return this</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    constructor(value)&#123;</span><br><span class=\"line\">        this.value &#x3D; value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    clone()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;this.constructor指向Funnn构造函数（类）</span><br><span class=\"line\">        return new this.constructor[Symbol.species](this.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let ff &#x3D; new Funnnn(11)</span><br><span class=\"line\">ff.clone()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"new-target\"><a href=\"#new-target\" class=\"headerlink\" title=\"new.target\"></a>new.target</h4><ul>\n<li>在构造函数中使用new.target</li>\n<li>简单情况下new.target等于构造函数</li>\n<li>类构造函数必须通过new关键字调用</li>\n<li>可以使用new.target创造一个抽象基类（不能被直接实例化的类）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class baseClass &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        if(new.target &#x3D;&#x3D;&#x3D; baseClass)&#123;</span><br><span class=\"line\">            throw new Error(&#39;不能被直接实例化&#39;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本的类声明语法\"><a href=\"#基本的类声明语法\" class=\"headerlink\" title=\"基本的类声明语法\"></a>基本的类声明语法</h3><ul>\n<li>注意：类的属性不可以被赋予新值</li>\n</ul>\n<ol>\n<li>类声明与let声明类似，不能被提升</li>\n<li>类声明所有代码都将自动运行在严格模式下</li>\n<li>在类中所有方法都不可被枚举，无需通过Object.defineProperty指定</li>\n<li>每个类都有一个[[Construct]]方法,通过new关键字调用不含[[Construct]]方法会报错</li>\n<li>使用除关键字new之外的方式调用类的构造函数会导致程序报错</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class personalClass &#123;</span><br><span class=\"line\">    constructor(name)&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;自有属性，不会出现在原型上</span><br><span class=\"line\">        this.name &#x3D; name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;等价于personClass.prototype.sayName</span><br><span class=\"line\">    sayName()&#123;</span><br><span class=\"line\">        console.log(this.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"类的名称\"><a href=\"#类的名称\" class=\"headerlink\" title=\"类的名称\"></a>类的名称</h4><ul>\n<li>类的名称在类中为常量，不能再类的方法中更改但是可以再外部更改</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        Foo &#x3D; &#39;bar&#39;&#x2F;&#x2F;执行时会报错</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo &#x3D; &#39;bar&#39;&#x2F;&#x2F;外部执行不会</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 等价于</span><br><span class=\"line\">let Foo1 &#x3D; (function () &#123;</span><br><span class=\"line\">    const Foo1 &#x3D; function (name) &#123;</span><br><span class=\"line\">        Foo1 &#x3D; &#39;bar&#39;</span><br><span class=\"line\">        this.name &#x3D; name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Object.defineProperty(Foo1,prototype,&#39;sayName&#39;,&#123;</span><br><span class=\"line\">        value: function () &#123;</span><br><span class=\"line\">            console.log(this.name)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n<h4 id=\"类表达式\"><a href=\"#类表达式\" class=\"headerlink\" title=\"类表达式\"></a>类表达式</h4><ul>\n<li>类表达式,不需要标识符在类后，除了语法类表达式功能上等价于类声明</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let perClass &#x3D; class &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>命名类表达式,此时p1Class是const定义，不可更改</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let pClass &#x3D; class p1Class&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>类可以传入函数，可以从函数返回、并且可以赋值给变量</li>\n</ul>\n<h4 id=\"类立即调用（创建单例）\"><a href=\"#类立即调用（创建单例）\" class=\"headerlink\" title=\"类立即调用（创建单例）\"></a>类立即调用（创建单例）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let person &#x3D; new class &#123;</span><br><span class=\"line\">    constructor(name)&#123;</span><br><span class=\"line\">        this.name &#x3D; name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(&#39;aa&#39;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"访问器属性\"><a href=\"#访问器属性\" class=\"headerlink\" title=\"访问器属性\"></a>访问器属性</h4><ul>\n<li>访问器属性，类支持在原型上定义访问器属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class getSetClass&#123;</span><br><span class=\"line\">    constructor(name)&#123;</span><br><span class=\"line\">        this.name &#x3D; name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    get age()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    set age(val)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;等价于</span><br><span class=\"line\">Object.defineProperty(getSetClass.prototype,&#39;age&#39;,&#123;</span><br><span class=\"line\">     get:function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     set:function (val) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可计算成员名称\"><a href=\"#可计算成员名称\" class=\"headerlink\" title=\"可计算成员名称\"></a>可计算成员名称</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name &#x3D; &#39;aaa&#39;</span><br><span class=\"line\">class pp&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [name]()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生成器方法\"><a href=\"#生成器方法\" class=\"headerlink\" title=\"生成器方法\"></a>生成器方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyClass &#123;</span><br><span class=\"line\">    *myGenerator()&#123;</span><br><span class=\"line\">        yield 1</span><br><span class=\"line\">        yield 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;定义默认迭代器</span><br><span class=\"line\">    *[symbol.iterator]()&#123;</span><br><span class=\"line\">        yield 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"静态成员\"><a href=\"#静态成员\" class=\"headerlink\" title=\"静态成员\"></a>静态成员</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class staticClass&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static create()&#123;</span><br><span class=\"line\">        return new staticClass()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;等价于</span><br><span class=\"line\">function aa() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">aa.create &#x3D; function () &#123;</span><br><span class=\"line\">    return new aa()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"继承与派生类\"><a href=\"#继承与派生类\" class=\"headerlink\" title=\"继承与派生类\"></a>继承与派生类</h3><ul>\n<li>继承自其他类的类被称为派生类，如果在派生类中指定了构造函数必须使用super()</li>\n<li>如果不使用构造函数，则会自动调用super()并传入所有参数</li>\n<li>注意：</li>\n</ul>\n<ol>\n<li>只可以在派生类的构造函数中使用super()</li>\n<li>在构造函数访问this之前一定要使用super()，它负责初始化this</li>\n<li>如果不想调用super()唯一的方法是让类的构造函数返回一个对象</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class father &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class child extends father &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;等价于father.call(this)</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>类方法遮蔽，派生类中的方法总会覆盖基类的同名方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Super&#123;</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Square extends Super&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;覆盖并遮蔽基类方法</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;调用基类中的方法，this会被自动正确设置</span><br><span class=\"line\">        super.Fun()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>静态成员继承，如果基类有静态成员，在派生类中也可以使用</li>\n</ul>\n<h4 id=\"派生自表达式的类\"><a href=\"#派生自表达式的类\" class=\"headerlink\" title=\"派生自表达式的类\"></a>派生自表达式的类</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bb() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;bb是一个ES5的构造函数，cc是一个类，由于bb具有[[Construct]]属性和原型，因此可以作为基类</span><br><span class=\"line\">class cc extends bb&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"mixin\"><a href=\"#mixin\" class=\"headerlink\" title=\"mixin\"></a>mixin</h3><ul>\n<li>首先创建一个base函数，再将每一个mixin的对象属性赋值给base原型</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let m1 &#x3D; &#123;</span><br><span class=\"line\">    Fun()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let m2 &#x3D; &#123;</span><br><span class=\"line\">    Fun1()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function mixin(...mixins) &#123;</span><br><span class=\"line\">    var base &#x3D; function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Object.assign(base.prototype,...mixins)</span><br><span class=\"line\">    return base</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class x extends mixin(m1,m2,)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内建对象的继承\"><a href=\"#内建对象的继承\" class=\"headerlink\" title=\"内建对象的继承\"></a>内建对象的继承</h3><ul>\n<li>ES5,MyArray实际行为与内建Array不一样，因为通过传统JS继承实现的数组继承没有从Array.apply()中活原型中继承相关功能</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MyArray() &#123;</span><br><span class=\"line\">    Array.apply(this,arguments)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyArray.prototype &#x3D; Object.create(Array.prototype,&#123;</span><br><span class=\"line\">    constructor: &#123;</span><br><span class=\"line\">        value: MyArray,</span><br><span class=\"line\">        writable: true,</span><br><span class=\"line\">        enumerable: false,</span><br><span class=\"line\">        configurable: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">var colors &#x3D; new MyArray()</span><br><span class=\"line\">colors.push(&#39;red&#39;)</span><br><span class=\"line\">colors.length &#x3D; 0</span><br><span class=\"line\">console.log(colors)&#x2F;&#x2F;[&#39;red&#39;]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ES6Class中继承与ES5不同\"><a href=\"#ES6Class中继承与ES5不同\" class=\"headerlink\" title=\"ES6Class中继承与ES5不同\"></a>ES6Class中继承与ES5不同</h4><ol>\n<li>ES5先由派生类创建this，然后调用基类的构造函数，this开始指向的是MyArray的实例，之后被来自Array的其他属性修饰</li>\n<li>ES6中继承相反，先由基类创建this值，然后派生类的构造函数再去修改这个值，所以一开始可以通过this调用基类所有的内建功能</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyArrayClass extends Array&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Symbol-species属性\"><a href=\"#Symbol-species属性\" class=\"headerlink\" title=\"Symbol.species属性\"></a>Symbol.species属性</h4><ul>\n<li>如果有一个派生类MyArray继承Array，那么slice()这样的方法返回的数组会继承自MyArray</li>\n<li>这是引擎通过Symbol.species属性实现的</li>\n<li>Symbol.species定义返回函数的静态访问器属性</li>\n<li>Array\\ArrayBuffer\\Map\\Promise\\RegExp\\Set\\Type arrays都有默认的Symbol.species属性，该属性的返回值为this,也就是总会返回构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;在自定义类中实现Symbol.species</span><br><span class=\"line\">class speciesClass &#123;</span><br><span class=\"line\">    static get [Symbol.species]()&#123;</span><br><span class=\"line\">        return this</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;在类方法中使用constructor以及Symbol.species</span><br><span class=\"line\">class Funnnn&#123;</span><br><span class=\"line\">    static get [Symbol.species]()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;这里返回构造函数,通过定义返回的构造函数，可以改变继承时clone的实例类型</span><br><span class=\"line\">        return this</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    constructor(value)&#123;</span><br><span class=\"line\">        this.value &#x3D; value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    clone()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;this.constructor指向Funnn构造函数（类）</span><br><span class=\"line\">        return new this.constructor[Symbol.species](this.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let ff &#x3D; new Funnnn(11)</span><br><span class=\"line\">ff.clone()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"new-target\"><a href=\"#new-target\" class=\"headerlink\" title=\"new.target\"></a>new.target</h4><ul>\n<li>在构造函数中使用new.target</li>\n<li>简单情况下new.target等于构造函数</li>\n<li>类构造函数必须通过new关键字调用</li>\n<li>可以使用new.target创造一个抽象基类（不能被直接实例化的类）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class baseClass &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        if(new.target &#x3D;&#x3D;&#x3D; baseClass)&#123;</span><br><span class=\"line\">            throw new Error(&#39;不能被直接实例化&#39;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"<ES6>promise","date":"2018-08-21T16:00:00.000Z","_content":"\n### 简介\n\n#### 异步编程\n\n- Promise可以完成其他语言中类似Future和Deferred功能\n\n- 异步编程的背景知识：\nJS引擎是基于单线程(single-threaded)事件循环概念构建的，同一时刻只允许一个代码块在执行，代码块放在一个任务队列(job queue)中，\n每当一个代码块准备执行，就会被添加到任务队列，JS引擎执行完一段代码后，事件循环会执行队列中的下一个任务，队列中的任务会从第一个执行到\n最后一个。\n- eventLoop：https://crazyaguai.github.io/2018/10/20/js-eventLoop/\n#### 事件模型\n- 事件模型,适用于响应用户交互和完成类似的低频功能，但是对于复杂的需求不是很灵活\n\n```\nlet btn = document.querySelector('.button')\n    btn.onclick = function (event) {\n}\n```\n\n#### 回调模式\n- 回调模式，如果嵌套了太多回调，会陷入回调地狱\n\n### Promise相关\n\n#### Promise基础知识\n\n- Promise相当于异步操作的占位符，让函数返回一个Promise\nPromise生命周期：\n- 先处于进行中(pending)状态，此时操作未完成，它也是未处理(unsettled)的，一旦异步操作结束，Promise变为已处理(settled)状态\n- 之后会进入Fulfilled(完成)或者Rejected(未成功)状态\n- 内部属性[[PromiseState]]被用来表示三种状态pending\\fufilled\\rejected\n- Promise有then()方法接收两个参数，fufilled状态调用的函数、rejected状态调用的函数\n- 如果有一个对象实现了then()方法，那么称之为thenable对象，所有Promise都是thenable对象。但并非所有thenable对象都是promise\n- Promise还有一个chache()方法用来接收错误，如果不给Promise添加拒绝处理程序，那么所有错误将被忽略，所以一定要添加\n- 每次调用then()\\cache()方法时都会创建一个任务，当promise被解决时，这些任务都会加入到一个为Promise定制的独立队列中\n\n#### 创建未完成的Promise\n\n```\nfunction Fun() {\n    return new Promise((resolve,reject)=>{\n        resolve()\n    })\n}\nFun().then(res=>{\n}).catch(err=>{\n})\n```\n\n- Promise执行器会立即执行，之后才会执行后续流程的代码\n\n```\nfunction Fun1() {\n    return new Promise((resolve,reject)=>{\n        //这里会立即执行function Fun1() {\n        console.log(1)\n        resolve(3)\n    })\n}\nFun1().then(res=>{\n    //这里会被添加到任务对列中并异步执行\n    //完成处理程序和拒绝处理程序总被添加到任务对列的末尾\n    console.log(res)\n})\nconsole.log(2)\n//1 2 3\n```\n\n#### 创建已处理的Promise\n\n- Promise.resolve(),接收参数返回一个完成状态的Promise,不会有任何编排过程\n\n```\nlet promise = Promise.resolve(1)\npromise.then(res=>{\n    console.log(res)\n})\npromise.then(res=>{\n    console.log(res)\n})\n//1 1\n```\n\n#### 创建拒绝状态的Promise\n\n- Promise.reject('error'),创建拒绝状态的Promise\n\n```\nlet promise = Promise.reject(1)\npromise.catch(res=>{\n    console.log(res)\n})\npromise.catch(res=>{\n    console.log(res)\n})\n//1 1\n```\n\n#### 非Promise的Thenable对象\n\n- 非Promise的Thenable对象，如果传入一个非Promise的Thenable对象，则这些方法会创建一个新的Promise并在then()函数中调用\n\n```\nlet thenable = {\n    then(resolve,reject){\n        setTimeout(()=>{\n            resolve('thenable')\n        },1000)\n    }\n}\nlet p1 = Promise.resolve(thenable)\np1.then(res=>{\n    console.log(res)\n})\n```\n\n### 相关应用\n\n#### Thenable对象\n - 可以使用Promise.resolve()或者Promise.reject()处理非Promise的Thenable对象，\n - ES6之前许多库使用了thenable对象，所以如果想兼容之前已有的库，需要将Thenable对象转换为正式的Promise对象，\n - 如果不确定某个对象是否为Promise对象，那么可以根据预期的结果将其传入Promise.resolve()或Promise.reject()，如果是Promise则不会有任何变化\n\n```\nvar original = Promise.resolve('我在第二行');\nvar cast = Promise.resolve(original);\ncast.then(function(value) {\n    console.log('value: ' + value);\n});\nconsole.log('original === cast ? ' + (original === cast));\n//打印顺序如下，这里有一个同步异步先后执行的区别\n//original === cast ? true\n//value: 我在第二行\n```\n\n- Resolve一个thenable对象\n\n```\nvar p1 = Promise.resolve({\n    then: function (onFulfill, onReject) {\n        onFulfill(\"fulfilled!\");\n    }\n});\nconsole.log(p1 instanceof Promise) // true, 这是一个Promise对象\n\np1.then(function (v) {\n    console.log(v); // 输出\"fulfilled!\"\n}, function (e) {\n    // 不会被调用\n});\n```\n\n-  Thenable在callback之前抛出异常\n\n```\n// Promise rejects\nvar thenable = {\n    then: function (resolve) {\n        throw new TypeError(\"Throwing\");\n        resolve(\"Resolving\");\n    }\n};\n\nvar p2 = Promise.resolve(thenable);\np2.then(function (v) {\n    // 不会被调用\n}, function (e) {\n    console.log(e); // TypeError: Throwing\n});\n```\n\n- Thenable在callback之后抛出异常\n\n```\n// Promise resolves\nvar thenable = {\n    then: function (resolve) {\n        resolve(\"Resolving\");\n        throw new TypeError(\"Throwing\");\n    }\n};\n\nvar p3 = Promise.resolve(thenable);\np3.then(function (v) {\n    console.log(v); // 输出\"Resolving\"\n}, function (e) {\n    // 不会被调用\n});\n```\n\n#### 执行器错误\n\n- 如果执行器内部抛出一个错误，那么Promise的拒绝程序就会被调用\n\n```\nlet p3 = new Promise(function (resolve,reject) {\n    throw new Error('Explosion')\n    //等价于\n    // try{\n    //     throw new Error('Explosion')\n    // }catch (e) {\n    //     reject(e)\n    // }\n})\np3.catch(function (error) {\n    console.log(error.message)\n})\n```\n\n#### 全局的Promise错误处理\n\n- NodeJS中：\n\n1. unhandledRejection在一个事件中当Promise被拒绝，并且没有提供拒绝处理程序时该事件被触发\n2. rejectionHandled在一个事件循环后，当Promise被拒绝时，若拒绝处理程序被调用，触发该事件\n\n```\n//拒绝原因以及被拒绝的promise作为参数被传入unhandleRejection事件处理程序\nlet rejected\nprocess.on('unhandleRejection', function (reason, promise) {\n    console.log(reason.message)\n    console.log(rejected === promise)\n})\nrejected = Promise.reject(\nthrow new Error('Explosion')\n)\n\n//rejectionHandle事件在拒绝处理程序最后被调用时触发，如果在创建rejected之后直接添加拒绝处理程序，那个rejectionHandle事件不会被触发\nlet rejected\nprocess.on('rejectionHandle', function (promise) {\n    console.log(rejected === promise)\n})\nrejected = Promise.reject(new Error('Explosion'))\nsetTimeout(() => {\n    rejected.catch(err => {\n        console.log(err.message)\n    })\n}, 1000)\n\n//通过rejectionHandle和事件unhandleRejection将潜在未处理的拒绝存储为一个列表\n\nlet possiblyUnhandleRejections = new Map()\n//如果一个拒绝没有被处理，则添加到map集合中\nprocess.on('unhandledRejection', function (reason, promise) {\n    possiblyUnhandleRejections.set(promise, reason)\n})\n\n//如果被处理了，移除promise\nprocess.on('rejectionHandled', function (promise) {\n    possiblyUnhandleRejections.delete(promise)\n})\n\n//循环未处理的Promise\nsetInterval(function () {\n    possiblyUnhandleRejections.forEach(function (reason, promise) {\n        //做一些处理\n    })\n    possiblyUnhandleRejections.clear()\n}, 6000)\n```\n\n#### 浏览器环境的拒绝处理\n\n- unhandledrejection:当一个Promise被拒绝并且没有提供拒绝处理时触发\n- rejectionhandled:在一个事件循环后,当Promise被拒绝时，若拒绝处理程序被调用，则触发该事件\n\n```\n//用DOM0级标记法onunhandledrejection和onrejectionhandled\n\nlet possiblyUnhandleRejections = new Map()\n//如果一个拒绝没有被处理，添加到map中\nwindow.onunhandledrejection = function (event) {\n    possiblyUnhandleRejections.set(event.promise, event.reason)\n}\n//如果出发了拒绝方法，从map中删除\nwindow.onrejectionhandled = function (event) {\n    possiblyUnhandleRejections.delete(event.promise)\n}\n//循环遍历处理\nsetInterval(() => {\n    possiblyUnhandleRejections.forEach((promise, reason) => {\n        console.log('111111')\n        console.log(promise)\n        console.log(reason)\n    })\n    possiblyUnhandleRejections.clear()\n}, 3000)\nlet p5 = Promise.reject('111')\n```\n\n#### 串联Promise\n\n- 每次调用then()、cache()方法，实际上创建并且返回了另一个Promise，当只有第一个Promise完成或者被拒绝后，第二个才会被解决\n\n```\nlet p7 = new Promise((resolve, reject) => {\n    resolve(1)\n})\np7.then((res) => {\n    console.log(res)//1\n}).then(res => {\n    console.log('Finished')\n}).catch(err => {\n    //这里可以处理公共的错误\n})\n```\n\n- 务必在Promise的结尾有一个处理拒绝的程序，以便能够正确处理所有的错误\n\n#### Promise的链返回值\n\n- Promise中返回一个值可以沿着这条链传递数据\n- 如果返回的是Promise对象，那么要看返回的Promise怎么处理\n- 响应多个Promise\n\n#### Promise.all()\n\n- 只有迭代中所有Promise都解决后才被解决\n- 如果有一个被拒绝，那么返回的Promise就立即被拒绝\n\n#### Promise.race()\n\n- 只要有一个被解决返回，Promise就被解决\n\n#### 自Promise继承\n\n- 定义自己的Promise来扩展内建Promise功能\n- 由于MyPromise.resolve()和MyPromise.reject()通过Symbol.species属性决定返回Promise类型，所以无论传什么值，都会返回MyPromise实例\n\n```\nclass MyPromise extends Promise{\n    success(resolve,reject){\n        return this.then(resolve,reject)\n    }\n    failure(reject){\n        return this.cache(reject)\n    }\n}\n\nlet mPromise = new MyPromise(function (resolve,reject) {\n    resolve('1')\n})\nmPromise.success(res=>{\n\n}).failure(err=>{\n\n})\n```\n\n#### Promise的异步执行\n\n- 对已完成的promise执行then,此时会执行then的操作\n\n```\nconst promise = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('111')\n    },1000)\n})\nsetTimeout(()=>{\n    promise.then(res=>{\n        console.log(res)\n    })\n},3000)\n```\n\n\n- then里面不返回新的promise\n\n```\nnew Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('2222')\n    },1000)\n}).then((res)=>{\n    (function f() {\n        return new Promise(resolve=>{\n            setTimeout(()=>{\n                resolve('333')\n            },1000)\n        })\n    }())\n    console.log(res)\n    return false\n}).then(res=>{\n    console.log(res)\n})\n```\n\n- then的嵌套\n- 需要返回一个新的promise实例才可以等resolve之后回调\n\n- 错误处理,catch也会返回promise实例，后面的then和catch也会执行\n\n```\nnew Promise((resolve, reject) => {\n    // reject('123')\n    // throw new Error('1111')\n}).then(res => {\n}).catch(err => {\n    console.log(err)\n})\n```\n\n- promise.all 与 map 连用\n\n```\nlet arr = [1,2,3]\nPromise.all(arr.map(item=>{\n    return new Promise(resolve=>{\n        resolve('1111')\n    })\n})).then(all=>{\n    console.log(all)\n})\n```\n\n- promise实现队列，使用.then返回新的promise实例\n\n```\nlet arr = [1,2,3,4]\nfunction queue(arr) {\n    let promise = Promise.resolve()\n    arr.forEach(item=>{\n        promise = promise.then(res=>{\n            console.log(res)\n            return new Promise(resolve=>{\n                 // 在这里处理相关逻辑\n                resolve(item)\n            })\n        })\n    })\n    return promise\n}\nqueue(arr).then(res=>{\n    console.log(res)\n})\n```\n\n- promise.resolve\n\n```\nPromise.resolve().then(res=>{\n    return Promise.resolve('123')\n}).then(res=>{\n    console.log(res)\n    return Promise.resolve(new Promise(resolve=>{\n        setTimeout(()=>{\n            resolve('456')\n        },1000)\n    })).then(res=>{\n        console.log(res)\n        Promise.resolve({\n            then(){\n                console.log('7890')\n            }\n        })\n    })\n})\n```\n","source":"_posts/[ES6]promise.md","raw":"---\ntitle: <ES6>promise\ndate: 2018-08-22 00:00:00\ntags: [ES6,js]\ncategories: ES6\n---\n\n### 简介\n\n#### 异步编程\n\n- Promise可以完成其他语言中类似Future和Deferred功能\n\n- 异步编程的背景知识：\nJS引擎是基于单线程(single-threaded)事件循环概念构建的，同一时刻只允许一个代码块在执行，代码块放在一个任务队列(job queue)中，\n每当一个代码块准备执行，就会被添加到任务队列，JS引擎执行完一段代码后，事件循环会执行队列中的下一个任务，队列中的任务会从第一个执行到\n最后一个。\n- eventLoop：https://crazyaguai.github.io/2018/10/20/js-eventLoop/\n#### 事件模型\n- 事件模型,适用于响应用户交互和完成类似的低频功能，但是对于复杂的需求不是很灵活\n\n```\nlet btn = document.querySelector('.button')\n    btn.onclick = function (event) {\n}\n```\n\n#### 回调模式\n- 回调模式，如果嵌套了太多回调，会陷入回调地狱\n\n### Promise相关\n\n#### Promise基础知识\n\n- Promise相当于异步操作的占位符，让函数返回一个Promise\nPromise生命周期：\n- 先处于进行中(pending)状态，此时操作未完成，它也是未处理(unsettled)的，一旦异步操作结束，Promise变为已处理(settled)状态\n- 之后会进入Fulfilled(完成)或者Rejected(未成功)状态\n- 内部属性[[PromiseState]]被用来表示三种状态pending\\fufilled\\rejected\n- Promise有then()方法接收两个参数，fufilled状态调用的函数、rejected状态调用的函数\n- 如果有一个对象实现了then()方法，那么称之为thenable对象，所有Promise都是thenable对象。但并非所有thenable对象都是promise\n- Promise还有一个chache()方法用来接收错误，如果不给Promise添加拒绝处理程序，那么所有错误将被忽略，所以一定要添加\n- 每次调用then()\\cache()方法时都会创建一个任务，当promise被解决时，这些任务都会加入到一个为Promise定制的独立队列中\n\n#### 创建未完成的Promise\n\n```\nfunction Fun() {\n    return new Promise((resolve,reject)=>{\n        resolve()\n    })\n}\nFun().then(res=>{\n}).catch(err=>{\n})\n```\n\n- Promise执行器会立即执行，之后才会执行后续流程的代码\n\n```\nfunction Fun1() {\n    return new Promise((resolve,reject)=>{\n        //这里会立即执行function Fun1() {\n        console.log(1)\n        resolve(3)\n    })\n}\nFun1().then(res=>{\n    //这里会被添加到任务对列中并异步执行\n    //完成处理程序和拒绝处理程序总被添加到任务对列的末尾\n    console.log(res)\n})\nconsole.log(2)\n//1 2 3\n```\n\n#### 创建已处理的Promise\n\n- Promise.resolve(),接收参数返回一个完成状态的Promise,不会有任何编排过程\n\n```\nlet promise = Promise.resolve(1)\npromise.then(res=>{\n    console.log(res)\n})\npromise.then(res=>{\n    console.log(res)\n})\n//1 1\n```\n\n#### 创建拒绝状态的Promise\n\n- Promise.reject('error'),创建拒绝状态的Promise\n\n```\nlet promise = Promise.reject(1)\npromise.catch(res=>{\n    console.log(res)\n})\npromise.catch(res=>{\n    console.log(res)\n})\n//1 1\n```\n\n#### 非Promise的Thenable对象\n\n- 非Promise的Thenable对象，如果传入一个非Promise的Thenable对象，则这些方法会创建一个新的Promise并在then()函数中调用\n\n```\nlet thenable = {\n    then(resolve,reject){\n        setTimeout(()=>{\n            resolve('thenable')\n        },1000)\n    }\n}\nlet p1 = Promise.resolve(thenable)\np1.then(res=>{\n    console.log(res)\n})\n```\n\n### 相关应用\n\n#### Thenable对象\n - 可以使用Promise.resolve()或者Promise.reject()处理非Promise的Thenable对象，\n - ES6之前许多库使用了thenable对象，所以如果想兼容之前已有的库，需要将Thenable对象转换为正式的Promise对象，\n - 如果不确定某个对象是否为Promise对象，那么可以根据预期的结果将其传入Promise.resolve()或Promise.reject()，如果是Promise则不会有任何变化\n\n```\nvar original = Promise.resolve('我在第二行');\nvar cast = Promise.resolve(original);\ncast.then(function(value) {\n    console.log('value: ' + value);\n});\nconsole.log('original === cast ? ' + (original === cast));\n//打印顺序如下，这里有一个同步异步先后执行的区别\n//original === cast ? true\n//value: 我在第二行\n```\n\n- Resolve一个thenable对象\n\n```\nvar p1 = Promise.resolve({\n    then: function (onFulfill, onReject) {\n        onFulfill(\"fulfilled!\");\n    }\n});\nconsole.log(p1 instanceof Promise) // true, 这是一个Promise对象\n\np1.then(function (v) {\n    console.log(v); // 输出\"fulfilled!\"\n}, function (e) {\n    // 不会被调用\n});\n```\n\n-  Thenable在callback之前抛出异常\n\n```\n// Promise rejects\nvar thenable = {\n    then: function (resolve) {\n        throw new TypeError(\"Throwing\");\n        resolve(\"Resolving\");\n    }\n};\n\nvar p2 = Promise.resolve(thenable);\np2.then(function (v) {\n    // 不会被调用\n}, function (e) {\n    console.log(e); // TypeError: Throwing\n});\n```\n\n- Thenable在callback之后抛出异常\n\n```\n// Promise resolves\nvar thenable = {\n    then: function (resolve) {\n        resolve(\"Resolving\");\n        throw new TypeError(\"Throwing\");\n    }\n};\n\nvar p3 = Promise.resolve(thenable);\np3.then(function (v) {\n    console.log(v); // 输出\"Resolving\"\n}, function (e) {\n    // 不会被调用\n});\n```\n\n#### 执行器错误\n\n- 如果执行器内部抛出一个错误，那么Promise的拒绝程序就会被调用\n\n```\nlet p3 = new Promise(function (resolve,reject) {\n    throw new Error('Explosion')\n    //等价于\n    // try{\n    //     throw new Error('Explosion')\n    // }catch (e) {\n    //     reject(e)\n    // }\n})\np3.catch(function (error) {\n    console.log(error.message)\n})\n```\n\n#### 全局的Promise错误处理\n\n- NodeJS中：\n\n1. unhandledRejection在一个事件中当Promise被拒绝，并且没有提供拒绝处理程序时该事件被触发\n2. rejectionHandled在一个事件循环后，当Promise被拒绝时，若拒绝处理程序被调用，触发该事件\n\n```\n//拒绝原因以及被拒绝的promise作为参数被传入unhandleRejection事件处理程序\nlet rejected\nprocess.on('unhandleRejection', function (reason, promise) {\n    console.log(reason.message)\n    console.log(rejected === promise)\n})\nrejected = Promise.reject(\nthrow new Error('Explosion')\n)\n\n//rejectionHandle事件在拒绝处理程序最后被调用时触发，如果在创建rejected之后直接添加拒绝处理程序，那个rejectionHandle事件不会被触发\nlet rejected\nprocess.on('rejectionHandle', function (promise) {\n    console.log(rejected === promise)\n})\nrejected = Promise.reject(new Error('Explosion'))\nsetTimeout(() => {\n    rejected.catch(err => {\n        console.log(err.message)\n    })\n}, 1000)\n\n//通过rejectionHandle和事件unhandleRejection将潜在未处理的拒绝存储为一个列表\n\nlet possiblyUnhandleRejections = new Map()\n//如果一个拒绝没有被处理，则添加到map集合中\nprocess.on('unhandledRejection', function (reason, promise) {\n    possiblyUnhandleRejections.set(promise, reason)\n})\n\n//如果被处理了，移除promise\nprocess.on('rejectionHandled', function (promise) {\n    possiblyUnhandleRejections.delete(promise)\n})\n\n//循环未处理的Promise\nsetInterval(function () {\n    possiblyUnhandleRejections.forEach(function (reason, promise) {\n        //做一些处理\n    })\n    possiblyUnhandleRejections.clear()\n}, 6000)\n```\n\n#### 浏览器环境的拒绝处理\n\n- unhandledrejection:当一个Promise被拒绝并且没有提供拒绝处理时触发\n- rejectionhandled:在一个事件循环后,当Promise被拒绝时，若拒绝处理程序被调用，则触发该事件\n\n```\n//用DOM0级标记法onunhandledrejection和onrejectionhandled\n\nlet possiblyUnhandleRejections = new Map()\n//如果一个拒绝没有被处理，添加到map中\nwindow.onunhandledrejection = function (event) {\n    possiblyUnhandleRejections.set(event.promise, event.reason)\n}\n//如果出发了拒绝方法，从map中删除\nwindow.onrejectionhandled = function (event) {\n    possiblyUnhandleRejections.delete(event.promise)\n}\n//循环遍历处理\nsetInterval(() => {\n    possiblyUnhandleRejections.forEach((promise, reason) => {\n        console.log('111111')\n        console.log(promise)\n        console.log(reason)\n    })\n    possiblyUnhandleRejections.clear()\n}, 3000)\nlet p5 = Promise.reject('111')\n```\n\n#### 串联Promise\n\n- 每次调用then()、cache()方法，实际上创建并且返回了另一个Promise，当只有第一个Promise完成或者被拒绝后，第二个才会被解决\n\n```\nlet p7 = new Promise((resolve, reject) => {\n    resolve(1)\n})\np7.then((res) => {\n    console.log(res)//1\n}).then(res => {\n    console.log('Finished')\n}).catch(err => {\n    //这里可以处理公共的错误\n})\n```\n\n- 务必在Promise的结尾有一个处理拒绝的程序，以便能够正确处理所有的错误\n\n#### Promise的链返回值\n\n- Promise中返回一个值可以沿着这条链传递数据\n- 如果返回的是Promise对象，那么要看返回的Promise怎么处理\n- 响应多个Promise\n\n#### Promise.all()\n\n- 只有迭代中所有Promise都解决后才被解决\n- 如果有一个被拒绝，那么返回的Promise就立即被拒绝\n\n#### Promise.race()\n\n- 只要有一个被解决返回，Promise就被解决\n\n#### 自Promise继承\n\n- 定义自己的Promise来扩展内建Promise功能\n- 由于MyPromise.resolve()和MyPromise.reject()通过Symbol.species属性决定返回Promise类型，所以无论传什么值，都会返回MyPromise实例\n\n```\nclass MyPromise extends Promise{\n    success(resolve,reject){\n        return this.then(resolve,reject)\n    }\n    failure(reject){\n        return this.cache(reject)\n    }\n}\n\nlet mPromise = new MyPromise(function (resolve,reject) {\n    resolve('1')\n})\nmPromise.success(res=>{\n\n}).failure(err=>{\n\n})\n```\n\n#### Promise的异步执行\n\n- 对已完成的promise执行then,此时会执行then的操作\n\n```\nconst promise = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('111')\n    },1000)\n})\nsetTimeout(()=>{\n    promise.then(res=>{\n        console.log(res)\n    })\n},3000)\n```\n\n\n- then里面不返回新的promise\n\n```\nnew Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('2222')\n    },1000)\n}).then((res)=>{\n    (function f() {\n        return new Promise(resolve=>{\n            setTimeout(()=>{\n                resolve('333')\n            },1000)\n        })\n    }())\n    console.log(res)\n    return false\n}).then(res=>{\n    console.log(res)\n})\n```\n\n- then的嵌套\n- 需要返回一个新的promise实例才可以等resolve之后回调\n\n- 错误处理,catch也会返回promise实例，后面的then和catch也会执行\n\n```\nnew Promise((resolve, reject) => {\n    // reject('123')\n    // throw new Error('1111')\n}).then(res => {\n}).catch(err => {\n    console.log(err)\n})\n```\n\n- promise.all 与 map 连用\n\n```\nlet arr = [1,2,3]\nPromise.all(arr.map(item=>{\n    return new Promise(resolve=>{\n        resolve('1111')\n    })\n})).then(all=>{\n    console.log(all)\n})\n```\n\n- promise实现队列，使用.then返回新的promise实例\n\n```\nlet arr = [1,2,3,4]\nfunction queue(arr) {\n    let promise = Promise.resolve()\n    arr.forEach(item=>{\n        promise = promise.then(res=>{\n            console.log(res)\n            return new Promise(resolve=>{\n                 // 在这里处理相关逻辑\n                resolve(item)\n            })\n        })\n    })\n    return promise\n}\nqueue(arr).then(res=>{\n    console.log(res)\n})\n```\n\n- promise.resolve\n\n```\nPromise.resolve().then(res=>{\n    return Promise.resolve('123')\n}).then(res=>{\n    console.log(res)\n    return Promise.resolve(new Promise(resolve=>{\n        setTimeout(()=>{\n            resolve('456')\n        },1000)\n    })).then(res=>{\n        console.log(res)\n        Promise.resolve({\n            then(){\n                console.log('7890')\n            }\n        })\n    })\n})\n```\n","slug":"[ES6]promise","published":1,"updated":"2021-03-15T14:37:14.281Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4djz0008wotj2evsb0n5","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><h4 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h4><ul>\n<li><p>Promise可以完成其他语言中类似Future和Deferred功能</p>\n</li>\n<li><p>异步编程的背景知识：<br>JS引擎是基于单线程(single-threaded)事件循环概念构建的，同一时刻只允许一个代码块在执行，代码块放在一个任务队列(job queue)中，<br>每当一个代码块准备执行，就会被添加到任务队列，JS引擎执行完一段代码后，事件循环会执行队列中的下一个任务，队列中的任务会从第一个执行到<br>最后一个。</p>\n</li>\n<li><p>eventLoop：<a href=\"https://crazyaguai.github.io/2018/10/20/js-eventLoop/\">https://crazyaguai.github.io/2018/10/20/js-eventLoop/</a></p>\n<h4 id=\"事件模型\"><a href=\"#事件模型\" class=\"headerlink\" title=\"事件模型\"></a>事件模型</h4></li>\n<li><p>事件模型,适用于响应用户交互和完成类似的低频功能，但是对于复杂的需求不是很灵活</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let btn &#x3D; document.querySelector(&#39;.button&#39;)</span><br><span class=\"line\">    btn.onclick &#x3D; function (event) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"回调模式\"><a href=\"#回调模式\" class=\"headerlink\" title=\"回调模式\"></a>回调模式</h4><ul>\n<li>回调模式，如果嵌套了太多回调，会陷入回调地狱</li>\n</ul>\n<h3 id=\"Promise相关\"><a href=\"#Promise相关\" class=\"headerlink\" title=\"Promise相关\"></a>Promise相关</h3><h4 id=\"Promise基础知识\"><a href=\"#Promise基础知识\" class=\"headerlink\" title=\"Promise基础知识\"></a>Promise基础知识</h4><ul>\n<li>Promise相当于异步操作的占位符，让函数返回一个Promise<br>Promise生命周期：</li>\n<li>先处于进行中(pending)状态，此时操作未完成，它也是未处理(unsettled)的，一旦异步操作结束，Promise变为已处理(settled)状态</li>\n<li>之后会进入Fulfilled(完成)或者Rejected(未成功)状态</li>\n<li>内部属性[[PromiseState]]被用来表示三种状态pending\\fufilled\\rejected</li>\n<li>Promise有then()方法接收两个参数，fufilled状态调用的函数、rejected状态调用的函数</li>\n<li>如果有一个对象实现了then()方法，那么称之为thenable对象，所有Promise都是thenable对象。但并非所有thenable对象都是promise</li>\n<li>Promise还有一个chache()方法用来接收错误，如果不给Promise添加拒绝处理程序，那么所有错误将被忽略，所以一定要添加</li>\n<li>每次调用then()\\cache()方法时都会创建一个任务，当promise被解决时，这些任务都会加入到一个为Promise定制的独立队列中</li>\n</ul>\n<h4 id=\"创建未完成的Promise\"><a href=\"#创建未完成的Promise\" class=\"headerlink\" title=\"创建未完成的Promise\"></a>创建未完成的Promise</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fun() &#123;</span><br><span class=\"line\">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun().then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">&#125;).catch(err&#x3D;&gt;&#123;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Promise执行器会立即执行，之后才会执行后续流程的代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fun1() &#123;</span><br><span class=\"line\">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;这里会立即执行function Fun1() &#123;</span><br><span class=\"line\">        console.log(1)</span><br><span class=\"line\">        resolve(3)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun1().then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;这里会被添加到任务对列中并异步执行</span><br><span class=\"line\">    &#x2F;&#x2F;完成处理程序和拒绝处理程序总被添加到任务对列的末尾</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(2)</span><br><span class=\"line\">&#x2F;&#x2F;1 2 3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建已处理的Promise\"><a href=\"#创建已处理的Promise\" class=\"headerlink\" title=\"创建已处理的Promise\"></a>创建已处理的Promise</h4><ul>\n<li>Promise.resolve(),接收参数返回一个完成状态的Promise,不会有任何编排过程</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let promise &#x3D; Promise.resolve(1)</span><br><span class=\"line\">promise.then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#x2F;&#x2F;1 1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建拒绝状态的Promise\"><a href=\"#创建拒绝状态的Promise\" class=\"headerlink\" title=\"创建拒绝状态的Promise\"></a>创建拒绝状态的Promise</h4><ul>\n<li>Promise.reject(‘error’),创建拒绝状态的Promise</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let promise &#x3D; Promise.reject(1)</span><br><span class=\"line\">promise.catch(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.catch(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#x2F;&#x2F;1 1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"非Promise的Thenable对象\"><a href=\"#非Promise的Thenable对象\" class=\"headerlink\" title=\"非Promise的Thenable对象\"></a>非Promise的Thenable对象</h4><ul>\n<li>非Promise的Thenable对象，如果传入一个非Promise的Thenable对象，则这些方法会创建一个新的Promise并在then()函数中调用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let thenable &#x3D; &#123;</span><br><span class=\"line\">    then(resolve,reject)&#123;</span><br><span class=\"line\">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">            resolve(&#39;thenable&#39;)</span><br><span class=\"line\">        &#125;,1000)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p1 &#x3D; Promise.resolve(thenable)</span><br><span class=\"line\">p1.then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"相关应用\"><a href=\"#相关应用\" class=\"headerlink\" title=\"相关应用\"></a>相关应用</h3><h4 id=\"Thenable对象\"><a href=\"#Thenable对象\" class=\"headerlink\" title=\"Thenable对象\"></a>Thenable对象</h4><ul>\n<li>可以使用Promise.resolve()或者Promise.reject()处理非Promise的Thenable对象，</li>\n<li>ES6之前许多库使用了thenable对象，所以如果想兼容之前已有的库，需要将Thenable对象转换为正式的Promise对象，</li>\n<li>如果不确定某个对象是否为Promise对象，那么可以根据预期的结果将其传入Promise.resolve()或Promise.reject()，如果是Promise则不会有任何变化</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var original &#x3D; Promise.resolve(&#39;我在第二行&#39;);</span><br><span class=\"line\">var cast &#x3D; Promise.resolve(original);</span><br><span class=\"line\">cast.then(function(value) &#123;</span><br><span class=\"line\">    console.log(&#39;value: &#39; + value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&#39;original &#x3D;&#x3D;&#x3D; cast ? &#39; + (original &#x3D;&#x3D;&#x3D; cast));</span><br><span class=\"line\">&#x2F;&#x2F;打印顺序如下，这里有一个同步异步先后执行的区别</span><br><span class=\"line\">&#x2F;&#x2F;original &#x3D;&#x3D;&#x3D; cast ? true</span><br><span class=\"line\">&#x2F;&#x2F;value: 我在第二行</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Resolve一个thenable对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 &#x3D; Promise.resolve(&#123;</span><br><span class=\"line\">    then: function (onFulfill, onReject) &#123;</span><br><span class=\"line\">        onFulfill(&quot;fulfilled!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(p1 instanceof Promise) &#x2F;&#x2F; true, 这是一个Promise对象</span><br><span class=\"line\"></span><br><span class=\"line\">p1.then(function (v) &#123;</span><br><span class=\"line\">    console.log(v); &#x2F;&#x2F; 输出&quot;fulfilled!&quot;</span><br><span class=\"line\">&#125;, function (e) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 不会被调用</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li> Thenable在callback之前抛出异常</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Promise rejects</span><br><span class=\"line\">var thenable &#x3D; &#123;</span><br><span class=\"line\">    then: function (resolve) &#123;</span><br><span class=\"line\">        throw new TypeError(&quot;Throwing&quot;);</span><br><span class=\"line\">        resolve(&quot;Resolving&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p2 &#x3D; Promise.resolve(thenable);</span><br><span class=\"line\">p2.then(function (v) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 不会被调用</span><br><span class=\"line\">&#125;, function (e) &#123;</span><br><span class=\"line\">    console.log(e); &#x2F;&#x2F; TypeError: Throwing</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Thenable在callback之后抛出异常</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Promise resolves</span><br><span class=\"line\">var thenable &#x3D; &#123;</span><br><span class=\"line\">    then: function (resolve) &#123;</span><br><span class=\"line\">        resolve(&quot;Resolving&quot;);</span><br><span class=\"line\">        throw new TypeError(&quot;Throwing&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p3 &#x3D; Promise.resolve(thenable);</span><br><span class=\"line\">p3.then(function (v) &#123;</span><br><span class=\"line\">    console.log(v); &#x2F;&#x2F; 输出&quot;Resolving&quot;</span><br><span class=\"line\">&#125;, function (e) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 不会被调用</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"执行器错误\"><a href=\"#执行器错误\" class=\"headerlink\" title=\"执行器错误\"></a>执行器错误</h4><ul>\n<li>如果执行器内部抛出一个错误，那么Promise的拒绝程序就会被调用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p3 &#x3D; new Promise(function (resolve,reject) &#123;</span><br><span class=\"line\">    throw new Error(&#39;Explosion&#39;)</span><br><span class=\"line\">    &#x2F;&#x2F;等价于</span><br><span class=\"line\">    &#x2F;&#x2F; try&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;     throw new Error(&#39;Explosion&#39;)</span><br><span class=\"line\">    &#x2F;&#x2F; &#125;catch (e) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;     reject(e)</span><br><span class=\"line\">    &#x2F;&#x2F; &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p3.catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error.message)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"全局的Promise错误处理\"><a href=\"#全局的Promise错误处理\" class=\"headerlink\" title=\"全局的Promise错误处理\"></a>全局的Promise错误处理</h4><ul>\n<li>NodeJS中：</li>\n</ul>\n<ol>\n<li>unhandledRejection在一个事件中当Promise被拒绝，并且没有提供拒绝处理程序时该事件被触发</li>\n<li>rejectionHandled在一个事件循环后，当Promise被拒绝时，若拒绝处理程序被调用，触发该事件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;拒绝原因以及被拒绝的promise作为参数被传入unhandleRejection事件处理程序</span><br><span class=\"line\">let rejected</span><br><span class=\"line\">process.on(&#39;unhandleRejection&#39;, function (reason, promise) &#123;</span><br><span class=\"line\">    console.log(reason.message)</span><br><span class=\"line\">    console.log(rejected &#x3D;&#x3D;&#x3D; promise)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">rejected &#x3D; Promise.reject(</span><br><span class=\"line\">throw new Error(&#39;Explosion&#39;)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;rejectionHandle事件在拒绝处理程序最后被调用时触发，如果在创建rejected之后直接添加拒绝处理程序，那个rejectionHandle事件不会被触发</span><br><span class=\"line\">let rejected</span><br><span class=\"line\">process.on(&#39;rejectionHandle&#39;, function (promise) &#123;</span><br><span class=\"line\">    console.log(rejected &#x3D;&#x3D;&#x3D; promise)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">rejected &#x3D; Promise.reject(new Error(&#39;Explosion&#39;))</span><br><span class=\"line\">setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">    rejected.catch(err &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(err.message)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;, 1000)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;通过rejectionHandle和事件unhandleRejection将潜在未处理的拒绝存储为一个列表</span><br><span class=\"line\"></span><br><span class=\"line\">let possiblyUnhandleRejections &#x3D; new Map()</span><br><span class=\"line\">&#x2F;&#x2F;如果一个拒绝没有被处理，则添加到map集合中</span><br><span class=\"line\">process.on(&#39;unhandledRejection&#39;, function (reason, promise) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.set(promise, reason)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;如果被处理了，移除promise</span><br><span class=\"line\">process.on(&#39;rejectionHandled&#39;, function (promise) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.delete(promise)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;循环未处理的Promise</span><br><span class=\"line\">setInterval(function () &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.forEach(function (reason, promise) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;做一些处理</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    possiblyUnhandleRejections.clear()</span><br><span class=\"line\">&#125;, 6000)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"浏览器环境的拒绝处理\"><a href=\"#浏览器环境的拒绝处理\" class=\"headerlink\" title=\"浏览器环境的拒绝处理\"></a>浏览器环境的拒绝处理</h4><ul>\n<li>unhandledrejection:当一个Promise被拒绝并且没有提供拒绝处理时触发</li>\n<li>rejectionhandled:在一个事件循环后,当Promise被拒绝时，若拒绝处理程序被调用，则触发该事件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;用DOM0级标记法onunhandledrejection和onrejectionhandled</span><br><span class=\"line\"></span><br><span class=\"line\">let possiblyUnhandleRejections &#x3D; new Map()</span><br><span class=\"line\">&#x2F;&#x2F;如果一个拒绝没有被处理，添加到map中</span><br><span class=\"line\">window.onunhandledrejection &#x3D; function (event) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.set(event.promise, event.reason)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;如果出发了拒绝方法，从map中删除</span><br><span class=\"line\">window.onrejectionhandled &#x3D; function (event) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.delete(event.promise)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;循环遍历处理</span><br><span class=\"line\">setInterval(() &#x3D;&gt; &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.forEach((promise, reason) &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(&#39;111111&#39;)</span><br><span class=\"line\">        console.log(promise)</span><br><span class=\"line\">        console.log(reason)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    possiblyUnhandleRejections.clear()</span><br><span class=\"line\">&#125;, 3000)</span><br><span class=\"line\">let p5 &#x3D; Promise.reject(&#39;111&#39;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"串联Promise\"><a href=\"#串联Promise\" class=\"headerlink\" title=\"串联Promise\"></a>串联Promise</h4><ul>\n<li>每次调用then()、cache()方法，实际上创建并且返回了另一个Promise，当只有第一个Promise完成或者被拒绝后，第二个才会被解决</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p7 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class=\"line\">    resolve(1)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p7.then((res) &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(res)&#x2F;&#x2F;1</span><br><span class=\"line\">&#125;).then(res &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(&#39;Finished&#39;)</span><br><span class=\"line\">&#125;).catch(err &#x3D;&gt; &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;这里可以处理公共的错误</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>务必在Promise的结尾有一个处理拒绝的程序，以便能够正确处理所有的错误</li>\n</ul>\n<h4 id=\"Promise的链返回值\"><a href=\"#Promise的链返回值\" class=\"headerlink\" title=\"Promise的链返回值\"></a>Promise的链返回值</h4><ul>\n<li>Promise中返回一个值可以沿着这条链传递数据</li>\n<li>如果返回的是Promise对象，那么要看返回的Promise怎么处理</li>\n<li>响应多个Promise</li>\n</ul>\n<h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4><ul>\n<li>只有迭代中所有Promise都解决后才被解决</li>\n<li>如果有一个被拒绝，那么返回的Promise就立即被拒绝</li>\n</ul>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><ul>\n<li>只要有一个被解决返回，Promise就被解决</li>\n</ul>\n<h4 id=\"自Promise继承\"><a href=\"#自Promise继承\" class=\"headerlink\" title=\"自Promise继承\"></a>自Promise继承</h4><ul>\n<li>定义自己的Promise来扩展内建Promise功能</li>\n<li>由于MyPromise.resolve()和MyPromise.reject()通过Symbol.species属性决定返回Promise类型，所以无论传什么值，都会返回MyPromise实例</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyPromise extends Promise&#123;</span><br><span class=\"line\">    success(resolve,reject)&#123;</span><br><span class=\"line\">        return this.then(resolve,reject)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    failure(reject)&#123;</span><br><span class=\"line\">        return this.cache(reject)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let mPromise &#x3D; new MyPromise(function (resolve,reject) &#123;</span><br><span class=\"line\">    resolve(&#39;1&#39;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">mPromise.success(res&#x3D;&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;).failure(err&#x3D;&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise的异步执行\"><a href=\"#Promise的异步执行\" class=\"headerlink\" title=\"Promise的异步执行\"></a>Promise的异步执行</h4><ul>\n<li>对已完成的promise执行then,此时会执行then的操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class=\"line\">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">        resolve(&#39;111&#39;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">    promise.then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">        console.log(res)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;,3000)</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>then里面不返回新的promise</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class=\"line\">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">        resolve(&#39;2222&#39;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;).then((res)&#x3D;&gt;&#123;</span><br><span class=\"line\">    (function f() &#123;</span><br><span class=\"line\">        return new Promise(resolve&#x3D;&gt;&#123;</span><br><span class=\"line\">            setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">                resolve(&#39;333&#39;)</span><br><span class=\"line\">            &#125;,1000)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;())</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">    return false</span><br><span class=\"line\">&#125;).then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>then的嵌套</p>\n</li>\n<li><p>需要返回一个新的promise实例才可以等resolve之后回调</p>\n</li>\n<li><p>错误处理,catch也会返回promise实例，后面的then和catch也会执行</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; reject(&#39;123&#39;)</span><br><span class=\"line\">    &#x2F;&#x2F; throw new Error(&#39;1111&#39;)</span><br><span class=\"line\">&#125;).then(res &#x3D;&gt; &#123;</span><br><span class=\"line\">&#125;).catch(err &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>promise.all 与 map 连用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1,2,3]</span><br><span class=\"line\">Promise.all(arr.map(item&#x3D;&gt;&#123;</span><br><span class=\"line\">    return new Promise(resolve&#x3D;&gt;&#123;</span><br><span class=\"line\">        resolve(&#39;1111&#39;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)).then(all&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(all)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>promise实现队列，使用.then返回新的promise实例</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1,2,3,4]</span><br><span class=\"line\">function queue(arr) &#123;</span><br><span class=\"line\">    let promise &#x3D; Promise.resolve()</span><br><span class=\"line\">    arr.forEach(item&#x3D;&gt;&#123;</span><br><span class=\"line\">        promise &#x3D; promise.then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">            console.log(res)</span><br><span class=\"line\">            return new Promise(resolve&#x3D;&gt;&#123;</span><br><span class=\"line\">                 &#x2F;&#x2F; 在这里处理相关逻辑</span><br><span class=\"line\">                resolve(item)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return promise</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">queue(arr).then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>promise.resolve</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve().then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    return Promise.resolve(&#39;123&#39;)</span><br><span class=\"line\">&#125;).then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">    return Promise.resolve(new Promise(resolve&#x3D;&gt;&#123;</span><br><span class=\"line\">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">            resolve(&#39;456&#39;)</span><br><span class=\"line\">        &#125;,1000)</span><br><span class=\"line\">    &#125;)).then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">        console.log(res)</span><br><span class=\"line\">        Promise.resolve(&#123;</span><br><span class=\"line\">            then()&#123;</span><br><span class=\"line\">                console.log(&#39;7890&#39;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><h4 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h4><ul>\n<li><p>Promise可以完成其他语言中类似Future和Deferred功能</p>\n</li>\n<li><p>异步编程的背景知识：<br>JS引擎是基于单线程(single-threaded)事件循环概念构建的，同一时刻只允许一个代码块在执行，代码块放在一个任务队列(job queue)中，<br>每当一个代码块准备执行，就会被添加到任务队列，JS引擎执行完一段代码后，事件循环会执行队列中的下一个任务，队列中的任务会从第一个执行到<br>最后一个。</p>\n</li>\n<li><p>eventLoop：<a href=\"https://crazyaguai.github.io/2018/10/20/js-eventLoop/\">https://crazyaguai.github.io/2018/10/20/js-eventLoop/</a></p>\n<h4 id=\"事件模型\"><a href=\"#事件模型\" class=\"headerlink\" title=\"事件模型\"></a>事件模型</h4></li>\n<li><p>事件模型,适用于响应用户交互和完成类似的低频功能，但是对于复杂的需求不是很灵活</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let btn &#x3D; document.querySelector(&#39;.button&#39;)</span><br><span class=\"line\">    btn.onclick &#x3D; function (event) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"回调模式\"><a href=\"#回调模式\" class=\"headerlink\" title=\"回调模式\"></a>回调模式</h4><ul>\n<li>回调模式，如果嵌套了太多回调，会陷入回调地狱</li>\n</ul>\n<h3 id=\"Promise相关\"><a href=\"#Promise相关\" class=\"headerlink\" title=\"Promise相关\"></a>Promise相关</h3><h4 id=\"Promise基础知识\"><a href=\"#Promise基础知识\" class=\"headerlink\" title=\"Promise基础知识\"></a>Promise基础知识</h4><ul>\n<li>Promise相当于异步操作的占位符，让函数返回一个Promise<br>Promise生命周期：</li>\n<li>先处于进行中(pending)状态，此时操作未完成，它也是未处理(unsettled)的，一旦异步操作结束，Promise变为已处理(settled)状态</li>\n<li>之后会进入Fulfilled(完成)或者Rejected(未成功)状态</li>\n<li>内部属性[[PromiseState]]被用来表示三种状态pending\\fufilled\\rejected</li>\n<li>Promise有then()方法接收两个参数，fufilled状态调用的函数、rejected状态调用的函数</li>\n<li>如果有一个对象实现了then()方法，那么称之为thenable对象，所有Promise都是thenable对象。但并非所有thenable对象都是promise</li>\n<li>Promise还有一个chache()方法用来接收错误，如果不给Promise添加拒绝处理程序，那么所有错误将被忽略，所以一定要添加</li>\n<li>每次调用then()\\cache()方法时都会创建一个任务，当promise被解决时，这些任务都会加入到一个为Promise定制的独立队列中</li>\n</ul>\n<h4 id=\"创建未完成的Promise\"><a href=\"#创建未完成的Promise\" class=\"headerlink\" title=\"创建未完成的Promise\"></a>创建未完成的Promise</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fun() &#123;</span><br><span class=\"line\">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun().then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">&#125;).catch(err&#x3D;&gt;&#123;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Promise执行器会立即执行，之后才会执行后续流程的代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fun1() &#123;</span><br><span class=\"line\">    return new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;这里会立即执行function Fun1() &#123;</span><br><span class=\"line\">        console.log(1)</span><br><span class=\"line\">        resolve(3)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun1().then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;这里会被添加到任务对列中并异步执行</span><br><span class=\"line\">    &#x2F;&#x2F;完成处理程序和拒绝处理程序总被添加到任务对列的末尾</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(2)</span><br><span class=\"line\">&#x2F;&#x2F;1 2 3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建已处理的Promise\"><a href=\"#创建已处理的Promise\" class=\"headerlink\" title=\"创建已处理的Promise\"></a>创建已处理的Promise</h4><ul>\n<li>Promise.resolve(),接收参数返回一个完成状态的Promise,不会有任何编排过程</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let promise &#x3D; Promise.resolve(1)</span><br><span class=\"line\">promise.then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#x2F;&#x2F;1 1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建拒绝状态的Promise\"><a href=\"#创建拒绝状态的Promise\" class=\"headerlink\" title=\"创建拒绝状态的Promise\"></a>创建拒绝状态的Promise</h4><ul>\n<li>Promise.reject(‘error’),创建拒绝状态的Promise</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let promise &#x3D; Promise.reject(1)</span><br><span class=\"line\">promise.catch(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.catch(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">&#x2F;&#x2F;1 1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"非Promise的Thenable对象\"><a href=\"#非Promise的Thenable对象\" class=\"headerlink\" title=\"非Promise的Thenable对象\"></a>非Promise的Thenable对象</h4><ul>\n<li>非Promise的Thenable对象，如果传入一个非Promise的Thenable对象，则这些方法会创建一个新的Promise并在then()函数中调用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let thenable &#x3D; &#123;</span><br><span class=\"line\">    then(resolve,reject)&#123;</span><br><span class=\"line\">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">            resolve(&#39;thenable&#39;)</span><br><span class=\"line\">        &#125;,1000)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p1 &#x3D; Promise.resolve(thenable)</span><br><span class=\"line\">p1.then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"相关应用\"><a href=\"#相关应用\" class=\"headerlink\" title=\"相关应用\"></a>相关应用</h3><h4 id=\"Thenable对象\"><a href=\"#Thenable对象\" class=\"headerlink\" title=\"Thenable对象\"></a>Thenable对象</h4><ul>\n<li>可以使用Promise.resolve()或者Promise.reject()处理非Promise的Thenable对象，</li>\n<li>ES6之前许多库使用了thenable对象，所以如果想兼容之前已有的库，需要将Thenable对象转换为正式的Promise对象，</li>\n<li>如果不确定某个对象是否为Promise对象，那么可以根据预期的结果将其传入Promise.resolve()或Promise.reject()，如果是Promise则不会有任何变化</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var original &#x3D; Promise.resolve(&#39;我在第二行&#39;);</span><br><span class=\"line\">var cast &#x3D; Promise.resolve(original);</span><br><span class=\"line\">cast.then(function(value) &#123;</span><br><span class=\"line\">    console.log(&#39;value: &#39; + value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&#39;original &#x3D;&#x3D;&#x3D; cast ? &#39; + (original &#x3D;&#x3D;&#x3D; cast));</span><br><span class=\"line\">&#x2F;&#x2F;打印顺序如下，这里有一个同步异步先后执行的区别</span><br><span class=\"line\">&#x2F;&#x2F;original &#x3D;&#x3D;&#x3D; cast ? true</span><br><span class=\"line\">&#x2F;&#x2F;value: 我在第二行</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Resolve一个thenable对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 &#x3D; Promise.resolve(&#123;</span><br><span class=\"line\">    then: function (onFulfill, onReject) &#123;</span><br><span class=\"line\">        onFulfill(&quot;fulfilled!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(p1 instanceof Promise) &#x2F;&#x2F; true, 这是一个Promise对象</span><br><span class=\"line\"></span><br><span class=\"line\">p1.then(function (v) &#123;</span><br><span class=\"line\">    console.log(v); &#x2F;&#x2F; 输出&quot;fulfilled!&quot;</span><br><span class=\"line\">&#125;, function (e) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 不会被调用</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li> Thenable在callback之前抛出异常</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Promise rejects</span><br><span class=\"line\">var thenable &#x3D; &#123;</span><br><span class=\"line\">    then: function (resolve) &#123;</span><br><span class=\"line\">        throw new TypeError(&quot;Throwing&quot;);</span><br><span class=\"line\">        resolve(&quot;Resolving&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p2 &#x3D; Promise.resolve(thenable);</span><br><span class=\"line\">p2.then(function (v) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 不会被调用</span><br><span class=\"line\">&#125;, function (e) &#123;</span><br><span class=\"line\">    console.log(e); &#x2F;&#x2F; TypeError: Throwing</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Thenable在callback之后抛出异常</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; Promise resolves</span><br><span class=\"line\">var thenable &#x3D; &#123;</span><br><span class=\"line\">    then: function (resolve) &#123;</span><br><span class=\"line\">        resolve(&quot;Resolving&quot;);</span><br><span class=\"line\">        throw new TypeError(&quot;Throwing&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p3 &#x3D; Promise.resolve(thenable);</span><br><span class=\"line\">p3.then(function (v) &#123;</span><br><span class=\"line\">    console.log(v); &#x2F;&#x2F; 输出&quot;Resolving&quot;</span><br><span class=\"line\">&#125;, function (e) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; 不会被调用</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"执行器错误\"><a href=\"#执行器错误\" class=\"headerlink\" title=\"执行器错误\"></a>执行器错误</h4><ul>\n<li>如果执行器内部抛出一个错误，那么Promise的拒绝程序就会被调用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p3 &#x3D; new Promise(function (resolve,reject) &#123;</span><br><span class=\"line\">    throw new Error(&#39;Explosion&#39;)</span><br><span class=\"line\">    &#x2F;&#x2F;等价于</span><br><span class=\"line\">    &#x2F;&#x2F; try&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;     throw new Error(&#39;Explosion&#39;)</span><br><span class=\"line\">    &#x2F;&#x2F; &#125;catch (e) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;     reject(e)</span><br><span class=\"line\">    &#x2F;&#x2F; &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p3.catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error.message)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"全局的Promise错误处理\"><a href=\"#全局的Promise错误处理\" class=\"headerlink\" title=\"全局的Promise错误处理\"></a>全局的Promise错误处理</h4><ul>\n<li>NodeJS中：</li>\n</ul>\n<ol>\n<li>unhandledRejection在一个事件中当Promise被拒绝，并且没有提供拒绝处理程序时该事件被触发</li>\n<li>rejectionHandled在一个事件循环后，当Promise被拒绝时，若拒绝处理程序被调用，触发该事件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;拒绝原因以及被拒绝的promise作为参数被传入unhandleRejection事件处理程序</span><br><span class=\"line\">let rejected</span><br><span class=\"line\">process.on(&#39;unhandleRejection&#39;, function (reason, promise) &#123;</span><br><span class=\"line\">    console.log(reason.message)</span><br><span class=\"line\">    console.log(rejected &#x3D;&#x3D;&#x3D; promise)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">rejected &#x3D; Promise.reject(</span><br><span class=\"line\">throw new Error(&#39;Explosion&#39;)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;rejectionHandle事件在拒绝处理程序最后被调用时触发，如果在创建rejected之后直接添加拒绝处理程序，那个rejectionHandle事件不会被触发</span><br><span class=\"line\">let rejected</span><br><span class=\"line\">process.on(&#39;rejectionHandle&#39;, function (promise) &#123;</span><br><span class=\"line\">    console.log(rejected &#x3D;&#x3D;&#x3D; promise)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">rejected &#x3D; Promise.reject(new Error(&#39;Explosion&#39;))</span><br><span class=\"line\">setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">    rejected.catch(err &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(err.message)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;, 1000)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;通过rejectionHandle和事件unhandleRejection将潜在未处理的拒绝存储为一个列表</span><br><span class=\"line\"></span><br><span class=\"line\">let possiblyUnhandleRejections &#x3D; new Map()</span><br><span class=\"line\">&#x2F;&#x2F;如果一个拒绝没有被处理，则添加到map集合中</span><br><span class=\"line\">process.on(&#39;unhandledRejection&#39;, function (reason, promise) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.set(promise, reason)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;如果被处理了，移除promise</span><br><span class=\"line\">process.on(&#39;rejectionHandled&#39;, function (promise) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.delete(promise)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;循环未处理的Promise</span><br><span class=\"line\">setInterval(function () &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.forEach(function (reason, promise) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;做一些处理</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    possiblyUnhandleRejections.clear()</span><br><span class=\"line\">&#125;, 6000)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"浏览器环境的拒绝处理\"><a href=\"#浏览器环境的拒绝处理\" class=\"headerlink\" title=\"浏览器环境的拒绝处理\"></a>浏览器环境的拒绝处理</h4><ul>\n<li>unhandledrejection:当一个Promise被拒绝并且没有提供拒绝处理时触发</li>\n<li>rejectionhandled:在一个事件循环后,当Promise被拒绝时，若拒绝处理程序被调用，则触发该事件</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;用DOM0级标记法onunhandledrejection和onrejectionhandled</span><br><span class=\"line\"></span><br><span class=\"line\">let possiblyUnhandleRejections &#x3D; new Map()</span><br><span class=\"line\">&#x2F;&#x2F;如果一个拒绝没有被处理，添加到map中</span><br><span class=\"line\">window.onunhandledrejection &#x3D; function (event) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.set(event.promise, event.reason)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;如果出发了拒绝方法，从map中删除</span><br><span class=\"line\">window.onrejectionhandled &#x3D; function (event) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.delete(event.promise)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;循环遍历处理</span><br><span class=\"line\">setInterval(() &#x3D;&gt; &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.forEach((promise, reason) &#x3D;&gt; &#123;</span><br><span class=\"line\">        console.log(&#39;111111&#39;)</span><br><span class=\"line\">        console.log(promise)</span><br><span class=\"line\">        console.log(reason)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    possiblyUnhandleRejections.clear()</span><br><span class=\"line\">&#125;, 3000)</span><br><span class=\"line\">let p5 &#x3D; Promise.reject(&#39;111&#39;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"串联Promise\"><a href=\"#串联Promise\" class=\"headerlink\" title=\"串联Promise\"></a>串联Promise</h4><ul>\n<li>每次调用then()、cache()方法，实际上创建并且返回了另一个Promise，当只有第一个Promise完成或者被拒绝后，第二个才会被解决</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p7 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class=\"line\">    resolve(1)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p7.then((res) &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(res)&#x2F;&#x2F;1</span><br><span class=\"line\">&#125;).then(res &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(&#39;Finished&#39;)</span><br><span class=\"line\">&#125;).catch(err &#x3D;&gt; &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;这里可以处理公共的错误</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>务必在Promise的结尾有一个处理拒绝的程序，以便能够正确处理所有的错误</li>\n</ul>\n<h4 id=\"Promise的链返回值\"><a href=\"#Promise的链返回值\" class=\"headerlink\" title=\"Promise的链返回值\"></a>Promise的链返回值</h4><ul>\n<li>Promise中返回一个值可以沿着这条链传递数据</li>\n<li>如果返回的是Promise对象，那么要看返回的Promise怎么处理</li>\n<li>响应多个Promise</li>\n</ul>\n<h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4><ul>\n<li>只有迭代中所有Promise都解决后才被解决</li>\n<li>如果有一个被拒绝，那么返回的Promise就立即被拒绝</li>\n</ul>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><ul>\n<li>只要有一个被解决返回，Promise就被解决</li>\n</ul>\n<h4 id=\"自Promise继承\"><a href=\"#自Promise继承\" class=\"headerlink\" title=\"自Promise继承\"></a>自Promise继承</h4><ul>\n<li>定义自己的Promise来扩展内建Promise功能</li>\n<li>由于MyPromise.resolve()和MyPromise.reject()通过Symbol.species属性决定返回Promise类型，所以无论传什么值，都会返回MyPromise实例</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyPromise extends Promise&#123;</span><br><span class=\"line\">    success(resolve,reject)&#123;</span><br><span class=\"line\">        return this.then(resolve,reject)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    failure(reject)&#123;</span><br><span class=\"line\">        return this.cache(reject)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let mPromise &#x3D; new MyPromise(function (resolve,reject) &#123;</span><br><span class=\"line\">    resolve(&#39;1&#39;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">mPromise.success(res&#x3D;&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;).failure(err&#x3D;&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Promise的异步执行\"><a href=\"#Promise的异步执行\" class=\"headerlink\" title=\"Promise的异步执行\"></a>Promise的异步执行</h4><ul>\n<li>对已完成的promise执行then,此时会执行then的操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise &#x3D; new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class=\"line\">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">        resolve(&#39;111&#39;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">    promise.then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">        console.log(res)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;,3000)</span><br></pre></td></tr></table></figure>\n\n\n<ul>\n<li>then里面不返回新的promise</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)&#x3D;&gt;&#123;</span><br><span class=\"line\">    setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">        resolve(&#39;2222&#39;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;).then((res)&#x3D;&gt;&#123;</span><br><span class=\"line\">    (function f() &#123;</span><br><span class=\"line\">        return new Promise(resolve&#x3D;&gt;&#123;</span><br><span class=\"line\">            setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">                resolve(&#39;333&#39;)</span><br><span class=\"line\">            &#125;,1000)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;())</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">    return false</span><br><span class=\"line\">&#125;).then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>then的嵌套</p>\n</li>\n<li><p>需要返回一个新的promise实例才可以等resolve之后回调</p>\n</li>\n<li><p>错误处理,catch也会返回promise实例，后面的then和catch也会执行</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; reject(&#39;123&#39;)</span><br><span class=\"line\">    &#x2F;&#x2F; throw new Error(&#39;1111&#39;)</span><br><span class=\"line\">&#125;).then(res &#x3D;&gt; &#123;</span><br><span class=\"line\">&#125;).catch(err &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>promise.all 与 map 连用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1,2,3]</span><br><span class=\"line\">Promise.all(arr.map(item&#x3D;&gt;&#123;</span><br><span class=\"line\">    return new Promise(resolve&#x3D;&gt;&#123;</span><br><span class=\"line\">        resolve(&#39;1111&#39;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)).then(all&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(all)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>promise实现队列，使用.then返回新的promise实例</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1,2,3,4]</span><br><span class=\"line\">function queue(arr) &#123;</span><br><span class=\"line\">    let promise &#x3D; Promise.resolve()</span><br><span class=\"line\">    arr.forEach(item&#x3D;&gt;&#123;</span><br><span class=\"line\">        promise &#x3D; promise.then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">            console.log(res)</span><br><span class=\"line\">            return new Promise(resolve&#x3D;&gt;&#123;</span><br><span class=\"line\">                 &#x2F;&#x2F; 在这里处理相关逻辑</span><br><span class=\"line\">                resolve(item)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return promise</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">queue(arr).then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>promise.resolve</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve().then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    return Promise.resolve(&#39;123&#39;)</span><br><span class=\"line\">&#125;).then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">    return Promise.resolve(new Promise(resolve&#x3D;&gt;&#123;</span><br><span class=\"line\">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">            resolve(&#39;456&#39;)</span><br><span class=\"line\">        &#125;,1000)</span><br><span class=\"line\">    &#125;)).then(res&#x3D;&gt;&#123;</span><br><span class=\"line\">        console.log(res)</span><br><span class=\"line\">        Promise.resolve(&#123;</span><br><span class=\"line\">            then()&#123;</span><br><span class=\"line\">                console.log(&#39;7890&#39;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n"},{"title":"<ES6>代理-Proxy-与反射-Reflection","date":"2019-02-14T16:00:00.000Z","_content":"\n### 简介\n\n- 代理Proxy是一种可以拦截并修改底层javascript引擎操作的包装器，在新语言中通过它暴露内部运作的对象。\n- 数组问题：ES6之前不能通过自己定义的对象模仿js数组对象的行为方式（赋值影响length属性）。\n\n### 代理和反射\n\n- 调用 new Proxy() 可以创建代替其他目标(target)对象的代理，虚化了目标，所以二者看起来功能一致。\n- 陷阱：每个陷阱复写js对象的一些内建特性\n- 创建一个简单的代理：示例中代理的所有操作都会转发给目标。\n\n```\nlet target = {}\nlet proxy = new Proxy(target,{})\nproxy.name = '123'\nconsole.log(target.name)//123\n\ntarget.age = 11\nconsole.log(proxy.age)//11\n```\n\n#### 使用set陷阱验证属性\n\n- 参数：trapTarget(代理目标)，key(写入属性字符串或者symbol)，value(写入值)，receiver(代理)\n- Reflect.set()是set陷阱对应的反射方法和默认特性，如果属性已经设置陷阱应该返回true，如果未设置返回false。即基于是否成功返回适当的值。\n\n```\nlet obj = {\n}\nlet proxyObj = new Proxy(obj,{\n    set(trapTarget,key,val,receiver){\n        return Reflect.set(trapTarget,key,val+1,receiver)\n    }\n})\nproxyObj.count = 1\nconsole.log(obj.count)//2\nobj.age = 2\nconsole.log(proxyObj.age)//2\n```\n\n#### 使用get陷阱验证对象结构\n\n```\nlet obj = {\n    name: '123'\n}\nlet proxyObj = new Proxy(obj,{\n    get(trapTarget,key,receiver){\n        if(!(key in trapTarget)){\n            throw new TypeError(`属性${key}不存在`)\n        }\n        return Reflect.get(trapTarget,key,receiver)\n    }\n})\nconsole.log(proxyObj.name)//123\nconsole.log(proxyObj.age)//Uncaught TypeError: 属性age不存在\n```\n\n#### 使用has陷阱隐藏已有属性\n\n- 用in操作符检测属性存在时，可以使用has陷阱拦截in操作符的属性返回不同的值。\n\n```\nlet obj = {\n    name: '123',\n    age: '11'\n}\nlet proxyObj = new Proxy(obj,{\n    has(trapTarget,key){\n        if(key === 'name'){\n            return false\n        }\n        return Reflect.has(trapTarget,key)\n    }\n})\nconsole.log('name' in proxyObj)//false\nconsole.log('age' in proxyObj)//true\n```\n\n#### 使用deleteProperty陷阱防止删除属性\n\n- 在严格模式下删除一个不可配置(nonconfigurable)的属性会报错，非严格模式下只会返回false\n\n```\nlet obj = {\n    name: '123',\n    age: '11'\n}\nlet proxyObj = new Proxy(obj,{\n    deleteProperty(trapTarget,key){\n        if(key === 'name'){\n            return false\n        }\n        return Reflect.deleteProperty(trapTarget,key)\n    }\n})\nconsole.log(delete proxyObj.name)//false\nconsole.log(delete proxyObj.age)//true\n```\n\n#### 原型代理陷阱\n\n- 通过代理setPrototypeOf和getPrototypeOf陷阱可以拦截Object.setPrototypeOf()和Object.getPrototypeOf()方法\n","source":"_posts/[ES6]代理-Proxy-与反射-Reflection.md","raw":"---\ntitle: <ES6>代理-Proxy-与反射-Reflection\ndate: 2019-02-15 00:00:00\ntags: [ES6,js]\ncategories: ES6\n---\n\n### 简介\n\n- 代理Proxy是一种可以拦截并修改底层javascript引擎操作的包装器，在新语言中通过它暴露内部运作的对象。\n- 数组问题：ES6之前不能通过自己定义的对象模仿js数组对象的行为方式（赋值影响length属性）。\n\n### 代理和反射\n\n- 调用 new Proxy() 可以创建代替其他目标(target)对象的代理，虚化了目标，所以二者看起来功能一致。\n- 陷阱：每个陷阱复写js对象的一些内建特性\n- 创建一个简单的代理：示例中代理的所有操作都会转发给目标。\n\n```\nlet target = {}\nlet proxy = new Proxy(target,{})\nproxy.name = '123'\nconsole.log(target.name)//123\n\ntarget.age = 11\nconsole.log(proxy.age)//11\n```\n\n#### 使用set陷阱验证属性\n\n- 参数：trapTarget(代理目标)，key(写入属性字符串或者symbol)，value(写入值)，receiver(代理)\n- Reflect.set()是set陷阱对应的反射方法和默认特性，如果属性已经设置陷阱应该返回true，如果未设置返回false。即基于是否成功返回适当的值。\n\n```\nlet obj = {\n}\nlet proxyObj = new Proxy(obj,{\n    set(trapTarget,key,val,receiver){\n        return Reflect.set(trapTarget,key,val+1,receiver)\n    }\n})\nproxyObj.count = 1\nconsole.log(obj.count)//2\nobj.age = 2\nconsole.log(proxyObj.age)//2\n```\n\n#### 使用get陷阱验证对象结构\n\n```\nlet obj = {\n    name: '123'\n}\nlet proxyObj = new Proxy(obj,{\n    get(trapTarget,key,receiver){\n        if(!(key in trapTarget)){\n            throw new TypeError(`属性${key}不存在`)\n        }\n        return Reflect.get(trapTarget,key,receiver)\n    }\n})\nconsole.log(proxyObj.name)//123\nconsole.log(proxyObj.age)//Uncaught TypeError: 属性age不存在\n```\n\n#### 使用has陷阱隐藏已有属性\n\n- 用in操作符检测属性存在时，可以使用has陷阱拦截in操作符的属性返回不同的值。\n\n```\nlet obj = {\n    name: '123',\n    age: '11'\n}\nlet proxyObj = new Proxy(obj,{\n    has(trapTarget,key){\n        if(key === 'name'){\n            return false\n        }\n        return Reflect.has(trapTarget,key)\n    }\n})\nconsole.log('name' in proxyObj)//false\nconsole.log('age' in proxyObj)//true\n```\n\n#### 使用deleteProperty陷阱防止删除属性\n\n- 在严格模式下删除一个不可配置(nonconfigurable)的属性会报错，非严格模式下只会返回false\n\n```\nlet obj = {\n    name: '123',\n    age: '11'\n}\nlet proxyObj = new Proxy(obj,{\n    deleteProperty(trapTarget,key){\n        if(key === 'name'){\n            return false\n        }\n        return Reflect.deleteProperty(trapTarget,key)\n    }\n})\nconsole.log(delete proxyObj.name)//false\nconsole.log(delete proxyObj.age)//true\n```\n\n#### 原型代理陷阱\n\n- 通过代理setPrototypeOf和getPrototypeOf陷阱可以拦截Object.setPrototypeOf()和Object.getPrototypeOf()方法\n","slug":"[ES6]代理-Proxy-与反射-Reflection","published":1,"updated":"2021-03-15T14:36:15.759Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dk0000bwotj94q1e8sq","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>代理Proxy是一种可以拦截并修改底层javascript引擎操作的包装器，在新语言中通过它暴露内部运作的对象。</li>\n<li>数组问题：ES6之前不能通过自己定义的对象模仿js数组对象的行为方式（赋值影响length属性）。</li>\n</ul>\n<h3 id=\"代理和反射\"><a href=\"#代理和反射\" class=\"headerlink\" title=\"代理和反射\"></a>代理和反射</h3><ul>\n<li>调用 new Proxy() 可以创建代替其他目标(target)对象的代理，虚化了目标，所以二者看起来功能一致。</li>\n<li>陷阱：每个陷阱复写js对象的一些内建特性</li>\n<li>创建一个简单的代理：示例中代理的所有操作都会转发给目标。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let target &#x3D; &#123;&#125;</span><br><span class=\"line\">let proxy &#x3D; new Proxy(target,&#123;&#125;)</span><br><span class=\"line\">proxy.name &#x3D; &#39;123&#39;</span><br><span class=\"line\">console.log(target.name)&#x2F;&#x2F;123</span><br><span class=\"line\"></span><br><span class=\"line\">target.age &#x3D; 11</span><br><span class=\"line\">console.log(proxy.age)&#x2F;&#x2F;11</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用set陷阱验证属性\"><a href=\"#使用set陷阱验证属性\" class=\"headerlink\" title=\"使用set陷阱验证属性\"></a>使用set陷阱验证属性</h4><ul>\n<li>参数：trapTarget(代理目标)，key(写入属性字符串或者symbol)，value(写入值)，receiver(代理)</li>\n<li>Reflect.set()是set陷阱对应的反射方法和默认特性，如果属性已经设置陷阱应该返回true，如果未设置返回false。即基于是否成功返回适当的值。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj &#x3D; new Proxy(obj,&#123;</span><br><span class=\"line\">    set(trapTarget,key,val,receiver)&#123;</span><br><span class=\"line\">        return Reflect.set(trapTarget,key,val+1,receiver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">proxyObj.count &#x3D; 1</span><br><span class=\"line\">console.log(obj.count)&#x2F;&#x2F;2</span><br><span class=\"line\">obj.age &#x3D; 2</span><br><span class=\"line\">console.log(proxyObj.age)&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用get陷阱验证对象结构\"><a href=\"#使用get陷阱验证对象结构\" class=\"headerlink\" title=\"使用get陷阱验证对象结构\"></a>使用get陷阱验证对象结构</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    name: &#39;123&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj &#x3D; new Proxy(obj,&#123;</span><br><span class=\"line\">    get(trapTarget,key,receiver)&#123;</span><br><span class=\"line\">        if(!(key in trapTarget))&#123;</span><br><span class=\"line\">            throw new TypeError(&#96;属性$&#123;key&#125;不存在&#96;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Reflect.get(trapTarget,key,receiver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(proxyObj.name)&#x2F;&#x2F;123</span><br><span class=\"line\">console.log(proxyObj.age)&#x2F;&#x2F;Uncaught TypeError: 属性age不存在</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用has陷阱隐藏已有属性\"><a href=\"#使用has陷阱隐藏已有属性\" class=\"headerlink\" title=\"使用has陷阱隐藏已有属性\"></a>使用has陷阱隐藏已有属性</h4><ul>\n<li>用in操作符检测属性存在时，可以使用has陷阱拦截in操作符的属性返回不同的值。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    name: &#39;123&#39;,</span><br><span class=\"line\">    age: &#39;11&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj &#x3D; new Proxy(obj,&#123;</span><br><span class=\"line\">    has(trapTarget,key)&#123;</span><br><span class=\"line\">        if(key &#x3D;&#x3D;&#x3D; &#39;name&#39;)&#123;</span><br><span class=\"line\">            return false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Reflect.has(trapTarget,key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(&#39;name&#39; in proxyObj)&#x2F;&#x2F;false</span><br><span class=\"line\">console.log(&#39;age&#39; in proxyObj)&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用deleteProperty陷阱防止删除属性\"><a href=\"#使用deleteProperty陷阱防止删除属性\" class=\"headerlink\" title=\"使用deleteProperty陷阱防止删除属性\"></a>使用deleteProperty陷阱防止删除属性</h4><ul>\n<li>在严格模式下删除一个不可配置(nonconfigurable)的属性会报错，非严格模式下只会返回false</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    name: &#39;123&#39;,</span><br><span class=\"line\">    age: &#39;11&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj &#x3D; new Proxy(obj,&#123;</span><br><span class=\"line\">    deleteProperty(trapTarget,key)&#123;</span><br><span class=\"line\">        if(key &#x3D;&#x3D;&#x3D; &#39;name&#39;)&#123;</span><br><span class=\"line\">            return false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Reflect.deleteProperty(trapTarget,key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(delete proxyObj.name)&#x2F;&#x2F;false</span><br><span class=\"line\">console.log(delete proxyObj.age)&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原型代理陷阱\"><a href=\"#原型代理陷阱\" class=\"headerlink\" title=\"原型代理陷阱\"></a>原型代理陷阱</h4><ul>\n<li>通过代理setPrototypeOf和getPrototypeOf陷阱可以拦截Object.setPrototypeOf()和Object.getPrototypeOf()方法</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>代理Proxy是一种可以拦截并修改底层javascript引擎操作的包装器，在新语言中通过它暴露内部运作的对象。</li>\n<li>数组问题：ES6之前不能通过自己定义的对象模仿js数组对象的行为方式（赋值影响length属性）。</li>\n</ul>\n<h3 id=\"代理和反射\"><a href=\"#代理和反射\" class=\"headerlink\" title=\"代理和反射\"></a>代理和反射</h3><ul>\n<li>调用 new Proxy() 可以创建代替其他目标(target)对象的代理，虚化了目标，所以二者看起来功能一致。</li>\n<li>陷阱：每个陷阱复写js对象的一些内建特性</li>\n<li>创建一个简单的代理：示例中代理的所有操作都会转发给目标。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let target &#x3D; &#123;&#125;</span><br><span class=\"line\">let proxy &#x3D; new Proxy(target,&#123;&#125;)</span><br><span class=\"line\">proxy.name &#x3D; &#39;123&#39;</span><br><span class=\"line\">console.log(target.name)&#x2F;&#x2F;123</span><br><span class=\"line\"></span><br><span class=\"line\">target.age &#x3D; 11</span><br><span class=\"line\">console.log(proxy.age)&#x2F;&#x2F;11</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用set陷阱验证属性\"><a href=\"#使用set陷阱验证属性\" class=\"headerlink\" title=\"使用set陷阱验证属性\"></a>使用set陷阱验证属性</h4><ul>\n<li>参数：trapTarget(代理目标)，key(写入属性字符串或者symbol)，value(写入值)，receiver(代理)</li>\n<li>Reflect.set()是set陷阱对应的反射方法和默认特性，如果属性已经设置陷阱应该返回true，如果未设置返回false。即基于是否成功返回适当的值。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj &#x3D; new Proxy(obj,&#123;</span><br><span class=\"line\">    set(trapTarget,key,val,receiver)&#123;</span><br><span class=\"line\">        return Reflect.set(trapTarget,key,val+1,receiver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">proxyObj.count &#x3D; 1</span><br><span class=\"line\">console.log(obj.count)&#x2F;&#x2F;2</span><br><span class=\"line\">obj.age &#x3D; 2</span><br><span class=\"line\">console.log(proxyObj.age)&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用get陷阱验证对象结构\"><a href=\"#使用get陷阱验证对象结构\" class=\"headerlink\" title=\"使用get陷阱验证对象结构\"></a>使用get陷阱验证对象结构</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    name: &#39;123&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj &#x3D; new Proxy(obj,&#123;</span><br><span class=\"line\">    get(trapTarget,key,receiver)&#123;</span><br><span class=\"line\">        if(!(key in trapTarget))&#123;</span><br><span class=\"line\">            throw new TypeError(&#96;属性$&#123;key&#125;不存在&#96;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Reflect.get(trapTarget,key,receiver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(proxyObj.name)&#x2F;&#x2F;123</span><br><span class=\"line\">console.log(proxyObj.age)&#x2F;&#x2F;Uncaught TypeError: 属性age不存在</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用has陷阱隐藏已有属性\"><a href=\"#使用has陷阱隐藏已有属性\" class=\"headerlink\" title=\"使用has陷阱隐藏已有属性\"></a>使用has陷阱隐藏已有属性</h4><ul>\n<li>用in操作符检测属性存在时，可以使用has陷阱拦截in操作符的属性返回不同的值。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    name: &#39;123&#39;,</span><br><span class=\"line\">    age: &#39;11&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj &#x3D; new Proxy(obj,&#123;</span><br><span class=\"line\">    has(trapTarget,key)&#123;</span><br><span class=\"line\">        if(key &#x3D;&#x3D;&#x3D; &#39;name&#39;)&#123;</span><br><span class=\"line\">            return false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Reflect.has(trapTarget,key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(&#39;name&#39; in proxyObj)&#x2F;&#x2F;false</span><br><span class=\"line\">console.log(&#39;age&#39; in proxyObj)&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"使用deleteProperty陷阱防止删除属性\"><a href=\"#使用deleteProperty陷阱防止删除属性\" class=\"headerlink\" title=\"使用deleteProperty陷阱防止删除属性\"></a>使用deleteProperty陷阱防止删除属性</h4><ul>\n<li>在严格模式下删除一个不可配置(nonconfigurable)的属性会报错，非严格模式下只会返回false</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    name: &#39;123&#39;,</span><br><span class=\"line\">    age: &#39;11&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj &#x3D; new Proxy(obj,&#123;</span><br><span class=\"line\">    deleteProperty(trapTarget,key)&#123;</span><br><span class=\"line\">        if(key &#x3D;&#x3D;&#x3D; &#39;name&#39;)&#123;</span><br><span class=\"line\">            return false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Reflect.deleteProperty(trapTarget,key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(delete proxyObj.name)&#x2F;&#x2F;false</span><br><span class=\"line\">console.log(delete proxyObj.age)&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原型代理陷阱\"><a href=\"#原型代理陷阱\" class=\"headerlink\" title=\"原型代理陷阱\"></a>原型代理陷阱</h4><ul>\n<li>通过代理setPrototypeOf和getPrototypeOf陷阱可以拦截Object.setPrototypeOf()和Object.getPrototypeOf()方法</li>\n</ul>\n"},{"title":"<ES6>函数","date":"2018-08-20T16:00:00.000Z","_content":"### 简介\n\n- ES6在ES5的基础上做了大量改进，使编程更加灵活，更少出错。\n\n### 参数默认值\n\n- ES5非严格模式下，命名参数的变化会体现在arguments对象中\n\n```\nfunction a(b,c) {\n    console.log(b === arguments[0])//true\n    console.log(c === arguments[1])//true\n    b = 3\n    c = 3\n    //会同步\n    console.log(b === arguments[0])//true\n    console.log(c === arguments[1])//true\n}\na(1,1)\n```\n\n- ES5严格模式下取消了对于arguments对象的同步行为\n\n```\nfunction a(b,c) {\n    'use strict'\n    console.log(b === arguments[0])//true\n    console.log(c === arguments[1])//true\n    b = 3\n    c = 3\n    //不会同步\n    console.log(b === arguments[0])//false\n    console.log(c === arguments[1])//false\n}\na(1,1)\n```\n```\nfunction defaultParam(a,b=1) {\n}\n```\n\n- 默认参数对arguments的影响（在ES6中如果一个函数使用了默认值，无论是否显示定义严格模式，arguments与ES5严格模式保持一致）\n\n```\nfunction Fun(a,b=1) {\n    console.log(arguments)//不传b参数时，没有arguments[1]\n    console.log(a === arguments[0])//true\n    console.log(b === arguments[1])//false\n    a = 2\n    b = 2\n    //不会同步\n    console.log(a === arguments[0])//false\n    console.log(b === arguments[1])//false\n}\nFun(1)\n```\n\n### 默认参数表达式\n\n- 注意如果忘记写小括号，则传入默认函数的引用\n\n```\nlet num = 1\nfunction Funa() {\n    return num++\n}\nfunction Fun(a,b=Funa()) {\n    console.log(b)\n}\nFun(1)//1\nFun(1)//2\n```\n\n- 可以使用先定义的参数作为后定义参数的默认值(但是反过来的话会产生临时死区TDZ)\n\n```\nfunction add(first,second = first) {\n    return first+second\n}\nadd(1)\n```\n\n- 参数的默认值不能访问函数体内声明的变量（参数和函数体的作用域相互独立）\n\n### 处理无命名参数\n\n#### 不定参数\n\n- 使用限制：\n\n1. 每个函数只能声明一个不定参数 2、不定参数必需放在所有参数的末尾\n\n- 不定参数对arguments的影响：无论是否使用不定参数，arguments对象总是包含所有传入的参数\n\n```\nfunction pick(object,...keys) {\n    console.log(arguments)\n    let result = Object.create(null)\n    for(let i = 0,len = keys.length; i<len ;i++){\n        result[keys[i]] = object[keys[i]]\n    }\n    return result\n}\npick({a:1,b:2},...['a','b'])\n```\n\n- 对象的setter只能包含一个参数\n\n```\nlet obj = {\n    set name(...arrs){\n\n    }\n}\n//报错：Uncaught SyntaxError: Setter function argument must not be a rest parameter\n```\n\n### Function构造函数增强\n\n```\nlet Funaa = new Function('a=1','...nums','console.log(a+nums[0])')//11(字符串)\nFunaa(1,[1])\n```\n\n### 展开运算符\n\n- 指定数组，打散后作为参数传入函数\n\n```\nlet numArr= [1,2,3]\nMath.max(...numArr,0)//在后边在传入参数，可以控制最小值\nMath.max.apply(null,numArr)//等同于这个，但是apply需要手动绑定this\n```\n### name属性\n\n1. 函数表达式的属性名字比函数赋值的变量权重高\n2. getter函数名字有get\n3. 调用bind生成函数名字有bound\n\n```\nfunction name2() {\n}\nlet name1 = name2\nconsole.log(name1.name)//name2\nconsole.log(name2.name)//name2\nlet person = {\n    get firstName(){\n        return '1234'\n    }\n}\nconsole.log(person.firstName.name)//get firstName\nlet name3 = name2.bind(null)\nconsole.log(name3.name)//bound name2\n```\n\n### 明确函数的多用途\n\n- ES5中判断函数被调用的方法，但是通过Person.call()或者Person.apply()方法调用就无法判断\n\n```\nfunction Person(name) {\n    if(this instanceof Person){\n        this.name = name\n    }else {\n        throw new Error('必须通过new关键字调用person')\n    }\n}\n```\n\n1. 函数有[[Call]]和[[Construct]]方法，分表表示直接调用和new构造\n2. 元属性new.target（判断函数是否通过new关键字调用）\n\n```\nfunction bbb() {\n    if(new.target === bbb){\n        this.a = 1\n    }else {\n        console.log('error')\n    }\n}\nbbb()//error\nnew bbb()\n```\n\n### 块级函数\n\n- ES5中处理块级函数，ES5严格模式中代码块内声明函数会报错\n\n```\n'use strict'\nif(true){\n    //抛出错误\n    function a() {\n\n    }\n}\n```\n\n- ES6严格模式下块级函数（代码中块级函数会被提升至块的顶部，而使用let声明的变量不会）\n\n```\nif(true){\n    console.log(typeof a)//function\n    function a() {\n\n    }\n    console.log(typeof b)//报错\n    let b = function () {\n\n    }\n}\n```\n\n- ES6非严格模式下，函数提升至外围函数或全局作用域的顶部\n\n```\nif(true){\n    function a() {\n\n    }\n}\nconsole.log(typeof a)//function\n```\n\n### 箭头函数\n\n1. 没有this\\super\\arguments\\ner.target绑定，箭头函数中的这些由外层最近一个非箭头函数决定\n2. 不能通过new关键字调用\n3. 没有原型\n4. 不可改变this指向\n5. 不支持arguments对象\n6. 不支持重复命名参数\n\n```\nlet reflec = val=>val//直接返回val\n\nlet refObj = ()=>({a:1})//直接返回object\n\nlet bbbb = ((val)=>{return val})(1)//立即执行\n\nlet nullRef = ()=>{}\ntypeof nullRef//function\n```\n\n### 多个箭头的函数与科里化\n\n```\nvar a = b => c => d => {\n    console.log(b)\n    console.log(c)\n    console.log(d)\n}\n\n    // 等价于\nvar a = function (b) {\n    return function (c) {\n        return function (d) {\n            console.log(b)\n            console.log(c)\n            console.log(d)\n        }\n\n    }\n}\n```\n\n### 尾调用优化\n\n- 尾调用指的是函数作为另一个函数的最后一条语句被执行\n- ES6缩减了严格模式下尾调用栈的大小，如果满足以下条件，尾调用不在创建新栈，而是清除并重用当前栈。\n- 需要同时满足：\n\n1. 尾调用不访问当前函数的变量\n2. 在函数内部，尾调用是最后一条语句\n3. 尾调用的结果作为函数的返回值\n\n- 适用于递归函数\n\n```\nfunction factorial(n,p=1) {\n    if(n<=1){\n        return 1\n    }else {\n        let result = n*p\n        return factorial(n-1,result)\n    }\n}\n```\n","source":"_posts/[ES6]函数.md","raw":"---\ntitle: <ES6>函数\ndate: 2018-08-21 00:00:00\ntags: [ES6,js]\ncategories: ES6\n---\n### 简介\n\n- ES6在ES5的基础上做了大量改进，使编程更加灵活，更少出错。\n\n### 参数默认值\n\n- ES5非严格模式下，命名参数的变化会体现在arguments对象中\n\n```\nfunction a(b,c) {\n    console.log(b === arguments[0])//true\n    console.log(c === arguments[1])//true\n    b = 3\n    c = 3\n    //会同步\n    console.log(b === arguments[0])//true\n    console.log(c === arguments[1])//true\n}\na(1,1)\n```\n\n- ES5严格模式下取消了对于arguments对象的同步行为\n\n```\nfunction a(b,c) {\n    'use strict'\n    console.log(b === arguments[0])//true\n    console.log(c === arguments[1])//true\n    b = 3\n    c = 3\n    //不会同步\n    console.log(b === arguments[0])//false\n    console.log(c === arguments[1])//false\n}\na(1,1)\n```\n```\nfunction defaultParam(a,b=1) {\n}\n```\n\n- 默认参数对arguments的影响（在ES6中如果一个函数使用了默认值，无论是否显示定义严格模式，arguments与ES5严格模式保持一致）\n\n```\nfunction Fun(a,b=1) {\n    console.log(arguments)//不传b参数时，没有arguments[1]\n    console.log(a === arguments[0])//true\n    console.log(b === arguments[1])//false\n    a = 2\n    b = 2\n    //不会同步\n    console.log(a === arguments[0])//false\n    console.log(b === arguments[1])//false\n}\nFun(1)\n```\n\n### 默认参数表达式\n\n- 注意如果忘记写小括号，则传入默认函数的引用\n\n```\nlet num = 1\nfunction Funa() {\n    return num++\n}\nfunction Fun(a,b=Funa()) {\n    console.log(b)\n}\nFun(1)//1\nFun(1)//2\n```\n\n- 可以使用先定义的参数作为后定义参数的默认值(但是反过来的话会产生临时死区TDZ)\n\n```\nfunction add(first,second = first) {\n    return first+second\n}\nadd(1)\n```\n\n- 参数的默认值不能访问函数体内声明的变量（参数和函数体的作用域相互独立）\n\n### 处理无命名参数\n\n#### 不定参数\n\n- 使用限制：\n\n1. 每个函数只能声明一个不定参数 2、不定参数必需放在所有参数的末尾\n\n- 不定参数对arguments的影响：无论是否使用不定参数，arguments对象总是包含所有传入的参数\n\n```\nfunction pick(object,...keys) {\n    console.log(arguments)\n    let result = Object.create(null)\n    for(let i = 0,len = keys.length; i<len ;i++){\n        result[keys[i]] = object[keys[i]]\n    }\n    return result\n}\npick({a:1,b:2},...['a','b'])\n```\n\n- 对象的setter只能包含一个参数\n\n```\nlet obj = {\n    set name(...arrs){\n\n    }\n}\n//报错：Uncaught SyntaxError: Setter function argument must not be a rest parameter\n```\n\n### Function构造函数增强\n\n```\nlet Funaa = new Function('a=1','...nums','console.log(a+nums[0])')//11(字符串)\nFunaa(1,[1])\n```\n\n### 展开运算符\n\n- 指定数组，打散后作为参数传入函数\n\n```\nlet numArr= [1,2,3]\nMath.max(...numArr,0)//在后边在传入参数，可以控制最小值\nMath.max.apply(null,numArr)//等同于这个，但是apply需要手动绑定this\n```\n### name属性\n\n1. 函数表达式的属性名字比函数赋值的变量权重高\n2. getter函数名字有get\n3. 调用bind生成函数名字有bound\n\n```\nfunction name2() {\n}\nlet name1 = name2\nconsole.log(name1.name)//name2\nconsole.log(name2.name)//name2\nlet person = {\n    get firstName(){\n        return '1234'\n    }\n}\nconsole.log(person.firstName.name)//get firstName\nlet name3 = name2.bind(null)\nconsole.log(name3.name)//bound name2\n```\n\n### 明确函数的多用途\n\n- ES5中判断函数被调用的方法，但是通过Person.call()或者Person.apply()方法调用就无法判断\n\n```\nfunction Person(name) {\n    if(this instanceof Person){\n        this.name = name\n    }else {\n        throw new Error('必须通过new关键字调用person')\n    }\n}\n```\n\n1. 函数有[[Call]]和[[Construct]]方法，分表表示直接调用和new构造\n2. 元属性new.target（判断函数是否通过new关键字调用）\n\n```\nfunction bbb() {\n    if(new.target === bbb){\n        this.a = 1\n    }else {\n        console.log('error')\n    }\n}\nbbb()//error\nnew bbb()\n```\n\n### 块级函数\n\n- ES5中处理块级函数，ES5严格模式中代码块内声明函数会报错\n\n```\n'use strict'\nif(true){\n    //抛出错误\n    function a() {\n\n    }\n}\n```\n\n- ES6严格模式下块级函数（代码中块级函数会被提升至块的顶部，而使用let声明的变量不会）\n\n```\nif(true){\n    console.log(typeof a)//function\n    function a() {\n\n    }\n    console.log(typeof b)//报错\n    let b = function () {\n\n    }\n}\n```\n\n- ES6非严格模式下，函数提升至外围函数或全局作用域的顶部\n\n```\nif(true){\n    function a() {\n\n    }\n}\nconsole.log(typeof a)//function\n```\n\n### 箭头函数\n\n1. 没有this\\super\\arguments\\ner.target绑定，箭头函数中的这些由外层最近一个非箭头函数决定\n2. 不能通过new关键字调用\n3. 没有原型\n4. 不可改变this指向\n5. 不支持arguments对象\n6. 不支持重复命名参数\n\n```\nlet reflec = val=>val//直接返回val\n\nlet refObj = ()=>({a:1})//直接返回object\n\nlet bbbb = ((val)=>{return val})(1)//立即执行\n\nlet nullRef = ()=>{}\ntypeof nullRef//function\n```\n\n### 多个箭头的函数与科里化\n\n```\nvar a = b => c => d => {\n    console.log(b)\n    console.log(c)\n    console.log(d)\n}\n\n    // 等价于\nvar a = function (b) {\n    return function (c) {\n        return function (d) {\n            console.log(b)\n            console.log(c)\n            console.log(d)\n        }\n\n    }\n}\n```\n\n### 尾调用优化\n\n- 尾调用指的是函数作为另一个函数的最后一条语句被执行\n- ES6缩减了严格模式下尾调用栈的大小，如果满足以下条件，尾调用不在创建新栈，而是清除并重用当前栈。\n- 需要同时满足：\n\n1. 尾调用不访问当前函数的变量\n2. 在函数内部，尾调用是最后一条语句\n3. 尾调用的结果作为函数的返回值\n\n- 适用于递归函数\n\n```\nfunction factorial(n,p=1) {\n    if(n<=1){\n        return 1\n    }else {\n        let result = n*p\n        return factorial(n-1,result)\n    }\n}\n```\n","slug":"[ES6]函数","published":1,"updated":"2021-03-15T14:36:34.777Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dk1000ewotj14ymh44s","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>ES6在ES5的基础上做了大量改进，使编程更加灵活，更少出错。</li>\n</ul>\n<h3 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h3><ul>\n<li>ES5非严格模式下，命名参数的变化会体现在arguments对象中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a(b,c) &#123;</span><br><span class=\"line\">    console.log(b &#x3D;&#x3D;&#x3D; arguments[0])&#x2F;&#x2F;true</span><br><span class=\"line\">    console.log(c &#x3D;&#x3D;&#x3D; arguments[1])&#x2F;&#x2F;true</span><br><span class=\"line\">    b &#x3D; 3</span><br><span class=\"line\">    c &#x3D; 3</span><br><span class=\"line\">    &#x2F;&#x2F;会同步</span><br><span class=\"line\">    console.log(b &#x3D;&#x3D;&#x3D; arguments[0])&#x2F;&#x2F;true</span><br><span class=\"line\">    console.log(c &#x3D;&#x3D;&#x3D; arguments[1])&#x2F;&#x2F;true</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(1,1)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES5严格模式下取消了对于arguments对象的同步行为</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a(b,c) &#123;</span><br><span class=\"line\">    &#39;use strict&#39;</span><br><span class=\"line\">    console.log(b &#x3D;&#x3D;&#x3D; arguments[0])&#x2F;&#x2F;true</span><br><span class=\"line\">    console.log(c &#x3D;&#x3D;&#x3D; arguments[1])&#x2F;&#x2F;true</span><br><span class=\"line\">    b &#x3D; 3</span><br><span class=\"line\">    c &#x3D; 3</span><br><span class=\"line\">    &#x2F;&#x2F;不会同步</span><br><span class=\"line\">    console.log(b &#x3D;&#x3D;&#x3D; arguments[0])&#x2F;&#x2F;false</span><br><span class=\"line\">    console.log(c &#x3D;&#x3D;&#x3D; arguments[1])&#x2F;&#x2F;false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(1,1)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function defaultParam(a,b&#x3D;1) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>默认参数对arguments的影响（在ES6中如果一个函数使用了默认值，无论是否显示定义严格模式，arguments与ES5严格模式保持一致）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fun(a,b&#x3D;1) &#123;</span><br><span class=\"line\">    console.log(arguments)&#x2F;&#x2F;不传b参数时，没有arguments[1]</span><br><span class=\"line\">    console.log(a &#x3D;&#x3D;&#x3D; arguments[0])&#x2F;&#x2F;true</span><br><span class=\"line\">    console.log(b &#x3D;&#x3D;&#x3D; arguments[1])&#x2F;&#x2F;false</span><br><span class=\"line\">    a &#x3D; 2</span><br><span class=\"line\">    b &#x3D; 2</span><br><span class=\"line\">    &#x2F;&#x2F;不会同步</span><br><span class=\"line\">    console.log(a &#x3D;&#x3D;&#x3D; arguments[0])&#x2F;&#x2F;false</span><br><span class=\"line\">    console.log(b &#x3D;&#x3D;&#x3D; arguments[1])&#x2F;&#x2F;false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun(1)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认参数表达式\"><a href=\"#默认参数表达式\" class=\"headerlink\" title=\"默认参数表达式\"></a>默认参数表达式</h3><ul>\n<li>注意如果忘记写小括号，则传入默认函数的引用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let num &#x3D; 1</span><br><span class=\"line\">function Funa() &#123;</span><br><span class=\"line\">    return num++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Fun(a,b&#x3D;Funa()) &#123;</span><br><span class=\"line\">    console.log(b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun(1)&#x2F;&#x2F;1</span><br><span class=\"line\">Fun(1)&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以使用先定义的参数作为后定义参数的默认值(但是反过来的话会产生临时死区TDZ)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(first,second &#x3D; first) &#123;</span><br><span class=\"line\">    return first+second</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(1)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参数的默认值不能访问函数体内声明的变量（参数和函数体的作用域相互独立）</li>\n</ul>\n<h3 id=\"处理无命名参数\"><a href=\"#处理无命名参数\" class=\"headerlink\" title=\"处理无命名参数\"></a>处理无命名参数</h3><h4 id=\"不定参数\"><a href=\"#不定参数\" class=\"headerlink\" title=\"不定参数\"></a>不定参数</h4><ul>\n<li>使用限制：</li>\n</ul>\n<ol>\n<li>每个函数只能声明一个不定参数 2、不定参数必需放在所有参数的末尾</li>\n</ol>\n<ul>\n<li>不定参数对arguments的影响：无论是否使用不定参数，arguments对象总是包含所有传入的参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function pick(object,...keys) &#123;</span><br><span class=\"line\">    console.log(arguments)</span><br><span class=\"line\">    let result &#x3D; Object.create(null)</span><br><span class=\"line\">    for(let i &#x3D; 0,len &#x3D; keys.length; i&lt;len ;i++)&#123;</span><br><span class=\"line\">        result[keys[i]] &#x3D; object[keys[i]]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">pick(&#123;a:1,b:2&#125;,...[&#39;a&#39;,&#39;b&#39;])</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对象的setter只能包含一个参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    set name(...arrs)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;报错：Uncaught SyntaxError: Setter function argument must not be a rest parameter</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Function构造函数增强\"><a href=\"#Function构造函数增强\" class=\"headerlink\" title=\"Function构造函数增强\"></a>Function构造函数增强</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let Funaa &#x3D; new Function(&#39;a&#x3D;1&#39;,&#39;...nums&#39;,&#39;console.log(a+nums[0])&#39;)&#x2F;&#x2F;11(字符串)</span><br><span class=\"line\">Funaa(1,[1])</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"展开运算符\"><a href=\"#展开运算符\" class=\"headerlink\" title=\"展开运算符\"></a>展开运算符</h3><ul>\n<li>指定数组，打散后作为参数传入函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let numArr&#x3D; [1,2,3]</span><br><span class=\"line\">Math.max(...numArr,0)&#x2F;&#x2F;在后边在传入参数，可以控制最小值</span><br><span class=\"line\">Math.max.apply(null,numArr)&#x2F;&#x2F;等同于这个，但是apply需要手动绑定this</span><br></pre></td></tr></table></figure>\n<h3 id=\"name属性\"><a href=\"#name属性\" class=\"headerlink\" title=\"name属性\"></a>name属性</h3><ol>\n<li>函数表达式的属性名字比函数赋值的变量权重高</li>\n<li>getter函数名字有get</li>\n<li>调用bind生成函数名字有bound</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function name2() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let name1 &#x3D; name2</span><br><span class=\"line\">console.log(name1.name)&#x2F;&#x2F;name2</span><br><span class=\"line\">console.log(name2.name)&#x2F;&#x2F;name2</span><br><span class=\"line\">let person &#x3D; &#123;</span><br><span class=\"line\">    get firstName()&#123;</span><br><span class=\"line\">        return &#39;1234&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(person.firstName.name)&#x2F;&#x2F;get firstName</span><br><span class=\"line\">let name3 &#x3D; name2.bind(null)</span><br><span class=\"line\">console.log(name3.name)&#x2F;&#x2F;bound name2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"明确函数的多用途\"><a href=\"#明确函数的多用途\" class=\"headerlink\" title=\"明确函数的多用途\"></a>明确函数的多用途</h3><ul>\n<li>ES5中判断函数被调用的方法，但是通过Person.call()或者Person.apply()方法调用就无法判断</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name) &#123;</span><br><span class=\"line\">    if(this instanceof Person)&#123;</span><br><span class=\"line\">        this.name &#x3D; name</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        throw new Error(&#39;必须通过new关键字调用person&#39;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>函数有[[Call]]和[[Construct]]方法，分表表示直接调用和new构造</li>\n<li>元属性new.target（判断函数是否通过new关键字调用）</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bbb() &#123;</span><br><span class=\"line\">    if(new.target &#x3D;&#x3D;&#x3D; bbb)&#123;</span><br><span class=\"line\">        this.a &#x3D; 1</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        console.log(&#39;error&#39;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bbb()&#x2F;&#x2F;error</span><br><span class=\"line\">new bbb()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"块级函数\"><a href=\"#块级函数\" class=\"headerlink\" title=\"块级函数\"></a>块级函数</h3><ul>\n<li>ES5中处理块级函数，ES5严格模式中代码块内声明函数会报错</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;use strict&#39;</span><br><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;抛出错误</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES6严格模式下块级函数（代码中块级函数会被提升至块的顶部，而使用let声明的变量不会）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    console.log(typeof a)&#x2F;&#x2F;function</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(typeof b)&#x2F;&#x2F;报错</span><br><span class=\"line\">    let b &#x3D; function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES6非严格模式下，函数提升至外围函数或全局作用域的顶部</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(typeof a)&#x2F;&#x2F;function</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><ol>\n<li>没有this\\super\\arguments\\ner.target绑定，箭头函数中的这些由外层最近一个非箭头函数决定</li>\n<li>不能通过new关键字调用</li>\n<li>没有原型</li>\n<li>不可改变this指向</li>\n<li>不支持arguments对象</li>\n<li>不支持重复命名参数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reflec &#x3D; val&#x3D;&gt;val&#x2F;&#x2F;直接返回val</span><br><span class=\"line\"></span><br><span class=\"line\">let refObj &#x3D; ()&#x3D;&gt;(&#123;a:1&#125;)&#x2F;&#x2F;直接返回object</span><br><span class=\"line\"></span><br><span class=\"line\">let bbbb &#x3D; ((val)&#x3D;&gt;&#123;return val&#125;)(1)&#x2F;&#x2F;立即执行</span><br><span class=\"line\"></span><br><span class=\"line\">let nullRef &#x3D; ()&#x3D;&gt;&#123;&#125;</span><br><span class=\"line\">typeof nullRef&#x2F;&#x2F;function</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多个箭头的函数与科里化\"><a href=\"#多个箭头的函数与科里化\" class=\"headerlink\" title=\"多个箭头的函数与科里化\"></a>多个箭头的函数与科里化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; b &#x3D;&gt; c &#x3D;&gt; d &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(b)</span><br><span class=\"line\">    console.log(c)</span><br><span class=\"line\">    console.log(d)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 等价于</span><br><span class=\"line\">var a &#x3D; function (b) &#123;</span><br><span class=\"line\">    return function (c) &#123;</span><br><span class=\"line\">        return function (d) &#123;</span><br><span class=\"line\">            console.log(b)</span><br><span class=\"line\">            console.log(c)</span><br><span class=\"line\">            console.log(d)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h3><ul>\n<li>尾调用指的是函数作为另一个函数的最后一条语句被执行</li>\n<li>ES6缩减了严格模式下尾调用栈的大小，如果满足以下条件，尾调用不在创建新栈，而是清除并重用当前栈。</li>\n<li>需要同时满足：</li>\n</ul>\n<ol>\n<li>尾调用不访问当前函数的变量</li>\n<li>在函数内部，尾调用是最后一条语句</li>\n<li>尾调用的结果作为函数的返回值</li>\n</ol>\n<ul>\n<li>适用于递归函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factorial(n,p&#x3D;1) &#123;</span><br><span class=\"line\">    if(n&lt;&#x3D;1)&#123;</span><br><span class=\"line\">        return 1</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        let result &#x3D; n*p</span><br><span class=\"line\">        return factorial(n-1,result)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>ES6在ES5的基础上做了大量改进，使编程更加灵活，更少出错。</li>\n</ul>\n<h3 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h3><ul>\n<li>ES5非严格模式下，命名参数的变化会体现在arguments对象中</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a(b,c) &#123;</span><br><span class=\"line\">    console.log(b &#x3D;&#x3D;&#x3D; arguments[0])&#x2F;&#x2F;true</span><br><span class=\"line\">    console.log(c &#x3D;&#x3D;&#x3D; arguments[1])&#x2F;&#x2F;true</span><br><span class=\"line\">    b &#x3D; 3</span><br><span class=\"line\">    c &#x3D; 3</span><br><span class=\"line\">    &#x2F;&#x2F;会同步</span><br><span class=\"line\">    console.log(b &#x3D;&#x3D;&#x3D; arguments[0])&#x2F;&#x2F;true</span><br><span class=\"line\">    console.log(c &#x3D;&#x3D;&#x3D; arguments[1])&#x2F;&#x2F;true</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(1,1)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES5严格模式下取消了对于arguments对象的同步行为</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a(b,c) &#123;</span><br><span class=\"line\">    &#39;use strict&#39;</span><br><span class=\"line\">    console.log(b &#x3D;&#x3D;&#x3D; arguments[0])&#x2F;&#x2F;true</span><br><span class=\"line\">    console.log(c &#x3D;&#x3D;&#x3D; arguments[1])&#x2F;&#x2F;true</span><br><span class=\"line\">    b &#x3D; 3</span><br><span class=\"line\">    c &#x3D; 3</span><br><span class=\"line\">    &#x2F;&#x2F;不会同步</span><br><span class=\"line\">    console.log(b &#x3D;&#x3D;&#x3D; arguments[0])&#x2F;&#x2F;false</span><br><span class=\"line\">    console.log(c &#x3D;&#x3D;&#x3D; arguments[1])&#x2F;&#x2F;false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(1,1)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function defaultParam(a,b&#x3D;1) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>默认参数对arguments的影响（在ES6中如果一个函数使用了默认值，无论是否显示定义严格模式，arguments与ES5严格模式保持一致）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fun(a,b&#x3D;1) &#123;</span><br><span class=\"line\">    console.log(arguments)&#x2F;&#x2F;不传b参数时，没有arguments[1]</span><br><span class=\"line\">    console.log(a &#x3D;&#x3D;&#x3D; arguments[0])&#x2F;&#x2F;true</span><br><span class=\"line\">    console.log(b &#x3D;&#x3D;&#x3D; arguments[1])&#x2F;&#x2F;false</span><br><span class=\"line\">    a &#x3D; 2</span><br><span class=\"line\">    b &#x3D; 2</span><br><span class=\"line\">    &#x2F;&#x2F;不会同步</span><br><span class=\"line\">    console.log(a &#x3D;&#x3D;&#x3D; arguments[0])&#x2F;&#x2F;false</span><br><span class=\"line\">    console.log(b &#x3D;&#x3D;&#x3D; arguments[1])&#x2F;&#x2F;false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun(1)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"默认参数表达式\"><a href=\"#默认参数表达式\" class=\"headerlink\" title=\"默认参数表达式\"></a>默认参数表达式</h3><ul>\n<li>注意如果忘记写小括号，则传入默认函数的引用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let num &#x3D; 1</span><br><span class=\"line\">function Funa() &#123;</span><br><span class=\"line\">    return num++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Fun(a,b&#x3D;Funa()) &#123;</span><br><span class=\"line\">    console.log(b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun(1)&#x2F;&#x2F;1</span><br><span class=\"line\">Fun(1)&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以使用先定义的参数作为后定义参数的默认值(但是反过来的话会产生临时死区TDZ)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(first,second &#x3D; first) &#123;</span><br><span class=\"line\">    return first+second</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(1)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>参数的默认值不能访问函数体内声明的变量（参数和函数体的作用域相互独立）</li>\n</ul>\n<h3 id=\"处理无命名参数\"><a href=\"#处理无命名参数\" class=\"headerlink\" title=\"处理无命名参数\"></a>处理无命名参数</h3><h4 id=\"不定参数\"><a href=\"#不定参数\" class=\"headerlink\" title=\"不定参数\"></a>不定参数</h4><ul>\n<li>使用限制：</li>\n</ul>\n<ol>\n<li>每个函数只能声明一个不定参数 2、不定参数必需放在所有参数的末尾</li>\n</ol>\n<ul>\n<li>不定参数对arguments的影响：无论是否使用不定参数，arguments对象总是包含所有传入的参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function pick(object,...keys) &#123;</span><br><span class=\"line\">    console.log(arguments)</span><br><span class=\"line\">    let result &#x3D; Object.create(null)</span><br><span class=\"line\">    for(let i &#x3D; 0,len &#x3D; keys.length; i&lt;len ;i++)&#123;</span><br><span class=\"line\">        result[keys[i]] &#x3D; object[keys[i]]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">pick(&#123;a:1,b:2&#125;,...[&#39;a&#39;,&#39;b&#39;])</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>对象的setter只能包含一个参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    set name(...arrs)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;报错：Uncaught SyntaxError: Setter function argument must not be a rest parameter</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Function构造函数增强\"><a href=\"#Function构造函数增强\" class=\"headerlink\" title=\"Function构造函数增强\"></a>Function构造函数增强</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let Funaa &#x3D; new Function(&#39;a&#x3D;1&#39;,&#39;...nums&#39;,&#39;console.log(a+nums[0])&#39;)&#x2F;&#x2F;11(字符串)</span><br><span class=\"line\">Funaa(1,[1])</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"展开运算符\"><a href=\"#展开运算符\" class=\"headerlink\" title=\"展开运算符\"></a>展开运算符</h3><ul>\n<li>指定数组，打散后作为参数传入函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let numArr&#x3D; [1,2,3]</span><br><span class=\"line\">Math.max(...numArr,0)&#x2F;&#x2F;在后边在传入参数，可以控制最小值</span><br><span class=\"line\">Math.max.apply(null,numArr)&#x2F;&#x2F;等同于这个，但是apply需要手动绑定this</span><br></pre></td></tr></table></figure>\n<h3 id=\"name属性\"><a href=\"#name属性\" class=\"headerlink\" title=\"name属性\"></a>name属性</h3><ol>\n<li>函数表达式的属性名字比函数赋值的变量权重高</li>\n<li>getter函数名字有get</li>\n<li>调用bind生成函数名字有bound</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function name2() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let name1 &#x3D; name2</span><br><span class=\"line\">console.log(name1.name)&#x2F;&#x2F;name2</span><br><span class=\"line\">console.log(name2.name)&#x2F;&#x2F;name2</span><br><span class=\"line\">let person &#x3D; &#123;</span><br><span class=\"line\">    get firstName()&#123;</span><br><span class=\"line\">        return &#39;1234&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(person.firstName.name)&#x2F;&#x2F;get firstName</span><br><span class=\"line\">let name3 &#x3D; name2.bind(null)</span><br><span class=\"line\">console.log(name3.name)&#x2F;&#x2F;bound name2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"明确函数的多用途\"><a href=\"#明确函数的多用途\" class=\"headerlink\" title=\"明确函数的多用途\"></a>明确函数的多用途</h3><ul>\n<li>ES5中判断函数被调用的方法，但是通过Person.call()或者Person.apply()方法调用就无法判断</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name) &#123;</span><br><span class=\"line\">    if(this instanceof Person)&#123;</span><br><span class=\"line\">        this.name &#x3D; name</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        throw new Error(&#39;必须通过new关键字调用person&#39;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>函数有[[Call]]和[[Construct]]方法，分表表示直接调用和new构造</li>\n<li>元属性new.target（判断函数是否通过new关键字调用）</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bbb() &#123;</span><br><span class=\"line\">    if(new.target &#x3D;&#x3D;&#x3D; bbb)&#123;</span><br><span class=\"line\">        this.a &#x3D; 1</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        console.log(&#39;error&#39;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bbb()&#x2F;&#x2F;error</span><br><span class=\"line\">new bbb()</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"块级函数\"><a href=\"#块级函数\" class=\"headerlink\" title=\"块级函数\"></a>块级函数</h3><ul>\n<li>ES5中处理块级函数，ES5严格模式中代码块内声明函数会报错</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;use strict&#39;</span><br><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    &#x2F;&#x2F;抛出错误</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES6严格模式下块级函数（代码中块级函数会被提升至块的顶部，而使用let声明的变量不会）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    console.log(typeof a)&#x2F;&#x2F;function</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(typeof b)&#x2F;&#x2F;报错</span><br><span class=\"line\">    let b &#x3D; function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES6非严格模式下，函数提升至外围函数或全局作用域的顶部</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(typeof a)&#x2F;&#x2F;function</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h3><ol>\n<li>没有this\\super\\arguments\\ner.target绑定，箭头函数中的这些由外层最近一个非箭头函数决定</li>\n<li>不能通过new关键字调用</li>\n<li>没有原型</li>\n<li>不可改变this指向</li>\n<li>不支持arguments对象</li>\n<li>不支持重复命名参数</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reflec &#x3D; val&#x3D;&gt;val&#x2F;&#x2F;直接返回val</span><br><span class=\"line\"></span><br><span class=\"line\">let refObj &#x3D; ()&#x3D;&gt;(&#123;a:1&#125;)&#x2F;&#x2F;直接返回object</span><br><span class=\"line\"></span><br><span class=\"line\">let bbbb &#x3D; ((val)&#x3D;&gt;&#123;return val&#125;)(1)&#x2F;&#x2F;立即执行</span><br><span class=\"line\"></span><br><span class=\"line\">let nullRef &#x3D; ()&#x3D;&gt;&#123;&#125;</span><br><span class=\"line\">typeof nullRef&#x2F;&#x2F;function</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"多个箭头的函数与科里化\"><a href=\"#多个箭头的函数与科里化\" class=\"headerlink\" title=\"多个箭头的函数与科里化\"></a>多个箭头的函数与科里化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; b &#x3D;&gt; c &#x3D;&gt; d &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(b)</span><br><span class=\"line\">    console.log(c)</span><br><span class=\"line\">    console.log(d)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; 等价于</span><br><span class=\"line\">var a &#x3D; function (b) &#123;</span><br><span class=\"line\">    return function (c) &#123;</span><br><span class=\"line\">        return function (d) &#123;</span><br><span class=\"line\">            console.log(b)</span><br><span class=\"line\">            console.log(c)</span><br><span class=\"line\">            console.log(d)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h3><ul>\n<li>尾调用指的是函数作为另一个函数的最后一条语句被执行</li>\n<li>ES6缩减了严格模式下尾调用栈的大小，如果满足以下条件，尾调用不在创建新栈，而是清除并重用当前栈。</li>\n<li>需要同时满足：</li>\n</ul>\n<ol>\n<li>尾调用不访问当前函数的变量</li>\n<li>在函数内部，尾调用是最后一条语句</li>\n<li>尾调用的结果作为函数的返回值</li>\n</ol>\n<ul>\n<li>适用于递归函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factorial(n,p&#x3D;1) &#123;</span><br><span class=\"line\">    if(n&lt;&#x3D;1)&#123;</span><br><span class=\"line\">        return 1</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        let result &#x3D; n*p</span><br><span class=\"line\">        return factorial(n-1,result)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"<ES6>扩展对象属性","date":"2018-08-20T16:00:00.000Z","_content":"\n### 简介\n\n- ES6通过多种方式加强对象的使用，通过简单的语法扩展，提供更多操作对象以及对象交互方法。\n\n### 初始值的简写\n\n```\nlet a = 1;\nlet obj = {\n    a\n}\n```\n\n### 对象方法的简写\n\n- 注意简写方法可以使用super关键字\n\n```\nlet obj = {\n    a(){\n    }\n}\n```\n\n### 可计算属性名\n\n```\nlet firstName = 'first name'\nlet name = 'name'\nlet person = {\n    [firstName]: 'yang',\n    ['last'+name]: 'xiao'\n}\nconsole.log(person[firstName])//yang\nconsole.log(person['first name'])//yang\nconsole.log(person['last'+name])//xiao\n```\n\n### 新增对象方法\n\n#### Object.is()\n\n- 以下几项比较特殊，其他比较与===相同\n\n```\nconsole.log(Object.is(+0,-0))//false\nconsole.log(Object.is(NaN,NaN))//true\nconsole.log(Object.is(0,''))//false\n```\n\n#### Object.assign()\n\n- 混合（Mixin）模式，接受一个接收对象和任意数量的源对象\n\n1. 对于对象属性是浅复制\n2. 不能将访问器属性复制到接收对象，只是调用get\n\n```\nlet obj = {}\nObject.assign(obj,{a:1},{a:2},{b:[1,2,3]},{get c(){\n        return 'c'\n    }})\nconsole.log(obj)//{a:2,b:[1,2,3],c:'c'}\n```\n\n### 自有属性的枚举顺序\n\n1. 所有数字按照升序排序\n2. 所有字母按照被加入对象的顺序排序\n3. symbol类型按照被加入顺序排序\n4. for-in循环不适用，因为浏览器厂商不一样\n\n### 增强对象原型\n\n- 对原型进行了改进\n\n#### Object.setPrototypeOf()\n\n- 改变对象的原型，改变对象内部专属[[Prototype]]，接收两个参数，**被改变原型的对象**，以及**替代原型的对象**\n\n#### 简化原型访问的super\n\n1. super相当于指针，指向Object.getPrototypeOf(this)的值\n2. 必须在简写方法时使用super\n\n```\nlet person = {\n    Fun(){\n        return 'hello'\n    }\n}\nlet dog = {\n    Fun(){\n        return 'wangwangwang'\n    }\n}\nlet friend = {\n\n    //必须在简写时使用super\n    Fun(){\n        //ES6写法\n        return super.Fun() + ' world'\n\n        //ES5写法\n        // return Object.getPrototypeOf(this).Fun.call(this) + ' world'\n    }\n}\n\nObject.setPrototypeOf(friend,person)\nconsole.log(friend.Fun())//hello world\nObject.setPrototypeOf(friend,dog)\nconsole.log(friend.Fun())//wangwangwang world\n```\n\n#### 正式的方法定义\n\n```\nlet obj = {\n    //是方法\n    a(){\n    }\n}\n//不是方法，是函数\nfunction a(){}\n```\n\n- 正式的方法定义内部存在[[HomeObject]]属性\n\n```\nlet obj = {\n    //是方法有[[HomeObject]]属性指向obj\n    //super的使用就是通过[[HomeObject]]来确定后续执行，因此必须为简写方法\n    Fun(){\n    },\n    //不是方法没有[[HomeObject]]属性\n    Fun1:function () {\n    }\n}\n```\n","source":"_posts/[ES6]扩展对象属性.md","raw":"---\ntitle: <ES6>扩展对象属性\ndate: 2018-08-21 00:00:00\ntags: [ES6,js]\ncategories: ES6\n---\n\n### 简介\n\n- ES6通过多种方式加强对象的使用，通过简单的语法扩展，提供更多操作对象以及对象交互方法。\n\n### 初始值的简写\n\n```\nlet a = 1;\nlet obj = {\n    a\n}\n```\n\n### 对象方法的简写\n\n- 注意简写方法可以使用super关键字\n\n```\nlet obj = {\n    a(){\n    }\n}\n```\n\n### 可计算属性名\n\n```\nlet firstName = 'first name'\nlet name = 'name'\nlet person = {\n    [firstName]: 'yang',\n    ['last'+name]: 'xiao'\n}\nconsole.log(person[firstName])//yang\nconsole.log(person['first name'])//yang\nconsole.log(person['last'+name])//xiao\n```\n\n### 新增对象方法\n\n#### Object.is()\n\n- 以下几项比较特殊，其他比较与===相同\n\n```\nconsole.log(Object.is(+0,-0))//false\nconsole.log(Object.is(NaN,NaN))//true\nconsole.log(Object.is(0,''))//false\n```\n\n#### Object.assign()\n\n- 混合（Mixin）模式，接受一个接收对象和任意数量的源对象\n\n1. 对于对象属性是浅复制\n2. 不能将访问器属性复制到接收对象，只是调用get\n\n```\nlet obj = {}\nObject.assign(obj,{a:1},{a:2},{b:[1,2,3]},{get c(){\n        return 'c'\n    }})\nconsole.log(obj)//{a:2,b:[1,2,3],c:'c'}\n```\n\n### 自有属性的枚举顺序\n\n1. 所有数字按照升序排序\n2. 所有字母按照被加入对象的顺序排序\n3. symbol类型按照被加入顺序排序\n4. for-in循环不适用，因为浏览器厂商不一样\n\n### 增强对象原型\n\n- 对原型进行了改进\n\n#### Object.setPrototypeOf()\n\n- 改变对象的原型，改变对象内部专属[[Prototype]]，接收两个参数，**被改变原型的对象**，以及**替代原型的对象**\n\n#### 简化原型访问的super\n\n1. super相当于指针，指向Object.getPrototypeOf(this)的值\n2. 必须在简写方法时使用super\n\n```\nlet person = {\n    Fun(){\n        return 'hello'\n    }\n}\nlet dog = {\n    Fun(){\n        return 'wangwangwang'\n    }\n}\nlet friend = {\n\n    //必须在简写时使用super\n    Fun(){\n        //ES6写法\n        return super.Fun() + ' world'\n\n        //ES5写法\n        // return Object.getPrototypeOf(this).Fun.call(this) + ' world'\n    }\n}\n\nObject.setPrototypeOf(friend,person)\nconsole.log(friend.Fun())//hello world\nObject.setPrototypeOf(friend,dog)\nconsole.log(friend.Fun())//wangwangwang world\n```\n\n#### 正式的方法定义\n\n```\nlet obj = {\n    //是方法\n    a(){\n    }\n}\n//不是方法，是函数\nfunction a(){}\n```\n\n- 正式的方法定义内部存在[[HomeObject]]属性\n\n```\nlet obj = {\n    //是方法有[[HomeObject]]属性指向obj\n    //super的使用就是通过[[HomeObject]]来确定后续执行，因此必须为简写方法\n    Fun(){\n    },\n    //不是方法没有[[HomeObject]]属性\n    Fun1:function () {\n    }\n}\n```\n","slug":"[ES6]扩展对象属性","published":1,"updated":"2021-03-15T14:36:49.088Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dk2000hwotj85vk1s7p","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>ES6通过多种方式加强对象的使用，通过简单的语法扩展，提供更多操作对象以及对象交互方法。</li>\n</ul>\n<h3 id=\"初始值的简写\"><a href=\"#初始值的简写\" class=\"headerlink\" title=\"初始值的简写\"></a>初始值的简写</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; 1;</span><br><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    a</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对象方法的简写\"><a href=\"#对象方法的简写\" class=\"headerlink\" title=\"对象方法的简写\"></a>对象方法的简写</h3><ul>\n<li>注意简写方法可以使用super关键字</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    a()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可计算属性名\"><a href=\"#可计算属性名\" class=\"headerlink\" title=\"可计算属性名\"></a>可计算属性名</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let firstName &#x3D; &#39;first name&#39;</span><br><span class=\"line\">let name &#x3D; &#39;name&#39;</span><br><span class=\"line\">let person &#x3D; &#123;</span><br><span class=\"line\">    [firstName]: &#39;yang&#39;,</span><br><span class=\"line\">    [&#39;last&#39;+name]: &#39;xiao&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(person[firstName])&#x2F;&#x2F;yang</span><br><span class=\"line\">console.log(person[&#39;first name&#39;])&#x2F;&#x2F;yang</span><br><span class=\"line\">console.log(person[&#39;last&#39;+name])&#x2F;&#x2F;xiao</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"新增对象方法\"><a href=\"#新增对象方法\" class=\"headerlink\" title=\"新增对象方法\"></a>新增对象方法</h3><h4 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is()\"></a>Object.is()</h4><ul>\n<li>以下几项比较特殊，其他比较与===相同</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Object.is(+0,-0))&#x2F;&#x2F;false</span><br><span class=\"line\">console.log(Object.is(NaN,NaN))&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(Object.is(0,&#39;&#39;))&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h4><ul>\n<li>混合（Mixin）模式，接受一个接收对象和任意数量的源对象</li>\n</ul>\n<ol>\n<li>对于对象属性是浅复制</li>\n<li>不能将访问器属性复制到接收对象，只是调用get</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;&#125;</span><br><span class=\"line\">Object.assign(obj,&#123;a:1&#125;,&#123;a:2&#125;,&#123;b:[1,2,3]&#125;,&#123;get c()&#123;</span><br><span class=\"line\">        return &#39;c&#39;</span><br><span class=\"line\">    &#125;&#125;)</span><br><span class=\"line\">console.log(obj)&#x2F;&#x2F;&#123;a:2,b:[1,2,3],c:&#39;c&#39;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自有属性的枚举顺序\"><a href=\"#自有属性的枚举顺序\" class=\"headerlink\" title=\"自有属性的枚举顺序\"></a>自有属性的枚举顺序</h3><ol>\n<li>所有数字按照升序排序</li>\n<li>所有字母按照被加入对象的顺序排序</li>\n<li>symbol类型按照被加入顺序排序</li>\n<li>for-in循环不适用，因为浏览器厂商不一样</li>\n</ol>\n<h3 id=\"增强对象原型\"><a href=\"#增强对象原型\" class=\"headerlink\" title=\"增强对象原型\"></a>增强对象原型</h3><ul>\n<li>对原型进行了改进</li>\n</ul>\n<h4 id=\"Object-setPrototypeOf\"><a href=\"#Object-setPrototypeOf\" class=\"headerlink\" title=\"Object.setPrototypeOf()\"></a>Object.setPrototypeOf()</h4><ul>\n<li>改变对象的原型，改变对象内部专属[[Prototype]]，接收两个参数，<strong>被改变原型的对象</strong>，以及<strong>替代原型的对象</strong></li>\n</ul>\n<h4 id=\"简化原型访问的super\"><a href=\"#简化原型访问的super\" class=\"headerlink\" title=\"简化原型访问的super\"></a>简化原型访问的super</h4><ol>\n<li>super相当于指针，指向Object.getPrototypeOf(this)的值</li>\n<li>必须在简写方法时使用super</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let person &#x3D; &#123;</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        return &#39;hello&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let dog &#x3D; &#123;</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        return &#39;wangwangwang&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let friend &#x3D; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;必须在简写时使用super</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;ES6写法</span><br><span class=\"line\">        return super.Fun() + &#39; world&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;ES5写法</span><br><span class=\"line\">        &#x2F;&#x2F; return Object.getPrototypeOf(this).Fun.call(this) + &#39; world&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.setPrototypeOf(friend,person)</span><br><span class=\"line\">console.log(friend.Fun())&#x2F;&#x2F;hello world</span><br><span class=\"line\">Object.setPrototypeOf(friend,dog)</span><br><span class=\"line\">console.log(friend.Fun())&#x2F;&#x2F;wangwangwang world</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"正式的方法定义\"><a href=\"#正式的方法定义\" class=\"headerlink\" title=\"正式的方法定义\"></a>正式的方法定义</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;是方法</span><br><span class=\"line\">    a()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;不是方法，是函数</span><br><span class=\"line\">function a()&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>正式的方法定义内部存在[[HomeObject]]属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;是方法有[[HomeObject]]属性指向obj</span><br><span class=\"line\">    &#x2F;&#x2F;super的使用就是通过[[HomeObject]]来确定后续执行，因此必须为简写方法</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;不是方法没有[[HomeObject]]属性</span><br><span class=\"line\">    Fun1:function () &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>ES6通过多种方式加强对象的使用，通过简单的语法扩展，提供更多操作对象以及对象交互方法。</li>\n</ul>\n<h3 id=\"初始值的简写\"><a href=\"#初始值的简写\" class=\"headerlink\" title=\"初始值的简写\"></a>初始值的简写</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; 1;</span><br><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    a</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"对象方法的简写\"><a href=\"#对象方法的简写\" class=\"headerlink\" title=\"对象方法的简写\"></a>对象方法的简写</h3><ul>\n<li>注意简写方法可以使用super关键字</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    a()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"可计算属性名\"><a href=\"#可计算属性名\" class=\"headerlink\" title=\"可计算属性名\"></a>可计算属性名</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let firstName &#x3D; &#39;first name&#39;</span><br><span class=\"line\">let name &#x3D; &#39;name&#39;</span><br><span class=\"line\">let person &#x3D; &#123;</span><br><span class=\"line\">    [firstName]: &#39;yang&#39;,</span><br><span class=\"line\">    [&#39;last&#39;+name]: &#39;xiao&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(person[firstName])&#x2F;&#x2F;yang</span><br><span class=\"line\">console.log(person[&#39;first name&#39;])&#x2F;&#x2F;yang</span><br><span class=\"line\">console.log(person[&#39;last&#39;+name])&#x2F;&#x2F;xiao</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"新增对象方法\"><a href=\"#新增对象方法\" class=\"headerlink\" title=\"新增对象方法\"></a>新增对象方法</h3><h4 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is()\"></a>Object.is()</h4><ul>\n<li>以下几项比较特殊，其他比较与===相同</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Object.is(+0,-0))&#x2F;&#x2F;false</span><br><span class=\"line\">console.log(Object.is(NaN,NaN))&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(Object.is(0,&#39;&#39;))&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h4><ul>\n<li>混合（Mixin）模式，接受一个接收对象和任意数量的源对象</li>\n</ul>\n<ol>\n<li>对于对象属性是浅复制</li>\n<li>不能将访问器属性复制到接收对象，只是调用get</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;&#125;</span><br><span class=\"line\">Object.assign(obj,&#123;a:1&#125;,&#123;a:2&#125;,&#123;b:[1,2,3]&#125;,&#123;get c()&#123;</span><br><span class=\"line\">        return &#39;c&#39;</span><br><span class=\"line\">    &#125;&#125;)</span><br><span class=\"line\">console.log(obj)&#x2F;&#x2F;&#123;a:2,b:[1,2,3],c:&#39;c&#39;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"自有属性的枚举顺序\"><a href=\"#自有属性的枚举顺序\" class=\"headerlink\" title=\"自有属性的枚举顺序\"></a>自有属性的枚举顺序</h3><ol>\n<li>所有数字按照升序排序</li>\n<li>所有字母按照被加入对象的顺序排序</li>\n<li>symbol类型按照被加入顺序排序</li>\n<li>for-in循环不适用，因为浏览器厂商不一样</li>\n</ol>\n<h3 id=\"增强对象原型\"><a href=\"#增强对象原型\" class=\"headerlink\" title=\"增强对象原型\"></a>增强对象原型</h3><ul>\n<li>对原型进行了改进</li>\n</ul>\n<h4 id=\"Object-setPrototypeOf\"><a href=\"#Object-setPrototypeOf\" class=\"headerlink\" title=\"Object.setPrototypeOf()\"></a>Object.setPrototypeOf()</h4><ul>\n<li>改变对象的原型，改变对象内部专属[[Prototype]]，接收两个参数，<strong>被改变原型的对象</strong>，以及<strong>替代原型的对象</strong></li>\n</ul>\n<h4 id=\"简化原型访问的super\"><a href=\"#简化原型访问的super\" class=\"headerlink\" title=\"简化原型访问的super\"></a>简化原型访问的super</h4><ol>\n<li>super相当于指针，指向Object.getPrototypeOf(this)的值</li>\n<li>必须在简写方法时使用super</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let person &#x3D; &#123;</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        return &#39;hello&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let dog &#x3D; &#123;</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        return &#39;wangwangwang&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let friend &#x3D; &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;必须在简写时使用super</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;ES6写法</span><br><span class=\"line\">        return super.Fun() + &#39; world&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;ES5写法</span><br><span class=\"line\">        &#x2F;&#x2F; return Object.getPrototypeOf(this).Fun.call(this) + &#39; world&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.setPrototypeOf(friend,person)</span><br><span class=\"line\">console.log(friend.Fun())&#x2F;&#x2F;hello world</span><br><span class=\"line\">Object.setPrototypeOf(friend,dog)</span><br><span class=\"line\">console.log(friend.Fun())&#x2F;&#x2F;wangwangwang world</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"正式的方法定义\"><a href=\"#正式的方法定义\" class=\"headerlink\" title=\"正式的方法定义\"></a>正式的方法定义</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;是方法</span><br><span class=\"line\">    a()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;不是方法，是函数</span><br><span class=\"line\">function a()&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>正式的方法定义内部存在[[HomeObject]]属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;是方法有[[HomeObject]]属性指向obj</span><br><span class=\"line\">    &#x2F;&#x2F;super的使用就是通过[[HomeObject]]来确定后续执行，因此必须为简写方法</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;不是方法没有[[HomeObject]]属性</span><br><span class=\"line\">    Fun1:function () &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"<ES6>改进数组功能","date":"2018-11-09T16:00:00.000Z","_content":"\n### 常用数组方法\n\n#### 检测数组\n\n```\nlet arr1 = [1,2,3]\nconsole.log(Array.isArray(arr1))//true\n```\n\n#### 转换方法\n\n```\nconsole.log(arr1.valueOf())//[1,2,3]\nconsole.log(arr1.toString())//1,2,3\nconsole.log(arr1.toLocaleString())//1,2,3（每一项调用的是toLocalString()方法）\nconsole.log(arr1.join('#'))//1#2#3\n```\n\n#### 栈方法\n\n```\nlet arr2 = [1,2,3]\narr2.push(4)\nconsole.log(arr2)//[1,2,3,4]\narr2.pop(4)\nconsole.log(arr2)//[1,2,3]\n```\n\n#### 对列方法\n\n```\nlet arr3 = [1,2,3]\narr3.unshift(0)//[0,1,2,3,4]\nconsole.log(arr3)\narr3.shift()\nconsole.log(arr3)\n```\n\n#### 排序方法\n\n```\nlet arr4 = [3,2,1]\narr4.reverse()//反转数组顺序\nconsole.log(arr4)\narr4.sort((a,b)=>{\n    return a - b\n})//由小到大\nconsole.log(arr4)\narr4.sort((a,b)=>{\n    return b - a\n})//由大到小\nconsole.log(arr4)\n\nlet arr5 = [1,2,'10']\nconsole.log(arr5.sort())//[1,'10',2]sort默认先toString()再排序\n```\n\n#### 操作方法\n\n```\nlet a1 = [1]\nlet a2 = [2]\nlet a3 = a1.concat(a2)\nconsole.log(a1)//[1]\nconsole.log(a2)//[2]\nconsole.log(a3)//[1,2]\n\nlet aa1 = [1,2,3,4,5]\nlet aa2 = aa1.slice(1,4)//slice()左闭右开\nlet aa3 = aa1.slice(1)\nconsole.log(aa1)//[1,2,3,4,5]\nconsole.log(aa2)//[2,3,4]\nconsole.log(aa3)//[2,3,4,5]\n```\n\n#### 删除、插入、替换\n\n- 删除splice(1,2)\\插入splice(2,0,'a','b')\\替换splice(1,2,3,4)\n\n```\nlet sa1 = [1,2,3,4,5]\nlet sa2 = sa1.splice(1,2,'a','b')//从1位置开始，删除两项，并添加'a'\\'b'两项\nconsole.log(sa1)\nconsole.log(sa2)//返回删除的数组\n```\n\n#### 位置方法\n\n```\nlet la = [1,2,3,2,1]\nconsole.log(la.indexOf(2))//1\nconsole.log(la.lastIndexOf(2))//3\n```\n\n#### 迭代方法\n\n- every()对数组中每一项进行运行给定函数，如果都返回true，则返回true\n- filter()对数组中每一项进行运行给定函数，如果都返回true，则返回true项组成的数组\n- forEach()对数组中每一项执行给定函数，没有返回值\n- map()对数组中每一项执行给定函数，返回每次函数调用结果返回的数组\n\n```\nlet ma = [1,2,3]\nlet ma1 = ma.map((item,index,arr)=>{\n    return 2\n})\nconsole.log(ma)//[1,2,3]\nconsole.log(ma1)//[2,2,2]\n```\n\n#### some()\n\n#### 归并方法reduce(),reduceRight()\n\n```\nlet ra = [1,2,3]\nlet res = ra.reduce((pre,cur,index,arr)=>{\n    return pre+cur\n})\nconsole.log(ra)\nconsole.log(res)\n```\n\n### ES6方法\n\n- ES6标准继续改进数组，添加了许多新功能，比如创建数组新方法、几个实用的方法、创建定型数组\n\n#### Array.of()\n\n- Array构造函数传入参数问题\n\n```\nlet arr = new Array(2)\nconsole.log(arr)//[undefined,undefined]\narr = new Array('2')\nconsole.log(arr)//['2']\narr = new Array(1,2)\nconsole.log(arr)//[1,2]\narr = new Array(2,'2')\nconsole.log(arr)//[2,'2']\n```\n\n- Array.of()方法总会创建一个包含所有参数的数组\n\n```\nlet arr1 = Array.of(1,2,3)\nconsole.log(arr1)//[1,2,3]\n```\n\n- 注意：Array.of()不使用Sympol.species属性返回确定的类型，而是使用of()方法中this()的值来返回数据类型\n\n#### Array.from()\n\n- js不支持直接将非数组对象转换为真实数组，如arguments，如果把它当做数组使用必须先转换该对象的类型\n- es5中的转换方法\n\n```\nfunction makeArray(arrayLike) {\n    var res = []\n    for(var i = 0;i<arrayLike.length;i++){\n        res.push(arrayLike[i])\n    }\n    //或者\n    // res = Array.prototype.slice().call(arrayLike)\n    return res\n}\n(function f(a,b,c) {\n    var arr = makeArray(arguments)\n    console.log(arr)//[1,2,3]\n})(1,2,3)\n```\n\n- Array.from()用来将对象转化为数组，可以接受可迭代对象或类数组对象作为第一个参数，第二个参数可以提供一个映射关系，将每一个值转换为其他形式，第三个参数用来表示映射函数this的值\n\n```\nfunction f1(a,b,c) {\n    let arr = Array.from(arguments,function (item) {\n        return item+this.a\n    },{a:1})\n    console.log(arr)//[3,4,5]\n}\nf1(2,3,4)\n```\n\n- 转换可迭代对象，如果一个对象即是类数组又是可迭代对象，那么会根据迭代器来决定转换哪个值\n\n```\nlet nums = {\n    *[Symbol.iterator](){\n        yield 1;\n        yield 2;\n        yield 3;\n    }\n}\nlet i_arr = Array.from(nums)\nconsole.log(i_arr)//[1,2,3]\n```\n\n#### find()\\findIndex()\n\n- find()返回找到的值、findIndex()返回找到值的位置，接收两个参数，一个是回调函数、一个是可选参数\n\n```\nlet n = [1,2,3,4,5]\nconsole.log(n.find(item=>item>2))//3\nconsole.log(n.findIndex(item=>item>2))//2\n```\n\n- 如果在数组中查找根据某个条件匹配的元素，使用find()，如果只是匹配某个元素值使用indexOf()\n\n#### fill()\n\n- fill()可以用指定的值填充一致多个数组元素\n\n```\nlet f_arr = [1,2,3,4]\nf_arr.fill(1)\nconsole.log(f_arr)//[1,1,1,1]\nf_arr.fill(0,1,3)\nconsole.log(f_arr)//[1,0,0,1]左闭右开\n```\n\n#### copyWithin()\n\n- copyWithin()从数组中复制元素的值\n\n```\nlet c_arr = [1,2,3,4,5]\nc_arr.copyWithin(2,0)\n```\n\n- console.log(c_arr)//[1,2,1,2,3]从索引2开始粘贴值，从索引0开始复制并持续到没有更多可复制的值\n\n#### 定型数组\n\n- 用于处理数值类型数据专用的数组\n- [定型数组](http://www.shaoqun.com/a/318331.html)\n\n#### Array.prototype.includes()\n\n- ES7语法\n\n```\nlet val = [1,2,3]\nconsole.log(val.includes(1))//true\n```\n","source":"_posts/[ES6]改进数组功能.md","raw":"---\ntitle: <ES6>改进数组功能\ndate: 2018-11-10 00:00:00\ntags: [ES6,js,Array]\ncategories: ES6\n---\n\n### 常用数组方法\n\n#### 检测数组\n\n```\nlet arr1 = [1,2,3]\nconsole.log(Array.isArray(arr1))//true\n```\n\n#### 转换方法\n\n```\nconsole.log(arr1.valueOf())//[1,2,3]\nconsole.log(arr1.toString())//1,2,3\nconsole.log(arr1.toLocaleString())//1,2,3（每一项调用的是toLocalString()方法）\nconsole.log(arr1.join('#'))//1#2#3\n```\n\n#### 栈方法\n\n```\nlet arr2 = [1,2,3]\narr2.push(4)\nconsole.log(arr2)//[1,2,3,4]\narr2.pop(4)\nconsole.log(arr2)//[1,2,3]\n```\n\n#### 对列方法\n\n```\nlet arr3 = [1,2,3]\narr3.unshift(0)//[0,1,2,3,4]\nconsole.log(arr3)\narr3.shift()\nconsole.log(arr3)\n```\n\n#### 排序方法\n\n```\nlet arr4 = [3,2,1]\narr4.reverse()//反转数组顺序\nconsole.log(arr4)\narr4.sort((a,b)=>{\n    return a - b\n})//由小到大\nconsole.log(arr4)\narr4.sort((a,b)=>{\n    return b - a\n})//由大到小\nconsole.log(arr4)\n\nlet arr5 = [1,2,'10']\nconsole.log(arr5.sort())//[1,'10',2]sort默认先toString()再排序\n```\n\n#### 操作方法\n\n```\nlet a1 = [1]\nlet a2 = [2]\nlet a3 = a1.concat(a2)\nconsole.log(a1)//[1]\nconsole.log(a2)//[2]\nconsole.log(a3)//[1,2]\n\nlet aa1 = [1,2,3,4,5]\nlet aa2 = aa1.slice(1,4)//slice()左闭右开\nlet aa3 = aa1.slice(1)\nconsole.log(aa1)//[1,2,3,4,5]\nconsole.log(aa2)//[2,3,4]\nconsole.log(aa3)//[2,3,4,5]\n```\n\n#### 删除、插入、替换\n\n- 删除splice(1,2)\\插入splice(2,0,'a','b')\\替换splice(1,2,3,4)\n\n```\nlet sa1 = [1,2,3,4,5]\nlet sa2 = sa1.splice(1,2,'a','b')//从1位置开始，删除两项，并添加'a'\\'b'两项\nconsole.log(sa1)\nconsole.log(sa2)//返回删除的数组\n```\n\n#### 位置方法\n\n```\nlet la = [1,2,3,2,1]\nconsole.log(la.indexOf(2))//1\nconsole.log(la.lastIndexOf(2))//3\n```\n\n#### 迭代方法\n\n- every()对数组中每一项进行运行给定函数，如果都返回true，则返回true\n- filter()对数组中每一项进行运行给定函数，如果都返回true，则返回true项组成的数组\n- forEach()对数组中每一项执行给定函数，没有返回值\n- map()对数组中每一项执行给定函数，返回每次函数调用结果返回的数组\n\n```\nlet ma = [1,2,3]\nlet ma1 = ma.map((item,index,arr)=>{\n    return 2\n})\nconsole.log(ma)//[1,2,3]\nconsole.log(ma1)//[2,2,2]\n```\n\n#### some()\n\n#### 归并方法reduce(),reduceRight()\n\n```\nlet ra = [1,2,3]\nlet res = ra.reduce((pre,cur,index,arr)=>{\n    return pre+cur\n})\nconsole.log(ra)\nconsole.log(res)\n```\n\n### ES6方法\n\n- ES6标准继续改进数组，添加了许多新功能，比如创建数组新方法、几个实用的方法、创建定型数组\n\n#### Array.of()\n\n- Array构造函数传入参数问题\n\n```\nlet arr = new Array(2)\nconsole.log(arr)//[undefined,undefined]\narr = new Array('2')\nconsole.log(arr)//['2']\narr = new Array(1,2)\nconsole.log(arr)//[1,2]\narr = new Array(2,'2')\nconsole.log(arr)//[2,'2']\n```\n\n- Array.of()方法总会创建一个包含所有参数的数组\n\n```\nlet arr1 = Array.of(1,2,3)\nconsole.log(arr1)//[1,2,3]\n```\n\n- 注意：Array.of()不使用Sympol.species属性返回确定的类型，而是使用of()方法中this()的值来返回数据类型\n\n#### Array.from()\n\n- js不支持直接将非数组对象转换为真实数组，如arguments，如果把它当做数组使用必须先转换该对象的类型\n- es5中的转换方法\n\n```\nfunction makeArray(arrayLike) {\n    var res = []\n    for(var i = 0;i<arrayLike.length;i++){\n        res.push(arrayLike[i])\n    }\n    //或者\n    // res = Array.prototype.slice().call(arrayLike)\n    return res\n}\n(function f(a,b,c) {\n    var arr = makeArray(arguments)\n    console.log(arr)//[1,2,3]\n})(1,2,3)\n```\n\n- Array.from()用来将对象转化为数组，可以接受可迭代对象或类数组对象作为第一个参数，第二个参数可以提供一个映射关系，将每一个值转换为其他形式，第三个参数用来表示映射函数this的值\n\n```\nfunction f1(a,b,c) {\n    let arr = Array.from(arguments,function (item) {\n        return item+this.a\n    },{a:1})\n    console.log(arr)//[3,4,5]\n}\nf1(2,3,4)\n```\n\n- 转换可迭代对象，如果一个对象即是类数组又是可迭代对象，那么会根据迭代器来决定转换哪个值\n\n```\nlet nums = {\n    *[Symbol.iterator](){\n        yield 1;\n        yield 2;\n        yield 3;\n    }\n}\nlet i_arr = Array.from(nums)\nconsole.log(i_arr)//[1,2,3]\n```\n\n#### find()\\findIndex()\n\n- find()返回找到的值、findIndex()返回找到值的位置，接收两个参数，一个是回调函数、一个是可选参数\n\n```\nlet n = [1,2,3,4,5]\nconsole.log(n.find(item=>item>2))//3\nconsole.log(n.findIndex(item=>item>2))//2\n```\n\n- 如果在数组中查找根据某个条件匹配的元素，使用find()，如果只是匹配某个元素值使用indexOf()\n\n#### fill()\n\n- fill()可以用指定的值填充一致多个数组元素\n\n```\nlet f_arr = [1,2,3,4]\nf_arr.fill(1)\nconsole.log(f_arr)//[1,1,1,1]\nf_arr.fill(0,1,3)\nconsole.log(f_arr)//[1,0,0,1]左闭右开\n```\n\n#### copyWithin()\n\n- copyWithin()从数组中复制元素的值\n\n```\nlet c_arr = [1,2,3,4,5]\nc_arr.copyWithin(2,0)\n```\n\n- console.log(c_arr)//[1,2,1,2,3]从索引2开始粘贴值，从索引0开始复制并持续到没有更多可复制的值\n\n#### 定型数组\n\n- 用于处理数值类型数据专用的数组\n- [定型数组](http://www.shaoqun.com/a/318331.html)\n\n#### Array.prototype.includes()\n\n- ES7语法\n\n```\nlet val = [1,2,3]\nconsole.log(val.includes(1))//true\n```\n","slug":"[ES6]改进数组功能","published":1,"updated":"2021-03-15T14:36:27.281Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dk3000kwotj9tus2wle","content":"<h3 id=\"常用数组方法\"><a href=\"#常用数组方法\" class=\"headerlink\" title=\"常用数组方法\"></a>常用数组方法</h3><h4 id=\"检测数组\"><a href=\"#检测数组\" class=\"headerlink\" title=\"检测数组\"></a>检测数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 &#x3D; [1,2,3]</span><br><span class=\"line\">console.log(Array.isArray(arr1))&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"转换方法\"><a href=\"#转换方法\" class=\"headerlink\" title=\"转换方法\"></a>转换方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(arr1.valueOf())&#x2F;&#x2F;[1,2,3]</span><br><span class=\"line\">console.log(arr1.toString())&#x2F;&#x2F;1,2,3</span><br><span class=\"line\">console.log(arr1.toLocaleString())&#x2F;&#x2F;1,2,3（每一项调用的是toLocalString()方法）</span><br><span class=\"line\">console.log(arr1.join(&#39;#&#39;))&#x2F;&#x2F;1#2#3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"栈方法\"><a href=\"#栈方法\" class=\"headerlink\" title=\"栈方法\"></a>栈方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr2 &#x3D; [1,2,3]</span><br><span class=\"line\">arr2.push(4)</span><br><span class=\"line\">console.log(arr2)&#x2F;&#x2F;[1,2,3,4]</span><br><span class=\"line\">arr2.pop(4)</span><br><span class=\"line\">console.log(arr2)&#x2F;&#x2F;[1,2,3]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对列方法\"><a href=\"#对列方法\" class=\"headerlink\" title=\"对列方法\"></a>对列方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr3 &#x3D; [1,2,3]</span><br><span class=\"line\">arr3.unshift(0)&#x2F;&#x2F;[0,1,2,3,4]</span><br><span class=\"line\">console.log(arr3)</span><br><span class=\"line\">arr3.shift()</span><br><span class=\"line\">console.log(arr3)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"排序方法\"><a href=\"#排序方法\" class=\"headerlink\" title=\"排序方法\"></a>排序方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr4 &#x3D; [3,2,1]</span><br><span class=\"line\">arr4.reverse()&#x2F;&#x2F;反转数组顺序</span><br><span class=\"line\">console.log(arr4)</span><br><span class=\"line\">arr4.sort((a,b)&#x3D;&gt;&#123;</span><br><span class=\"line\">    return a - b</span><br><span class=\"line\">&#125;)&#x2F;&#x2F;由小到大</span><br><span class=\"line\">console.log(arr4)</span><br><span class=\"line\">arr4.sort((a,b)&#x3D;&gt;&#123;</span><br><span class=\"line\">    return b - a</span><br><span class=\"line\">&#125;)&#x2F;&#x2F;由大到小</span><br><span class=\"line\">console.log(arr4)</span><br><span class=\"line\"></span><br><span class=\"line\">let arr5 &#x3D; [1,2,&#39;10&#39;]</span><br><span class=\"line\">console.log(arr5.sort())&#x2F;&#x2F;[1,&#39;10&#39;,2]sort默认先toString()再排序</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a1 &#x3D; [1]</span><br><span class=\"line\">let a2 &#x3D; [2]</span><br><span class=\"line\">let a3 &#x3D; a1.concat(a2)</span><br><span class=\"line\">console.log(a1)&#x2F;&#x2F;[1]</span><br><span class=\"line\">console.log(a2)&#x2F;&#x2F;[2]</span><br><span class=\"line\">console.log(a3)&#x2F;&#x2F;[1,2]</span><br><span class=\"line\"></span><br><span class=\"line\">let aa1 &#x3D; [1,2,3,4,5]</span><br><span class=\"line\">let aa2 &#x3D; aa1.slice(1,4)&#x2F;&#x2F;slice()左闭右开</span><br><span class=\"line\">let aa3 &#x3D; aa1.slice(1)</span><br><span class=\"line\">console.log(aa1)&#x2F;&#x2F;[1,2,3,4,5]</span><br><span class=\"line\">console.log(aa2)&#x2F;&#x2F;[2,3,4]</span><br><span class=\"line\">console.log(aa3)&#x2F;&#x2F;[2,3,4,5]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"删除、插入、替换\"><a href=\"#删除、插入、替换\" class=\"headerlink\" title=\"删除、插入、替换\"></a>删除、插入、替换</h4><ul>\n<li>删除splice(1,2)\\插入splice(2,0,’a’,’b’)\\替换splice(1,2,3,4)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let sa1 &#x3D; [1,2,3,4,5]</span><br><span class=\"line\">let sa2 &#x3D; sa1.splice(1,2,&#39;a&#39;,&#39;b&#39;)&#x2F;&#x2F;从1位置开始，删除两项，并添加&#39;a&#39;\\&#39;b&#39;两项</span><br><span class=\"line\">console.log(sa1)</span><br><span class=\"line\">console.log(sa2)&#x2F;&#x2F;返回删除的数组</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"位置方法\"><a href=\"#位置方法\" class=\"headerlink\" title=\"位置方法\"></a>位置方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let la &#x3D; [1,2,3,2,1]</span><br><span class=\"line\">console.log(la.indexOf(2))&#x2F;&#x2F;1</span><br><span class=\"line\">console.log(la.lastIndexOf(2))&#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"迭代方法\"><a href=\"#迭代方法\" class=\"headerlink\" title=\"迭代方法\"></a>迭代方法</h4><ul>\n<li>every()对数组中每一项进行运行给定函数，如果都返回true，则返回true</li>\n<li>filter()对数组中每一项进行运行给定函数，如果都返回true，则返回true项组成的数组</li>\n<li>forEach()对数组中每一项执行给定函数，没有返回值</li>\n<li>map()对数组中每一项执行给定函数，返回每次函数调用结果返回的数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ma &#x3D; [1,2,3]</span><br><span class=\"line\">let ma1 &#x3D; ma.map((item,index,arr)&#x3D;&gt;&#123;</span><br><span class=\"line\">    return 2</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(ma)&#x2F;&#x2F;[1,2,3]</span><br><span class=\"line\">console.log(ma1)&#x2F;&#x2F;[2,2,2]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some()\"></a>some()</h4><h4 id=\"归并方法reduce-reduceRight\"><a href=\"#归并方法reduce-reduceRight\" class=\"headerlink\" title=\"归并方法reduce(),reduceRight()\"></a>归并方法reduce(),reduceRight()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ra &#x3D; [1,2,3]</span><br><span class=\"line\">let res &#x3D; ra.reduce((pre,cur,index,arr)&#x3D;&gt;&#123;</span><br><span class=\"line\">    return pre+cur</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(ra)</span><br><span class=\"line\">console.log(res)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ES6方法\"><a href=\"#ES6方法\" class=\"headerlink\" title=\"ES6方法\"></a>ES6方法</h3><ul>\n<li>ES6标准继续改进数组，添加了许多新功能，比如创建数组新方法、几个实用的方法、创建定型数组</li>\n</ul>\n<h4 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h4><ul>\n<li>Array构造函数传入参数问题</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; new Array(2)</span><br><span class=\"line\">console.log(arr)&#x2F;&#x2F;[undefined,undefined]</span><br><span class=\"line\">arr &#x3D; new Array(&#39;2&#39;)</span><br><span class=\"line\">console.log(arr)&#x2F;&#x2F;[&#39;2&#39;]</span><br><span class=\"line\">arr &#x3D; new Array(1,2)</span><br><span class=\"line\">console.log(arr)&#x2F;&#x2F;[1,2]</span><br><span class=\"line\">arr &#x3D; new Array(2,&#39;2&#39;)</span><br><span class=\"line\">console.log(arr)&#x2F;&#x2F;[2,&#39;2&#39;]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Array.of()方法总会创建一个包含所有参数的数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 &#x3D; Array.of(1,2,3)</span><br><span class=\"line\">console.log(arr1)&#x2F;&#x2F;[1,2,3]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意：Array.of()不使用Sympol.species属性返回确定的类型，而是使用of()方法中this()的值来返回数据类型</li>\n</ul>\n<h4 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h4><ul>\n<li>js不支持直接将非数组对象转换为真实数组，如arguments，如果把它当做数组使用必须先转换该对象的类型</li>\n<li>es5中的转换方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function makeArray(arrayLike) &#123;</span><br><span class=\"line\">    var res &#x3D; []</span><br><span class=\"line\">    for(var i &#x3D; 0;i&lt;arrayLike.length;i++)&#123;</span><br><span class=\"line\">        res.push(arrayLike[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;或者</span><br><span class=\"line\">    &#x2F;&#x2F; res &#x3D; Array.prototype.slice().call(arrayLike)</span><br><span class=\"line\">    return res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(function f(a,b,c) &#123;</span><br><span class=\"line\">    var arr &#x3D; makeArray(arguments)</span><br><span class=\"line\">    console.log(arr)&#x2F;&#x2F;[1,2,3]</span><br><span class=\"line\">&#125;)(1,2,3)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Array.from()用来将对象转化为数组，可以接受可迭代对象或类数组对象作为第一个参数，第二个参数可以提供一个映射关系，将每一个值转换为其他形式，第三个参数用来表示映射函数this的值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1(a,b,c) &#123;</span><br><span class=\"line\">    let arr &#x3D; Array.from(arguments,function (item) &#123;</span><br><span class=\"line\">        return item+this.a</span><br><span class=\"line\">    &#125;,&#123;a:1&#125;)</span><br><span class=\"line\">    console.log(arr)&#x2F;&#x2F;[3,4,5]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f1(2,3,4)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>转换可迭代对象，如果一个对象即是类数组又是可迭代对象，那么会根据迭代器来决定转换哪个值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let nums &#x3D; &#123;</span><br><span class=\"line\">    *[Symbol.iterator]()&#123;</span><br><span class=\"line\">        yield 1;</span><br><span class=\"line\">        yield 2;</span><br><span class=\"line\">        yield 3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let i_arr &#x3D; Array.from(nums)</span><br><span class=\"line\">console.log(i_arr)&#x2F;&#x2F;[1,2,3]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"find-findIndex\"><a href=\"#find-findIndex\" class=\"headerlink\" title=\"find()\\findIndex()\"></a>find()\\findIndex()</h4><ul>\n<li>find()返回找到的值、findIndex()返回找到值的位置，接收两个参数，一个是回调函数、一个是可选参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let n &#x3D; [1,2,3,4,5]</span><br><span class=\"line\">console.log(n.find(item&#x3D;&gt;item&gt;2))&#x2F;&#x2F;3</span><br><span class=\"line\">console.log(n.findIndex(item&#x3D;&gt;item&gt;2))&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果在数组中查找根据某个条件匹配的元素，使用find()，如果只是匹配某个元素值使用indexOf()</li>\n</ul>\n<h4 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill()\"></a>fill()</h4><ul>\n<li>fill()可以用指定的值填充一致多个数组元素</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let f_arr &#x3D; [1,2,3,4]</span><br><span class=\"line\">f_arr.fill(1)</span><br><span class=\"line\">console.log(f_arr)&#x2F;&#x2F;[1,1,1,1]</span><br><span class=\"line\">f_arr.fill(0,1,3)</span><br><span class=\"line\">console.log(f_arr)&#x2F;&#x2F;[1,0,0,1]左闭右开</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"copyWithin\"><a href=\"#copyWithin\" class=\"headerlink\" title=\"copyWithin()\"></a>copyWithin()</h4><ul>\n<li>copyWithin()从数组中复制元素的值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let c_arr &#x3D; [1,2,3,4,5]</span><br><span class=\"line\">c_arr.copyWithin(2,0)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>console.log(c_arr)//[1,2,1,2,3]从索引2开始粘贴值，从索引0开始复制并持续到没有更多可复制的值</li>\n</ul>\n<h4 id=\"定型数组\"><a href=\"#定型数组\" class=\"headerlink\" title=\"定型数组\"></a>定型数组</h4><ul>\n<li>用于处理数值类型数据专用的数组</li>\n<li><a href=\"http://www.shaoqun.com/a/318331.html\">定型数组</a></li>\n</ul>\n<h4 id=\"Array-prototype-includes\"><a href=\"#Array-prototype-includes\" class=\"headerlink\" title=\"Array.prototype.includes()\"></a>Array.prototype.includes()</h4><ul>\n<li>ES7语法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let val &#x3D; [1,2,3]</span><br><span class=\"line\">console.log(val.includes(1))&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"常用数组方法\"><a href=\"#常用数组方法\" class=\"headerlink\" title=\"常用数组方法\"></a>常用数组方法</h3><h4 id=\"检测数组\"><a href=\"#检测数组\" class=\"headerlink\" title=\"检测数组\"></a>检测数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 &#x3D; [1,2,3]</span><br><span class=\"line\">console.log(Array.isArray(arr1))&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"转换方法\"><a href=\"#转换方法\" class=\"headerlink\" title=\"转换方法\"></a>转换方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(arr1.valueOf())&#x2F;&#x2F;[1,2,3]</span><br><span class=\"line\">console.log(arr1.toString())&#x2F;&#x2F;1,2,3</span><br><span class=\"line\">console.log(arr1.toLocaleString())&#x2F;&#x2F;1,2,3（每一项调用的是toLocalString()方法）</span><br><span class=\"line\">console.log(arr1.join(&#39;#&#39;))&#x2F;&#x2F;1#2#3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"栈方法\"><a href=\"#栈方法\" class=\"headerlink\" title=\"栈方法\"></a>栈方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr2 &#x3D; [1,2,3]</span><br><span class=\"line\">arr2.push(4)</span><br><span class=\"line\">console.log(arr2)&#x2F;&#x2F;[1,2,3,4]</span><br><span class=\"line\">arr2.pop(4)</span><br><span class=\"line\">console.log(arr2)&#x2F;&#x2F;[1,2,3]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"对列方法\"><a href=\"#对列方法\" class=\"headerlink\" title=\"对列方法\"></a>对列方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr3 &#x3D; [1,2,3]</span><br><span class=\"line\">arr3.unshift(0)&#x2F;&#x2F;[0,1,2,3,4]</span><br><span class=\"line\">console.log(arr3)</span><br><span class=\"line\">arr3.shift()</span><br><span class=\"line\">console.log(arr3)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"排序方法\"><a href=\"#排序方法\" class=\"headerlink\" title=\"排序方法\"></a>排序方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr4 &#x3D; [3,2,1]</span><br><span class=\"line\">arr4.reverse()&#x2F;&#x2F;反转数组顺序</span><br><span class=\"line\">console.log(arr4)</span><br><span class=\"line\">arr4.sort((a,b)&#x3D;&gt;&#123;</span><br><span class=\"line\">    return a - b</span><br><span class=\"line\">&#125;)&#x2F;&#x2F;由小到大</span><br><span class=\"line\">console.log(arr4)</span><br><span class=\"line\">arr4.sort((a,b)&#x3D;&gt;&#123;</span><br><span class=\"line\">    return b - a</span><br><span class=\"line\">&#125;)&#x2F;&#x2F;由大到小</span><br><span class=\"line\">console.log(arr4)</span><br><span class=\"line\"></span><br><span class=\"line\">let arr5 &#x3D; [1,2,&#39;10&#39;]</span><br><span class=\"line\">console.log(arr5.sort())&#x2F;&#x2F;[1,&#39;10&#39;,2]sort默认先toString()再排序</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a1 &#x3D; [1]</span><br><span class=\"line\">let a2 &#x3D; [2]</span><br><span class=\"line\">let a3 &#x3D; a1.concat(a2)</span><br><span class=\"line\">console.log(a1)&#x2F;&#x2F;[1]</span><br><span class=\"line\">console.log(a2)&#x2F;&#x2F;[2]</span><br><span class=\"line\">console.log(a3)&#x2F;&#x2F;[1,2]</span><br><span class=\"line\"></span><br><span class=\"line\">let aa1 &#x3D; [1,2,3,4,5]</span><br><span class=\"line\">let aa2 &#x3D; aa1.slice(1,4)&#x2F;&#x2F;slice()左闭右开</span><br><span class=\"line\">let aa3 &#x3D; aa1.slice(1)</span><br><span class=\"line\">console.log(aa1)&#x2F;&#x2F;[1,2,3,4,5]</span><br><span class=\"line\">console.log(aa2)&#x2F;&#x2F;[2,3,4]</span><br><span class=\"line\">console.log(aa3)&#x2F;&#x2F;[2,3,4,5]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"删除、插入、替换\"><a href=\"#删除、插入、替换\" class=\"headerlink\" title=\"删除、插入、替换\"></a>删除、插入、替换</h4><ul>\n<li>删除splice(1,2)\\插入splice(2,0,’a’,’b’)\\替换splice(1,2,3,4)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let sa1 &#x3D; [1,2,3,4,5]</span><br><span class=\"line\">let sa2 &#x3D; sa1.splice(1,2,&#39;a&#39;,&#39;b&#39;)&#x2F;&#x2F;从1位置开始，删除两项，并添加&#39;a&#39;\\&#39;b&#39;两项</span><br><span class=\"line\">console.log(sa1)</span><br><span class=\"line\">console.log(sa2)&#x2F;&#x2F;返回删除的数组</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"位置方法\"><a href=\"#位置方法\" class=\"headerlink\" title=\"位置方法\"></a>位置方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let la &#x3D; [1,2,3,2,1]</span><br><span class=\"line\">console.log(la.indexOf(2))&#x2F;&#x2F;1</span><br><span class=\"line\">console.log(la.lastIndexOf(2))&#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"迭代方法\"><a href=\"#迭代方法\" class=\"headerlink\" title=\"迭代方法\"></a>迭代方法</h4><ul>\n<li>every()对数组中每一项进行运行给定函数，如果都返回true，则返回true</li>\n<li>filter()对数组中每一项进行运行给定函数，如果都返回true，则返回true项组成的数组</li>\n<li>forEach()对数组中每一项执行给定函数，没有返回值</li>\n<li>map()对数组中每一项执行给定函数，返回每次函数调用结果返回的数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ma &#x3D; [1,2,3]</span><br><span class=\"line\">let ma1 &#x3D; ma.map((item,index,arr)&#x3D;&gt;&#123;</span><br><span class=\"line\">    return 2</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(ma)&#x2F;&#x2F;[1,2,3]</span><br><span class=\"line\">console.log(ma1)&#x2F;&#x2F;[2,2,2]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some()\"></a>some()</h4><h4 id=\"归并方法reduce-reduceRight\"><a href=\"#归并方法reduce-reduceRight\" class=\"headerlink\" title=\"归并方法reduce(),reduceRight()\"></a>归并方法reduce(),reduceRight()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ra &#x3D; [1,2,3]</span><br><span class=\"line\">let res &#x3D; ra.reduce((pre,cur,index,arr)&#x3D;&gt;&#123;</span><br><span class=\"line\">    return pre+cur</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(ra)</span><br><span class=\"line\">console.log(res)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ES6方法\"><a href=\"#ES6方法\" class=\"headerlink\" title=\"ES6方法\"></a>ES6方法</h3><ul>\n<li>ES6标准继续改进数组，添加了许多新功能，比如创建数组新方法、几个实用的方法、创建定型数组</li>\n</ul>\n<h4 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h4><ul>\n<li>Array构造函数传入参数问题</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; new Array(2)</span><br><span class=\"line\">console.log(arr)&#x2F;&#x2F;[undefined,undefined]</span><br><span class=\"line\">arr &#x3D; new Array(&#39;2&#39;)</span><br><span class=\"line\">console.log(arr)&#x2F;&#x2F;[&#39;2&#39;]</span><br><span class=\"line\">arr &#x3D; new Array(1,2)</span><br><span class=\"line\">console.log(arr)&#x2F;&#x2F;[1,2]</span><br><span class=\"line\">arr &#x3D; new Array(2,&#39;2&#39;)</span><br><span class=\"line\">console.log(arr)&#x2F;&#x2F;[2,&#39;2&#39;]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Array.of()方法总会创建一个包含所有参数的数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 &#x3D; Array.of(1,2,3)</span><br><span class=\"line\">console.log(arr1)&#x2F;&#x2F;[1,2,3]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意：Array.of()不使用Sympol.species属性返回确定的类型，而是使用of()方法中this()的值来返回数据类型</li>\n</ul>\n<h4 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h4><ul>\n<li>js不支持直接将非数组对象转换为真实数组，如arguments，如果把它当做数组使用必须先转换该对象的类型</li>\n<li>es5中的转换方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function makeArray(arrayLike) &#123;</span><br><span class=\"line\">    var res &#x3D; []</span><br><span class=\"line\">    for(var i &#x3D; 0;i&lt;arrayLike.length;i++)&#123;</span><br><span class=\"line\">        res.push(arrayLike[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F;或者</span><br><span class=\"line\">    &#x2F;&#x2F; res &#x3D; Array.prototype.slice().call(arrayLike)</span><br><span class=\"line\">    return res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(function f(a,b,c) &#123;</span><br><span class=\"line\">    var arr &#x3D; makeArray(arguments)</span><br><span class=\"line\">    console.log(arr)&#x2F;&#x2F;[1,2,3]</span><br><span class=\"line\">&#125;)(1,2,3)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Array.from()用来将对象转化为数组，可以接受可迭代对象或类数组对象作为第一个参数，第二个参数可以提供一个映射关系，将每一个值转换为其他形式，第三个参数用来表示映射函数this的值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1(a,b,c) &#123;</span><br><span class=\"line\">    let arr &#x3D; Array.from(arguments,function (item) &#123;</span><br><span class=\"line\">        return item+this.a</span><br><span class=\"line\">    &#125;,&#123;a:1&#125;)</span><br><span class=\"line\">    console.log(arr)&#x2F;&#x2F;[3,4,5]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f1(2,3,4)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>转换可迭代对象，如果一个对象即是类数组又是可迭代对象，那么会根据迭代器来决定转换哪个值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let nums &#x3D; &#123;</span><br><span class=\"line\">    *[Symbol.iterator]()&#123;</span><br><span class=\"line\">        yield 1;</span><br><span class=\"line\">        yield 2;</span><br><span class=\"line\">        yield 3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let i_arr &#x3D; Array.from(nums)</span><br><span class=\"line\">console.log(i_arr)&#x2F;&#x2F;[1,2,3]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"find-findIndex\"><a href=\"#find-findIndex\" class=\"headerlink\" title=\"find()\\findIndex()\"></a>find()\\findIndex()</h4><ul>\n<li>find()返回找到的值、findIndex()返回找到值的位置，接收两个参数，一个是回调函数、一个是可选参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let n &#x3D; [1,2,3,4,5]</span><br><span class=\"line\">console.log(n.find(item&#x3D;&gt;item&gt;2))&#x2F;&#x2F;3</span><br><span class=\"line\">console.log(n.findIndex(item&#x3D;&gt;item&gt;2))&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果在数组中查找根据某个条件匹配的元素，使用find()，如果只是匹配某个元素值使用indexOf()</li>\n</ul>\n<h4 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill()\"></a>fill()</h4><ul>\n<li>fill()可以用指定的值填充一致多个数组元素</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let f_arr &#x3D; [1,2,3,4]</span><br><span class=\"line\">f_arr.fill(1)</span><br><span class=\"line\">console.log(f_arr)&#x2F;&#x2F;[1,1,1,1]</span><br><span class=\"line\">f_arr.fill(0,1,3)</span><br><span class=\"line\">console.log(f_arr)&#x2F;&#x2F;[1,0,0,1]左闭右开</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"copyWithin\"><a href=\"#copyWithin\" class=\"headerlink\" title=\"copyWithin()\"></a>copyWithin()</h4><ul>\n<li>copyWithin()从数组中复制元素的值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let c_arr &#x3D; [1,2,3,4,5]</span><br><span class=\"line\">c_arr.copyWithin(2,0)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>console.log(c_arr)//[1,2,1,2,3]从索引2开始粘贴值，从索引0开始复制并持续到没有更多可复制的值</li>\n</ul>\n<h4 id=\"定型数组\"><a href=\"#定型数组\" class=\"headerlink\" title=\"定型数组\"></a>定型数组</h4><ul>\n<li>用于处理数值类型数据专用的数组</li>\n<li><a href=\"http://www.shaoqun.com/a/318331.html\">定型数组</a></li>\n</ul>\n<h4 id=\"Array-prototype-includes\"><a href=\"#Array-prototype-includes\" class=\"headerlink\" title=\"Array.prototype.includes()\"></a>Array.prototype.includes()</h4><ul>\n<li>ES7语法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let val &#x3D; [1,2,3]</span><br><span class=\"line\">console.log(val.includes(1))&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n"},{"title":"<ES6>解构","date":"2017-08-16T16:00:00.000Z","_content":"\n### 简介\n\n- 对象和数组是JS里面常用的两种数据结构，ES6中添加了简化任务的新特性：结构，是一种打破数据结构，拆分成更小部分的过程。\n\n### 解构对象\n\n```\nlet obj = {\n    a: 1,b: 2\n}\nlet {a,b} = obj//注意右侧要初始化程序\nconsole.log(a)//1\nconsole.log(b)//2\n```\n\n#### 解构赋值\n\n```\nlet a = 1,b = 1,obj = {a:2,b:2};//这里的;一定要加上，否则报错\n({a,b} = obj)//注意这里的括号要加上\nconsole.log(a)//2\nconsole.log(b)//2\n```\n\n#### 如果值为null或者undefined会导致程序抛出错误\n\n```\nlet {a,b} = null\n//报错:VM222:1 Uncaught TypeError: Cannot destructure property `a` of 'undefined' or 'null'.\n```\n\n#### 默认值\n\n```\nlet obj = {\n    a: 2\n}\nlet {a ,b = 1} = obj\nconsole.log(a)//2\nconsole.log(b)//1\n```\n\n#### 非同名局部变量赋值\n\n```\nlet obj = {\n    type: '1'\n}\nlet {type: localType} = obj\nconsole.log(localType)//'1'\n```\n\n#### 嵌套对象解构\n\n```\nlet obj = {\n    a: {\n        s: 4\n    }\n}\nlet {a: {s}} = obj//此时a不是绑定，只代表在对象中的检索属性位置\nconsole.log(s)//4\n```\n\n### 数组解构\n\n```\nlet arr = [1,2]\nlet [a,b] = arr\nconsole.log(a,b)//1  2\n```\n\n#### 数组解构赋值\n\n```\nlet arr2 = [3,4];//这个;符号必须要加\n[a,b] = arr2\nconsole.log(a,b)//3  4\n```\n\n#### 特殊用法，交换变量位置\n\n```\nlet m = 1,n=2;\n[m,n] = [n,m]\n```\n\n#### 默认值\n\n```\nlet arr = [1]\nlet [a,b=1] = arr\nconsole.log(a,b)//1  1\n```\n\n#### 嵌套解构\n\n```\nlet arr = [1,[1,2,3]]\nlet [h,[g]] = arr\nconsole.log(h,g)//1  1\n```\n\n#### 不定元素（不定元素一定要放在最后）\n\n```\nlet arr = [1,2,3,4,5]\nlet [a,...b] = arr\nconsole.log(b)//[2,3,4,5]\n```\n\n#### 不定元素可以解决数组克隆功能\n\n```\nlet arr = [1,2,3]\nlet arr1 = arr.concat()//ES5做法\nlet [...arr2] = arr//不定元素\n```\n\n### 混合解构\n\n```\nlet obj = {\n    a: [1, 2, 3],\n    b: 2\n};\nlet {\n    a: [c],\n        b\n} = obj\nconsole.log(c,b)\n```\n\n### 解构参数\n\n```\nconst defaultParams = {\n    a: 1,b:2\n}\nfunction Fun({a,b}=defaultParams) {\n    console.log(a)\n    console.log(b)\n}\nFun({a:3,b:4})\n```\n","source":"_posts/[ES6]解构.md","raw":"---\ntitle: <ES6>解构\ndate: 2017-08-17 00:00:00\ntags: [ES6,js]\ncategories: ES6\n---\n\n### 简介\n\n- 对象和数组是JS里面常用的两种数据结构，ES6中添加了简化任务的新特性：结构，是一种打破数据结构，拆分成更小部分的过程。\n\n### 解构对象\n\n```\nlet obj = {\n    a: 1,b: 2\n}\nlet {a,b} = obj//注意右侧要初始化程序\nconsole.log(a)//1\nconsole.log(b)//2\n```\n\n#### 解构赋值\n\n```\nlet a = 1,b = 1,obj = {a:2,b:2};//这里的;一定要加上，否则报错\n({a,b} = obj)//注意这里的括号要加上\nconsole.log(a)//2\nconsole.log(b)//2\n```\n\n#### 如果值为null或者undefined会导致程序抛出错误\n\n```\nlet {a,b} = null\n//报错:VM222:1 Uncaught TypeError: Cannot destructure property `a` of 'undefined' or 'null'.\n```\n\n#### 默认值\n\n```\nlet obj = {\n    a: 2\n}\nlet {a ,b = 1} = obj\nconsole.log(a)//2\nconsole.log(b)//1\n```\n\n#### 非同名局部变量赋值\n\n```\nlet obj = {\n    type: '1'\n}\nlet {type: localType} = obj\nconsole.log(localType)//'1'\n```\n\n#### 嵌套对象解构\n\n```\nlet obj = {\n    a: {\n        s: 4\n    }\n}\nlet {a: {s}} = obj//此时a不是绑定，只代表在对象中的检索属性位置\nconsole.log(s)//4\n```\n\n### 数组解构\n\n```\nlet arr = [1,2]\nlet [a,b] = arr\nconsole.log(a,b)//1  2\n```\n\n#### 数组解构赋值\n\n```\nlet arr2 = [3,4];//这个;符号必须要加\n[a,b] = arr2\nconsole.log(a,b)//3  4\n```\n\n#### 特殊用法，交换变量位置\n\n```\nlet m = 1,n=2;\n[m,n] = [n,m]\n```\n\n#### 默认值\n\n```\nlet arr = [1]\nlet [a,b=1] = arr\nconsole.log(a,b)//1  1\n```\n\n#### 嵌套解构\n\n```\nlet arr = [1,[1,2,3]]\nlet [h,[g]] = arr\nconsole.log(h,g)//1  1\n```\n\n#### 不定元素（不定元素一定要放在最后）\n\n```\nlet arr = [1,2,3,4,5]\nlet [a,...b] = arr\nconsole.log(b)//[2,3,4,5]\n```\n\n#### 不定元素可以解决数组克隆功能\n\n```\nlet arr = [1,2,3]\nlet arr1 = arr.concat()//ES5做法\nlet [...arr2] = arr//不定元素\n```\n\n### 混合解构\n\n```\nlet obj = {\n    a: [1, 2, 3],\n    b: 2\n};\nlet {\n    a: [c],\n        b\n} = obj\nconsole.log(c,b)\n```\n\n### 解构参数\n\n```\nconst defaultParams = {\n    a: 1,b:2\n}\nfunction Fun({a,b}=defaultParams) {\n    console.log(a)\n    console.log(b)\n}\nFun({a:3,b:4})\n```\n","slug":"[ES6]解构","published":1,"updated":"2021-03-15T14:36:40.988Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dk5000nwotj92uehy4f","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>对象和数组是JS里面常用的两种数据结构，ES6中添加了简化任务的新特性：结构，是一种打破数据结构，拆分成更小部分的过程。</li>\n</ul>\n<h3 id=\"解构对象\"><a href=\"#解构对象\" class=\"headerlink\" title=\"解构对象\"></a>解构对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    a: 1,b: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;a,b&#125; &#x3D; obj&#x2F;&#x2F;注意右侧要初始化程序</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;1</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; 1,b &#x3D; 1,obj &#x3D; &#123;a:2,b:2&#125;;&#x2F;&#x2F;这里的;一定要加上，否则报错</span><br><span class=\"line\">(&#123;a,b&#125; &#x3D; obj)&#x2F;&#x2F;注意这里的括号要加上</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;2</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"如果值为null或者undefined会导致程序抛出错误\"><a href=\"#如果值为null或者undefined会导致程序抛出错误\" class=\"headerlink\" title=\"如果值为null或者undefined会导致程序抛出错误\"></a>如果值为null或者undefined会导致程序抛出错误</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;a,b&#125; &#x3D; null</span><br><span class=\"line\">&#x2F;&#x2F;报错:VM222:1 Uncaught TypeError: Cannot destructure property &#96;a&#96; of &#39;undefined&#39; or &#39;null&#39;.</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    a: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;a ,b &#x3D; 1&#125; &#x3D; obj</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;2</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"非同名局部变量赋值\"><a href=\"#非同名局部变量赋值\" class=\"headerlink\" title=\"非同名局部变量赋值\"></a>非同名局部变量赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    type: &#39;1&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;type: localType&#125; &#x3D; obj</span><br><span class=\"line\">console.log(localType)&#x2F;&#x2F;&#39;1&#39;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"嵌套对象解构\"><a href=\"#嵌套对象解构\" class=\"headerlink\" title=\"嵌套对象解构\"></a>嵌套对象解构</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    a: &#123;</span><br><span class=\"line\">        s: 4</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;a: &#123;s&#125;&#125; &#x3D; obj&#x2F;&#x2F;此时a不是绑定，只代表在对象中的检索属性位置</span><br><span class=\"line\">console.log(s)&#x2F;&#x2F;4</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1,2]</span><br><span class=\"line\">let [a,b] &#x3D; arr</span><br><span class=\"line\">console.log(a,b)&#x2F;&#x2F;1  2</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组解构赋值\"><a href=\"#数组解构赋值\" class=\"headerlink\" title=\"数组解构赋值\"></a>数组解构赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr2 &#x3D; [3,4];&#x2F;&#x2F;这个;符号必须要加</span><br><span class=\"line\">[a,b] &#x3D; arr2</span><br><span class=\"line\">console.log(a,b)&#x2F;&#x2F;3  4</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"特殊用法，交换变量位置\"><a href=\"#特殊用法，交换变量位置\" class=\"headerlink\" title=\"特殊用法，交换变量位置\"></a>特殊用法，交换变量位置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let m &#x3D; 1,n&#x3D;2;</span><br><span class=\"line\">[m,n] &#x3D; [n,m]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"默认值-1\"><a href=\"#默认值-1\" class=\"headerlink\" title=\"默认值\"></a>默认值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1]</span><br><span class=\"line\">let [a,b&#x3D;1] &#x3D; arr</span><br><span class=\"line\">console.log(a,b)&#x2F;&#x2F;1  1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"嵌套解构\"><a href=\"#嵌套解构\" class=\"headerlink\" title=\"嵌套解构\"></a>嵌套解构</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1,[1,2,3]]</span><br><span class=\"line\">let [h,[g]] &#x3D; arr</span><br><span class=\"line\">console.log(h,g)&#x2F;&#x2F;1  1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不定元素（不定元素一定要放在最后）\"><a href=\"#不定元素（不定元素一定要放在最后）\" class=\"headerlink\" title=\"不定元素（不定元素一定要放在最后）\"></a>不定元素（不定元素一定要放在最后）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1,2,3,4,5]</span><br><span class=\"line\">let [a,...b] &#x3D; arr</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;[2,3,4,5]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不定元素可以解决数组克隆功能\"><a href=\"#不定元素可以解决数组克隆功能\" class=\"headerlink\" title=\"不定元素可以解决数组克隆功能\"></a>不定元素可以解决数组克隆功能</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1,2,3]</span><br><span class=\"line\">let arr1 &#x3D; arr.concat()&#x2F;&#x2F;ES5做法</span><br><span class=\"line\">let [...arr2] &#x3D; arr&#x2F;&#x2F;不定元素</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"混合解构\"><a href=\"#混合解构\" class=\"headerlink\" title=\"混合解构\"></a>混合解构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    a: [1, 2, 3],</span><br><span class=\"line\">    b: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let &#123;</span><br><span class=\"line\">    a: [c],</span><br><span class=\"line\">        b</span><br><span class=\"line\">&#125; &#x3D; obj</span><br><span class=\"line\">console.log(c,b)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解构参数\"><a href=\"#解构参数\" class=\"headerlink\" title=\"解构参数\"></a>解构参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const defaultParams &#x3D; &#123;</span><br><span class=\"line\">    a: 1,b:2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Fun(&#123;a,b&#125;&#x3D;defaultParams) &#123;</span><br><span class=\"line\">    console.log(a)</span><br><span class=\"line\">    console.log(b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun(&#123;a:3,b:4&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>对象和数组是JS里面常用的两种数据结构，ES6中添加了简化任务的新特性：结构，是一种打破数据结构，拆分成更小部分的过程。</li>\n</ul>\n<h3 id=\"解构对象\"><a href=\"#解构对象\" class=\"headerlink\" title=\"解构对象\"></a>解构对象</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    a: 1,b: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;a,b&#125; &#x3D; obj&#x2F;&#x2F;注意右侧要初始化程序</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;1</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; 1,b &#x3D; 1,obj &#x3D; &#123;a:2,b:2&#125;;&#x2F;&#x2F;这里的;一定要加上，否则报错</span><br><span class=\"line\">(&#123;a,b&#125; &#x3D; obj)&#x2F;&#x2F;注意这里的括号要加上</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;2</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"如果值为null或者undefined会导致程序抛出错误\"><a href=\"#如果值为null或者undefined会导致程序抛出错误\" class=\"headerlink\" title=\"如果值为null或者undefined会导致程序抛出错误\"></a>如果值为null或者undefined会导致程序抛出错误</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;a,b&#125; &#x3D; null</span><br><span class=\"line\">&#x2F;&#x2F;报错:VM222:1 Uncaught TypeError: Cannot destructure property &#96;a&#96; of &#39;undefined&#39; or &#39;null&#39;.</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    a: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;a ,b &#x3D; 1&#125; &#x3D; obj</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;2</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"非同名局部变量赋值\"><a href=\"#非同名局部变量赋值\" class=\"headerlink\" title=\"非同名局部变量赋值\"></a>非同名局部变量赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    type: &#39;1&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;type: localType&#125; &#x3D; obj</span><br><span class=\"line\">console.log(localType)&#x2F;&#x2F;&#39;1&#39;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"嵌套对象解构\"><a href=\"#嵌套对象解构\" class=\"headerlink\" title=\"嵌套对象解构\"></a>嵌套对象解构</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    a: &#123;</span><br><span class=\"line\">        s: 4</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;a: &#123;s&#125;&#125; &#x3D; obj&#x2F;&#x2F;此时a不是绑定，只代表在对象中的检索属性位置</span><br><span class=\"line\">console.log(s)&#x2F;&#x2F;4</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1,2]</span><br><span class=\"line\">let [a,b] &#x3D; arr</span><br><span class=\"line\">console.log(a,b)&#x2F;&#x2F;1  2</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数组解构赋值\"><a href=\"#数组解构赋值\" class=\"headerlink\" title=\"数组解构赋值\"></a>数组解构赋值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr2 &#x3D; [3,4];&#x2F;&#x2F;这个;符号必须要加</span><br><span class=\"line\">[a,b] &#x3D; arr2</span><br><span class=\"line\">console.log(a,b)&#x2F;&#x2F;3  4</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"特殊用法，交换变量位置\"><a href=\"#特殊用法，交换变量位置\" class=\"headerlink\" title=\"特殊用法，交换变量位置\"></a>特殊用法，交换变量位置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let m &#x3D; 1,n&#x3D;2;</span><br><span class=\"line\">[m,n] &#x3D; [n,m]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"默认值-1\"><a href=\"#默认值-1\" class=\"headerlink\" title=\"默认值\"></a>默认值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1]</span><br><span class=\"line\">let [a,b&#x3D;1] &#x3D; arr</span><br><span class=\"line\">console.log(a,b)&#x2F;&#x2F;1  1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"嵌套解构\"><a href=\"#嵌套解构\" class=\"headerlink\" title=\"嵌套解构\"></a>嵌套解构</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1,[1,2,3]]</span><br><span class=\"line\">let [h,[g]] &#x3D; arr</span><br><span class=\"line\">console.log(h,g)&#x2F;&#x2F;1  1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不定元素（不定元素一定要放在最后）\"><a href=\"#不定元素（不定元素一定要放在最后）\" class=\"headerlink\" title=\"不定元素（不定元素一定要放在最后）\"></a>不定元素（不定元素一定要放在最后）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1,2,3,4,5]</span><br><span class=\"line\">let [a,...b] &#x3D; arr</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;[2,3,4,5]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"不定元素可以解决数组克隆功能\"><a href=\"#不定元素可以解决数组克隆功能\" class=\"headerlink\" title=\"不定元素可以解决数组克隆功能\"></a>不定元素可以解决数组克隆功能</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1,2,3]</span><br><span class=\"line\">let arr1 &#x3D; arr.concat()&#x2F;&#x2F;ES5做法</span><br><span class=\"line\">let [...arr2] &#x3D; arr&#x2F;&#x2F;不定元素</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"混合解构\"><a href=\"#混合解构\" class=\"headerlink\" title=\"混合解构\"></a>混合解构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    a: [1, 2, 3],</span><br><span class=\"line\">    b: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let &#123;</span><br><span class=\"line\">    a: [c],</span><br><span class=\"line\">        b</span><br><span class=\"line\">&#125; &#x3D; obj</span><br><span class=\"line\">console.log(c,b)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"解构参数\"><a href=\"#解构参数\" class=\"headerlink\" title=\"解构参数\"></a>解构参数</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const defaultParams &#x3D; &#123;</span><br><span class=\"line\">    a: 1,b:2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Fun(&#123;a,b&#125;&#x3D;defaultParams) &#123;</span><br><span class=\"line\">    console.log(a)</span><br><span class=\"line\">    console.log(b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun(&#123;a:3,b:4&#125;)</span><br></pre></td></tr></table></figure>\n"},{"title":"<ES6>模块化","date":"2019-02-10T16:00:00.000Z","_content":"\n### 简介\n\n - ES6之前，在应用的每一个js定义中都共享一个全局作用域，会引起命名冲突和安全问题。\n - ES6为了解决作用域问题，引入了模块。\n - 模块是自动运行在严格模式下的js代码，在模块顶部创建的变量不会被加到全局作用域中，这个变量仅在模块的顶级作用域存在，模块可以导入导出。\n - 在模块的顶部，this的值是undefined，模块不支持HTML风格代码注释。\n\n### 基本语法\n\n#### 导出\n\n```\nexport var a = 1\nexport function b(){}\nexport class c(){}\n```\n\n- 使用default关键字可以导出匿名函数或者类\n\n#### 导入\n\n```\nimport {a,b,c} from 'a.js'\n```\n\n- 导入整个模块\n\n```\nimport * as A from 'a.js'\n```\n\n- 不管import语句在一个模块执行多少次，只会执行一次\n\n```\n//a.js只会执行一次\nimport {a} from 'a.js'\nimport {b} from 'a.js'\nimport {c} from 'a.js'\n```\n\n- export和import限制必须在其他语句和函数之外使用\n\n```\nif(true){\n    export var a = 1//语法错误\n}\n```\n\n```\n//不能在一条语句中使用import\nfunction fun(){\n    import {a} from 'a.js'\n}\n```\n\n- ES6的import语句为函数、变量、类创建的是只读绑定，而不是像正常变量一样简单引用原始绑定\n\n```\nexport var a = 1\n\nimport {a} from 'a.js'\na = 2//抛出错误\n```\n\n- 导入重命名\n\n```\nimport {a as A} from 'a.js'\n```\n\n#### 模块的默认值\n\n```\nexport default a\nexport {a as default}\n```\n```\n//导入默认值和其他值\nimport a,{b,c} from 'a.js'\n```\n\n#### 无绑定导入\n\n- 某些模块可能不导出任何东西，只是修改全局作用域中的对象\n- 无绑定导入可以用来创建polyfill和shim\n\n```\nimport './a.js'\n```\n","source":"_posts/[ES6]模块化.md","raw":"---\ntitle: <ES6>模块化\ndate: 2019-02-11 00:00:00\ntags: [ES6,js]\ncategories: ES6\n---\n\n### 简介\n\n - ES6之前，在应用的每一个js定义中都共享一个全局作用域，会引起命名冲突和安全问题。\n - ES6为了解决作用域问题，引入了模块。\n - 模块是自动运行在严格模式下的js代码，在模块顶部创建的变量不会被加到全局作用域中，这个变量仅在模块的顶级作用域存在，模块可以导入导出。\n - 在模块的顶部，this的值是undefined，模块不支持HTML风格代码注释。\n\n### 基本语法\n\n#### 导出\n\n```\nexport var a = 1\nexport function b(){}\nexport class c(){}\n```\n\n- 使用default关键字可以导出匿名函数或者类\n\n#### 导入\n\n```\nimport {a,b,c} from 'a.js'\n```\n\n- 导入整个模块\n\n```\nimport * as A from 'a.js'\n```\n\n- 不管import语句在一个模块执行多少次，只会执行一次\n\n```\n//a.js只会执行一次\nimport {a} from 'a.js'\nimport {b} from 'a.js'\nimport {c} from 'a.js'\n```\n\n- export和import限制必须在其他语句和函数之外使用\n\n```\nif(true){\n    export var a = 1//语法错误\n}\n```\n\n```\n//不能在一条语句中使用import\nfunction fun(){\n    import {a} from 'a.js'\n}\n```\n\n- ES6的import语句为函数、变量、类创建的是只读绑定，而不是像正常变量一样简单引用原始绑定\n\n```\nexport var a = 1\n\nimport {a} from 'a.js'\na = 2//抛出错误\n```\n\n- 导入重命名\n\n```\nimport {a as A} from 'a.js'\n```\n\n#### 模块的默认值\n\n```\nexport default a\nexport {a as default}\n```\n```\n//导入默认值和其他值\nimport a,{b,c} from 'a.js'\n```\n\n#### 无绑定导入\n\n- 某些模块可能不导出任何东西，只是修改全局作用域中的对象\n- 无绑定导入可以用来创建polyfill和shim\n\n```\nimport './a.js'\n```\n","slug":"[ES6]模块化","published":1,"updated":"2021-03-15T14:36:55.378Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dk6000qwotj6svv7rn9","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>ES6之前，在应用的每一个js定义中都共享一个全局作用域，会引起命名冲突和安全问题。</li>\n<li>ES6为了解决作用域问题，引入了模块。</li>\n<li>模块是自动运行在严格模式下的js代码，在模块顶部创建的变量不会被加到全局作用域中，这个变量仅在模块的顶级作用域存在，模块可以导入导出。</li>\n<li>在模块的顶部，this的值是undefined，模块不支持HTML风格代码注释。</li>\n</ul>\n<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><h4 id=\"导出\"><a href=\"#导出\" class=\"headerlink\" title=\"导出\"></a>导出</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export var a &#x3D; 1</span><br><span class=\"line\">export function b()&#123;&#125;</span><br><span class=\"line\">export class c()&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用default关键字可以导出匿名函数或者类</li>\n</ul>\n<h4 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;a,b,c&#125; from &#39;a.js&#39;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>导入整个模块</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as A from &#39;a.js&#39;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>不管import语句在一个模块执行多少次，只会执行一次</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;a.js只会执行一次</span><br><span class=\"line\">import &#123;a&#125; from &#39;a.js&#39;</span><br><span class=\"line\">import &#123;b&#125; from &#39;a.js&#39;</span><br><span class=\"line\">import &#123;c&#125; from &#39;a.js&#39;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>export和import限制必须在其他语句和函数之外使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    export var a &#x3D; 1&#x2F;&#x2F;语法错误</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;不能在一条语句中使用import</span><br><span class=\"line\">function fun()&#123;</span><br><span class=\"line\">    import &#123;a&#125; from &#39;a.js&#39;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES6的import语句为函数、变量、类创建的是只读绑定，而不是像正常变量一样简单引用原始绑定</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export var a &#x3D; 1</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;a&#125; from &#39;a.js&#39;</span><br><span class=\"line\">a &#x3D; 2&#x2F;&#x2F;抛出错误</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>导入重命名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;a as A&#125; from &#39;a.js&#39;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"模块的默认值\"><a href=\"#模块的默认值\" class=\"headerlink\" title=\"模块的默认值\"></a>模块的默认值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default a</span><br><span class=\"line\">export &#123;a as default&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;导入默认值和其他值</span><br><span class=\"line\">import a,&#123;b,c&#125; from &#39;a.js&#39;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"无绑定导入\"><a href=\"#无绑定导入\" class=\"headerlink\" title=\"无绑定导入\"></a>无绑定导入</h4><ul>\n<li>某些模块可能不导出任何东西，只是修改全局作用域中的对象</li>\n<li>无绑定导入可以用来创建polyfill和shim</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#39;.&#x2F;a.js&#39;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>ES6之前，在应用的每一个js定义中都共享一个全局作用域，会引起命名冲突和安全问题。</li>\n<li>ES6为了解决作用域问题，引入了模块。</li>\n<li>模块是自动运行在严格模式下的js代码，在模块顶部创建的变量不会被加到全局作用域中，这个变量仅在模块的顶级作用域存在，模块可以导入导出。</li>\n<li>在模块的顶部，this的值是undefined，模块不支持HTML风格代码注释。</li>\n</ul>\n<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><h4 id=\"导出\"><a href=\"#导出\" class=\"headerlink\" title=\"导出\"></a>导出</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export var a &#x3D; 1</span><br><span class=\"line\">export function b()&#123;&#125;</span><br><span class=\"line\">export class c()&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用default关键字可以导出匿名函数或者类</li>\n</ul>\n<h4 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;a,b,c&#125; from &#39;a.js&#39;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>导入整个模块</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as A from &#39;a.js&#39;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>不管import语句在一个模块执行多少次，只会执行一次</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;a.js只会执行一次</span><br><span class=\"line\">import &#123;a&#125; from &#39;a.js&#39;</span><br><span class=\"line\">import &#123;b&#125; from &#39;a.js&#39;</span><br><span class=\"line\">import &#123;c&#125; from &#39;a.js&#39;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>export和import限制必须在其他语句和函数之外使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    export var a &#x3D; 1&#x2F;&#x2F;语法错误</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;不能在一条语句中使用import</span><br><span class=\"line\">function fun()&#123;</span><br><span class=\"line\">    import &#123;a&#125; from &#39;a.js&#39;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>ES6的import语句为函数、变量、类创建的是只读绑定，而不是像正常变量一样简单引用原始绑定</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export var a &#x3D; 1</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;a&#125; from &#39;a.js&#39;</span><br><span class=\"line\">a &#x3D; 2&#x2F;&#x2F;抛出错误</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>导入重命名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;a as A&#125; from &#39;a.js&#39;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"模块的默认值\"><a href=\"#模块的默认值\" class=\"headerlink\" title=\"模块的默认值\"></a>模块的默认值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default a</span><br><span class=\"line\">export &#123;a as default&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;导入默认值和其他值</span><br><span class=\"line\">import a,&#123;b,c&#125; from &#39;a.js&#39;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"无绑定导入\"><a href=\"#无绑定导入\" class=\"headerlink\" title=\"无绑定导入\"></a>无绑定导入</h4><ul>\n<li>某些模块可能不导出任何东西，只是修改全局作用域中的对象</li>\n<li>无绑定导入可以用来创建polyfill和shim</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#39;.&#x2F;a.js&#39;</span><br></pre></td></tr></table></figure>\n"},{"title":"<css>flexible布局&1px解决方案","date":"2019-01-20T15:11:44.000Z","_content":"\n### 视口概念\n\n- https://crazyaguai.github.io/2019/01/20/%E8%A7%86%E5%8F%A3%E6%A6%82%E5%BF%B5/\n\n### flexble布局\n\n1. 把布局视口分为10份，设置html元素font-size大小。\n\n```\nvar rem = docEl.clientWidth / 10\ndocEl.style.fontSize = rem + 'px'\n```\n\n2. 基本宽度 = UI设计稿宽度 / 10，元素尺寸使用rem单位，即元素尺寸 = 元素设计稿尺寸 / 基本宽度，这样实现按比例自适应尺寸。\n3. 转换rem尺寸方式\n\n- 使用postcss插件：[postcss-plugin-px2rem](https://github.com/pigcan/postcss-plugin-px2rem)\n\n```\n//.postcssrc.js文件配置\nmodule.exports = {\n    \"plugins\": {\n        \"postcss-import\": {},\n        \"postcss-url\": {},\n        \"postcss-plugin-px2rem\": {\n            rootValue: 37.5,\n            propBlackList: ['border'],//border不转换\n            exclude: [/((src)|(node_modules))/],//特定文件夹不转换\n        },\n        // 浏览器兼容部分在package.json中\n        \"autoprefixer\": {}\n    }\n}\n```\n\n- 编写sass函数转换\n\n```\n@function px2em($px, $base-font-size: 37.5px) {\n    @return ($px / $base-font-size) * 1rem;\n}\n```\n\n### 1px边框解决方法\n\n```\nfunction fix1px() {\n    var metas = document.querySelectorAll('meta')\n    metas.forEach(item=>{\n        if(item.name == 'viewport'){\n            document.getElementsByTagName('head')[0].removeChild(item)\n        }\n    })\n\n    //解决1px线问题\n    var scale = 1/dpr\n    var meta = document.createElement('meta')\n    meta.setAttribute('name', 'viewport')\n    meta.setAttribute('content', 'width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no')\n    document.getElementsByTagName('head')[0].appendChild(meta)\n}\n```\n\n- dpr=2时meta\n\n```\n<meta name=\"viewport\" content=\"width=device-width initial-scale=0.5 maximum-scale=0.5 minimum-scale=0.5 user-scalable=no\">\n```\n\n- 解读：首先设置width=device-width，布局视口=理想视口（此时1css像素=2物理像素），同时理想视口=视觉视口，因此布局视口=视觉视口，initial-scale=0.5，会使布局视口和视觉视口扩大为原来2倍，布局视口仍然=视觉视口，所以会在整个屏幕显示，同时1css像素=1物理像素，解决了边框问题。\n- 开发时，如果使用postcss插件，配置不转换边框，需要转换的border属性（比如用border画三角形）可以自己转换成rem尺寸。\n\n### 方案代码\n\n```\n(function flexible(window, document) {\n    var docEl = document.documentElement\n    var dpr = window.devicePixelRatio || 1\n    // adjust body font size\n    function setBodyFontSize() {\n        if (document.body) {\n            document.body.style.fontSize = (12 * dpr) + 'px'\n        }\n        else {\n            document.addEventListener('DOMContentLoaded', setBodyFontSize)\n        }\n    }\n\n    setBodyFontSize();\n\n    // set 1rem = viewWidth / 10\n    function setRemUnit() {\n        fix1px()\n        var rem = docEl.clientWidth / 10\n        docEl.style.fontSize = rem + 'px'\n    }\n\n    setRemUnit()\n\n    // reset rem unit on page resize\n    window.addEventListener('resize', setRemUnit)\n    window.addEventListener('pageshow', function (e) {\n        if (e.persisted) {\n            setRemUnit()\n        }\n    })\n\n    // detect 0.5px supports\n    if (dpr >= 2) {\n        var fakeBody = document.createElement('body')\n        var testElement = document.createElement('div')\n        testElement.style.border = '.5px solid transparent'\n        fakeBody.appendChild(testElement)\n        docEl.appendChild(fakeBody)\n        if (testElement.offsetHeight === 1) {\n            docEl.classList.add('hairlines')\n        }\n        docEl.removeChild(fakeBody)\n    }\n\n    function fix1px() {\n        var metas = document.querySelectorAll('meta')\n        metas.forEach(item=>{\n            if(item.name == 'viewport'){\n                document.getElementsByTagName('head')[0].removeChild(item)\n            }\n        })\n\n        //解决1px线问题\n        var scale = 1/dpr\n        var meta = document.createElement('meta')\n        meta.setAttribute('name', 'viewport')\n        meta.setAttribute('content', 'width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no')\n        document.getElementsByTagName('head')[0].appendChild(meta)\n    }\n}(window, document))\n```\n","source":"_posts/[css]flexible布局&1px解决方案.md","raw":"---\ntitle: <css>flexible布局&1px解决方案\ndate: 2019-01-20 23:11:44\ntags: [flexible,h5]\ncategories: flexible\n---\n\n### 视口概念\n\n- https://crazyaguai.github.io/2019/01/20/%E8%A7%86%E5%8F%A3%E6%A6%82%E5%BF%B5/\n\n### flexble布局\n\n1. 把布局视口分为10份，设置html元素font-size大小。\n\n```\nvar rem = docEl.clientWidth / 10\ndocEl.style.fontSize = rem + 'px'\n```\n\n2. 基本宽度 = UI设计稿宽度 / 10，元素尺寸使用rem单位，即元素尺寸 = 元素设计稿尺寸 / 基本宽度，这样实现按比例自适应尺寸。\n3. 转换rem尺寸方式\n\n- 使用postcss插件：[postcss-plugin-px2rem](https://github.com/pigcan/postcss-plugin-px2rem)\n\n```\n//.postcssrc.js文件配置\nmodule.exports = {\n    \"plugins\": {\n        \"postcss-import\": {},\n        \"postcss-url\": {},\n        \"postcss-plugin-px2rem\": {\n            rootValue: 37.5,\n            propBlackList: ['border'],//border不转换\n            exclude: [/((src)|(node_modules))/],//特定文件夹不转换\n        },\n        // 浏览器兼容部分在package.json中\n        \"autoprefixer\": {}\n    }\n}\n```\n\n- 编写sass函数转换\n\n```\n@function px2em($px, $base-font-size: 37.5px) {\n    @return ($px / $base-font-size) * 1rem;\n}\n```\n\n### 1px边框解决方法\n\n```\nfunction fix1px() {\n    var metas = document.querySelectorAll('meta')\n    metas.forEach(item=>{\n        if(item.name == 'viewport'){\n            document.getElementsByTagName('head')[0].removeChild(item)\n        }\n    })\n\n    //解决1px线问题\n    var scale = 1/dpr\n    var meta = document.createElement('meta')\n    meta.setAttribute('name', 'viewport')\n    meta.setAttribute('content', 'width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no')\n    document.getElementsByTagName('head')[0].appendChild(meta)\n}\n```\n\n- dpr=2时meta\n\n```\n<meta name=\"viewport\" content=\"width=device-width initial-scale=0.5 maximum-scale=0.5 minimum-scale=0.5 user-scalable=no\">\n```\n\n- 解读：首先设置width=device-width，布局视口=理想视口（此时1css像素=2物理像素），同时理想视口=视觉视口，因此布局视口=视觉视口，initial-scale=0.5，会使布局视口和视觉视口扩大为原来2倍，布局视口仍然=视觉视口，所以会在整个屏幕显示，同时1css像素=1物理像素，解决了边框问题。\n- 开发时，如果使用postcss插件，配置不转换边框，需要转换的border属性（比如用border画三角形）可以自己转换成rem尺寸。\n\n### 方案代码\n\n```\n(function flexible(window, document) {\n    var docEl = document.documentElement\n    var dpr = window.devicePixelRatio || 1\n    // adjust body font size\n    function setBodyFontSize() {\n        if (document.body) {\n            document.body.style.fontSize = (12 * dpr) + 'px'\n        }\n        else {\n            document.addEventListener('DOMContentLoaded', setBodyFontSize)\n        }\n    }\n\n    setBodyFontSize();\n\n    // set 1rem = viewWidth / 10\n    function setRemUnit() {\n        fix1px()\n        var rem = docEl.clientWidth / 10\n        docEl.style.fontSize = rem + 'px'\n    }\n\n    setRemUnit()\n\n    // reset rem unit on page resize\n    window.addEventListener('resize', setRemUnit)\n    window.addEventListener('pageshow', function (e) {\n        if (e.persisted) {\n            setRemUnit()\n        }\n    })\n\n    // detect 0.5px supports\n    if (dpr >= 2) {\n        var fakeBody = document.createElement('body')\n        var testElement = document.createElement('div')\n        testElement.style.border = '.5px solid transparent'\n        fakeBody.appendChild(testElement)\n        docEl.appendChild(fakeBody)\n        if (testElement.offsetHeight === 1) {\n            docEl.classList.add('hairlines')\n        }\n        docEl.removeChild(fakeBody)\n    }\n\n    function fix1px() {\n        var metas = document.querySelectorAll('meta')\n        metas.forEach(item=>{\n            if(item.name == 'viewport'){\n                document.getElementsByTagName('head')[0].removeChild(item)\n            }\n        })\n\n        //解决1px线问题\n        var scale = 1/dpr\n        var meta = document.createElement('meta')\n        meta.setAttribute('name', 'viewport')\n        meta.setAttribute('content', 'width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no')\n        document.getElementsByTagName('head')[0].appendChild(meta)\n    }\n}(window, document))\n```\n","slug":"[css]flexible布局&1px解决方案","published":1,"updated":"2021-03-15T14:35:57.505Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dk7000twotjfcy43b9i","content":"<h3 id=\"视口概念\"><a href=\"#视口概念\" class=\"headerlink\" title=\"视口概念\"></a>视口概念</h3><ul>\n<li><a href=\"https://crazyaguai.github.io/2019/01/20/%E8%A7%86%E5%8F%A3%E6%A6%82%E5%BF%B5/\">https://crazyaguai.github.io/2019/01/20/%E8%A7%86%E5%8F%A3%E6%A6%82%E5%BF%B5/</a></li>\n</ul>\n<h3 id=\"flexble布局\"><a href=\"#flexble布局\" class=\"headerlink\" title=\"flexble布局\"></a>flexble布局</h3><ol>\n<li>把布局视口分为10份，设置html元素font-size大小。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var rem &#x3D; docEl.clientWidth &#x2F; 10</span><br><span class=\"line\">docEl.style.fontSize &#x3D; rem + &#39;px&#39;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>基本宽度 = UI设计稿宽度 / 10，元素尺寸使用rem单位，即元素尺寸 = 元素设计稿尺寸 / 基本宽度，这样实现按比例自适应尺寸。</li>\n<li>转换rem尺寸方式</li>\n</ol>\n<ul>\n<li>使用postcss插件：<a href=\"https://github.com/pigcan/postcss-plugin-px2rem\">postcss-plugin-px2rem</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;.postcssrc.js文件配置</span><br><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">    &quot;plugins&quot;: &#123;</span><br><span class=\"line\">        &quot;postcss-import&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-url&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-plugin-px2rem&quot;: &#123;</span><br><span class=\"line\">            rootValue: 37.5,</span><br><span class=\"line\">            propBlackList: [&#39;border&#39;],&#x2F;&#x2F;border不转换</span><br><span class=\"line\">            exclude: [&#x2F;((src)|(node_modules))&#x2F;],&#x2F;&#x2F;特定文件夹不转换</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#x2F;&#x2F; 浏览器兼容部分在package.json中</span><br><span class=\"line\">        &quot;autoprefixer&quot;: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编写sass函数转换</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function px2em($px, $base-font-size: 37.5px) &#123;</span><br><span class=\"line\">    @return ($px &#x2F; $base-font-size) * 1rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1px边框解决方法\"><a href=\"#1px边框解决方法\" class=\"headerlink\" title=\"1px边框解决方法\"></a>1px边框解决方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fix1px() &#123;</span><br><span class=\"line\">    var metas &#x3D; document.querySelectorAll(&#39;meta&#39;)</span><br><span class=\"line\">    metas.forEach(item&#x3D;&gt;&#123;</span><br><span class=\"line\">        if(item.name &#x3D;&#x3D; &#39;viewport&#39;)&#123;</span><br><span class=\"line\">            document.getElementsByTagName(&#39;head&#39;)[0].removeChild(item)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;解决1px线问题</span><br><span class=\"line\">    var scale &#x3D; 1&#x2F;dpr</span><br><span class=\"line\">    var meta &#x3D; document.createElement(&#39;meta&#39;)</span><br><span class=\"line\">    meta.setAttribute(&#39;name&#39;, &#39;viewport&#39;)</span><br><span class=\"line\">    meta.setAttribute(&#39;content&#39;, &#39;width&#x3D;device-width,initial-scale&#x3D;&#39; + scale + &#39;, maximum-scale&#x3D;&#39; + scale + &#39;, minimum-scale&#x3D;&#39; + scale + &#39;, user-scalable&#x3D;no&#39;)</span><br><span class=\"line\">    document.getElementsByTagName(&#39;head&#39;)[0].appendChild(meta)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>dpr=2时meta</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width initial-scale&#x3D;0.5 maximum-scale&#x3D;0.5 minimum-scale&#x3D;0.5 user-scalable&#x3D;no&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>解读：首先设置width=device-width，布局视口=理想视口（此时1css像素=2物理像素），同时理想视口=视觉视口，因此布局视口=视觉视口，initial-scale=0.5，会使布局视口和视觉视口扩大为原来2倍，布局视口仍然=视觉视口，所以会在整个屏幕显示，同时1css像素=1物理像素，解决了边框问题。</li>\n<li>开发时，如果使用postcss插件，配置不转换边框，需要转换的border属性（比如用border画三角形）可以自己转换成rem尺寸。</li>\n</ul>\n<h3 id=\"方案代码\"><a href=\"#方案代码\" class=\"headerlink\" title=\"方案代码\"></a>方案代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function flexible(window, document) &#123;</span><br><span class=\"line\">    var docEl &#x3D; document.documentElement</span><br><span class=\"line\">    var dpr &#x3D; window.devicePixelRatio || 1</span><br><span class=\"line\">    &#x2F;&#x2F; adjust body font size</span><br><span class=\"line\">    function setBodyFontSize() &#123;</span><br><span class=\"line\">        if (document.body) &#123;</span><br><span class=\"line\">            document.body.style.fontSize &#x3D; (12 * dpr) + &#39;px&#39;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            document.addEventListener(&#39;DOMContentLoaded&#39;, setBodyFontSize)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    setBodyFontSize();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; set 1rem &#x3D; viewWidth &#x2F; 10</span><br><span class=\"line\">    function setRemUnit() &#123;</span><br><span class=\"line\">        fix1px()</span><br><span class=\"line\">        var rem &#x3D; docEl.clientWidth &#x2F; 10</span><br><span class=\"line\">        docEl.style.fontSize &#x3D; rem + &#39;px&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    setRemUnit()</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; reset rem unit on page resize</span><br><span class=\"line\">    window.addEventListener(&#39;resize&#39;, setRemUnit)</span><br><span class=\"line\">    window.addEventListener(&#39;pageshow&#39;, function (e) &#123;</span><br><span class=\"line\">        if (e.persisted) &#123;</span><br><span class=\"line\">            setRemUnit()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; detect 0.5px supports</span><br><span class=\"line\">    if (dpr &gt;&#x3D; 2) &#123;</span><br><span class=\"line\">        var fakeBody &#x3D; document.createElement(&#39;body&#39;)</span><br><span class=\"line\">        var testElement &#x3D; document.createElement(&#39;div&#39;)</span><br><span class=\"line\">        testElement.style.border &#x3D; &#39;.5px solid transparent&#39;</span><br><span class=\"line\">        fakeBody.appendChild(testElement)</span><br><span class=\"line\">        docEl.appendChild(fakeBody)</span><br><span class=\"line\">        if (testElement.offsetHeight &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class=\"line\">            docEl.classList.add(&#39;hairlines&#39;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        docEl.removeChild(fakeBody)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function fix1px() &#123;</span><br><span class=\"line\">        var metas &#x3D; document.querySelectorAll(&#39;meta&#39;)</span><br><span class=\"line\">        metas.forEach(item&#x3D;&gt;&#123;</span><br><span class=\"line\">            if(item.name &#x3D;&#x3D; &#39;viewport&#39;)&#123;</span><br><span class=\"line\">                document.getElementsByTagName(&#39;head&#39;)[0].removeChild(item)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;解决1px线问题</span><br><span class=\"line\">        var scale &#x3D; 1&#x2F;dpr</span><br><span class=\"line\">        var meta &#x3D; document.createElement(&#39;meta&#39;)</span><br><span class=\"line\">        meta.setAttribute(&#39;name&#39;, &#39;viewport&#39;)</span><br><span class=\"line\">        meta.setAttribute(&#39;content&#39;, &#39;width&#x3D;device-width,initial-scale&#x3D;&#39; + scale + &#39;, maximum-scale&#x3D;&#39; + scale + &#39;, minimum-scale&#x3D;&#39; + scale + &#39;, user-scalable&#x3D;no&#39;)</span><br><span class=\"line\">        document.getElementsByTagName(&#39;head&#39;)[0].appendChild(meta)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(window, document))</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"视口概念\"><a href=\"#视口概念\" class=\"headerlink\" title=\"视口概念\"></a>视口概念</h3><ul>\n<li><a href=\"https://crazyaguai.github.io/2019/01/20/%E8%A7%86%E5%8F%A3%E6%A6%82%E5%BF%B5/\">https://crazyaguai.github.io/2019/01/20/%E8%A7%86%E5%8F%A3%E6%A6%82%E5%BF%B5/</a></li>\n</ul>\n<h3 id=\"flexble布局\"><a href=\"#flexble布局\" class=\"headerlink\" title=\"flexble布局\"></a>flexble布局</h3><ol>\n<li>把布局视口分为10份，设置html元素font-size大小。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var rem &#x3D; docEl.clientWidth &#x2F; 10</span><br><span class=\"line\">docEl.style.fontSize &#x3D; rem + &#39;px&#39;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>基本宽度 = UI设计稿宽度 / 10，元素尺寸使用rem单位，即元素尺寸 = 元素设计稿尺寸 / 基本宽度，这样实现按比例自适应尺寸。</li>\n<li>转换rem尺寸方式</li>\n</ol>\n<ul>\n<li>使用postcss插件：<a href=\"https://github.com/pigcan/postcss-plugin-px2rem\">postcss-plugin-px2rem</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;.postcssrc.js文件配置</span><br><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">    &quot;plugins&quot;: &#123;</span><br><span class=\"line\">        &quot;postcss-import&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-url&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-plugin-px2rem&quot;: &#123;</span><br><span class=\"line\">            rootValue: 37.5,</span><br><span class=\"line\">            propBlackList: [&#39;border&#39;],&#x2F;&#x2F;border不转换</span><br><span class=\"line\">            exclude: [&#x2F;((src)|(node_modules))&#x2F;],&#x2F;&#x2F;特定文件夹不转换</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#x2F;&#x2F; 浏览器兼容部分在package.json中</span><br><span class=\"line\">        &quot;autoprefixer&quot;: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>编写sass函数转换</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function px2em($px, $base-font-size: 37.5px) &#123;</span><br><span class=\"line\">    @return ($px &#x2F; $base-font-size) * 1rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"1px边框解决方法\"><a href=\"#1px边框解决方法\" class=\"headerlink\" title=\"1px边框解决方法\"></a>1px边框解决方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fix1px() &#123;</span><br><span class=\"line\">    var metas &#x3D; document.querySelectorAll(&#39;meta&#39;)</span><br><span class=\"line\">    metas.forEach(item&#x3D;&gt;&#123;</span><br><span class=\"line\">        if(item.name &#x3D;&#x3D; &#39;viewport&#39;)&#123;</span><br><span class=\"line\">            document.getElementsByTagName(&#39;head&#39;)[0].removeChild(item)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;解决1px线问题</span><br><span class=\"line\">    var scale &#x3D; 1&#x2F;dpr</span><br><span class=\"line\">    var meta &#x3D; document.createElement(&#39;meta&#39;)</span><br><span class=\"line\">    meta.setAttribute(&#39;name&#39;, &#39;viewport&#39;)</span><br><span class=\"line\">    meta.setAttribute(&#39;content&#39;, &#39;width&#x3D;device-width,initial-scale&#x3D;&#39; + scale + &#39;, maximum-scale&#x3D;&#39; + scale + &#39;, minimum-scale&#x3D;&#39; + scale + &#39;, user-scalable&#x3D;no&#39;)</span><br><span class=\"line\">    document.getElementsByTagName(&#39;head&#39;)[0].appendChild(meta)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>dpr=2时meta</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width initial-scale&#x3D;0.5 maximum-scale&#x3D;0.5 minimum-scale&#x3D;0.5 user-scalable&#x3D;no&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>解读：首先设置width=device-width，布局视口=理想视口（此时1css像素=2物理像素），同时理想视口=视觉视口，因此布局视口=视觉视口，initial-scale=0.5，会使布局视口和视觉视口扩大为原来2倍，布局视口仍然=视觉视口，所以会在整个屏幕显示，同时1css像素=1物理像素，解决了边框问题。</li>\n<li>开发时，如果使用postcss插件，配置不转换边框，需要转换的border属性（比如用border画三角形）可以自己转换成rem尺寸。</li>\n</ul>\n<h3 id=\"方案代码\"><a href=\"#方案代码\" class=\"headerlink\" title=\"方案代码\"></a>方案代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function flexible(window, document) &#123;</span><br><span class=\"line\">    var docEl &#x3D; document.documentElement</span><br><span class=\"line\">    var dpr &#x3D; window.devicePixelRatio || 1</span><br><span class=\"line\">    &#x2F;&#x2F; adjust body font size</span><br><span class=\"line\">    function setBodyFontSize() &#123;</span><br><span class=\"line\">        if (document.body) &#123;</span><br><span class=\"line\">            document.body.style.fontSize &#x3D; (12 * dpr) + &#39;px&#39;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            document.addEventListener(&#39;DOMContentLoaded&#39;, setBodyFontSize)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    setBodyFontSize();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; set 1rem &#x3D; viewWidth &#x2F; 10</span><br><span class=\"line\">    function setRemUnit() &#123;</span><br><span class=\"line\">        fix1px()</span><br><span class=\"line\">        var rem &#x3D; docEl.clientWidth &#x2F; 10</span><br><span class=\"line\">        docEl.style.fontSize &#x3D; rem + &#39;px&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    setRemUnit()</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; reset rem unit on page resize</span><br><span class=\"line\">    window.addEventListener(&#39;resize&#39;, setRemUnit)</span><br><span class=\"line\">    window.addEventListener(&#39;pageshow&#39;, function (e) &#123;</span><br><span class=\"line\">        if (e.persisted) &#123;</span><br><span class=\"line\">            setRemUnit()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F; detect 0.5px supports</span><br><span class=\"line\">    if (dpr &gt;&#x3D; 2) &#123;</span><br><span class=\"line\">        var fakeBody &#x3D; document.createElement(&#39;body&#39;)</span><br><span class=\"line\">        var testElement &#x3D; document.createElement(&#39;div&#39;)</span><br><span class=\"line\">        testElement.style.border &#x3D; &#39;.5px solid transparent&#39;</span><br><span class=\"line\">        fakeBody.appendChild(testElement)</span><br><span class=\"line\">        docEl.appendChild(fakeBody)</span><br><span class=\"line\">        if (testElement.offsetHeight &#x3D;&#x3D;&#x3D; 1) &#123;</span><br><span class=\"line\">            docEl.classList.add(&#39;hairlines&#39;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        docEl.removeChild(fakeBody)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function fix1px() &#123;</span><br><span class=\"line\">        var metas &#x3D; document.querySelectorAll(&#39;meta&#39;)</span><br><span class=\"line\">        metas.forEach(item&#x3D;&gt;&#123;</span><br><span class=\"line\">            if(item.name &#x3D;&#x3D; &#39;viewport&#39;)&#123;</span><br><span class=\"line\">                document.getElementsByTagName(&#39;head&#39;)[0].removeChild(item)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        &#x2F;&#x2F;解决1px线问题</span><br><span class=\"line\">        var scale &#x3D; 1&#x2F;dpr</span><br><span class=\"line\">        var meta &#x3D; document.createElement(&#39;meta&#39;)</span><br><span class=\"line\">        meta.setAttribute(&#39;name&#39;, &#39;viewport&#39;)</span><br><span class=\"line\">        meta.setAttribute(&#39;content&#39;, &#39;width&#x3D;device-width,initial-scale&#x3D;&#39; + scale + &#39;, maximum-scale&#x3D;&#39; + scale + &#39;, minimum-scale&#x3D;&#39; + scale + &#39;, user-scalable&#x3D;no&#39;)</span><br><span class=\"line\">        document.getElementsByTagName(&#39;head&#39;)[0].appendChild(meta)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(window, document))</span><br></pre></td></tr></table></figure>\n"},{"title":"<ES6>迭代器iterator&生成器generator","date":"2018-08-21T16:00:00.000Z","_content":"\n### 简介\n\n- 通过程序化的方式使用迭代器对象返回集合中的元素，可以极大地简化数据操作，例如：for...of循环、展开运算符（...）、异步编程。\n- 循环存在的问题(如果多个循环要追踪多个变量，代码复杂度大大增加)\n\n```\nlet arr = [1,2,3]\nfor(let i = 0;i<arr.length;i++){\n    console.log(arr[i])\n}\n```\n\n### 迭代器（iterator）\n\n- 是一个特殊的对象，为专门的迭代程序设计了接口，都有一个next()方法\n- 每次调用next()返回一个对象有两个属性value和done,{value:'',done:''}\n- 每一次调用next()都会返回下一次的值，如果没有值的话，返回{value:undefined,done:true}\n\n```\nfunction createIterator(items) {\n    var i = 0\n    return {\n        next: function () {\n            var done = (i>=items.length)\n            var value = !done ? items[i++] : undefined\n            return {\n                done: done,\n                value: value\n            }\n        }\n    }\n}\nvar iterator = createIterator([1,2])\nconsole.log(iterator.next())//{done:false,value:1}\nconsole.log(iterator.next())\nconsole.log(iterator.next())//{done:true,value:undefined}\n```\n\n### 生成器（generator）\n\n- 生成器是一种返回迭代器的函数，通过function关键字后的*号来表示，函数中会用到新的关键字yield\n- *号可以紧挨function也可以有个空格\n- 生成器中当每执行一条yield之后会自动停止执行，继续调用next()才会继续执行\n- 注意：yield只可以在生成器函数内部调用，在其他地方调用会出现语法错误，即使是在生成器内部函数里面调用\n\n```\nfunction *Fun() {\n    yield 1\n    yield 2\n}\nlet iterator1 = Fun()\nconsole.log(iterator1.next())\nconsole.log(iterator1.next())\nconsole.log(iterator1.next())\n\n//生成器函数表达式\nlet Fun1 = function *() {\n    yield 1\n    yield 2\n}\n```\n\n#### 生成器对象方法\n\n- 生成器对象方法（生成器本身是函数，可以添加到对象中）\n\n```\nlet obj = {\n    createIterator: function *() {\n        yield 1\n    },\n    *Fun(){//ES6函数写法创建\n\n    }\n}\n```\n\n#### 可迭代对象与for...of循环\n\n- 可迭代对象与for...of循环\n- 可迭代对象具有Symbol.iterator属性，通过指定的函数可以返回一个作用于附属对象的迭代器\n- ES6中所有对象合集（数组、Set、Map、字符串）都是可迭代对象，都有默认的可迭代器\n- for...of循环就是用到可迭代对象的这些功能，每执行一次都会调用可迭代对象的next()方法\n- 通过调用Symbol.iterator方法来获得迭代器\n\n```\n//默认的迭代器，通过Symbol.iterator来访问对象默认的迭代器\nlet arr1 = [1,2]\nlet iterator2 = arr1[Symbol.iterator]()\nconsole.log(iterator2.next())\nconsole.log(iterator2.next())\nconsole.log(iterator2.next())\n\n//可以使用Symbol.iterator检测是否为可迭代对象\nfunction checkItertor(obj){\n    return typeof obj[Symbol.iterator] === 'function'\n}\nconsole.log(checkItertor([1,2]))//true\nconsole.log(checkItertor(1))//false\n```\n\n#### 创建可迭代对象\n\n- 创建可迭代对象，开发者定义的对象都是不可迭代的，如果给对象Symbol.iterator属性添加一个生成器可变为可迭代对象\n- 先创建一个生成器，并赋值给Symbol.iterator属性来创建默认的迭代器\n\n```\nlet collection = {\n    items: [],\n    *[Symbol.iterator](){\n        for(let item of this.items){\n            yield item\n        }\n    }\n}\ncollection.items.push(1)\ncollection.items.push(2)\nfor(let item of collection){\n    console.log(item)\n}\n```\n\n### 内建迭代器\n- entries(),多个键值对\n- values(),集合的值\n- keys(),所有的键名(数组打印出来的都是数字类型的索引)\n- 默认的迭代器\n- 数组、Set是values\n- Map是entries()\n- 注意：WeakMap与WeakSet没有内建迭代器，因为要管理弱引用无法确定存在的值\n\n```\nlet map = new Map([['a',1],['b',2]])\nfor(let [k,value] of map.entries()){//解构运用\n    console.log(k)\n    console.log(value)\n}\n```\n\n#### 字符串迭代器\n\n- 字符串迭代器（可以正确使用双字节字符）\n\n```\nlet msg = '123'\nfor(let s of msg){\n    console.log(s)\n}\n```\n\n#### NodeList迭代器\n\n```\nlet divs = document.getElementsByTagName('div')\nfor(let d of divs){\n    console.log(d)\n}\n```\n\n#### Set转换数组\n\n- 展开运算符与非数组可迭代对象(将可迭代对象转换为数组)\n\n```\nlet set1 = new\nSet([1,2,2,3])\nconsole.log([...set1])//[1,2,3]\n```\n\n### 高级迭代器功能\n\n#### 给迭代器传递参数\n- 如果给迭代器的next()方法传递参数，这个参数会替代生成器内部上一条yield语句的返回值\n- 注意：第一次调用next()时无论传什么参数都会被丢弃\n\n```\nfunction *createIterator2() {\n    let first = yield 1\n    let secoud = yield first + 1\n    yield secoud + 1\n}\nlet iterator4 = createIterator2()\nconsole.log(iterator4.next())\nconsole.log(iterator4.next(1))\nconsole.log(iterator4.next(2))\nconsole.log(iterator4.next())\n```\n\n#### 在迭代器中抛出错误\n- 通过throw()方法，当迭代器执行时可以抛出错误\n- next()和throw()像是迭代器两条指令，调用都会继续执行，但是调用throw()会抛出错误\n- 在错误之后的执行取决于内部的代码\n\n```\nfunction *errIterator() {\n    yield 1\n    yield 2\n    yield 3\n}\nlet iterator5 = errIterator()\nconsole.log(iterator5.next())\n// console.log(iterator5.throw(new Error('error')))\nconsole.log(iterator5.next())//不会在执行\n\n//可以在内部通过try-catch捕获错误\nfunction *errIterator1() {\n    let first = yield 1\n    let secound\n    try {//由于生成器捕获了这些错误因此会继续执行下一条语句\n        secound = yield first + 1\n    }catch (e) {\n        secound = 2\n    }\n    yield secound + 1\n}\nlet iterator6 = errIterator1()\nconsole.log(iterator6.next())\nconsole.log(iterator6.next(1))\nconsole.log(iterator6.throw(new Error('error')))\nconsole.log(iterator6.next(1))\n```\n\n#### 生成器的return返回语句\n\n- 可以通过return提前退出执行，如果return了值，则为{done:true,value:对应值}\n- 注意：展开运算符和for...of循环会直接忽略通过return返回的任何值，只要done变为true就会停止\n\n```\nfunction *returnIterator() {\n    return 1\n}\nlet iterator7 = returnIterator()\nconsole.log(iterator7.next())//{value:1,done:true}\n```\n\n#### 委托生成器（合并迭代器）\n\n```\nfunction *c1() {\n    yield 1\n    return 2\n}\nfunction *c2() {\n    yield 3\n    return 4\n}\nfunction *c3() {\n    let result = yield *c1()\n    yield result//如果想返回这个return值需要这个么做\n    yield *c2()\n    yield *'aaa'//会使用字符串的默认迭代器\n}\nlet iteratorC = c3()\n```\n\n#### 异步任务执行器\n\n```\nfunction run(taskDef) {\n\n    //创建一个无限使用的迭代器\n    let task = taskDef()\n\n    //开始执行任务\n    let result = task.next()\n\n    //循环调用使用next()函数\n    function step() {\n        if(!result.done){\n            //判断如果是函数则执行函数\n            if(typeof result.value === 'function'){\n                //执行异步函数，传入回调，再回调中继续执行next(),处理数据\n                result.value(function (err,data) {\n                    if(err){\n                        task.throw(err)\n                        return\n                    }\n                    result = task.next(data)\n                    step()\n                })\n            }else {\n                result = task.next(result.value)\n                step()\n            }\n        }\n    }\n    step()\n}\n\nfunction outFun() {\n    return function (callback) {\n        setTimeout(()=>{\n            console.log('111')\n            callback(null,'123')\n        },1000)\n    }\n}\n\nrun(function *() {\n    let res = yield outFun()\n    console.log('2222')\n})\n```\n","source":"_posts/[ES6]迭代器iterator&生成器generator.md","raw":"---\ntitle: <ES6>迭代器iterator&生成器generator\ndate: 2018-08-22 00:00:00\ntags: [ES6,js]\ncategories: ES6\n---\n\n### 简介\n\n- 通过程序化的方式使用迭代器对象返回集合中的元素，可以极大地简化数据操作，例如：for...of循环、展开运算符（...）、异步编程。\n- 循环存在的问题(如果多个循环要追踪多个变量，代码复杂度大大增加)\n\n```\nlet arr = [1,2,3]\nfor(let i = 0;i<arr.length;i++){\n    console.log(arr[i])\n}\n```\n\n### 迭代器（iterator）\n\n- 是一个特殊的对象，为专门的迭代程序设计了接口，都有一个next()方法\n- 每次调用next()返回一个对象有两个属性value和done,{value:'',done:''}\n- 每一次调用next()都会返回下一次的值，如果没有值的话，返回{value:undefined,done:true}\n\n```\nfunction createIterator(items) {\n    var i = 0\n    return {\n        next: function () {\n            var done = (i>=items.length)\n            var value = !done ? items[i++] : undefined\n            return {\n                done: done,\n                value: value\n            }\n        }\n    }\n}\nvar iterator = createIterator([1,2])\nconsole.log(iterator.next())//{done:false,value:1}\nconsole.log(iterator.next())\nconsole.log(iterator.next())//{done:true,value:undefined}\n```\n\n### 生成器（generator）\n\n- 生成器是一种返回迭代器的函数，通过function关键字后的*号来表示，函数中会用到新的关键字yield\n- *号可以紧挨function也可以有个空格\n- 生成器中当每执行一条yield之后会自动停止执行，继续调用next()才会继续执行\n- 注意：yield只可以在生成器函数内部调用，在其他地方调用会出现语法错误，即使是在生成器内部函数里面调用\n\n```\nfunction *Fun() {\n    yield 1\n    yield 2\n}\nlet iterator1 = Fun()\nconsole.log(iterator1.next())\nconsole.log(iterator1.next())\nconsole.log(iterator1.next())\n\n//生成器函数表达式\nlet Fun1 = function *() {\n    yield 1\n    yield 2\n}\n```\n\n#### 生成器对象方法\n\n- 生成器对象方法（生成器本身是函数，可以添加到对象中）\n\n```\nlet obj = {\n    createIterator: function *() {\n        yield 1\n    },\n    *Fun(){//ES6函数写法创建\n\n    }\n}\n```\n\n#### 可迭代对象与for...of循环\n\n- 可迭代对象与for...of循环\n- 可迭代对象具有Symbol.iterator属性，通过指定的函数可以返回一个作用于附属对象的迭代器\n- ES6中所有对象合集（数组、Set、Map、字符串）都是可迭代对象，都有默认的可迭代器\n- for...of循环就是用到可迭代对象的这些功能，每执行一次都会调用可迭代对象的next()方法\n- 通过调用Symbol.iterator方法来获得迭代器\n\n```\n//默认的迭代器，通过Symbol.iterator来访问对象默认的迭代器\nlet arr1 = [1,2]\nlet iterator2 = arr1[Symbol.iterator]()\nconsole.log(iterator2.next())\nconsole.log(iterator2.next())\nconsole.log(iterator2.next())\n\n//可以使用Symbol.iterator检测是否为可迭代对象\nfunction checkItertor(obj){\n    return typeof obj[Symbol.iterator] === 'function'\n}\nconsole.log(checkItertor([1,2]))//true\nconsole.log(checkItertor(1))//false\n```\n\n#### 创建可迭代对象\n\n- 创建可迭代对象，开发者定义的对象都是不可迭代的，如果给对象Symbol.iterator属性添加一个生成器可变为可迭代对象\n- 先创建一个生成器，并赋值给Symbol.iterator属性来创建默认的迭代器\n\n```\nlet collection = {\n    items: [],\n    *[Symbol.iterator](){\n        for(let item of this.items){\n            yield item\n        }\n    }\n}\ncollection.items.push(1)\ncollection.items.push(2)\nfor(let item of collection){\n    console.log(item)\n}\n```\n\n### 内建迭代器\n- entries(),多个键值对\n- values(),集合的值\n- keys(),所有的键名(数组打印出来的都是数字类型的索引)\n- 默认的迭代器\n- 数组、Set是values\n- Map是entries()\n- 注意：WeakMap与WeakSet没有内建迭代器，因为要管理弱引用无法确定存在的值\n\n```\nlet map = new Map([['a',1],['b',2]])\nfor(let [k,value] of map.entries()){//解构运用\n    console.log(k)\n    console.log(value)\n}\n```\n\n#### 字符串迭代器\n\n- 字符串迭代器（可以正确使用双字节字符）\n\n```\nlet msg = '123'\nfor(let s of msg){\n    console.log(s)\n}\n```\n\n#### NodeList迭代器\n\n```\nlet divs = document.getElementsByTagName('div')\nfor(let d of divs){\n    console.log(d)\n}\n```\n\n#### Set转换数组\n\n- 展开运算符与非数组可迭代对象(将可迭代对象转换为数组)\n\n```\nlet set1 = new\nSet([1,2,2,3])\nconsole.log([...set1])//[1,2,3]\n```\n\n### 高级迭代器功能\n\n#### 给迭代器传递参数\n- 如果给迭代器的next()方法传递参数，这个参数会替代生成器内部上一条yield语句的返回值\n- 注意：第一次调用next()时无论传什么参数都会被丢弃\n\n```\nfunction *createIterator2() {\n    let first = yield 1\n    let secoud = yield first + 1\n    yield secoud + 1\n}\nlet iterator4 = createIterator2()\nconsole.log(iterator4.next())\nconsole.log(iterator4.next(1))\nconsole.log(iterator4.next(2))\nconsole.log(iterator4.next())\n```\n\n#### 在迭代器中抛出错误\n- 通过throw()方法，当迭代器执行时可以抛出错误\n- next()和throw()像是迭代器两条指令，调用都会继续执行，但是调用throw()会抛出错误\n- 在错误之后的执行取决于内部的代码\n\n```\nfunction *errIterator() {\n    yield 1\n    yield 2\n    yield 3\n}\nlet iterator5 = errIterator()\nconsole.log(iterator5.next())\n// console.log(iterator5.throw(new Error('error')))\nconsole.log(iterator5.next())//不会在执行\n\n//可以在内部通过try-catch捕获错误\nfunction *errIterator1() {\n    let first = yield 1\n    let secound\n    try {//由于生成器捕获了这些错误因此会继续执行下一条语句\n        secound = yield first + 1\n    }catch (e) {\n        secound = 2\n    }\n    yield secound + 1\n}\nlet iterator6 = errIterator1()\nconsole.log(iterator6.next())\nconsole.log(iterator6.next(1))\nconsole.log(iterator6.throw(new Error('error')))\nconsole.log(iterator6.next(1))\n```\n\n#### 生成器的return返回语句\n\n- 可以通过return提前退出执行，如果return了值，则为{done:true,value:对应值}\n- 注意：展开运算符和for...of循环会直接忽略通过return返回的任何值，只要done变为true就会停止\n\n```\nfunction *returnIterator() {\n    return 1\n}\nlet iterator7 = returnIterator()\nconsole.log(iterator7.next())//{value:1,done:true}\n```\n\n#### 委托生成器（合并迭代器）\n\n```\nfunction *c1() {\n    yield 1\n    return 2\n}\nfunction *c2() {\n    yield 3\n    return 4\n}\nfunction *c3() {\n    let result = yield *c1()\n    yield result//如果想返回这个return值需要这个么做\n    yield *c2()\n    yield *'aaa'//会使用字符串的默认迭代器\n}\nlet iteratorC = c3()\n```\n\n#### 异步任务执行器\n\n```\nfunction run(taskDef) {\n\n    //创建一个无限使用的迭代器\n    let task = taskDef()\n\n    //开始执行任务\n    let result = task.next()\n\n    //循环调用使用next()函数\n    function step() {\n        if(!result.done){\n            //判断如果是函数则执行函数\n            if(typeof result.value === 'function'){\n                //执行异步函数，传入回调，再回调中继续执行next(),处理数据\n                result.value(function (err,data) {\n                    if(err){\n                        task.throw(err)\n                        return\n                    }\n                    result = task.next(data)\n                    step()\n                })\n            }else {\n                result = task.next(result.value)\n                step()\n            }\n        }\n    }\n    step()\n}\n\nfunction outFun() {\n    return function (callback) {\n        setTimeout(()=>{\n            console.log('111')\n            callback(null,'123')\n        },1000)\n    }\n}\n\nrun(function *() {\n    let res = yield outFun()\n    console.log('2222')\n})\n```\n","slug":"[ES6]迭代器iterator&生成器generator","published":1,"updated":"2021-03-15T14:36:21.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dk8000wwotj92sv9qks","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>通过程序化的方式使用迭代器对象返回集合中的元素，可以极大地简化数据操作，例如：for…of循环、展开运算符（…）、异步编程。</li>\n<li>循环存在的问题(如果多个循环要追踪多个变量，代码复杂度大大增加)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1,2,3]</span><br><span class=\"line\">for(let i &#x3D; 0;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">    console.log(arr[i])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"迭代器（iterator）\"><a href=\"#迭代器（iterator）\" class=\"headerlink\" title=\"迭代器（iterator）\"></a>迭代器（iterator）</h3><ul>\n<li>是一个特殊的对象，为专门的迭代程序设计了接口，都有一个next()方法</li>\n<li>每次调用next()返回一个对象有两个属性value和done,{value:’’,done:’’}</li>\n<li>每一次调用next()都会返回下一次的值，如果没有值的话，返回{value:undefined,done:true}</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createIterator(items) &#123;</span><br><span class=\"line\">    var i &#x3D; 0</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        next: function () &#123;</span><br><span class=\"line\">            var done &#x3D; (i&gt;&#x3D;items.length)</span><br><span class=\"line\">            var value &#x3D; !done ? items[i++] : undefined</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                done: done,</span><br><span class=\"line\">                value: value</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var iterator &#x3D; createIterator([1,2])</span><br><span class=\"line\">console.log(iterator.next())&#x2F;&#x2F;&#123;done:false,value:1&#125;</span><br><span class=\"line\">console.log(iterator.next())</span><br><span class=\"line\">console.log(iterator.next())&#x2F;&#x2F;&#123;done:true,value:undefined&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生成器（generator）\"><a href=\"#生成器（generator）\" class=\"headerlink\" title=\"生成器（generator）\"></a>生成器（generator）</h3><ul>\n<li>生成器是一种返回迭代器的函数，通过function关键字后的*号来表示，函数中会用到新的关键字yield</li>\n<li>*号可以紧挨function也可以有个空格</li>\n<li>生成器中当每执行一条yield之后会自动停止执行，继续调用next()才会继续执行</li>\n<li>注意：yield只可以在生成器函数内部调用，在其他地方调用会出现语法错误，即使是在生成器内部函数里面调用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *Fun() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    yield 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator1 &#x3D; Fun()</span><br><span class=\"line\">console.log(iterator1.next())</span><br><span class=\"line\">console.log(iterator1.next())</span><br><span class=\"line\">console.log(iterator1.next())</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;生成器函数表达式</span><br><span class=\"line\">let Fun1 &#x3D; function *() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    yield 2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生成器对象方法\"><a href=\"#生成器对象方法\" class=\"headerlink\" title=\"生成器对象方法\"></a>生成器对象方法</h4><ul>\n<li>生成器对象方法（生成器本身是函数，可以添加到对象中）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    createIterator: function *() &#123;</span><br><span class=\"line\">        yield 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    *Fun()&#123;&#x2F;&#x2F;ES6函数写法创建</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可迭代对象与for…of循环\"><a href=\"#可迭代对象与for…of循环\" class=\"headerlink\" title=\"可迭代对象与for…of循环\"></a>可迭代对象与for…of循环</h4><ul>\n<li>可迭代对象与for…of循环</li>\n<li>可迭代对象具有Symbol.iterator属性，通过指定的函数可以返回一个作用于附属对象的迭代器</li>\n<li>ES6中所有对象合集（数组、Set、Map、字符串）都是可迭代对象，都有默认的可迭代器</li>\n<li>for…of循环就是用到可迭代对象的这些功能，每执行一次都会调用可迭代对象的next()方法</li>\n<li>通过调用Symbol.iterator方法来获得迭代器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;默认的迭代器，通过Symbol.iterator来访问对象默认的迭代器</span><br><span class=\"line\">let arr1 &#x3D; [1,2]</span><br><span class=\"line\">let iterator2 &#x3D; arr1[Symbol.iterator]()</span><br><span class=\"line\">console.log(iterator2.next())</span><br><span class=\"line\">console.log(iterator2.next())</span><br><span class=\"line\">console.log(iterator2.next())</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;可以使用Symbol.iterator检测是否为可迭代对象</span><br><span class=\"line\">function checkItertor(obj)&#123;</span><br><span class=\"line\">    return typeof obj[Symbol.iterator] &#x3D;&#x3D;&#x3D; &#39;function&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(checkItertor([1,2]))&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(checkItertor(1))&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建可迭代对象\"><a href=\"#创建可迭代对象\" class=\"headerlink\" title=\"创建可迭代对象\"></a>创建可迭代对象</h4><ul>\n<li>创建可迭代对象，开发者定义的对象都是不可迭代的，如果给对象Symbol.iterator属性添加一个生成器可变为可迭代对象</li>\n<li>先创建一个生成器，并赋值给Symbol.iterator属性来创建默认的迭代器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let collection &#x3D; &#123;</span><br><span class=\"line\">    items: [],</span><br><span class=\"line\">    *[Symbol.iterator]()&#123;</span><br><span class=\"line\">        for(let item of this.items)&#123;</span><br><span class=\"line\">            yield item</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">collection.items.push(1)</span><br><span class=\"line\">collection.items.push(2)</span><br><span class=\"line\">for(let item of collection)&#123;</span><br><span class=\"line\">    console.log(item)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内建迭代器\"><a href=\"#内建迭代器\" class=\"headerlink\" title=\"内建迭代器\"></a>内建迭代器</h3><ul>\n<li>entries(),多个键值对</li>\n<li>values(),集合的值</li>\n<li>keys(),所有的键名(数组打印出来的都是数字类型的索引)</li>\n<li>默认的迭代器</li>\n<li>数组、Set是values</li>\n<li>Map是entries()</li>\n<li>注意：WeakMap与WeakSet没有内建迭代器，因为要管理弱引用无法确定存在的值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map &#x3D; new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</span><br><span class=\"line\">for(let [k,value] of map.entries())&#123;&#x2F;&#x2F;解构运用</span><br><span class=\"line\">    console.log(k)</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字符串迭代器\"><a href=\"#字符串迭代器\" class=\"headerlink\" title=\"字符串迭代器\"></a>字符串迭代器</h4><ul>\n<li>字符串迭代器（可以正确使用双字节字符）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let msg &#x3D; &#39;123&#39;</span><br><span class=\"line\">for(let s of msg)&#123;</span><br><span class=\"line\">    console.log(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NodeList迭代器\"><a href=\"#NodeList迭代器\" class=\"headerlink\" title=\"NodeList迭代器\"></a>NodeList迭代器</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let divs &#x3D; document.getElementsByTagName(&#39;div&#39;)</span><br><span class=\"line\">for(let d of divs)&#123;</span><br><span class=\"line\">    console.log(d)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Set转换数组\"><a href=\"#Set转换数组\" class=\"headerlink\" title=\"Set转换数组\"></a>Set转换数组</h4><ul>\n<li>展开运算符与非数组可迭代对象(将可迭代对象转换为数组)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set1 &#x3D; new</span><br><span class=\"line\">Set([1,2,2,3])</span><br><span class=\"line\">console.log([...set1])&#x2F;&#x2F;[1,2,3]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"高级迭代器功能\"><a href=\"#高级迭代器功能\" class=\"headerlink\" title=\"高级迭代器功能\"></a>高级迭代器功能</h3><h4 id=\"给迭代器传递参数\"><a href=\"#给迭代器传递参数\" class=\"headerlink\" title=\"给迭代器传递参数\"></a>给迭代器传递参数</h4><ul>\n<li>如果给迭代器的next()方法传递参数，这个参数会替代生成器内部上一条yield语句的返回值</li>\n<li>注意：第一次调用next()时无论传什么参数都会被丢弃</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *createIterator2() &#123;</span><br><span class=\"line\">    let first &#x3D; yield 1</span><br><span class=\"line\">    let secoud &#x3D; yield first + 1</span><br><span class=\"line\">    yield secoud + 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator4 &#x3D; createIterator2()</span><br><span class=\"line\">console.log(iterator4.next())</span><br><span class=\"line\">console.log(iterator4.next(1))</span><br><span class=\"line\">console.log(iterator4.next(2))</span><br><span class=\"line\">console.log(iterator4.next())</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在迭代器中抛出错误\"><a href=\"#在迭代器中抛出错误\" class=\"headerlink\" title=\"在迭代器中抛出错误\"></a>在迭代器中抛出错误</h4><ul>\n<li>通过throw()方法，当迭代器执行时可以抛出错误</li>\n<li>next()和throw()像是迭代器两条指令，调用都会继续执行，但是调用throw()会抛出错误</li>\n<li>在错误之后的执行取决于内部的代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *errIterator() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    yield 2</span><br><span class=\"line\">    yield 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator5 &#x3D; errIterator()</span><br><span class=\"line\">console.log(iterator5.next())</span><br><span class=\"line\">&#x2F;&#x2F; console.log(iterator5.throw(new Error(&#39;error&#39;)))</span><br><span class=\"line\">console.log(iterator5.next())&#x2F;&#x2F;不会在执行</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;可以在内部通过try-catch捕获错误</span><br><span class=\"line\">function *errIterator1() &#123;</span><br><span class=\"line\">    let first &#x3D; yield 1</span><br><span class=\"line\">    let secound</span><br><span class=\"line\">    try &#123;&#x2F;&#x2F;由于生成器捕获了这些错误因此会继续执行下一条语句</span><br><span class=\"line\">        secound &#x3D; yield first + 1</span><br><span class=\"line\">    &#125;catch (e) &#123;</span><br><span class=\"line\">        secound &#x3D; 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    yield secound + 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator6 &#x3D; errIterator1()</span><br><span class=\"line\">console.log(iterator6.next())</span><br><span class=\"line\">console.log(iterator6.next(1))</span><br><span class=\"line\">console.log(iterator6.throw(new Error(&#39;error&#39;)))</span><br><span class=\"line\">console.log(iterator6.next(1))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生成器的return返回语句\"><a href=\"#生成器的return返回语句\" class=\"headerlink\" title=\"生成器的return返回语句\"></a>生成器的return返回语句</h4><ul>\n<li>可以通过return提前退出执行，如果return了值，则为{done:true,value:对应值}</li>\n<li>注意：展开运算符和for…of循环会直接忽略通过return返回的任何值，只要done变为true就会停止</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *returnIterator() &#123;</span><br><span class=\"line\">    return 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator7 &#x3D; returnIterator()</span><br><span class=\"line\">console.log(iterator7.next())&#x2F;&#x2F;&#123;value:1,done:true&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"委托生成器（合并迭代器）\"><a href=\"#委托生成器（合并迭代器）\" class=\"headerlink\" title=\"委托生成器（合并迭代器）\"></a>委托生成器（合并迭代器）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *c1() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    return 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function *c2() &#123;</span><br><span class=\"line\">    yield 3</span><br><span class=\"line\">    return 4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function *c3() &#123;</span><br><span class=\"line\">    let result &#x3D; yield *c1()</span><br><span class=\"line\">    yield result&#x2F;&#x2F;如果想返回这个return值需要这个么做</span><br><span class=\"line\">    yield *c2()</span><br><span class=\"line\">    yield *&#39;aaa&#39;&#x2F;&#x2F;会使用字符串的默认迭代器</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iteratorC &#x3D; c3()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"异步任务执行器\"><a href=\"#异步任务执行器\" class=\"headerlink\" title=\"异步任务执行器\"></a>异步任务执行器</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function run(taskDef) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;创建一个无限使用的迭代器</span><br><span class=\"line\">    let task &#x3D; taskDef()</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;开始执行任务</span><br><span class=\"line\">    let result &#x3D; task.next()</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;循环调用使用next()函数</span><br><span class=\"line\">    function step() &#123;</span><br><span class=\"line\">        if(!result.done)&#123;</span><br><span class=\"line\">            &#x2F;&#x2F;判断如果是函数则执行函数</span><br><span class=\"line\">            if(typeof result.value &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class=\"line\">                &#x2F;&#x2F;执行异步函数，传入回调，再回调中继续执行next(),处理数据</span><br><span class=\"line\">                result.value(function (err,data) &#123;</span><br><span class=\"line\">                    if(err)&#123;</span><br><span class=\"line\">                        task.throw(err)</span><br><span class=\"line\">                        return</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    result &#x3D; task.next(data)</span><br><span class=\"line\">                    step()</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                result &#x3D; task.next(result.value)</span><br><span class=\"line\">                step()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    step()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function outFun() &#123;</span><br><span class=\"line\">    return function (callback) &#123;</span><br><span class=\"line\">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">            console.log(&#39;111&#39;)</span><br><span class=\"line\">            callback(null,&#39;123&#39;)</span><br><span class=\"line\">        &#125;,1000)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">run(function *() &#123;</span><br><span class=\"line\">    let res &#x3D; yield outFun()</span><br><span class=\"line\">    console.log(&#39;2222&#39;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>通过程序化的方式使用迭代器对象返回集合中的元素，可以极大地简化数据操作，例如：for…of循环、展开运算符（…）、异步编程。</li>\n<li>循环存在的问题(如果多个循环要追踪多个变量，代码复杂度大大增加)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr &#x3D; [1,2,3]</span><br><span class=\"line\">for(let i &#x3D; 0;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">    console.log(arr[i])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"迭代器（iterator）\"><a href=\"#迭代器（iterator）\" class=\"headerlink\" title=\"迭代器（iterator）\"></a>迭代器（iterator）</h3><ul>\n<li>是一个特殊的对象，为专门的迭代程序设计了接口，都有一个next()方法</li>\n<li>每次调用next()返回一个对象有两个属性value和done,{value:’’,done:’’}</li>\n<li>每一次调用next()都会返回下一次的值，如果没有值的话，返回{value:undefined,done:true}</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createIterator(items) &#123;</span><br><span class=\"line\">    var i &#x3D; 0</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        next: function () &#123;</span><br><span class=\"line\">            var done &#x3D; (i&gt;&#x3D;items.length)</span><br><span class=\"line\">            var value &#x3D; !done ? items[i++] : undefined</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                done: done,</span><br><span class=\"line\">                value: value</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var iterator &#x3D; createIterator([1,2])</span><br><span class=\"line\">console.log(iterator.next())&#x2F;&#x2F;&#123;done:false,value:1&#125;</span><br><span class=\"line\">console.log(iterator.next())</span><br><span class=\"line\">console.log(iterator.next())&#x2F;&#x2F;&#123;done:true,value:undefined&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"生成器（generator）\"><a href=\"#生成器（generator）\" class=\"headerlink\" title=\"生成器（generator）\"></a>生成器（generator）</h3><ul>\n<li>生成器是一种返回迭代器的函数，通过function关键字后的*号来表示，函数中会用到新的关键字yield</li>\n<li>*号可以紧挨function也可以有个空格</li>\n<li>生成器中当每执行一条yield之后会自动停止执行，继续调用next()才会继续执行</li>\n<li>注意：yield只可以在生成器函数内部调用，在其他地方调用会出现语法错误，即使是在生成器内部函数里面调用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *Fun() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    yield 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator1 &#x3D; Fun()</span><br><span class=\"line\">console.log(iterator1.next())</span><br><span class=\"line\">console.log(iterator1.next())</span><br><span class=\"line\">console.log(iterator1.next())</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;生成器函数表达式</span><br><span class=\"line\">let Fun1 &#x3D; function *() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    yield 2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生成器对象方法\"><a href=\"#生成器对象方法\" class=\"headerlink\" title=\"生成器对象方法\"></a>生成器对象方法</h4><ul>\n<li>生成器对象方法（生成器本身是函数，可以添加到对象中）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    createIterator: function *() &#123;</span><br><span class=\"line\">        yield 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    *Fun()&#123;&#x2F;&#x2F;ES6函数写法创建</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"可迭代对象与for…of循环\"><a href=\"#可迭代对象与for…of循环\" class=\"headerlink\" title=\"可迭代对象与for…of循环\"></a>可迭代对象与for…of循环</h4><ul>\n<li>可迭代对象与for…of循环</li>\n<li>可迭代对象具有Symbol.iterator属性，通过指定的函数可以返回一个作用于附属对象的迭代器</li>\n<li>ES6中所有对象合集（数组、Set、Map、字符串）都是可迭代对象，都有默认的可迭代器</li>\n<li>for…of循环就是用到可迭代对象的这些功能，每执行一次都会调用可迭代对象的next()方法</li>\n<li>通过调用Symbol.iterator方法来获得迭代器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;默认的迭代器，通过Symbol.iterator来访问对象默认的迭代器</span><br><span class=\"line\">let arr1 &#x3D; [1,2]</span><br><span class=\"line\">let iterator2 &#x3D; arr1[Symbol.iterator]()</span><br><span class=\"line\">console.log(iterator2.next())</span><br><span class=\"line\">console.log(iterator2.next())</span><br><span class=\"line\">console.log(iterator2.next())</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;可以使用Symbol.iterator检测是否为可迭代对象</span><br><span class=\"line\">function checkItertor(obj)&#123;</span><br><span class=\"line\">    return typeof obj[Symbol.iterator] &#x3D;&#x3D;&#x3D; &#39;function&#39;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(checkItertor([1,2]))&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(checkItertor(1))&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"创建可迭代对象\"><a href=\"#创建可迭代对象\" class=\"headerlink\" title=\"创建可迭代对象\"></a>创建可迭代对象</h4><ul>\n<li>创建可迭代对象，开发者定义的对象都是不可迭代的，如果给对象Symbol.iterator属性添加一个生成器可变为可迭代对象</li>\n<li>先创建一个生成器，并赋值给Symbol.iterator属性来创建默认的迭代器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let collection &#x3D; &#123;</span><br><span class=\"line\">    items: [],</span><br><span class=\"line\">    *[Symbol.iterator]()&#123;</span><br><span class=\"line\">        for(let item of this.items)&#123;</span><br><span class=\"line\">            yield item</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">collection.items.push(1)</span><br><span class=\"line\">collection.items.push(2)</span><br><span class=\"line\">for(let item of collection)&#123;</span><br><span class=\"line\">    console.log(item)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"内建迭代器\"><a href=\"#内建迭代器\" class=\"headerlink\" title=\"内建迭代器\"></a>内建迭代器</h3><ul>\n<li>entries(),多个键值对</li>\n<li>values(),集合的值</li>\n<li>keys(),所有的键名(数组打印出来的都是数字类型的索引)</li>\n<li>默认的迭代器</li>\n<li>数组、Set是values</li>\n<li>Map是entries()</li>\n<li>注意：WeakMap与WeakSet没有内建迭代器，因为要管理弱引用无法确定存在的值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map &#x3D; new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</span><br><span class=\"line\">for(let [k,value] of map.entries())&#123;&#x2F;&#x2F;解构运用</span><br><span class=\"line\">    console.log(k)</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字符串迭代器\"><a href=\"#字符串迭代器\" class=\"headerlink\" title=\"字符串迭代器\"></a>字符串迭代器</h4><ul>\n<li>字符串迭代器（可以正确使用双字节字符）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let msg &#x3D; &#39;123&#39;</span><br><span class=\"line\">for(let s of msg)&#123;</span><br><span class=\"line\">    console.log(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"NodeList迭代器\"><a href=\"#NodeList迭代器\" class=\"headerlink\" title=\"NodeList迭代器\"></a>NodeList迭代器</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let divs &#x3D; document.getElementsByTagName(&#39;div&#39;)</span><br><span class=\"line\">for(let d of divs)&#123;</span><br><span class=\"line\">    console.log(d)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Set转换数组\"><a href=\"#Set转换数组\" class=\"headerlink\" title=\"Set转换数组\"></a>Set转换数组</h4><ul>\n<li>展开运算符与非数组可迭代对象(将可迭代对象转换为数组)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set1 &#x3D; new</span><br><span class=\"line\">Set([1,2,2,3])</span><br><span class=\"line\">console.log([...set1])&#x2F;&#x2F;[1,2,3]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"高级迭代器功能\"><a href=\"#高级迭代器功能\" class=\"headerlink\" title=\"高级迭代器功能\"></a>高级迭代器功能</h3><h4 id=\"给迭代器传递参数\"><a href=\"#给迭代器传递参数\" class=\"headerlink\" title=\"给迭代器传递参数\"></a>给迭代器传递参数</h4><ul>\n<li>如果给迭代器的next()方法传递参数，这个参数会替代生成器内部上一条yield语句的返回值</li>\n<li>注意：第一次调用next()时无论传什么参数都会被丢弃</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *createIterator2() &#123;</span><br><span class=\"line\">    let first &#x3D; yield 1</span><br><span class=\"line\">    let secoud &#x3D; yield first + 1</span><br><span class=\"line\">    yield secoud + 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator4 &#x3D; createIterator2()</span><br><span class=\"line\">console.log(iterator4.next())</span><br><span class=\"line\">console.log(iterator4.next(1))</span><br><span class=\"line\">console.log(iterator4.next(2))</span><br><span class=\"line\">console.log(iterator4.next())</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"在迭代器中抛出错误\"><a href=\"#在迭代器中抛出错误\" class=\"headerlink\" title=\"在迭代器中抛出错误\"></a>在迭代器中抛出错误</h4><ul>\n<li>通过throw()方法，当迭代器执行时可以抛出错误</li>\n<li>next()和throw()像是迭代器两条指令，调用都会继续执行，但是调用throw()会抛出错误</li>\n<li>在错误之后的执行取决于内部的代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *errIterator() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    yield 2</span><br><span class=\"line\">    yield 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator5 &#x3D; errIterator()</span><br><span class=\"line\">console.log(iterator5.next())</span><br><span class=\"line\">&#x2F;&#x2F; console.log(iterator5.throw(new Error(&#39;error&#39;)))</span><br><span class=\"line\">console.log(iterator5.next())&#x2F;&#x2F;不会在执行</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F;可以在内部通过try-catch捕获错误</span><br><span class=\"line\">function *errIterator1() &#123;</span><br><span class=\"line\">    let first &#x3D; yield 1</span><br><span class=\"line\">    let secound</span><br><span class=\"line\">    try &#123;&#x2F;&#x2F;由于生成器捕获了这些错误因此会继续执行下一条语句</span><br><span class=\"line\">        secound &#x3D; yield first + 1</span><br><span class=\"line\">    &#125;catch (e) &#123;</span><br><span class=\"line\">        secound &#x3D; 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    yield secound + 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator6 &#x3D; errIterator1()</span><br><span class=\"line\">console.log(iterator6.next())</span><br><span class=\"line\">console.log(iterator6.next(1))</span><br><span class=\"line\">console.log(iterator6.throw(new Error(&#39;error&#39;)))</span><br><span class=\"line\">console.log(iterator6.next(1))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"生成器的return返回语句\"><a href=\"#生成器的return返回语句\" class=\"headerlink\" title=\"生成器的return返回语句\"></a>生成器的return返回语句</h4><ul>\n<li>可以通过return提前退出执行，如果return了值，则为{done:true,value:对应值}</li>\n<li>注意：展开运算符和for…of循环会直接忽略通过return返回的任何值，只要done变为true就会停止</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *returnIterator() &#123;</span><br><span class=\"line\">    return 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator7 &#x3D; returnIterator()</span><br><span class=\"line\">console.log(iterator7.next())&#x2F;&#x2F;&#123;value:1,done:true&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"委托生成器（合并迭代器）\"><a href=\"#委托生成器（合并迭代器）\" class=\"headerlink\" title=\"委托生成器（合并迭代器）\"></a>委托生成器（合并迭代器）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *c1() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    return 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function *c2() &#123;</span><br><span class=\"line\">    yield 3</span><br><span class=\"line\">    return 4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function *c3() &#123;</span><br><span class=\"line\">    let result &#x3D; yield *c1()</span><br><span class=\"line\">    yield result&#x2F;&#x2F;如果想返回这个return值需要这个么做</span><br><span class=\"line\">    yield *c2()</span><br><span class=\"line\">    yield *&#39;aaa&#39;&#x2F;&#x2F;会使用字符串的默认迭代器</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iteratorC &#x3D; c3()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"异步任务执行器\"><a href=\"#异步任务执行器\" class=\"headerlink\" title=\"异步任务执行器\"></a>异步任务执行器</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function run(taskDef) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;创建一个无限使用的迭代器</span><br><span class=\"line\">    let task &#x3D; taskDef()</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;开始执行任务</span><br><span class=\"line\">    let result &#x3D; task.next()</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;循环调用使用next()函数</span><br><span class=\"line\">    function step() &#123;</span><br><span class=\"line\">        if(!result.done)&#123;</span><br><span class=\"line\">            &#x2F;&#x2F;判断如果是函数则执行函数</span><br><span class=\"line\">            if(typeof result.value &#x3D;&#x3D;&#x3D; &#39;function&#39;)&#123;</span><br><span class=\"line\">                &#x2F;&#x2F;执行异步函数，传入回调，再回调中继续执行next(),处理数据</span><br><span class=\"line\">                result.value(function (err,data) &#123;</span><br><span class=\"line\">                    if(err)&#123;</span><br><span class=\"line\">                        task.throw(err)</span><br><span class=\"line\">                        return</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    result &#x3D; task.next(data)</span><br><span class=\"line\">                    step()</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                result &#x3D; task.next(result.value)</span><br><span class=\"line\">                step()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    step()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function outFun() &#123;</span><br><span class=\"line\">    return function (callback) &#123;</span><br><span class=\"line\">        setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">            console.log(&#39;111&#39;)</span><br><span class=\"line\">            callback(null,&#39;123&#39;)</span><br><span class=\"line\">        &#125;,1000)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">run(function *() &#123;</span><br><span class=\"line\">    let res &#x3D; yield outFun()</span><br><span class=\"line\">    console.log(&#39;2222&#39;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n"},{"title":"<css>postcss相关配置","date":"2019-01-30T16:00:00.000Z","_content":"\n### postcss做了什么\n\n1. postcss 将你的 css 文件转变成 JS 对象\n2. postcss 插件会遍历生成的js对象添加/删除/修改选择器或属性\n3. postcss 将该对象转换成 css 文件\n\n### webpack配置postcss\n\n```\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'postcss-loader'],\n      },\n      {\n        test: /\\.jsx?$/,\n        use: ['babel-loader', 'astroturf/loader'],\n      }\n    ]\n  }\n}\n```\n### 常用postcss插件\n\n#### autoprefixer\n\n- 添加浏览器前缀\n\n#### postcss-import\n\n- 解析@import路径用\n- https://github.com/postcss/postcss-import\n\n#### postcss-url\n\n- 解析url()，可以改路径、转换base64、复制加hash\n- https://github.com/postcss/postcss-url\n\n#### postcss-plugin-px2rem\n\n- 转换px为rem\n- https://github.com/pigcan/postcss-plugin-px2rem\n\n### .postcssrc.js文件配置\n\n```\nmodule.exports = {\n    \"plugins\": {\n        \"postcss-import\": {},\n        \"postcss-url\": {},\n        \"postcss-plugin-px2rem\": {\n            //设计稿尺寸/10\n            rootValue: 37.5,\n            //屏蔽的属性\n            propBlackList: ['border'],\n            //屏蔽的路径\n            exclude: /src/,\n        },\n        \"autoprefixer\": {}\n    }\n}\n```\n","source":"_posts/[css]postcss相关配置.md","raw":"---\ntitle: <css>postcss相关配置\ndate: 2019-01-31 00:00:00\ntags: [css,postcss]\ncategories: postcss\n---\n\n### postcss做了什么\n\n1. postcss 将你的 css 文件转变成 JS 对象\n2. postcss 插件会遍历生成的js对象添加/删除/修改选择器或属性\n3. postcss 将该对象转换成 css 文件\n\n### webpack配置postcss\n\n```\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'postcss-loader'],\n      },\n      {\n        test: /\\.jsx?$/,\n        use: ['babel-loader', 'astroturf/loader'],\n      }\n    ]\n  }\n}\n```\n### 常用postcss插件\n\n#### autoprefixer\n\n- 添加浏览器前缀\n\n#### postcss-import\n\n- 解析@import路径用\n- https://github.com/postcss/postcss-import\n\n#### postcss-url\n\n- 解析url()，可以改路径、转换base64、复制加hash\n- https://github.com/postcss/postcss-url\n\n#### postcss-plugin-px2rem\n\n- 转换px为rem\n- https://github.com/pigcan/postcss-plugin-px2rem\n\n### .postcssrc.js文件配置\n\n```\nmodule.exports = {\n    \"plugins\": {\n        \"postcss-import\": {},\n        \"postcss-url\": {},\n        \"postcss-plugin-px2rem\": {\n            //设计稿尺寸/10\n            rootValue: 37.5,\n            //屏蔽的属性\n            propBlackList: ['border'],\n            //屏蔽的路径\n            exclude: /src/,\n        },\n        \"autoprefixer\": {}\n    }\n}\n```\n","slug":"[css]postcss相关配置","published":1,"updated":"2021-03-15T14:36:03.517Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dk9000zwotj04ar0sma","content":"<h3 id=\"postcss做了什么\"><a href=\"#postcss做了什么\" class=\"headerlink\" title=\"postcss做了什么\"></a>postcss做了什么</h3><ol>\n<li>postcss 将你的 css 文件转变成 JS 对象</li>\n<li>postcss 插件会遍历生成的js对象添加/删除/修改选择器或属性</li>\n<li>postcss 将该对象转换成 css 文件</li>\n</ol>\n<h3 id=\"webpack配置postcss\"><a href=\"#webpack配置postcss\" class=\"headerlink\" title=\"webpack配置postcss\"></a>webpack配置postcss</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: &#x2F;\\.css$&#x2F;,</span><br><span class=\"line\">        use: [&#39;style-loader&#39;, &#39;postcss-loader&#39;],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: &#x2F;\\.jsx?$&#x2F;,</span><br><span class=\"line\">        use: [&#39;babel-loader&#39;, &#39;astroturf&#x2F;loader&#39;],</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"常用postcss插件\"><a href=\"#常用postcss插件\" class=\"headerlink\" title=\"常用postcss插件\"></a>常用postcss插件</h3><h4 id=\"autoprefixer\"><a href=\"#autoprefixer\" class=\"headerlink\" title=\"autoprefixer\"></a>autoprefixer</h4><ul>\n<li>添加浏览器前缀</li>\n</ul>\n<h4 id=\"postcss-import\"><a href=\"#postcss-import\" class=\"headerlink\" title=\"postcss-import\"></a>postcss-import</h4><ul>\n<li>解析@import路径用</li>\n<li><a href=\"https://github.com/postcss/postcss-import\">https://github.com/postcss/postcss-import</a></li>\n</ul>\n<h4 id=\"postcss-url\"><a href=\"#postcss-url\" class=\"headerlink\" title=\"postcss-url\"></a>postcss-url</h4><ul>\n<li>解析url()，可以改路径、转换base64、复制加hash</li>\n<li><a href=\"https://github.com/postcss/postcss-url\">https://github.com/postcss/postcss-url</a></li>\n</ul>\n<h4 id=\"postcss-plugin-px2rem\"><a href=\"#postcss-plugin-px2rem\" class=\"headerlink\" title=\"postcss-plugin-px2rem\"></a>postcss-plugin-px2rem</h4><ul>\n<li>转换px为rem</li>\n<li><a href=\"https://github.com/pigcan/postcss-plugin-px2rem\">https://github.com/pigcan/postcss-plugin-px2rem</a></li>\n</ul>\n<h3 id=\"postcssrc-js文件配置\"><a href=\"#postcssrc-js文件配置\" class=\"headerlink\" title=\".postcssrc.js文件配置\"></a>.postcssrc.js文件配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">    &quot;plugins&quot;: &#123;</span><br><span class=\"line\">        &quot;postcss-import&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-url&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-plugin-px2rem&quot;: &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;设计稿尺寸&#x2F;10</span><br><span class=\"line\">            rootValue: 37.5,</span><br><span class=\"line\">            &#x2F;&#x2F;屏蔽的属性</span><br><span class=\"line\">            propBlackList: [&#39;border&#39;],</span><br><span class=\"line\">            &#x2F;&#x2F;屏蔽的路径</span><br><span class=\"line\">            exclude: &#x2F;src&#x2F;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;autoprefixer&quot;: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"postcss做了什么\"><a href=\"#postcss做了什么\" class=\"headerlink\" title=\"postcss做了什么\"></a>postcss做了什么</h3><ol>\n<li>postcss 将你的 css 文件转变成 JS 对象</li>\n<li>postcss 插件会遍历生成的js对象添加/删除/修改选择器或属性</li>\n<li>postcss 将该对象转换成 css 文件</li>\n</ol>\n<h3 id=\"webpack配置postcss\"><a href=\"#webpack配置postcss\" class=\"headerlink\" title=\"webpack配置postcss\"></a>webpack配置postcss</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: &#x2F;\\.css$&#x2F;,</span><br><span class=\"line\">        use: [&#39;style-loader&#39;, &#39;postcss-loader&#39;],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: &#x2F;\\.jsx?$&#x2F;,</span><br><span class=\"line\">        use: [&#39;babel-loader&#39;, &#39;astroturf&#x2F;loader&#39;],</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"常用postcss插件\"><a href=\"#常用postcss插件\" class=\"headerlink\" title=\"常用postcss插件\"></a>常用postcss插件</h3><h4 id=\"autoprefixer\"><a href=\"#autoprefixer\" class=\"headerlink\" title=\"autoprefixer\"></a>autoprefixer</h4><ul>\n<li>添加浏览器前缀</li>\n</ul>\n<h4 id=\"postcss-import\"><a href=\"#postcss-import\" class=\"headerlink\" title=\"postcss-import\"></a>postcss-import</h4><ul>\n<li>解析@import路径用</li>\n<li><a href=\"https://github.com/postcss/postcss-import\">https://github.com/postcss/postcss-import</a></li>\n</ul>\n<h4 id=\"postcss-url\"><a href=\"#postcss-url\" class=\"headerlink\" title=\"postcss-url\"></a>postcss-url</h4><ul>\n<li>解析url()，可以改路径、转换base64、复制加hash</li>\n<li><a href=\"https://github.com/postcss/postcss-url\">https://github.com/postcss/postcss-url</a></li>\n</ul>\n<h4 id=\"postcss-plugin-px2rem\"><a href=\"#postcss-plugin-px2rem\" class=\"headerlink\" title=\"postcss-plugin-px2rem\"></a>postcss-plugin-px2rem</h4><ul>\n<li>转换px为rem</li>\n<li><a href=\"https://github.com/pigcan/postcss-plugin-px2rem\">https://github.com/pigcan/postcss-plugin-px2rem</a></li>\n</ul>\n<h3 id=\"postcssrc-js文件配置\"><a href=\"#postcssrc-js文件配置\" class=\"headerlink\" title=\".postcssrc.js文件配置\"></a>.postcssrc.js文件配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">    &quot;plugins&quot;: &#123;</span><br><span class=\"line\">        &quot;postcss-import&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-url&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-plugin-px2rem&quot;: &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;设计稿尺寸&#x2F;10</span><br><span class=\"line\">            rootValue: 37.5,</span><br><span class=\"line\">            &#x2F;&#x2F;屏蔽的属性</span><br><span class=\"line\">            propBlackList: [&#39;border&#39;],</span><br><span class=\"line\">            &#x2F;&#x2F;屏蔽的路径</span><br><span class=\"line\">            exclude: &#x2F;src&#x2F;,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;autoprefixer&quot;: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"<css>translateY-实现列表hover的box-shadow动画","date":"2018-10-01T16:00:00.000Z","_content":"### demo\n[demo](https://codepen.io/crazyaguai/pen/gQvBdY)\n\n### 代码\n\n```\n<style>\n    .container{\n        transition: box-shadow .28s cubic-bezier(.4,0,.2,1);\n        box-shadow: 0 1px 4px 0 rgba(10,16,20,.37);\n    }\n    .item{\n        color: #1a2326;\n        border: 1px solid transparent;\n        margin: 0;\n        padding: 16px 23px;\n        position: relative;\n        text-decoration: none;\n        transition: .3s;\n        height: 60px;\n    }\n    .item:hover{\n        cursor: pointer;\n        border-color: #2b85e7;\n        border-radius: 4px;\n        box-shadow: 0 8px 8px rgba(1,67,163,.24), 0 0 8px rgba(1,67,163,.12), 0 6px 18px rgba(43,133,231,.12);\n        transform: translateY(-2px);\n    }\n</style>\n<body>\n<div class=\"container\">\n    <div class=\"item\">1</div>\n    <div class=\"item\">2</div>\n    <div class=\"item\">3</div>\n    <div class=\"item\">4</div>\n    <div class=\"item\">5</div>\n</div>\n</body>\n```\n\n\n","source":"_posts/[css]translateY-实现列表hover的box-shadow动画.md","raw":"---\ntitle: <css>translateY-实现列表hover的box-shadow动画\ndate: 2018-10-02 00:00:00\ntags: [css,css动画]\ncategories: css\n---\n### demo\n[demo](https://codepen.io/crazyaguai/pen/gQvBdY)\n\n### 代码\n\n```\n<style>\n    .container{\n        transition: box-shadow .28s cubic-bezier(.4,0,.2,1);\n        box-shadow: 0 1px 4px 0 rgba(10,16,20,.37);\n    }\n    .item{\n        color: #1a2326;\n        border: 1px solid transparent;\n        margin: 0;\n        padding: 16px 23px;\n        position: relative;\n        text-decoration: none;\n        transition: .3s;\n        height: 60px;\n    }\n    .item:hover{\n        cursor: pointer;\n        border-color: #2b85e7;\n        border-radius: 4px;\n        box-shadow: 0 8px 8px rgba(1,67,163,.24), 0 0 8px rgba(1,67,163,.12), 0 6px 18px rgba(43,133,231,.12);\n        transform: translateY(-2px);\n    }\n</style>\n<body>\n<div class=\"container\">\n    <div class=\"item\">1</div>\n    <div class=\"item\">2</div>\n    <div class=\"item\">3</div>\n    <div class=\"item\">4</div>\n    <div class=\"item\">5</div>\n</div>\n</body>\n```\n\n\n","slug":"[css]translateY-实现列表hover的box-shadow动画","published":1,"updated":"2021-03-15T14:36:09.545Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dka0012wotj65fg1eom","content":"<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><p><a href=\"https://codepen.io/crazyaguai/pen/gQvBdY\">demo</a></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .container&#123;</span><br><span class=\"line\">        transition: box-shadow .28s cubic-bezier(.4,0,.2,1);</span><br><span class=\"line\">        box-shadow: 0 1px 4px 0 rgba(10,16,20,.37);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .item&#123;</span><br><span class=\"line\">        color: #1a2326;</span><br><span class=\"line\">        border: 1px solid transparent;</span><br><span class=\"line\">        margin: 0;</span><br><span class=\"line\">        padding: 16px 23px;</span><br><span class=\"line\">        position: relative;</span><br><span class=\"line\">        text-decoration: none;</span><br><span class=\"line\">        transition: .3s;</span><br><span class=\"line\">        height: 60px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .item:hover&#123;</span><br><span class=\"line\">        cursor: pointer;</span><br><span class=\"line\">        border-color: #2b85e7;</span><br><span class=\"line\">        border-radius: 4px;</span><br><span class=\"line\">        box-shadow: 0 8px 8px rgba(1,67,163,.24), 0 0 8px rgba(1,67,163,.12), 0 6px 18px rgba(43,133,231,.12);</span><br><span class=\"line\">        transform: translateY(-2px);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;item&quot;&gt;1&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;item&quot;&gt;2&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;item&quot;&gt;3&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;item&quot;&gt;4&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;item&quot;&gt;5&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"demo\"><a href=\"#demo\" class=\"headerlink\" title=\"demo\"></a>demo</h3><p><a href=\"https://codepen.io/crazyaguai/pen/gQvBdY\">demo</a></p>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .container&#123;</span><br><span class=\"line\">        transition: box-shadow .28s cubic-bezier(.4,0,.2,1);</span><br><span class=\"line\">        box-shadow: 0 1px 4px 0 rgba(10,16,20,.37);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .item&#123;</span><br><span class=\"line\">        color: #1a2326;</span><br><span class=\"line\">        border: 1px solid transparent;</span><br><span class=\"line\">        margin: 0;</span><br><span class=\"line\">        padding: 16px 23px;</span><br><span class=\"line\">        position: relative;</span><br><span class=\"line\">        text-decoration: none;</span><br><span class=\"line\">        transition: .3s;</span><br><span class=\"line\">        height: 60px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .item:hover&#123;</span><br><span class=\"line\">        cursor: pointer;</span><br><span class=\"line\">        border-color: #2b85e7;</span><br><span class=\"line\">        border-radius: 4px;</span><br><span class=\"line\">        box-shadow: 0 8px 8px rgba(1,67,163,.24), 0 0 8px rgba(1,67,163,.12), 0 6px 18px rgba(43,133,231,.12);</span><br><span class=\"line\">        transform: translateY(-2px);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;&#x2F;style&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;item&quot;&gt;1&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;item&quot;&gt;2&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;item&quot;&gt;3&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;item&quot;&gt;4&lt;&#x2F;div&gt;</span><br><span class=\"line\">    &lt;div class&#x3D;&quot;item&quot;&gt;5&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"<css>动画相关概念","date":"2019-02-15T16:00:00.000Z","_content":"\n### transition\n\n#### 基本参数\n\n1. transition-property: 过渡属性(默认值为all)\n\n- 只有具有中间值的属性才具备过渡效果\n\n2. transition-duration: 过渡持续时间(默认值为0s)\n\n- 单位是秒s或毫秒ms\n\n3. transiton-timing-function: 过渡函数(默认值为ease函数)\n\n- steps函数，将过渡时间划分成大小相等的时间时隔来运行，steps(<integer>[,start | end]?)，第二个参数: 该参数可选，默认是end，表示开始值保持一次；若参数为start，表示开始不保持（设置start开始就执行第一次变化）。\n- 贝塞尔曲线\n- 关键字，关键字其实是bezier函数或steps函数的特殊值\n\n```\nease: 开始和结束慢，中间快。相当于cubic-bezier(0.25,0.1,0.25,1)\nlinear: 匀速。相当于cubic-bezier(0,0,1,1)\nease-in: 开始慢。相当于cubic-bezier(0.42,0,1,1)\nease-out: 结束慢。相当于cubic-bezier(0,0,0.58,1)\nease-in-out: 和ease类似，但比ease幅度大。相当于cubic-bezier(0.42,0,0.58,1)\nstep-start: 直接位于结束处。相当于steps(1,start)\nstep-end: 位于开始处经过时间间隔后结束。相当于steps(1,end)\n```\n\n4. transition-delay: 过渡延迟时间(默认值为0s)\n\n- 单位是秒s或毫秒ms\n\n#### 复合属性\n\n```\ntransition: <transition-property> || <transition-duration> || <transition-timing-function> || <transition-delay>\n```\n\n#### 多值、无效值、重复值情况\n\n```\n#test1{\n    transition-property: width,width,xxx,background;\n    transition-duration: 2s,500ms;\n    transition-timing-function: linear,ease;\n    transition-delay: 200ms,0s;\n}\n/*类似于*/\n#test2{\n    transition: width 500ms ease 0ms,background 500ms ease 0ms;\n}\n```\n\n#### 触发方式\n\n- :hover、:focus、:active\n- @media触发\n- 事件改变属性\n\n#### 过渡transitionend事件\n\n```\ndocument.getElementById('tran').addEventListener('transitionend',(e)=>{\n    console.log(e.propertyName)//属性名称\n    console.log(e.elapsedTime)//过度时间\n    console.log(e.pseudoElement)//如果transition效果发生在伪元素，会返回该伪元素的名称，以“::”开头。(::after)\n})\n```\n\n1. 过渡分为两个阶段：前进阶段和反向阶段。transitionend事件在前进阶段结束时会触发，在反向阶段结束时也会触发。\n2. 如果过渡属性是复合属性，如border-width相当于是border-top-width、border-bottom-width、border-left-width和border-right-width这四个属性的集合。则过渡事件触发4次。\n3. 如果过渡属性是默认值all，则过渡事件的次数是计算后的非复合的过渡属性的个数。如果发生过渡的属性是border-width和width，则经过计算后过渡事件应该触发5次。\n4. 如果过渡延迟时间为负值，且绝对值大于等于过渡持续时间时，低版本webkit内核浏览器不会产生过渡效果，但会触发过渡事件；而其他浏览器即不会产生过渡效果，也不会触发过渡事件。\n5. 如果过渡属性存在复合属性及该复合属性包含的非复合属性，则浏览器计算复合属性的子属性时，不会重复计算已包含的属性。\n\n#### 参考\n\n- https://www.cnblogs.com/xiaohuochai/p/5347930.html\n\n### animation\n\n#### 基本参数\n\n1. animation-name ：检索或设置对象所应用的动画名称\n\n```\n@keyframes testanimations {\n\tfrom { transform: translate(0, 0); }\n\t20% { transform: translate(20px, 20px); }\n\t40% { transform: translate(40px, 0); }\n\t60% { transform: translate(60px, 20); }\n\t80% { transform: translate(80px, 0); }\n\tto { transform: translate(100px, 20px); }\n}\n```\n\n2. animation-duration ：检索或设置对象动画的持续时间\n3. animation-timing-function：检索或设置对象动画的过渡类型\n\n- linear：线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)\n- ease：平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)\n- ease-in：由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)\n- ease-out：由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0)\n- ease-in-out：由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)\n- step-start：等同于 steps(1, start)\n- step-end：等同于 steps(1, end)\n- steps(<integer>[, [ start | end ] ]?)：接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是start或end，指定每一步的值发生变化的时间点。第二个参数是可选的，默认值为end。\n- cubic-bezier(<number>, <number>, <number>, <number>)：特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内\n\n4. animation-delay：检索或设置对象动画延迟的时间\n5. animation-iteration-count：检索或设置对象动画的循环次数\n- infinite：无限循环\n- <number>：指定对象动画的具体循环次数\n6. animation-direction：检索或设置对象动画在循环中是否反向运动\n\n- normal：正常方向\n- reverse：反方向运行\n- alternate：动画先正常运行再反方向运行，并持续交替运行\n- alternate-reverse：动画先反运行再正方向运行，并持续交替运行\n\n7. animation-fill-mode：检索或设置对象动画时间之外的状态\n\n- none：默认值。不设置对象动画之外的状态\n- forwards：设置对象状态为动画结束时的状态\n- backwards：设置对象状态为动画开始时的状态\n- both：设置对象状态为动画结束或开始的状态\n\n8. animation-play-state ：检索或设置对象动画的状态。w3c正考虑是否将该属性移除，因为动画的状态可以通过其它的方式实现，比如重设样式\n\n- running：运动\n- paused：暂停\n\n#### 复合属性\n\n```\nanimation: <single-animation-name> || <animation-duration> || <single-animation-timing-function> || <animation-delay> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state>\n```\n\n#### 参考\n\n- https://www.css88.com/book/css/properties/animation/animation.htm\n\n### Web Animations API\n\n#### 参考\n\n- https://www.zhangxinxu.com/wordpress/2018/03/web-animations-api-dynamic-feature-animation/\n- https://juejin.im/post/5bc58bd9e51d450e721108a4\n\n### SVG SMIL animation\n\n#### 参考\n- https://www.zhangxinxu.com/wordpress/2014/08/so-powerful-svg-smil-animation/\n\n### Canvas绘制\n","source":"_posts/[css]动画相关概念.md","raw":"---\ntitle: <css>动画相关概念\ndate: 2019-02-16 00:00:00\ntags: [css,动画]\ncategories: css\n---\n\n### transition\n\n#### 基本参数\n\n1. transition-property: 过渡属性(默认值为all)\n\n- 只有具有中间值的属性才具备过渡效果\n\n2. transition-duration: 过渡持续时间(默认值为0s)\n\n- 单位是秒s或毫秒ms\n\n3. transiton-timing-function: 过渡函数(默认值为ease函数)\n\n- steps函数，将过渡时间划分成大小相等的时间时隔来运行，steps(<integer>[,start | end]?)，第二个参数: 该参数可选，默认是end，表示开始值保持一次；若参数为start，表示开始不保持（设置start开始就执行第一次变化）。\n- 贝塞尔曲线\n- 关键字，关键字其实是bezier函数或steps函数的特殊值\n\n```\nease: 开始和结束慢，中间快。相当于cubic-bezier(0.25,0.1,0.25,1)\nlinear: 匀速。相当于cubic-bezier(0,0,1,1)\nease-in: 开始慢。相当于cubic-bezier(0.42,0,1,1)\nease-out: 结束慢。相当于cubic-bezier(0,0,0.58,1)\nease-in-out: 和ease类似，但比ease幅度大。相当于cubic-bezier(0.42,0,0.58,1)\nstep-start: 直接位于结束处。相当于steps(1,start)\nstep-end: 位于开始处经过时间间隔后结束。相当于steps(1,end)\n```\n\n4. transition-delay: 过渡延迟时间(默认值为0s)\n\n- 单位是秒s或毫秒ms\n\n#### 复合属性\n\n```\ntransition: <transition-property> || <transition-duration> || <transition-timing-function> || <transition-delay>\n```\n\n#### 多值、无效值、重复值情况\n\n```\n#test1{\n    transition-property: width,width,xxx,background;\n    transition-duration: 2s,500ms;\n    transition-timing-function: linear,ease;\n    transition-delay: 200ms,0s;\n}\n/*类似于*/\n#test2{\n    transition: width 500ms ease 0ms,background 500ms ease 0ms;\n}\n```\n\n#### 触发方式\n\n- :hover、:focus、:active\n- @media触发\n- 事件改变属性\n\n#### 过渡transitionend事件\n\n```\ndocument.getElementById('tran').addEventListener('transitionend',(e)=>{\n    console.log(e.propertyName)//属性名称\n    console.log(e.elapsedTime)//过度时间\n    console.log(e.pseudoElement)//如果transition效果发生在伪元素，会返回该伪元素的名称，以“::”开头。(::after)\n})\n```\n\n1. 过渡分为两个阶段：前进阶段和反向阶段。transitionend事件在前进阶段结束时会触发，在反向阶段结束时也会触发。\n2. 如果过渡属性是复合属性，如border-width相当于是border-top-width、border-bottom-width、border-left-width和border-right-width这四个属性的集合。则过渡事件触发4次。\n3. 如果过渡属性是默认值all，则过渡事件的次数是计算后的非复合的过渡属性的个数。如果发生过渡的属性是border-width和width，则经过计算后过渡事件应该触发5次。\n4. 如果过渡延迟时间为负值，且绝对值大于等于过渡持续时间时，低版本webkit内核浏览器不会产生过渡效果，但会触发过渡事件；而其他浏览器即不会产生过渡效果，也不会触发过渡事件。\n5. 如果过渡属性存在复合属性及该复合属性包含的非复合属性，则浏览器计算复合属性的子属性时，不会重复计算已包含的属性。\n\n#### 参考\n\n- https://www.cnblogs.com/xiaohuochai/p/5347930.html\n\n### animation\n\n#### 基本参数\n\n1. animation-name ：检索或设置对象所应用的动画名称\n\n```\n@keyframes testanimations {\n\tfrom { transform: translate(0, 0); }\n\t20% { transform: translate(20px, 20px); }\n\t40% { transform: translate(40px, 0); }\n\t60% { transform: translate(60px, 20); }\n\t80% { transform: translate(80px, 0); }\n\tto { transform: translate(100px, 20px); }\n}\n```\n\n2. animation-duration ：检索或设置对象动画的持续时间\n3. animation-timing-function：检索或设置对象动画的过渡类型\n\n- linear：线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)\n- ease：平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)\n- ease-in：由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)\n- ease-out：由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0)\n- ease-in-out：由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)\n- step-start：等同于 steps(1, start)\n- step-end：等同于 steps(1, end)\n- steps(<integer>[, [ start | end ] ]?)：接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是start或end，指定每一步的值发生变化的时间点。第二个参数是可选的，默认值为end。\n- cubic-bezier(<number>, <number>, <number>, <number>)：特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内\n\n4. animation-delay：检索或设置对象动画延迟的时间\n5. animation-iteration-count：检索或设置对象动画的循环次数\n- infinite：无限循环\n- <number>：指定对象动画的具体循环次数\n6. animation-direction：检索或设置对象动画在循环中是否反向运动\n\n- normal：正常方向\n- reverse：反方向运行\n- alternate：动画先正常运行再反方向运行，并持续交替运行\n- alternate-reverse：动画先反运行再正方向运行，并持续交替运行\n\n7. animation-fill-mode：检索或设置对象动画时间之外的状态\n\n- none：默认值。不设置对象动画之外的状态\n- forwards：设置对象状态为动画结束时的状态\n- backwards：设置对象状态为动画开始时的状态\n- both：设置对象状态为动画结束或开始的状态\n\n8. animation-play-state ：检索或设置对象动画的状态。w3c正考虑是否将该属性移除，因为动画的状态可以通过其它的方式实现，比如重设样式\n\n- running：运动\n- paused：暂停\n\n#### 复合属性\n\n```\nanimation: <single-animation-name> || <animation-duration> || <single-animation-timing-function> || <animation-delay> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state>\n```\n\n#### 参考\n\n- https://www.css88.com/book/css/properties/animation/animation.htm\n\n### Web Animations API\n\n#### 参考\n\n- https://www.zhangxinxu.com/wordpress/2018/03/web-animations-api-dynamic-feature-animation/\n- https://juejin.im/post/5bc58bd9e51d450e721108a4\n\n### SVG SMIL animation\n\n#### 参考\n- https://www.zhangxinxu.com/wordpress/2014/08/so-powerful-svg-smil-animation/\n\n### Canvas绘制\n","slug":"[css]动画相关概念","published":1,"updated":"2021-03-15T14:35:39.633Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dkb0015wotj9xcygqlq","content":"<h3 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h3><h4 id=\"基本参数\"><a href=\"#基本参数\" class=\"headerlink\" title=\"基本参数\"></a>基本参数</h4><ol>\n<li>transition-property: 过渡属性(默认值为all)</li>\n</ol>\n<ul>\n<li>只有具有中间值的属性才具备过渡效果</li>\n</ul>\n<ol start=\"2\">\n<li>transition-duration: 过渡持续时间(默认值为0s)</li>\n</ol>\n<ul>\n<li>单位是秒s或毫秒ms</li>\n</ul>\n<ol start=\"3\">\n<li>transiton-timing-function: 过渡函数(默认值为ease函数)</li>\n</ol>\n<ul>\n<li>steps函数，将过渡时间划分成大小相等的时间时隔来运行，steps(<integer>[,start | end]?)，第二个参数: 该参数可选，默认是end，表示开始值保持一次；若参数为start，表示开始不保持（设置start开始就执行第一次变化）。</li>\n<li>贝塞尔曲线</li>\n<li>关键字，关键字其实是bezier函数或steps函数的特殊值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ease: 开始和结束慢，中间快。相当于cubic-bezier(0.25,0.1,0.25,1)</span><br><span class=\"line\">linear: 匀速。相当于cubic-bezier(0,0,1,1)</span><br><span class=\"line\">ease-in: 开始慢。相当于cubic-bezier(0.42,0,1,1)</span><br><span class=\"line\">ease-out: 结束慢。相当于cubic-bezier(0,0,0.58,1)</span><br><span class=\"line\">ease-in-out: 和ease类似，但比ease幅度大。相当于cubic-bezier(0.42,0,0.58,1)</span><br><span class=\"line\">step-start: 直接位于结束处。相当于steps(1,start)</span><br><span class=\"line\">step-end: 位于开始处经过时间间隔后结束。相当于steps(1,end)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>transition-delay: 过渡延迟时间(默认值为0s)</li>\n</ol>\n<ul>\n<li>单位是秒s或毫秒ms</li>\n</ul>\n<h4 id=\"复合属性\"><a href=\"#复合属性\" class=\"headerlink\" title=\"复合属性\"></a>复合属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transition: &lt;transition-property&gt; || &lt;transition-duration&gt; || &lt;transition-timing-function&gt; || &lt;transition-delay&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多值、无效值、重复值情况\"><a href=\"#多值、无效值、重复值情况\" class=\"headerlink\" title=\"多值、无效值、重复值情况\"></a>多值、无效值、重复值情况</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#test1&#123;</span><br><span class=\"line\">    transition-property: width,width,xxx,background;</span><br><span class=\"line\">    transition-duration: 2s,500ms;</span><br><span class=\"line\">    transition-timing-function: linear,ease;</span><br><span class=\"line\">    transition-delay: 200ms,0s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;*类似于*&#x2F;</span><br><span class=\"line\">#test2&#123;</span><br><span class=\"line\">    transition: width 500ms ease 0ms,background 500ms ease 0ms;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"触发方式\"><a href=\"#触发方式\" class=\"headerlink\" title=\"触发方式\"></a>触发方式</h4><ul>\n<li>:hover、:focus、:active</li>\n<li>@media触发</li>\n<li>事件改变属性</li>\n</ul>\n<h4 id=\"过渡transitionend事件\"><a href=\"#过渡transitionend事件\" class=\"headerlink\" title=\"过渡transitionend事件\"></a>过渡transitionend事件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&#39;tran&#39;).addEventListener(&#39;transitionend&#39;,(e)&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(e.propertyName)&#x2F;&#x2F;属性名称</span><br><span class=\"line\">    console.log(e.elapsedTime)&#x2F;&#x2F;过度时间</span><br><span class=\"line\">    console.log(e.pseudoElement)&#x2F;&#x2F;如果transition效果发生在伪元素，会返回该伪元素的名称，以“::”开头。(::after)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>过渡分为两个阶段：前进阶段和反向阶段。transitionend事件在前进阶段结束时会触发，在反向阶段结束时也会触发。</li>\n<li>如果过渡属性是复合属性，如border-width相当于是border-top-width、border-bottom-width、border-left-width和border-right-width这四个属性的集合。则过渡事件触发4次。</li>\n<li>如果过渡属性是默认值all，则过渡事件的次数是计算后的非复合的过渡属性的个数。如果发生过渡的属性是border-width和width，则经过计算后过渡事件应该触发5次。</li>\n<li>如果过渡延迟时间为负值，且绝对值大于等于过渡持续时间时，低版本webkit内核浏览器不会产生过渡效果，但会触发过渡事件；而其他浏览器即不会产生过渡效果，也不会触发过渡事件。</li>\n<li>如果过渡属性存在复合属性及该复合属性包含的非复合属性，则浏览器计算复合属性的子属性时，不会重复计算已包含的属性。</li>\n</ol>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ul>\n<li><a href=\"https://www.cnblogs.com/xiaohuochai/p/5347930.html\">https://www.cnblogs.com/xiaohuochai/p/5347930.html</a></li>\n</ul>\n<h3 id=\"animation\"><a href=\"#animation\" class=\"headerlink\" title=\"animation\"></a>animation</h3><h4 id=\"基本参数-1\"><a href=\"#基本参数-1\" class=\"headerlink\" title=\"基本参数\"></a>基本参数</h4><ol>\n<li>animation-name ：检索或设置对象所应用的动画名称</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@keyframes testanimations &#123;</span><br><span class=\"line\">\tfrom &#123; transform: translate(0, 0); &#125;</span><br><span class=\"line\">\t20% &#123; transform: translate(20px, 20px); &#125;</span><br><span class=\"line\">\t40% &#123; transform: translate(40px, 0); &#125;</span><br><span class=\"line\">\t60% &#123; transform: translate(60px, 20); &#125;</span><br><span class=\"line\">\t80% &#123; transform: translate(80px, 0); &#125;</span><br><span class=\"line\">\tto &#123; transform: translate(100px, 20px); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>animation-duration ：检索或设置对象动画的持续时间</li>\n<li>animation-timing-function：检索或设置对象动画的过渡类型</li>\n</ol>\n<ul>\n<li>linear：线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)</li>\n<li>ease：平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)</li>\n<li>ease-in：由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)</li>\n<li>ease-out：由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0)</li>\n<li>ease-in-out：由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)</li>\n<li>step-start：等同于 steps(1, start)</li>\n<li>step-end：等同于 steps(1, end)</li>\n<li>steps(<integer>[, [ start | end ] ]?)：接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是start或end，指定每一步的值发生变化的时间点。第二个参数是可选的，默认值为end。</li>\n<li>cubic-bezier(<number>, <number>, <number>, <number>)：特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内</li>\n</ul>\n<ol start=\"4\">\n<li>animation-delay：检索或设置对象动画延迟的时间</li>\n<li>animation-iteration-count：检索或设置对象动画的循环次数</li>\n</ol>\n<ul>\n<li>infinite：无限循环</li>\n<li><number>：指定对象动画的具体循环次数</li>\n</ul>\n<ol start=\"6\">\n<li>animation-direction：检索或设置对象动画在循环中是否反向运动</li>\n</ol>\n<ul>\n<li>normal：正常方向</li>\n<li>reverse：反方向运行</li>\n<li>alternate：动画先正常运行再反方向运行，并持续交替运行</li>\n<li>alternate-reverse：动画先反运行再正方向运行，并持续交替运行</li>\n</ul>\n<ol start=\"7\">\n<li>animation-fill-mode：检索或设置对象动画时间之外的状态</li>\n</ol>\n<ul>\n<li>none：默认值。不设置对象动画之外的状态</li>\n<li>forwards：设置对象状态为动画结束时的状态</li>\n<li>backwards：设置对象状态为动画开始时的状态</li>\n<li>both：设置对象状态为动画结束或开始的状态</li>\n</ul>\n<ol start=\"8\">\n<li>animation-play-state ：检索或设置对象动画的状态。w3c正考虑是否将该属性移除，因为动画的状态可以通过其它的方式实现，比如重设样式</li>\n</ol>\n<ul>\n<li>running：运动</li>\n<li>paused：暂停</li>\n</ul>\n<h4 id=\"复合属性-1\"><a href=\"#复合属性-1\" class=\"headerlink\" title=\"复合属性\"></a>复合属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animation: &lt;single-animation-name&gt; || &lt;animation-duration&gt; || &lt;single-animation-timing-function&gt; || &lt;animation-delay&gt; || &lt;single-animation-iteration-count&gt; || &lt;single-animation-direction&gt; || &lt;single-animation-fill-mode&gt; || &lt;single-animation-play-state&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参考-1\"><a href=\"#参考-1\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ul>\n<li><a href=\"https://www.css88.com/book/css/properties/animation/animation.htm\">https://www.css88.com/book/css/properties/animation/animation.htm</a></li>\n</ul>\n<h3 id=\"Web-Animations-API\"><a href=\"#Web-Animations-API\" class=\"headerlink\" title=\"Web Animations API\"></a>Web Animations API</h3><h4 id=\"参考-2\"><a href=\"#参考-2\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ul>\n<li><a href=\"https://www.zhangxinxu.com/wordpress/2018/03/web-animations-api-dynamic-feature-animation/\">https://www.zhangxinxu.com/wordpress/2018/03/web-animations-api-dynamic-feature-animation/</a></li>\n<li><a href=\"https://juejin.im/post/5bc58bd9e51d450e721108a4\">https://juejin.im/post/5bc58bd9e51d450e721108a4</a></li>\n</ul>\n<h3 id=\"SVG-SMIL-animation\"><a href=\"#SVG-SMIL-animation\" class=\"headerlink\" title=\"SVG SMIL animation\"></a>SVG SMIL animation</h3><h4 id=\"参考-3\"><a href=\"#参考-3\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ul>\n<li><a href=\"https://www.zhangxinxu.com/wordpress/2014/08/so-powerful-svg-smil-animation/\">https://www.zhangxinxu.com/wordpress/2014/08/so-powerful-svg-smil-animation/</a></li>\n</ul>\n<h3 id=\"Canvas绘制\"><a href=\"#Canvas绘制\" class=\"headerlink\" title=\"Canvas绘制\"></a>Canvas绘制</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"transition\"><a href=\"#transition\" class=\"headerlink\" title=\"transition\"></a>transition</h3><h4 id=\"基本参数\"><a href=\"#基本参数\" class=\"headerlink\" title=\"基本参数\"></a>基本参数</h4><ol>\n<li>transition-property: 过渡属性(默认值为all)</li>\n</ol>\n<ul>\n<li>只有具有中间值的属性才具备过渡效果</li>\n</ul>\n<ol start=\"2\">\n<li>transition-duration: 过渡持续时间(默认值为0s)</li>\n</ol>\n<ul>\n<li>单位是秒s或毫秒ms</li>\n</ul>\n<ol start=\"3\">\n<li>transiton-timing-function: 过渡函数(默认值为ease函数)</li>\n</ol>\n<ul>\n<li>steps函数，将过渡时间划分成大小相等的时间时隔来运行，steps(<integer>[,start | end]?)，第二个参数: 该参数可选，默认是end，表示开始值保持一次；若参数为start，表示开始不保持（设置start开始就执行第一次变化）。</li>\n<li>贝塞尔曲线</li>\n<li>关键字，关键字其实是bezier函数或steps函数的特殊值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ease: 开始和结束慢，中间快。相当于cubic-bezier(0.25,0.1,0.25,1)</span><br><span class=\"line\">linear: 匀速。相当于cubic-bezier(0,0,1,1)</span><br><span class=\"line\">ease-in: 开始慢。相当于cubic-bezier(0.42,0,1,1)</span><br><span class=\"line\">ease-out: 结束慢。相当于cubic-bezier(0,0,0.58,1)</span><br><span class=\"line\">ease-in-out: 和ease类似，但比ease幅度大。相当于cubic-bezier(0.42,0,0.58,1)</span><br><span class=\"line\">step-start: 直接位于结束处。相当于steps(1,start)</span><br><span class=\"line\">step-end: 位于开始处经过时间间隔后结束。相当于steps(1,end)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>transition-delay: 过渡延迟时间(默认值为0s)</li>\n</ol>\n<ul>\n<li>单位是秒s或毫秒ms</li>\n</ul>\n<h4 id=\"复合属性\"><a href=\"#复合属性\" class=\"headerlink\" title=\"复合属性\"></a>复合属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">transition: &lt;transition-property&gt; || &lt;transition-duration&gt; || &lt;transition-timing-function&gt; || &lt;transition-delay&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"多值、无效值、重复值情况\"><a href=\"#多值、无效值、重复值情况\" class=\"headerlink\" title=\"多值、无效值、重复值情况\"></a>多值、无效值、重复值情况</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#test1&#123;</span><br><span class=\"line\">    transition-property: width,width,xxx,background;</span><br><span class=\"line\">    transition-duration: 2s,500ms;</span><br><span class=\"line\">    transition-timing-function: linear,ease;</span><br><span class=\"line\">    transition-delay: 200ms,0s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;*类似于*&#x2F;</span><br><span class=\"line\">#test2&#123;</span><br><span class=\"line\">    transition: width 500ms ease 0ms,background 500ms ease 0ms;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"触发方式\"><a href=\"#触发方式\" class=\"headerlink\" title=\"触发方式\"></a>触发方式</h4><ul>\n<li>:hover、:focus、:active</li>\n<li>@media触发</li>\n<li>事件改变属性</li>\n</ul>\n<h4 id=\"过渡transitionend事件\"><a href=\"#过渡transitionend事件\" class=\"headerlink\" title=\"过渡transitionend事件\"></a>过渡transitionend事件</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.getElementById(&#39;tran&#39;).addEventListener(&#39;transitionend&#39;,(e)&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(e.propertyName)&#x2F;&#x2F;属性名称</span><br><span class=\"line\">    console.log(e.elapsedTime)&#x2F;&#x2F;过度时间</span><br><span class=\"line\">    console.log(e.pseudoElement)&#x2F;&#x2F;如果transition效果发生在伪元素，会返回该伪元素的名称，以“::”开头。(::after)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>过渡分为两个阶段：前进阶段和反向阶段。transitionend事件在前进阶段结束时会触发，在反向阶段结束时也会触发。</li>\n<li>如果过渡属性是复合属性，如border-width相当于是border-top-width、border-bottom-width、border-left-width和border-right-width这四个属性的集合。则过渡事件触发4次。</li>\n<li>如果过渡属性是默认值all，则过渡事件的次数是计算后的非复合的过渡属性的个数。如果发生过渡的属性是border-width和width，则经过计算后过渡事件应该触发5次。</li>\n<li>如果过渡延迟时间为负值，且绝对值大于等于过渡持续时间时，低版本webkit内核浏览器不会产生过渡效果，但会触发过渡事件；而其他浏览器即不会产生过渡效果，也不会触发过渡事件。</li>\n<li>如果过渡属性存在复合属性及该复合属性包含的非复合属性，则浏览器计算复合属性的子属性时，不会重复计算已包含的属性。</li>\n</ol>\n<h4 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ul>\n<li><a href=\"https://www.cnblogs.com/xiaohuochai/p/5347930.html\">https://www.cnblogs.com/xiaohuochai/p/5347930.html</a></li>\n</ul>\n<h3 id=\"animation\"><a href=\"#animation\" class=\"headerlink\" title=\"animation\"></a>animation</h3><h4 id=\"基本参数-1\"><a href=\"#基本参数-1\" class=\"headerlink\" title=\"基本参数\"></a>基本参数</h4><ol>\n<li>animation-name ：检索或设置对象所应用的动画名称</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@keyframes testanimations &#123;</span><br><span class=\"line\">\tfrom &#123; transform: translate(0, 0); &#125;</span><br><span class=\"line\">\t20% &#123; transform: translate(20px, 20px); &#125;</span><br><span class=\"line\">\t40% &#123; transform: translate(40px, 0); &#125;</span><br><span class=\"line\">\t60% &#123; transform: translate(60px, 20); &#125;</span><br><span class=\"line\">\t80% &#123; transform: translate(80px, 0); &#125;</span><br><span class=\"line\">\tto &#123; transform: translate(100px, 20px); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>animation-duration ：检索或设置对象动画的持续时间</li>\n<li>animation-timing-function：检索或设置对象动画的过渡类型</li>\n</ol>\n<ul>\n<li>linear：线性过渡。等同于贝塞尔曲线(0.0, 0.0, 1.0, 1.0)</li>\n<li>ease：平滑过渡。等同于贝塞尔曲线(0.25, 0.1, 0.25, 1.0)</li>\n<li>ease-in：由慢到快。等同于贝塞尔曲线(0.42, 0, 1.0, 1.0)</li>\n<li>ease-out：由快到慢。等同于贝塞尔曲线(0, 0, 0.58, 1.0)</li>\n<li>ease-in-out：由慢到快再到慢。等同于贝塞尔曲线(0.42, 0, 0.58, 1.0)</li>\n<li>step-start：等同于 steps(1, start)</li>\n<li>step-end：等同于 steps(1, end)</li>\n<li>steps(<integer>[, [ start | end ] ]?)：接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是start或end，指定每一步的值发生变化的时间点。第二个参数是可选的，默认值为end。</li>\n<li>cubic-bezier(<number>, <number>, <number>, <number>)：特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内</li>\n</ul>\n<ol start=\"4\">\n<li>animation-delay：检索或设置对象动画延迟的时间</li>\n<li>animation-iteration-count：检索或设置对象动画的循环次数</li>\n</ol>\n<ul>\n<li>infinite：无限循环</li>\n<li><number>：指定对象动画的具体循环次数</li>\n</ul>\n<ol start=\"6\">\n<li>animation-direction：检索或设置对象动画在循环中是否反向运动</li>\n</ol>\n<ul>\n<li>normal：正常方向</li>\n<li>reverse：反方向运行</li>\n<li>alternate：动画先正常运行再反方向运行，并持续交替运行</li>\n<li>alternate-reverse：动画先反运行再正方向运行，并持续交替运行</li>\n</ul>\n<ol start=\"7\">\n<li>animation-fill-mode：检索或设置对象动画时间之外的状态</li>\n</ol>\n<ul>\n<li>none：默认值。不设置对象动画之外的状态</li>\n<li>forwards：设置对象状态为动画结束时的状态</li>\n<li>backwards：设置对象状态为动画开始时的状态</li>\n<li>both：设置对象状态为动画结束或开始的状态</li>\n</ul>\n<ol start=\"8\">\n<li>animation-play-state ：检索或设置对象动画的状态。w3c正考虑是否将该属性移除，因为动画的状态可以通过其它的方式实现，比如重设样式</li>\n</ol>\n<ul>\n<li>running：运动</li>\n<li>paused：暂停</li>\n</ul>\n<h4 id=\"复合属性-1\"><a href=\"#复合属性-1\" class=\"headerlink\" title=\"复合属性\"></a>复合属性</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">animation: &lt;single-animation-name&gt; || &lt;animation-duration&gt; || &lt;single-animation-timing-function&gt; || &lt;animation-delay&gt; || &lt;single-animation-iteration-count&gt; || &lt;single-animation-direction&gt; || &lt;single-animation-fill-mode&gt; || &lt;single-animation-play-state&gt;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"参考-1\"><a href=\"#参考-1\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ul>\n<li><a href=\"https://www.css88.com/book/css/properties/animation/animation.htm\">https://www.css88.com/book/css/properties/animation/animation.htm</a></li>\n</ul>\n<h3 id=\"Web-Animations-API\"><a href=\"#Web-Animations-API\" class=\"headerlink\" title=\"Web Animations API\"></a>Web Animations API</h3><h4 id=\"参考-2\"><a href=\"#参考-2\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ul>\n<li><a href=\"https://www.zhangxinxu.com/wordpress/2018/03/web-animations-api-dynamic-feature-animation/\">https://www.zhangxinxu.com/wordpress/2018/03/web-animations-api-dynamic-feature-animation/</a></li>\n<li><a href=\"https://juejin.im/post/5bc58bd9e51d450e721108a4\">https://juejin.im/post/5bc58bd9e51d450e721108a4</a></li>\n</ul>\n<h3 id=\"SVG-SMIL-animation\"><a href=\"#SVG-SMIL-animation\" class=\"headerlink\" title=\"SVG SMIL animation\"></a>SVG SMIL animation</h3><h4 id=\"参考-3\"><a href=\"#参考-3\" class=\"headerlink\" title=\"参考\"></a>参考</h4><ul>\n<li><a href=\"https://www.zhangxinxu.com/wordpress/2014/08/so-powerful-svg-smil-animation/\">https://www.zhangxinxu.com/wordpress/2014/08/so-powerful-svg-smil-animation/</a></li>\n</ul>\n<h3 id=\"Canvas绘制\"><a href=\"#Canvas绘制\" class=\"headerlink\" title=\"Canvas绘制\"></a>Canvas绘制</h3>"},{"title":"<css>选择器","date":"2019-04-19T16:00:00.000Z","_content":"\n### 选择器\n\n- [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference#Selectors)\n- [选择器参考手册](http://www.w3school.com.cn/cssref/css_selectors.asp)\n\n### 优先级\n\n- 接近度对优先级没有影响\n- 内联 > ID选择器 > 类选择器 > 标签选择器\n\n#### 计算规则\n\n- 优先级由(A,B,C,D)四项值决定。\n- 从左往右依次进行比较，较大者胜出，如果相等，则继续往又移动一位进行比较 。如果4位全部相等，则后面的会覆盖前面的\n- 计算方法\n\n1. 如果存在内联样式，那么 A = 1, 否则 A = 0;\n2. B 的值等于 ID选择器 出现的次数;\n3. C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数;\n4. D 的值等于 标签选择器 和 伪元素 出现的总次数。\n\n#### !important\n\n- max-width超越width !important\n","source":"_posts/[css]选择器.md","raw":"---\ntitle: <css>选择器\ndate: 2019-04-20 00:00:00\ntags: [css]\ncategories: css\n---\n\n### 选择器\n\n- [MDN](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference#Selectors)\n- [选择器参考手册](http://www.w3school.com.cn/cssref/css_selectors.asp)\n\n### 优先级\n\n- 接近度对优先级没有影响\n- 内联 > ID选择器 > 类选择器 > 标签选择器\n\n#### 计算规则\n\n- 优先级由(A,B,C,D)四项值决定。\n- 从左往右依次进行比较，较大者胜出，如果相等，则继续往又移动一位进行比较 。如果4位全部相等，则后面的会覆盖前面的\n- 计算方法\n\n1. 如果存在内联样式，那么 A = 1, 否则 A = 0;\n2. B 的值等于 ID选择器 出现的次数;\n3. C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数;\n4. D 的值等于 标签选择器 和 伪元素 出现的总次数。\n\n#### !important\n\n- max-width超越width !important\n","slug":"[css]选择器","published":1,"updated":"2021-03-15T14:35:51.436Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dkb0018wotj3ih58qto","content":"<h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Reference#Selectors\">MDN</a></li>\n<li><a href=\"http://www.w3school.com.cn/cssref/css_selectors.asp\">选择器参考手册</a></li>\n</ul>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><ul>\n<li>接近度对优先级没有影响</li>\n<li>内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</li>\n</ul>\n<h4 id=\"计算规则\"><a href=\"#计算规则\" class=\"headerlink\" title=\"计算规则\"></a>计算规则</h4><ul>\n<li>优先级由(A,B,C,D)四项值决定。</li>\n<li>从左往右依次进行比较，较大者胜出，如果相等，则继续往又移动一位进行比较 。如果4位全部相等，则后面的会覆盖前面的</li>\n<li>计算方法</li>\n</ul>\n<ol>\n<li>如果存在内联样式，那么 A = 1, 否则 A = 0;</li>\n<li>B 的值等于 ID选择器 出现的次数;</li>\n<li>C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数;</li>\n<li>D 的值等于 标签选择器 和 伪元素 出现的总次数。</li>\n</ol>\n<h4 id=\"important\"><a href=\"#important\" class=\"headerlink\" title=\"!important\"></a>!important</h4><ul>\n<li>max-width超越width !important</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"选择器\"><a href=\"#选择器\" class=\"headerlink\" title=\"选择器\"></a>选择器</h3><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Reference#Selectors\">MDN</a></li>\n<li><a href=\"http://www.w3school.com.cn/cssref/css_selectors.asp\">选择器参考手册</a></li>\n</ul>\n<h3 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h3><ul>\n<li>接近度对优先级没有影响</li>\n<li>内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</li>\n</ul>\n<h4 id=\"计算规则\"><a href=\"#计算规则\" class=\"headerlink\" title=\"计算规则\"></a>计算规则</h4><ul>\n<li>优先级由(A,B,C,D)四项值决定。</li>\n<li>从左往右依次进行比较，较大者胜出，如果相等，则继续往又移动一位进行比较 。如果4位全部相等，则后面的会覆盖前面的</li>\n<li>计算方法</li>\n</ul>\n<ol>\n<li>如果存在内联样式，那么 A = 1, 否则 A = 0;</li>\n<li>B 的值等于 ID选择器 出现的次数;</li>\n<li>C 的值等于 类选择器 和 属性选择器 和 伪类 出现的总次数;</li>\n<li>D 的值等于 标签选择器 和 伪元素 出现的总次数。</li>\n</ol>\n<h4 id=\"important\"><a href=\"#important\" class=\"headerlink\" title=\"!important\"></a>!important</h4><ul>\n<li>max-width超越width !important</li>\n</ul>\n"},{"title":"<hexo>创建Hexo-github博客流程","date":"2018-08-19T16:00:00.000Z","_content":"### 简介\n\n- HEXO快速、简单且功能强大的 Node.js 博客框架。\nhttps://hexo.io/zh-cn/\n\n### 安装\n\n1. 全局安装git以及nodeJs\n2. 全局安装hexo\n\n```\nnpm install -g hexo\n```\n\n3. 新建项目文件夹\n\n```\nmkdir hexo-project\n```\n\n4. 进入项目文件夹，初始化hexo\n\n```\ncd hexo-project\nhexo init\n\n```\n\n5. 安装依赖\n\n```\nnpm install\n```\n\n6. 启动服务\n\n```\nhexo server || hexo s\n```\n\n- 访问 http://127.0.0.1:4000/\n\n7. 此时可以在本地访问服务，下面进行提交代码到git的步骤，首先在 github (https://github.com/) 上创建项目，注意项目名字有格式要求必须为：[github用户名].github.io，否则不能使用，参考：https://github.com/crazyaguai/crazyaguai.github.io 名称。\n8. 安装hexo-deployer-git提交代码到git用，在项目中执行\n\n```\nnpm install hexo-deployer-git --save\n```\n\n9. 配置根路径_config.yml文件\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/crazyaguai/crazyaguai.github.io(你的项目地址)\n  branch: master\n```\n\n10. 配置完成就可以将Hexo博客提交代码到github上了，执行\n\n```\nhexo clean && hexo generate && hexo deploy || hexo c && hexo g && hexo d\n```\n\n11. 打开你的github hexo项目地址查看，例如 https://crazyaguai.github.io/\n\n### 目录结构\n\n- _config.yml：全局配置文件\n- package.json：依赖\n- scaffolds：文章脚手架，根据文件夹下的配置构建文章\n- source：新建文章保存在这个文件夹下，在此修改文章\n- themes：主题目录\n\n### _config.yml文件配置\n\n#### 根路径_config.yml配置\n\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n# Site 这里的配置，哪项配置反映在哪里，可以参考我的博客\ntitle:  #站点名，站点左上角\nsubtitle:  #副标题，站点左上角\ndescription:  #给搜索引擎看的，对站点的描述，可以自定义\nauthor:  #默认在站点左下角可以看到\nemail: #邮箱\nlanguage: zh-CN #语言包设置。\n# URL #访问地址等信息设置，可根据需要自己修改。\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: #访问域名\nroot: /\npermalink: :year/:month/:day/:title/ #具体内容页的存储路径结构\ntag_dir: tags #标签目录名\narchive_dir: archives #归档目录名\ncategory_dir: categories #分类目录名\n# Directory #默认文章和生成目录设置\nsource_dir: source\npublic_dir: public\n# Writing 文章布局、写作格式的定义\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\nauto_spacing: false # Add spaces between asian characters and western characters\ntitlecase: false # Transform title into titlecase\nmax_open_file: 100\nfilename_case: 0\nhighlight:\n  enable: true\n  backtick_code_block: true\n  line_number: true\n  tab_replace:\n# Category & Tag 分类和标签设置\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n# Archives 默认值为2，如果这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n# Server 本地预览服务信息，默认端口是4000，有需要的话可以自己修改\n## Hexo uses Connect as a server\n## You can customize the logger format as defined in\n## http://www.senchalabs.org/connect/logger.html\nport: 4000\nlogger: false\nlogger_format:\n# Date / Time format 日期格式\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: MMM D YYYY\ntime_format: H:mm:ss\n# Pagination 每页显示文章数，可以自定义\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page\n# Disqus Disqus 插件，我们会替换成“多说”\ndisqus_shortname:\n# Extensions 这里配置站点所用主题和插件\n## Plugins: https://github.com/hexojs/hexo/wiki/Plugins\n## Themes: https://github.com/hexojs/hexo/wiki/Themes\ntheme: light\nexclude_generator:\n# Deployment 站点部署到github要配置\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: github\n  repository:\n  branch: master\n```\n\n#### 主题_config.yml配置\n\n```\nmenu: #右上角导航菜单，冒号前面是菜单名，后面是访问路径。\n  Home: /\n  Archives: /archives\n  About: /about\n\nwidgets: #站点右边栏，可以调整顺序和增减内容，会自动调用主题layout/_widget目录下的同名文件。\n- search\n- category\n- tagcloud\nexcerpt_link: Read More #列表页里Read more链接名称，可以替换成’查看更多‘等。\nplugins:\ntwitter: #右边栏要显示twitter展示的话，需要在此设置\n  username:\n  show_replies: false\n  tweet_count: 5\naddthis: #分享设置\n  enable: true\n  pubid:\n  facebook: true\n  twitter: true\n  google: true\n  pinterest: true\nfancybox: true #图片效果，默认\ngoogle_analytics: #google_analytics统计ID\nrss:  #生成RSS路径\n```\n\n### 常用命令\n\n- hexo new \"postName\" #新建文章\n- hexo new page \"pageName\" #新建页面\n- hexo clean #清除缓存\n- hexo generate #生成静态页面至public目录\n- hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n- hexo deploy #将.deploy目录部署到GitHub\n\n#### 命令简写\n\n- hexo n \"我的博客\" == hexo new \"我的博客\" #新建文章\n- hexo p == hexo publish\n- hexo g == hexo generate#生成\n- hexo s == hexo server #启动服务预览\n- hexo d == hexo deploy#部署\n\n### Hexo主题相关\n\n- 参考：http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/\n\n### 添加搜索\n\n- 参考：https://www.jianshu.com/p/2010ad07d960\n\n\n### 分类和标签设置\n\n- 参考：http://ijiaober.github.io/2014/08/05/hexo/hexo-04/、https://www.jianshu.com/p/3d2e7b3ec182\n","source":"_posts/[hexo]创建Hexo-github博客流程.md","raw":"---\ntitle: <hexo>创建Hexo-github博客流程\ndate: 2018-08-20 00:00:00\ntags: [hexo]\ncategories: hexo\n---\n### 简介\n\n- HEXO快速、简单且功能强大的 Node.js 博客框架。\nhttps://hexo.io/zh-cn/\n\n### 安装\n\n1. 全局安装git以及nodeJs\n2. 全局安装hexo\n\n```\nnpm install -g hexo\n```\n\n3. 新建项目文件夹\n\n```\nmkdir hexo-project\n```\n\n4. 进入项目文件夹，初始化hexo\n\n```\ncd hexo-project\nhexo init\n\n```\n\n5. 安装依赖\n\n```\nnpm install\n```\n\n6. 启动服务\n\n```\nhexo server || hexo s\n```\n\n- 访问 http://127.0.0.1:4000/\n\n7. 此时可以在本地访问服务，下面进行提交代码到git的步骤，首先在 github (https://github.com/) 上创建项目，注意项目名字有格式要求必须为：[github用户名].github.io，否则不能使用，参考：https://github.com/crazyaguai/crazyaguai.github.io 名称。\n8. 安装hexo-deployer-git提交代码到git用，在项目中执行\n\n```\nnpm install hexo-deployer-git --save\n```\n\n9. 配置根路径_config.yml文件\n\n```\ndeploy:\n  type: git\n  repo: https://github.com/crazyaguai/crazyaguai.github.io(你的项目地址)\n  branch: master\n```\n\n10. 配置完成就可以将Hexo博客提交代码到github上了，执行\n\n```\nhexo clean && hexo generate && hexo deploy || hexo c && hexo g && hexo d\n```\n\n11. 打开你的github hexo项目地址查看，例如 https://crazyaguai.github.io/\n\n### 目录结构\n\n- _config.yml：全局配置文件\n- package.json：依赖\n- scaffolds：文章脚手架，根据文件夹下的配置构建文章\n- source：新建文章保存在这个文件夹下，在此修改文章\n- themes：主题目录\n\n### _config.yml文件配置\n\n#### 根路径_config.yml配置\n\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n# Site 这里的配置，哪项配置反映在哪里，可以参考我的博客\ntitle:  #站点名，站点左上角\nsubtitle:  #副标题，站点左上角\ndescription:  #给搜索引擎看的，对站点的描述，可以自定义\nauthor:  #默认在站点左下角可以看到\nemail: #邮箱\nlanguage: zh-CN #语言包设置。\n# URL #访问地址等信息设置，可根据需要自己修改。\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: #访问域名\nroot: /\npermalink: :year/:month/:day/:title/ #具体内容页的存储路径结构\ntag_dir: tags #标签目录名\narchive_dir: archives #归档目录名\ncategory_dir: categories #分类目录名\n# Directory #默认文章和生成目录设置\nsource_dir: source\npublic_dir: public\n# Writing 文章布局、写作格式的定义\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\nauto_spacing: false # Add spaces between asian characters and western characters\ntitlecase: false # Transform title into titlecase\nmax_open_file: 100\nfilename_case: 0\nhighlight:\n  enable: true\n  backtick_code_block: true\n  line_number: true\n  tab_replace:\n# Category & Tag 分类和标签设置\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n# Archives 默认值为2，如果这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n# Server 本地预览服务信息，默认端口是4000，有需要的话可以自己修改\n## Hexo uses Connect as a server\n## You can customize the logger format as defined in\n## http://www.senchalabs.org/connect/logger.html\nport: 4000\nlogger: false\nlogger_format:\n# Date / Time format 日期格式\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: MMM D YYYY\ntime_format: H:mm:ss\n# Pagination 每页显示文章数，可以自定义\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page\n# Disqus Disqus 插件，我们会替换成“多说”\ndisqus_shortname:\n# Extensions 这里配置站点所用主题和插件\n## Plugins: https://github.com/hexojs/hexo/wiki/Plugins\n## Themes: https://github.com/hexojs/hexo/wiki/Themes\ntheme: light\nexclude_generator:\n# Deployment 站点部署到github要配置\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: github\n  repository:\n  branch: master\n```\n\n#### 主题_config.yml配置\n\n```\nmenu: #右上角导航菜单，冒号前面是菜单名，后面是访问路径。\n  Home: /\n  Archives: /archives\n  About: /about\n\nwidgets: #站点右边栏，可以调整顺序和增减内容，会自动调用主题layout/_widget目录下的同名文件。\n- search\n- category\n- tagcloud\nexcerpt_link: Read More #列表页里Read more链接名称，可以替换成’查看更多‘等。\nplugins:\ntwitter: #右边栏要显示twitter展示的话，需要在此设置\n  username:\n  show_replies: false\n  tweet_count: 5\naddthis: #分享设置\n  enable: true\n  pubid:\n  facebook: true\n  twitter: true\n  google: true\n  pinterest: true\nfancybox: true #图片效果，默认\ngoogle_analytics: #google_analytics统计ID\nrss:  #生成RSS路径\n```\n\n### 常用命令\n\n- hexo new \"postName\" #新建文章\n- hexo new page \"pageName\" #新建页面\n- hexo clean #清除缓存\n- hexo generate #生成静态页面至public目录\n- hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n- hexo deploy #将.deploy目录部署到GitHub\n\n#### 命令简写\n\n- hexo n \"我的博客\" == hexo new \"我的博客\" #新建文章\n- hexo p == hexo publish\n- hexo g == hexo generate#生成\n- hexo s == hexo server #启动服务预览\n- hexo d == hexo deploy#部署\n\n### Hexo主题相关\n\n- 参考：http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/\n\n### 添加搜索\n\n- 参考：https://www.jianshu.com/p/2010ad07d960\n\n\n### 分类和标签设置\n\n- 参考：http://ijiaober.github.io/2014/08/05/hexo/hexo-04/、https://www.jianshu.com/p/3d2e7b3ec182\n","slug":"[hexo]创建Hexo-github博客流程","published":1,"updated":"2021-03-15T14:41:36.045Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dkc001bwotjc5kc1xub","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>HEXO快速、简单且功能强大的 Node.js 博客框架。<br><a href=\"https://hexo.io/zh-cn/\">https://hexo.io/zh-cn/</a></li>\n</ul>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ol>\n<li>全局安装git以及nodeJs</li>\n<li>全局安装hexo</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>新建项目文件夹</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir hexo-project</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>进入项目文件夹，初始化hexo</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo-project</span><br><span class=\"line\">hexo init</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>安装依赖</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>启动服务</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server || hexo s</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>访问 <a href=\"http://127.0.0.1:4000/\">http://127.0.0.1:4000/</a></li>\n</ul>\n<ol start=\"7\">\n<li>此时可以在本地访问服务，下面进行提交代码到git的步骤，首先在 github (<a href=\"https://github.com/\">https://github.com/</a>) 上创建项目，注意项目名字有格式要求必须为：[github用户名].github.io，否则不能使用，参考：<a href=\"https://github.com/crazyaguai/crazyaguai.github.io\">https://github.com/crazyaguai/crazyaguai.github.io</a> 名称。</li>\n<li>安装hexo-deployer-git提交代码到git用，在项目中执行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li>配置根路径_config.yml文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https:&#x2F;&#x2F;github.com&#x2F;crazyaguai&#x2F;crazyaguai.github.io(你的项目地址)</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li>配置完成就可以将Hexo博客提交代码到github上了，执行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy || hexo c &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>\n\n<ol start=\"11\">\n<li>打开你的github hexo项目地址查看，例如 <a href=\"https://crazyaguai.github.io/\">https://crazyaguai.github.io/</a></li>\n</ol>\n<h3 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><ul>\n<li>_config.yml：全局配置文件</li>\n<li>package.json：依赖</li>\n<li>scaffolds：文章脚手架，根据文件夹下的配置构建文章</li>\n<li>source：新建文章保存在这个文件夹下，在此修改文章</li>\n<li>themes：主题目录</li>\n</ul>\n<h3 id=\"config-yml文件配置\"><a href=\"#config-yml文件配置\" class=\"headerlink\" title=\"_config.yml文件配置\"></a>_config.yml文件配置</h3><h4 id=\"根路径-config-yml配置\"><a href=\"#根路径-config-yml配置\" class=\"headerlink\" title=\"根路径_config.yml配置\"></a>根路径_config.yml配置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Hexo Configuration</span><br><span class=\"line\">## Docs: http:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html</span><br><span class=\"line\">## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;</span><br><span class=\"line\"># Site 这里的配置，哪项配置反映在哪里，可以参考我的博客</span><br><span class=\"line\">title:  #站点名，站点左上角</span><br><span class=\"line\">subtitle:  #副标题，站点左上角</span><br><span class=\"line\">description:  #给搜索引擎看的，对站点的描述，可以自定义</span><br><span class=\"line\">author:  #默认在站点左下角可以看到</span><br><span class=\"line\">email: #邮箱</span><br><span class=\"line\">language: zh-CN #语言包设置。</span><br><span class=\"line\"># URL #访问地址等信息设置，可根据需要自己修改。</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class=\"line\">url: #访问域名</span><br><span class=\"line\">root: &#x2F;</span><br><span class=\"line\">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; #具体内容页的存储路径结构</span><br><span class=\"line\">tag_dir: tags #标签目录名</span><br><span class=\"line\">archive_dir: archives #归档目录名</span><br><span class=\"line\">category_dir: categories #分类目录名</span><br><span class=\"line\"># Directory #默认文章和生成目录设置</span><br><span class=\"line\">source_dir: source</span><br><span class=\"line\">public_dir: public</span><br><span class=\"line\"># Writing 文章布局、写作格式的定义</span><br><span class=\"line\">new_post_name: :title.md # File name of new posts</span><br><span class=\"line\">default_layout: post</span><br><span class=\"line\">auto_spacing: false # Add spaces between asian characters and western characters</span><br><span class=\"line\">titlecase: false # Transform title into titlecase</span><br><span class=\"line\">max_open_file: 100</span><br><span class=\"line\">filename_case: 0</span><br><span class=\"line\">highlight:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  backtick_code_block: true</span><br><span class=\"line\">  line_number: true</span><br><span class=\"line\">  tab_replace:</span><br><span class=\"line\"># Category &amp; Tag 分类和标签设置</span><br><span class=\"line\">default_category: uncategorized</span><br><span class=\"line\">category_map:</span><br><span class=\"line\">tag_map:</span><br><span class=\"line\"># Archives 默认值为2，如果这里都修改为1，相应页面就只会列出标题，而非全文</span><br><span class=\"line\">## 2: Enable pagination</span><br><span class=\"line\">## 1: Disable pagination</span><br><span class=\"line\">## 0: Fully Disable</span><br><span class=\"line\">archive: 1</span><br><span class=\"line\">category: 1</span><br><span class=\"line\">tag: 1</span><br><span class=\"line\"># Server 本地预览服务信息，默认端口是4000，有需要的话可以自己修改</span><br><span class=\"line\">## Hexo uses Connect as a server</span><br><span class=\"line\">## You can customize the logger format as defined in</span><br><span class=\"line\">## http:&#x2F;&#x2F;www.senchalabs.org&#x2F;connect&#x2F;logger.html</span><br><span class=\"line\">port: 4000</span><br><span class=\"line\">logger: false</span><br><span class=\"line\">logger_format:</span><br><span class=\"line\"># Date &#x2F; Time format 日期格式</span><br><span class=\"line\">## Hexo uses Moment.js to parse and display date</span><br><span class=\"line\">## You can customize the date format as defined in</span><br><span class=\"line\">## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F;</span><br><span class=\"line\">date_format: MMM D YYYY</span><br><span class=\"line\">time_format: H:mm:ss</span><br><span class=\"line\"># Pagination 每页显示文章数，可以自定义</span><br><span class=\"line\">## Set per_page to 0 to disable pagination</span><br><span class=\"line\">per_page: 5</span><br><span class=\"line\">pagination_dir: page</span><br><span class=\"line\"># Disqus Disqus 插件，我们会替换成“多说”</span><br><span class=\"line\">disqus_shortname:</span><br><span class=\"line\"># Extensions 这里配置站点所用主题和插件</span><br><span class=\"line\">## Plugins: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;wiki&#x2F;Plugins</span><br><span class=\"line\">## Themes: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;wiki&#x2F;Themes</span><br><span class=\"line\">theme: light</span><br><span class=\"line\">exclude_generator:</span><br><span class=\"line\"># Deployment 站点部署到github要配置</span><br><span class=\"line\">## Docs: http:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: github</span><br><span class=\"line\">  repository:</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"主题-config-yml配置\"><a href=\"#主题-config-yml配置\" class=\"headerlink\" title=\"主题_config.yml配置\"></a>主题_config.yml配置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu: #右上角导航菜单，冒号前面是菜单名，后面是访问路径。</span><br><span class=\"line\">  Home: &#x2F;</span><br><span class=\"line\">  Archives: &#x2F;archives</span><br><span class=\"line\">  About: &#x2F;about</span><br><span class=\"line\"></span><br><span class=\"line\">widgets: #站点右边栏，可以调整顺序和增减内容，会自动调用主题layout&#x2F;_widget目录下的同名文件。</span><br><span class=\"line\">- search</span><br><span class=\"line\">- category</span><br><span class=\"line\">- tagcloud</span><br><span class=\"line\">excerpt_link: Read More #列表页里Read more链接名称，可以替换成’查看更多‘等。</span><br><span class=\"line\">plugins:</span><br><span class=\"line\">twitter: #右边栏要显示twitter展示的话，需要在此设置</span><br><span class=\"line\">  username:</span><br><span class=\"line\">  show_replies: false</span><br><span class=\"line\">  tweet_count: 5</span><br><span class=\"line\">addthis: #分享设置</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  pubid:</span><br><span class=\"line\">  facebook: true</span><br><span class=\"line\">  twitter: true</span><br><span class=\"line\">  google: true</span><br><span class=\"line\">  pinterest: true</span><br><span class=\"line\">fancybox: true #图片效果，默认</span><br><span class=\"line\">google_analytics: #google_analytics统计ID</span><br><span class=\"line\">rss:  #生成RSS路径</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ul>\n<li>hexo new “postName” #新建文章</li>\n<li>hexo new page “pageName” #新建页面</li>\n<li>hexo clean #清除缓存</li>\n<li>hexo generate #生成静态页面至public目录</li>\n<li>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</li>\n<li>hexo deploy #将.deploy目录部署到GitHub</li>\n</ul>\n<h4 id=\"命令简写\"><a href=\"#命令简写\" class=\"headerlink\" title=\"命令简写\"></a>命令简写</h4><ul>\n<li>hexo n “我的博客” == hexo new “我的博客” #新建文章</li>\n<li>hexo p == hexo publish</li>\n<li>hexo g == hexo generate#生成</li>\n<li>hexo s == hexo server #启动服务预览</li>\n<li>hexo d == hexo deploy#部署</li>\n</ul>\n<h3 id=\"Hexo主题相关\"><a href=\"#Hexo主题相关\" class=\"headerlink\" title=\"Hexo主题相关\"></a>Hexo主题相关</h3><ul>\n<li>参考：<a href=\"http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/\">http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/</a></li>\n</ul>\n<h3 id=\"添加搜索\"><a href=\"#添加搜索\" class=\"headerlink\" title=\"添加搜索\"></a>添加搜索</h3><ul>\n<li>参考：<a href=\"https://www.jianshu.com/p/2010ad07d960\">https://www.jianshu.com/p/2010ad07d960</a></li>\n</ul>\n<h3 id=\"分类和标签设置\"><a href=\"#分类和标签设置\" class=\"headerlink\" title=\"分类和标签设置\"></a>分类和标签设置</h3><ul>\n<li>参考：<a href=\"http://ijiaober.github.io/2014/08/05/hexo/hexo-04/%E3%80%81https://www.jianshu.com/p/3d2e7b3ec182\">http://ijiaober.github.io/2014/08/05/hexo/hexo-04/、https://www.jianshu.com/p/3d2e7b3ec182</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>HEXO快速、简单且功能强大的 Node.js 博客框架。<br><a href=\"https://hexo.io/zh-cn/\">https://hexo.io/zh-cn/</a></li>\n</ul>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><ol>\n<li>全局安装git以及nodeJs</li>\n<li>全局安装hexo</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>新建项目文件夹</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir hexo-project</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>进入项目文件夹，初始化hexo</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo-project</span><br><span class=\"line\">hexo init</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>安装依赖</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>启动服务</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server || hexo s</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>访问 <a href=\"http://127.0.0.1:4000/\">http://127.0.0.1:4000/</a></li>\n</ul>\n<ol start=\"7\">\n<li>此时可以在本地访问服务，下面进行提交代码到git的步骤，首先在 github (<a href=\"https://github.com/\">https://github.com/</a>) 上创建项目，注意项目名字有格式要求必须为：[github用户名].github.io，否则不能使用，参考：<a href=\"https://github.com/crazyaguai/crazyaguai.github.io\">https://github.com/crazyaguai/crazyaguai.github.io</a> 名称。</li>\n<li>安装hexo-deployer-git提交代码到git用，在项目中执行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<ol start=\"9\">\n<li>配置根路径_config.yml文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https:&#x2F;&#x2F;github.com&#x2F;crazyaguai&#x2F;crazyaguai.github.io(你的项目地址)</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li>配置完成就可以将Hexo博客提交代码到github上了，执行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy || hexo c &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>\n\n<ol start=\"11\">\n<li>打开你的github hexo项目地址查看，例如 <a href=\"https://crazyaguai.github.io/\">https://crazyaguai.github.io/</a></li>\n</ol>\n<h3 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h3><ul>\n<li>_config.yml：全局配置文件</li>\n<li>package.json：依赖</li>\n<li>scaffolds：文章脚手架，根据文件夹下的配置构建文章</li>\n<li>source：新建文章保存在这个文件夹下，在此修改文章</li>\n<li>themes：主题目录</li>\n</ul>\n<h3 id=\"config-yml文件配置\"><a href=\"#config-yml文件配置\" class=\"headerlink\" title=\"_config.yml文件配置\"></a>_config.yml文件配置</h3><h4 id=\"根路径-config-yml配置\"><a href=\"#根路径-config-yml配置\" class=\"headerlink\" title=\"根路径_config.yml配置\"></a>根路径_config.yml配置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Hexo Configuration</span><br><span class=\"line\">## Docs: http:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html</span><br><span class=\"line\">## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;</span><br><span class=\"line\"># Site 这里的配置，哪项配置反映在哪里，可以参考我的博客</span><br><span class=\"line\">title:  #站点名，站点左上角</span><br><span class=\"line\">subtitle:  #副标题，站点左上角</span><br><span class=\"line\">description:  #给搜索引擎看的，对站点的描述，可以自定义</span><br><span class=\"line\">author:  #默认在站点左下角可以看到</span><br><span class=\"line\">email: #邮箱</span><br><span class=\"line\">language: zh-CN #语言包设置。</span><br><span class=\"line\"># URL #访问地址等信息设置，可根据需要自己修改。</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class=\"line\">url: #访问域名</span><br><span class=\"line\">root: &#x2F;</span><br><span class=\"line\">permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F; #具体内容页的存储路径结构</span><br><span class=\"line\">tag_dir: tags #标签目录名</span><br><span class=\"line\">archive_dir: archives #归档目录名</span><br><span class=\"line\">category_dir: categories #分类目录名</span><br><span class=\"line\"># Directory #默认文章和生成目录设置</span><br><span class=\"line\">source_dir: source</span><br><span class=\"line\">public_dir: public</span><br><span class=\"line\"># Writing 文章布局、写作格式的定义</span><br><span class=\"line\">new_post_name: :title.md # File name of new posts</span><br><span class=\"line\">default_layout: post</span><br><span class=\"line\">auto_spacing: false # Add spaces between asian characters and western characters</span><br><span class=\"line\">titlecase: false # Transform title into titlecase</span><br><span class=\"line\">max_open_file: 100</span><br><span class=\"line\">filename_case: 0</span><br><span class=\"line\">highlight:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  backtick_code_block: true</span><br><span class=\"line\">  line_number: true</span><br><span class=\"line\">  tab_replace:</span><br><span class=\"line\"># Category &amp; Tag 分类和标签设置</span><br><span class=\"line\">default_category: uncategorized</span><br><span class=\"line\">category_map:</span><br><span class=\"line\">tag_map:</span><br><span class=\"line\"># Archives 默认值为2，如果这里都修改为1，相应页面就只会列出标题，而非全文</span><br><span class=\"line\">## 2: Enable pagination</span><br><span class=\"line\">## 1: Disable pagination</span><br><span class=\"line\">## 0: Fully Disable</span><br><span class=\"line\">archive: 1</span><br><span class=\"line\">category: 1</span><br><span class=\"line\">tag: 1</span><br><span class=\"line\"># Server 本地预览服务信息，默认端口是4000，有需要的话可以自己修改</span><br><span class=\"line\">## Hexo uses Connect as a server</span><br><span class=\"line\">## You can customize the logger format as defined in</span><br><span class=\"line\">## http:&#x2F;&#x2F;www.senchalabs.org&#x2F;connect&#x2F;logger.html</span><br><span class=\"line\">port: 4000</span><br><span class=\"line\">logger: false</span><br><span class=\"line\">logger_format:</span><br><span class=\"line\"># Date &#x2F; Time format 日期格式</span><br><span class=\"line\">## Hexo uses Moment.js to parse and display date</span><br><span class=\"line\">## You can customize the date format as defined in</span><br><span class=\"line\">## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F;</span><br><span class=\"line\">date_format: MMM D YYYY</span><br><span class=\"line\">time_format: H:mm:ss</span><br><span class=\"line\"># Pagination 每页显示文章数，可以自定义</span><br><span class=\"line\">## Set per_page to 0 to disable pagination</span><br><span class=\"line\">per_page: 5</span><br><span class=\"line\">pagination_dir: page</span><br><span class=\"line\"># Disqus Disqus 插件，我们会替换成“多说”</span><br><span class=\"line\">disqus_shortname:</span><br><span class=\"line\"># Extensions 这里配置站点所用主题和插件</span><br><span class=\"line\">## Plugins: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;wiki&#x2F;Plugins</span><br><span class=\"line\">## Themes: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;wiki&#x2F;Themes</span><br><span class=\"line\">theme: light</span><br><span class=\"line\">exclude_generator:</span><br><span class=\"line\"># Deployment 站点部署到github要配置</span><br><span class=\"line\">## Docs: http:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: github</span><br><span class=\"line\">  repository:</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"主题-config-yml配置\"><a href=\"#主题-config-yml配置\" class=\"headerlink\" title=\"主题_config.yml配置\"></a>主题_config.yml配置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu: #右上角导航菜单，冒号前面是菜单名，后面是访问路径。</span><br><span class=\"line\">  Home: &#x2F;</span><br><span class=\"line\">  Archives: &#x2F;archives</span><br><span class=\"line\">  About: &#x2F;about</span><br><span class=\"line\"></span><br><span class=\"line\">widgets: #站点右边栏，可以调整顺序和增减内容，会自动调用主题layout&#x2F;_widget目录下的同名文件。</span><br><span class=\"line\">- search</span><br><span class=\"line\">- category</span><br><span class=\"line\">- tagcloud</span><br><span class=\"line\">excerpt_link: Read More #列表页里Read more链接名称，可以替换成’查看更多‘等。</span><br><span class=\"line\">plugins:</span><br><span class=\"line\">twitter: #右边栏要显示twitter展示的话，需要在此设置</span><br><span class=\"line\">  username:</span><br><span class=\"line\">  show_replies: false</span><br><span class=\"line\">  tweet_count: 5</span><br><span class=\"line\">addthis: #分享设置</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  pubid:</span><br><span class=\"line\">  facebook: true</span><br><span class=\"line\">  twitter: true</span><br><span class=\"line\">  google: true</span><br><span class=\"line\">  pinterest: true</span><br><span class=\"line\">fancybox: true #图片效果，默认</span><br><span class=\"line\">google_analytics: #google_analytics统计ID</span><br><span class=\"line\">rss:  #生成RSS路径</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h3><ul>\n<li>hexo new “postName” #新建文章</li>\n<li>hexo new page “pageName” #新建页面</li>\n<li>hexo clean #清除缓存</li>\n<li>hexo generate #生成静态页面至public目录</li>\n<li>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</li>\n<li>hexo deploy #将.deploy目录部署到GitHub</li>\n</ul>\n<h4 id=\"命令简写\"><a href=\"#命令简写\" class=\"headerlink\" title=\"命令简写\"></a>命令简写</h4><ul>\n<li>hexo n “我的博客” == hexo new “我的博客” #新建文章</li>\n<li>hexo p == hexo publish</li>\n<li>hexo g == hexo generate#生成</li>\n<li>hexo s == hexo server #启动服务预览</li>\n<li>hexo d == hexo deploy#部署</li>\n</ul>\n<h3 id=\"Hexo主题相关\"><a href=\"#Hexo主题相关\" class=\"headerlink\" title=\"Hexo主题相关\"></a>Hexo主题相关</h3><ul>\n<li>参考：<a href=\"http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/\">http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/</a></li>\n</ul>\n<h3 id=\"添加搜索\"><a href=\"#添加搜索\" class=\"headerlink\" title=\"添加搜索\"></a>添加搜索</h3><ul>\n<li>参考：<a href=\"https://www.jianshu.com/p/2010ad07d960\">https://www.jianshu.com/p/2010ad07d960</a></li>\n</ul>\n<h3 id=\"分类和标签设置\"><a href=\"#分类和标签设置\" class=\"headerlink\" title=\"分类和标签设置\"></a>分类和标签设置</h3><ul>\n<li>参考：<a href=\"http://ijiaober.github.io/2014/08/05/hexo/hexo-04/%E3%80%81https://www.jianshu.com/p/3d2e7b3ec182\">http://ijiaober.github.io/2014/08/05/hexo/hexo-04/、https://www.jianshu.com/p/3d2e7b3ec182</a></li>\n</ul>\n"},{"title":"<css>视口概念","date":"2019-01-19T16:00:00.000Z","_content":"### 视口\n\n#### 像素（pixel）\n\n1. 设备像素：任何屏幕的物理像素数量是固定的\n2. CSS像素：CSS抽象的\n\n#### 布局视口\n\n- 概念\n\n1. CSS中，被称为初始包含块，是所有CSS百分比宽度推算的根源。\n2. PC浏览器布局视口的宽度与浏览器的宽度相同。\n3. 移动端浏览器，布局视口与浏览器屏幕宽度不再相互关联，完全独立。\n\n- js获取方式\n\n1. document.documentElement.clientWidth\n2. document.documentElement.clientWidth\n\n#### 视觉视口\n\n- 概念\n\n1. 用户正在看到的网站区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口，布局视口仍会保持原来的宽度。\n2. 移动端视觉视口与设备屏幕一样宽，并且它表示的CSS像素数量会根据缩放改变。\n\n- js获取方式\n\n1. window.innerWidth\n2. window.innerHeight\n\n#### 理想视口\n\n- 概念\n\n1. 移动设备上，布局视口的默认宽度不是一个理想的宽度，因此引进理想视口。\n2. 当网站是移动设备使用时理想视口才会生效（meta标签生效）。\n3. 设置布局视口宽度与理想视口宽度一致。\n4. 浏览器厂商决定理想视口。\n\n```\n<meta name=\"device\" content=\"width=device-width\">\n```\n\n- js获取方式\n\n1. screen.width/height 存在严重的兼容性问题，也可能返回浏览器设备像素尺寸。\n\n### 视口之间的关系\n\n1. 桌面浏览器，浏览器窗口就是布局视口。\n2. 手机上，布局视口限制CSS布局，视觉视口决定用户看到的内容。\n3. 理想视口是移动浏览器布局的一个理想尺寸，可以把布局视口尺寸设置为理想视口尺寸，实现响应式布局。\n\n### 缩放\n\n- 缩放行为在手机和桌面上区别很大。\n- 桌面上：\n\n1. 行为一般是一次性的。\n2. 布局视口会被缩放影响，因为桌面布局视口与视觉视口相同。\n\n- 移动设备上\n\n1. 缩放是一个交互过程\n2. 布局视口不会被缩放影响。\n3. 移动端缩放不会导致CSS布局被重新计算。\n4. 移动端浏览器根据理想视口的大小来计算缩放程度。\n5. 拖放\n6. 禁止缩放\n\n```\n<meta name=\"viewport\" content=\"user-scalable=no\">\n```\n\n### 分辨率\n\n#### 物理分辨率\n\n1. 物理分辨率 = 像素数量 / 英寸单位宽度\n2. 简称DPI\n3. 每英寸像素数量越多显示越清晰\n4. 有些手机可以动过screen.width获取，但是有兼容性问题\n5. 96dpi = 1dppx\n\n```\n//css使用需要加单位\n@media all and (min-resolution: 192dpi){\n\n}\n```\n\n#### 设备像素比\n\n1. 设备像素比 = 设备像素个数 / 理想视口\n2. 简称DPR(Device Pixel Ratio)\n3. js属性window.devicePixelRatio\n4. CSS device-pixel-ratio（基于webkit浏览器）和分辨率的媒体查询。\n5. 浏览器厂商决定理想视口，因此DPR也由他们决定。\n6. 单位dppx但是使用时不需要添加。\n7. 96dpi = 1dppx\n\n```\n//js使用\nif(window.devicePixelRatio>=2){\n\n}\n//css使用\n@media all and (-webkit-min-device-pixel-ratio: 2){\n\n}\n```\n\n### meta\n\n1. width：设置布局视口宽度为特定值。\n2. initial-scale：设置页面初始缩放程度和布局视口的宽度。\n3. minimum-scale\\maximum-scale设置用户最小最大可缩放程度。\n4. user-scalable：是否阻止缩放。\n\n- 将布局视口设置为设备理想视口\n\n```\n<meta name=\"viewport\" content=\"width=device-width\">\n```\n\n- initial-scale\n\n1. 缩放程度根据理想视口计算。\n2. initial-scale=1时，视觉视口和理想视口尺寸一样。\n3. initial-scale=2时，会放大到200%，此时视觉视口的宽高是理想视口的一半。\n4. 使用initial-scale，同时会将布局视口的尺寸设置为缩放后的尺寸。\n5. initial-scale与width=decice-width效果一样。\n\n```\n<meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n```\n\n### 媒体查询\n\n- 语法\n\n1. 媒介类型：media_type: all | aural | braille | handheld | print | projection | screen | tty | tv | embossed\n2. and\n\n```\n@media tv and (min-width: 700px) and (orientation: landscape) { }\n```\n\n3. or：使用逗号分隔效果等同于or逻辑操作符\n\n```\n@media (min-width: 700px), handheld and (orientation: landscape) {}\n```\n\n4. not：not关键字仅能应用于整个查询，而不能单独应用于一个独立的查询\n\n```\n//例如\n@media not all and (monochrome) {}\n//等价于\n@media not (all and (monochrome)) {}\n//而不是\n@media (not all) and (monochrome) {}\n```\n```\n@media not screen and (color), print and (color)\n//等价于\n@media (not (screen and (color))), print and (color)\n```\n\n- [MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries)\n\n#### 媒体查询三种类型：\n\n1. 媒介查询，是什么类型的设备\n\n```\n@media print{\n}\n```\n\n2. 视口相关查询\n\n```\n//布局视口宽度小于等于400px时生效\n@media all and (max-width: 400){\n}\n```\n```\n//布局视口不超过400px，设备处于横屏，并且devicePixelRatio小于1.5时生效\n@media all and (max-width: 400) and (orientation: potrait) and  ((max-resolution: 144dpi),(-webkit-max-device-pixel-ratio: 1.5)) {}\n```\n\n3. 特性相关查询，浏览器是否支持某些特性\n\n```\n@supports ( display: flex ) {\n    .foo { display: flex; }\n}\n```\n\n","source":"_posts/[css]视口概念.md","raw":"---\ntitle: <css>视口概念\ndate: 2019-01-20 00:00:00\ntags: [视口,h5]\ncategories: 视口\n---\n### 视口\n\n#### 像素（pixel）\n\n1. 设备像素：任何屏幕的物理像素数量是固定的\n2. CSS像素：CSS抽象的\n\n#### 布局视口\n\n- 概念\n\n1. CSS中，被称为初始包含块，是所有CSS百分比宽度推算的根源。\n2. PC浏览器布局视口的宽度与浏览器的宽度相同。\n3. 移动端浏览器，布局视口与浏览器屏幕宽度不再相互关联，完全独立。\n\n- js获取方式\n\n1. document.documentElement.clientWidth\n2. document.documentElement.clientWidth\n\n#### 视觉视口\n\n- 概念\n\n1. 用户正在看到的网站区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口，布局视口仍会保持原来的宽度。\n2. 移动端视觉视口与设备屏幕一样宽，并且它表示的CSS像素数量会根据缩放改变。\n\n- js获取方式\n\n1. window.innerWidth\n2. window.innerHeight\n\n#### 理想视口\n\n- 概念\n\n1. 移动设备上，布局视口的默认宽度不是一个理想的宽度，因此引进理想视口。\n2. 当网站是移动设备使用时理想视口才会生效（meta标签生效）。\n3. 设置布局视口宽度与理想视口宽度一致。\n4. 浏览器厂商决定理想视口。\n\n```\n<meta name=\"device\" content=\"width=device-width\">\n```\n\n- js获取方式\n\n1. screen.width/height 存在严重的兼容性问题，也可能返回浏览器设备像素尺寸。\n\n### 视口之间的关系\n\n1. 桌面浏览器，浏览器窗口就是布局视口。\n2. 手机上，布局视口限制CSS布局，视觉视口决定用户看到的内容。\n3. 理想视口是移动浏览器布局的一个理想尺寸，可以把布局视口尺寸设置为理想视口尺寸，实现响应式布局。\n\n### 缩放\n\n- 缩放行为在手机和桌面上区别很大。\n- 桌面上：\n\n1. 行为一般是一次性的。\n2. 布局视口会被缩放影响，因为桌面布局视口与视觉视口相同。\n\n- 移动设备上\n\n1. 缩放是一个交互过程\n2. 布局视口不会被缩放影响。\n3. 移动端缩放不会导致CSS布局被重新计算。\n4. 移动端浏览器根据理想视口的大小来计算缩放程度。\n5. 拖放\n6. 禁止缩放\n\n```\n<meta name=\"viewport\" content=\"user-scalable=no\">\n```\n\n### 分辨率\n\n#### 物理分辨率\n\n1. 物理分辨率 = 像素数量 / 英寸单位宽度\n2. 简称DPI\n3. 每英寸像素数量越多显示越清晰\n4. 有些手机可以动过screen.width获取，但是有兼容性问题\n5. 96dpi = 1dppx\n\n```\n//css使用需要加单位\n@media all and (min-resolution: 192dpi){\n\n}\n```\n\n#### 设备像素比\n\n1. 设备像素比 = 设备像素个数 / 理想视口\n2. 简称DPR(Device Pixel Ratio)\n3. js属性window.devicePixelRatio\n4. CSS device-pixel-ratio（基于webkit浏览器）和分辨率的媒体查询。\n5. 浏览器厂商决定理想视口，因此DPR也由他们决定。\n6. 单位dppx但是使用时不需要添加。\n7. 96dpi = 1dppx\n\n```\n//js使用\nif(window.devicePixelRatio>=2){\n\n}\n//css使用\n@media all and (-webkit-min-device-pixel-ratio: 2){\n\n}\n```\n\n### meta\n\n1. width：设置布局视口宽度为特定值。\n2. initial-scale：设置页面初始缩放程度和布局视口的宽度。\n3. minimum-scale\\maximum-scale设置用户最小最大可缩放程度。\n4. user-scalable：是否阻止缩放。\n\n- 将布局视口设置为设备理想视口\n\n```\n<meta name=\"viewport\" content=\"width=device-width\">\n```\n\n- initial-scale\n\n1. 缩放程度根据理想视口计算。\n2. initial-scale=1时，视觉视口和理想视口尺寸一样。\n3. initial-scale=2时，会放大到200%，此时视觉视口的宽高是理想视口的一半。\n4. 使用initial-scale，同时会将布局视口的尺寸设置为缩放后的尺寸。\n5. initial-scale与width=decice-width效果一样。\n\n```\n<meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n```\n\n### 媒体查询\n\n- 语法\n\n1. 媒介类型：media_type: all | aural | braille | handheld | print | projection | screen | tty | tv | embossed\n2. and\n\n```\n@media tv and (min-width: 700px) and (orientation: landscape) { }\n```\n\n3. or：使用逗号分隔效果等同于or逻辑操作符\n\n```\n@media (min-width: 700px), handheld and (orientation: landscape) {}\n```\n\n4. not：not关键字仅能应用于整个查询，而不能单独应用于一个独立的查询\n\n```\n//例如\n@media not all and (monochrome) {}\n//等价于\n@media not (all and (monochrome)) {}\n//而不是\n@media (not all) and (monochrome) {}\n```\n```\n@media not screen and (color), print and (color)\n//等价于\n@media (not (screen and (color))), print and (color)\n```\n\n- [MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries)\n\n#### 媒体查询三种类型：\n\n1. 媒介查询，是什么类型的设备\n\n```\n@media print{\n}\n```\n\n2. 视口相关查询\n\n```\n//布局视口宽度小于等于400px时生效\n@media all and (max-width: 400){\n}\n```\n```\n//布局视口不超过400px，设备处于横屏，并且devicePixelRatio小于1.5时生效\n@media all and (max-width: 400) and (orientation: potrait) and  ((max-resolution: 144dpi),(-webkit-max-device-pixel-ratio: 1.5)) {}\n```\n\n3. 特性相关查询，浏览器是否支持某些特性\n\n```\n@supports ( display: flex ) {\n    .foo { display: flex; }\n}\n```\n\n","slug":"[css]视口概念","published":1,"updated":"2021-03-15T14:35:45.582Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dkd001ewotjeoo06xtj","content":"<h3 id=\"视口\"><a href=\"#视口\" class=\"headerlink\" title=\"视口\"></a>视口</h3><h4 id=\"像素（pixel）\"><a href=\"#像素（pixel）\" class=\"headerlink\" title=\"像素（pixel）\"></a>像素（pixel）</h4><ol>\n<li>设备像素：任何屏幕的物理像素数量是固定的</li>\n<li>CSS像素：CSS抽象的</li>\n</ol>\n<h4 id=\"布局视口\"><a href=\"#布局视口\" class=\"headerlink\" title=\"布局视口\"></a>布局视口</h4><ul>\n<li>概念</li>\n</ul>\n<ol>\n<li>CSS中，被称为初始包含块，是所有CSS百分比宽度推算的根源。</li>\n<li>PC浏览器布局视口的宽度与浏览器的宽度相同。</li>\n<li>移动端浏览器，布局视口与浏览器屏幕宽度不再相互关联，完全独立。</li>\n</ol>\n<ul>\n<li>js获取方式</li>\n</ul>\n<ol>\n<li>document.documentElement.clientWidth</li>\n<li>document.documentElement.clientWidth</li>\n</ol>\n<h4 id=\"视觉视口\"><a href=\"#视觉视口\" class=\"headerlink\" title=\"视觉视口\"></a>视觉视口</h4><ul>\n<li>概念</li>\n</ul>\n<ol>\n<li>用户正在看到的网站区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口，布局视口仍会保持原来的宽度。</li>\n<li>移动端视觉视口与设备屏幕一样宽，并且它表示的CSS像素数量会根据缩放改变。</li>\n</ol>\n<ul>\n<li>js获取方式</li>\n</ul>\n<ol>\n<li>window.innerWidth</li>\n<li>window.innerHeight</li>\n</ol>\n<h4 id=\"理想视口\"><a href=\"#理想视口\" class=\"headerlink\" title=\"理想视口\"></a>理想视口</h4><ul>\n<li>概念</li>\n</ul>\n<ol>\n<li>移动设备上，布局视口的默认宽度不是一个理想的宽度，因此引进理想视口。</li>\n<li>当网站是移动设备使用时理想视口才会生效（meta标签生效）。</li>\n<li>设置布局视口宽度与理想视口宽度一致。</li>\n<li>浏览器厂商决定理想视口。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name&#x3D;&quot;device&quot; content&#x3D;&quot;width&#x3D;device-width&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>js获取方式</li>\n</ul>\n<ol>\n<li>screen.width/height 存在严重的兼容性问题，也可能返回浏览器设备像素尺寸。</li>\n</ol>\n<h3 id=\"视口之间的关系\"><a href=\"#视口之间的关系\" class=\"headerlink\" title=\"视口之间的关系\"></a>视口之间的关系</h3><ol>\n<li>桌面浏览器，浏览器窗口就是布局视口。</li>\n<li>手机上，布局视口限制CSS布局，视觉视口决定用户看到的内容。</li>\n<li>理想视口是移动浏览器布局的一个理想尺寸，可以把布局视口尺寸设置为理想视口尺寸，实现响应式布局。</li>\n</ol>\n<h3 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h3><ul>\n<li>缩放行为在手机和桌面上区别很大。</li>\n<li>桌面上：</li>\n</ul>\n<ol>\n<li>行为一般是一次性的。</li>\n<li>布局视口会被缩放影响，因为桌面布局视口与视觉视口相同。</li>\n</ol>\n<ul>\n<li>移动设备上</li>\n</ul>\n<ol>\n<li>缩放是一个交互过程</li>\n<li>布局视口不会被缩放影响。</li>\n<li>移动端缩放不会导致CSS布局被重新计算。</li>\n<li>移动端浏览器根据理想视口的大小来计算缩放程度。</li>\n<li>拖放</li>\n<li>禁止缩放</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;user-scalable&#x3D;no&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分辨率\"><a href=\"#分辨率\" class=\"headerlink\" title=\"分辨率\"></a>分辨率</h3><h4 id=\"物理分辨率\"><a href=\"#物理分辨率\" class=\"headerlink\" title=\"物理分辨率\"></a>物理分辨率</h4><ol>\n<li>物理分辨率 = 像素数量 / 英寸单位宽度</li>\n<li>简称DPI</li>\n<li>每英寸像素数量越多显示越清晰</li>\n<li>有些手机可以动过screen.width获取，但是有兼容性问题</li>\n<li>96dpi = 1dppx</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;css使用需要加单位</span><br><span class=\"line\">@media all and (min-resolution: 192dpi)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设备像素比\"><a href=\"#设备像素比\" class=\"headerlink\" title=\"设备像素比\"></a>设备像素比</h4><ol>\n<li>设备像素比 = 设备像素个数 / 理想视口</li>\n<li>简称DPR(Device Pixel Ratio)</li>\n<li>js属性window.devicePixelRatio</li>\n<li>CSS device-pixel-ratio（基于webkit浏览器）和分辨率的媒体查询。</li>\n<li>浏览器厂商决定理想视口，因此DPR也由他们决定。</li>\n<li>单位dppx但是使用时不需要添加。</li>\n<li>96dpi = 1dppx</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;js使用</span><br><span class=\"line\">if(window.devicePixelRatio&gt;&#x3D;2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;css使用</span><br><span class=\"line\">@media all and (-webkit-min-device-pixel-ratio: 2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"meta\"><a href=\"#meta\" class=\"headerlink\" title=\"meta\"></a>meta</h3><ol>\n<li>width：设置布局视口宽度为特定值。</li>\n<li>initial-scale：设置页面初始缩放程度和布局视口的宽度。</li>\n<li>minimum-scale\\maximum-scale设置用户最小最大可缩放程度。</li>\n<li>user-scalable：是否阻止缩放。</li>\n</ol>\n<ul>\n<li>将布局视口设置为设备理想视口</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>initial-scale</li>\n</ul>\n<ol>\n<li>缩放程度根据理想视口计算。</li>\n<li>initial-scale=1时，视觉视口和理想视口尺寸一样。</li>\n<li>initial-scale=2时，会放大到200%，此时视觉视口的宽高是理想视口的一半。</li>\n<li>使用initial-scale，同时会将布局视口的尺寸设置为缩放后的尺寸。</li>\n<li>initial-scale与width=decice-width效果一样。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"媒体查询\"><a href=\"#媒体查询\" class=\"headerlink\" title=\"媒体查询\"></a>媒体查询</h3><ul>\n<li>语法</li>\n</ul>\n<ol>\n<li>媒介类型：media_type: all | aural | braille | handheld | print | projection | screen | tty | tv | embossed</li>\n<li>and</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media tv and (min-width: 700px) and (orientation: landscape) &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>or：使用逗号分隔效果等同于or逻辑操作符</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media (min-width: 700px), handheld and (orientation: landscape) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>not：not关键字仅能应用于整个查询，而不能单独应用于一个独立的查询</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;例如</span><br><span class=\"line\">@media not all and (monochrome) &#123;&#125;</span><br><span class=\"line\">&#x2F;&#x2F;等价于</span><br><span class=\"line\">@media not (all and (monochrome)) &#123;&#125;</span><br><span class=\"line\">&#x2F;&#x2F;而不是</span><br><span class=\"line\">@media (not all) and (monochrome) &#123;&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media not screen and (color), print and (color)</span><br><span class=\"line\">&#x2F;&#x2F;等价于</span><br><span class=\"line\">@media (not (screen and (color))), print and (color)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries\">MDN</a></li>\n</ul>\n<h4 id=\"媒体查询三种类型：\"><a href=\"#媒体查询三种类型：\" class=\"headerlink\" title=\"媒体查询三种类型：\"></a>媒体查询三种类型：</h4><ol>\n<li>媒介查询，是什么类型的设备</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media print&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>视口相关查询</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;布局视口宽度小于等于400px时生效</span><br><span class=\"line\">@media all and (max-width: 400)&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;布局视口不超过400px，设备处于横屏，并且devicePixelRatio小于1.5时生效</span><br><span class=\"line\">@media all and (max-width: 400) and (orientation: potrait) and  ((max-resolution: 144dpi),(-webkit-max-device-pixel-ratio: 1.5)) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>特性相关查询，浏览器是否支持某些特性</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@supports ( display: flex ) &#123;</span><br><span class=\"line\">    .foo &#123; display: flex; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"视口\"><a href=\"#视口\" class=\"headerlink\" title=\"视口\"></a>视口</h3><h4 id=\"像素（pixel）\"><a href=\"#像素（pixel）\" class=\"headerlink\" title=\"像素（pixel）\"></a>像素（pixel）</h4><ol>\n<li>设备像素：任何屏幕的物理像素数量是固定的</li>\n<li>CSS像素：CSS抽象的</li>\n</ol>\n<h4 id=\"布局视口\"><a href=\"#布局视口\" class=\"headerlink\" title=\"布局视口\"></a>布局视口</h4><ul>\n<li>概念</li>\n</ul>\n<ol>\n<li>CSS中，被称为初始包含块，是所有CSS百分比宽度推算的根源。</li>\n<li>PC浏览器布局视口的宽度与浏览器的宽度相同。</li>\n<li>移动端浏览器，布局视口与浏览器屏幕宽度不再相互关联，完全独立。</li>\n</ol>\n<ul>\n<li>js获取方式</li>\n</ul>\n<ol>\n<li>document.documentElement.clientWidth</li>\n<li>document.documentElement.clientWidth</li>\n</ol>\n<h4 id=\"视觉视口\"><a href=\"#视觉视口\" class=\"headerlink\" title=\"视觉视口\"></a>视觉视口</h4><ul>\n<li>概念</li>\n</ul>\n<ol>\n<li>用户正在看到的网站区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口，布局视口仍会保持原来的宽度。</li>\n<li>移动端视觉视口与设备屏幕一样宽，并且它表示的CSS像素数量会根据缩放改变。</li>\n</ol>\n<ul>\n<li>js获取方式</li>\n</ul>\n<ol>\n<li>window.innerWidth</li>\n<li>window.innerHeight</li>\n</ol>\n<h4 id=\"理想视口\"><a href=\"#理想视口\" class=\"headerlink\" title=\"理想视口\"></a>理想视口</h4><ul>\n<li>概念</li>\n</ul>\n<ol>\n<li>移动设备上，布局视口的默认宽度不是一个理想的宽度，因此引进理想视口。</li>\n<li>当网站是移动设备使用时理想视口才会生效（meta标签生效）。</li>\n<li>设置布局视口宽度与理想视口宽度一致。</li>\n<li>浏览器厂商决定理想视口。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name&#x3D;&quot;device&quot; content&#x3D;&quot;width&#x3D;device-width&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>js获取方式</li>\n</ul>\n<ol>\n<li>screen.width/height 存在严重的兼容性问题，也可能返回浏览器设备像素尺寸。</li>\n</ol>\n<h3 id=\"视口之间的关系\"><a href=\"#视口之间的关系\" class=\"headerlink\" title=\"视口之间的关系\"></a>视口之间的关系</h3><ol>\n<li>桌面浏览器，浏览器窗口就是布局视口。</li>\n<li>手机上，布局视口限制CSS布局，视觉视口决定用户看到的内容。</li>\n<li>理想视口是移动浏览器布局的一个理想尺寸，可以把布局视口尺寸设置为理想视口尺寸，实现响应式布局。</li>\n</ol>\n<h3 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h3><ul>\n<li>缩放行为在手机和桌面上区别很大。</li>\n<li>桌面上：</li>\n</ul>\n<ol>\n<li>行为一般是一次性的。</li>\n<li>布局视口会被缩放影响，因为桌面布局视口与视觉视口相同。</li>\n</ol>\n<ul>\n<li>移动设备上</li>\n</ul>\n<ol>\n<li>缩放是一个交互过程</li>\n<li>布局视口不会被缩放影响。</li>\n<li>移动端缩放不会导致CSS布局被重新计算。</li>\n<li>移动端浏览器根据理想视口的大小来计算缩放程度。</li>\n<li>拖放</li>\n<li>禁止缩放</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;user-scalable&#x3D;no&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分辨率\"><a href=\"#分辨率\" class=\"headerlink\" title=\"分辨率\"></a>分辨率</h3><h4 id=\"物理分辨率\"><a href=\"#物理分辨率\" class=\"headerlink\" title=\"物理分辨率\"></a>物理分辨率</h4><ol>\n<li>物理分辨率 = 像素数量 / 英寸单位宽度</li>\n<li>简称DPI</li>\n<li>每英寸像素数量越多显示越清晰</li>\n<li>有些手机可以动过screen.width获取，但是有兼容性问题</li>\n<li>96dpi = 1dppx</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;css使用需要加单位</span><br><span class=\"line\">@media all and (min-resolution: 192dpi)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"设备像素比\"><a href=\"#设备像素比\" class=\"headerlink\" title=\"设备像素比\"></a>设备像素比</h4><ol>\n<li>设备像素比 = 设备像素个数 / 理想视口</li>\n<li>简称DPR(Device Pixel Ratio)</li>\n<li>js属性window.devicePixelRatio</li>\n<li>CSS device-pixel-ratio（基于webkit浏览器）和分辨率的媒体查询。</li>\n<li>浏览器厂商决定理想视口，因此DPR也由他们决定。</li>\n<li>单位dppx但是使用时不需要添加。</li>\n<li>96dpi = 1dppx</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;js使用</span><br><span class=\"line\">if(window.devicePixelRatio&gt;&#x3D;2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;css使用</span><br><span class=\"line\">@media all and (-webkit-min-device-pixel-ratio: 2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"meta\"><a href=\"#meta\" class=\"headerlink\" title=\"meta\"></a>meta</h3><ol>\n<li>width：设置布局视口宽度为特定值。</li>\n<li>initial-scale：设置页面初始缩放程度和布局视口的宽度。</li>\n<li>minimum-scale\\maximum-scale设置用户最小最大可缩放程度。</li>\n<li>user-scalable：是否阻止缩放。</li>\n</ol>\n<ul>\n<li>将布局视口设置为设备理想视口</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>initial-scale</li>\n</ul>\n<ol>\n<li>缩放程度根据理想视口计算。</li>\n<li>initial-scale=1时，视觉视口和理想视口尺寸一样。</li>\n<li>initial-scale=2时，会放大到200%，此时视觉视口的宽高是理想视口的一半。</li>\n<li>使用initial-scale，同时会将布局视口的尺寸设置为缩放后的尺寸。</li>\n<li>initial-scale与width=decice-width效果一样。</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;width&#x3D;device-width, user-scalable&#x3D;no, initial-scale&#x3D;1.0, maximum-scale&#x3D;1.0, minimum-scale&#x3D;1.0&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"媒体查询\"><a href=\"#媒体查询\" class=\"headerlink\" title=\"媒体查询\"></a>媒体查询</h3><ul>\n<li>语法</li>\n</ul>\n<ol>\n<li>媒介类型：media_type: all | aural | braille | handheld | print | projection | screen | tty | tv | embossed</li>\n<li>and</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media tv and (min-width: 700px) and (orientation: landscape) &#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>or：使用逗号分隔效果等同于or逻辑操作符</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media (min-width: 700px), handheld and (orientation: landscape) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>not：not关键字仅能应用于整个查询，而不能单独应用于一个独立的查询</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;例如</span><br><span class=\"line\">@media not all and (monochrome) &#123;&#125;</span><br><span class=\"line\">&#x2F;&#x2F;等价于</span><br><span class=\"line\">@media not (all and (monochrome)) &#123;&#125;</span><br><span class=\"line\">&#x2F;&#x2F;而不是</span><br><span class=\"line\">@media (not all) and (monochrome) &#123;&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media not screen and (color), print and (color)</span><br><span class=\"line\">&#x2F;&#x2F;等价于</span><br><span class=\"line\">@media (not (screen and (color))), print and (color)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries\">MDN</a></li>\n</ul>\n<h4 id=\"媒体查询三种类型：\"><a href=\"#媒体查询三种类型：\" class=\"headerlink\" title=\"媒体查询三种类型：\"></a>媒体查询三种类型：</h4><ol>\n<li>媒介查询，是什么类型的设备</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media print&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>视口相关查询</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;布局视口宽度小于等于400px时生效</span><br><span class=\"line\">@media all and (max-width: 400)&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;布局视口不超过400px，设备处于横屏，并且devicePixelRatio小于1.5时生效</span><br><span class=\"line\">@media all and (max-width: 400) and (orientation: potrait) and  ((max-resolution: 144dpi),(-webkit-max-device-pixel-ratio: 1.5)) &#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>特性相关查询，浏览器是否支持某些特性</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@supports ( display: flex ) &#123;</span><br><span class=\"line\">    .foo &#123; display: flex; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"<js>babel生态","date":"2018-11-13T16:00:00.000Z","_content":"\n### core-js\n\n- 由 Lerna 搭建的 Monorepo 风格的项目\n- core-js 将自身能力充分解耦，提供出的多个包都可以被其他项目所依赖\n\tcore-js-compact 可以被 Babel 生态使用，由 Babel 分析出根据环境需要按需加载的垫片；\n\tcore-js-builder 可以被 Node.js 服务使用，构建出不同场景的垫片包。\n\n#### core-js相关包\n\n1. core-js\n\n\n- core-js 实现的基础垫片能力，是整个 core-js 的逻辑核心\n\n2. core-js-pure\n\n- core-js-pure 提供了不污染全局变量的垫片能力\n\n```javascript\nimport _from from 'core-js-pure/features/array/from';\nimport _flat from 'core-js-pure/features/array/flat';\n```\n\n3. core-js-compact\n\n- core-js-compact 维护了按照browserslist规范的垫片需求数据\n\n```javascript\nconst {\n  list, // array of required modules\n  targets, // object with targets for each module\n} = require('core-js-compat')({\n  targets: '> 2.5%'\n});\n```\n\n4. core-js-builder\n\n- core-js-builder 可以结合 core-js-compact 以及 core-js，并利用 webpack 能力，根据需求打包出 core-js 代码\n\n```javascript\nrequire('core-js-builder')({\n  targets: '> 0.5%',\n  filename: './my-core-js-bundle.js',\n}).then(code => {}).catch(error => {});\n```\n\n5. core-js-bundle\n\n#### polyfill 方案\n\n- 核心原则：按照用户终端环境、按照业务代码使用情况\n\n1. 手动打补丁：\n\n- es5-shim 和 es6-shim 方案\n- 缺点：方案原始而难以维护，同时对于 polyfill 的实现要求较高\n\n2. babel-polyfill 方案：\n\n- babel-polyfill 融合了 core-js 和 regenerator-runtime\n- 缺点：如果粗暴地使用 babel-polyfill 一次性全量导入到项目中，会导致项目 size 过大\n\n3. babel-polyfill 结合 @babel/preset-env + useBuiltins（entry） + preset-env targets 的方案\n\n- @babel/preset-env 定义了 Babel 所需插件预设，同时由 Babel 根据 preset-env targets 配置的支持环境，自动按需加载 polyfills\n\n```javascript\n// babel配置\n{\n  \"presets\": [\n    [\"@babel/env\", {\n      useBuiltIns: 'entry',\n      targets: { chrome: 44 }\n    }]\n  ]\n}\n\n// 工程入口处\nimport '@babel/polyfill';\n\n// 编译后\nimport \"core-js/XXXX/XXXX\";\nimport \"core-js/XXXX/XXXXX\";\n```\n\n4. 在线动态打补丁\n\n- Polyfill.\n- 在高版本浏览器上，可能会返回空内容，因为该浏览器已经支持了 ES2015 特性。如果在低版本浏览器上，将会得到真实的 polyfills bundle\n\n```\n<script src=\"https://polyfill.io/v3/polyfill.min.js?features=es2015\"></script>\n```\n\n### babel\n\n- 是一个 JavaScript 的“编译器”\n- 功能：\n\t语法转换，一般是高级语言特性的降级；\n\tPolyfill（垫片/补丁）特性的实现和接入；\n\t源码转换，比如 JSX 等。\n- 理念\n\t可插拔（Pluggable）：Babel 需要有一套灵活的插件机制，召集第三方开发者力量，同时还需要方便接入各种工具\n\t可调式（Debuggable）：编译过程中提供 source map\n\t基于协定（Compact）：实现灵活的配置方式,帮助开发者在“尽量还原规范”和“更小的编译产出体积”之间，找到平衡\n\n#### babel相关包\n\n1. @babel/core\n\n- Babel 实现转换的核心，它可以根据配置，进行源码的编译转换\n\n```javascript\nvar babel = require(\"@babel/core\");\n\nbabel.transform(code, options, function(err, result) {\n  result; // => { code, map, ast }\n});\n```\n\n2. @babel/cli\n\n- Babel 提供的命令行，它可以在终端中通过命令行方式运行，编译文件或目录\n- @babel/cli 使用了 commander 库搭建基本的命令行开发\n- @babel/cli 负责获取配置内容，并最终依赖了 @babel/core 完成编译\n\n3. @babel/standalone\n\n- 在非 Node.js 环境（比如浏览器环境）自动编译含有 text/babel 或 text/jsx 的 type 值的 script 标签，并进行编译\n- 编译行为由 @babel/core 提供\n- @babel/standalone 可以在浏览器中直接执行，因此这个包对于浏览器环境动态插入高级语言特性的脚本、在线自动解析编译非常有意义\n- Babel 官网也用到了这个包，JSFiddle、JS Bin 等也都是 @babel/standalone 的受益者\n\n\n```javascript\n<script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n<script type=\"text/babel\">// 含有type=\"text/babel\"进行编译\n\tconst getMessage = () => \"Hello World\";\n\tdocument.getElementById('output').innerHTML = getMessage();\n</script>\n```\n\n4. @babel/parser、@babel/code-frame、@babel/generator、@babel/traverse、@babel/types\n\n- @babel/parser\n\tBabel 用来对 JavaScript 语言解析的解析器\n\trequire(\"@babel/parser\").parse()方法可以返回给我们一个针对源码编译得到的 AST\n\n- @babel/traverse\n\t可以对 babel AST 进行遍历，可以在遍历过程中进行修改\n\n- @babel/types\n\t包提供了对具体的 AST 节点的修改能力\n\n- @babel/generator\n\t对新的 AST 进行聚合并生成 JavaScript 代码\n\n5. @babel/preset-env\n\n- 直接暴露给开发者在业务中运用的包能力\n- @babel/preset-env 允许我们配置需要支持的目标环境（一般是浏览器范围或 Node.js 版本范围），利用 babel-polyfill 完成补丁的接入\n- 通过 targets 参数，按照 browserslist 规范，结 合core-js-compat，筛选出适配环境所需的 polyfills\n\n6. @babel/polyfill\n\n- @babel/polyfill 其实就是 core-js 和 regenerator-runtime 两个包的结合\n- @babel/polyfill 源码层面，通过 build-dist.sh 脚本，利用 browserify 进行打包\n- @babel/polyfill 目前已经计划废弃，新的 Babel 生态（@babel/preset-env V7.4.0 版本）鼓励开发者直接在代码中引入 core-js 和 regenerator-runtime\n\n7. @babel/plugin-transform-runtime\n\n- 可以重复使用 Babel 注入的 helpers 函数，达到节省代码大小的目的\n- 例如：将 _instanceof _classCallCheck 等helper函数，转换为引入\n- helper 函数由 @babel/runtime 给出\n\n```javascript\n// 源代码\nclass Person{}\n\n// 使用babel编译后\nfunction _instanceof(left, right) { \n  // ...\n}\nfunction _classCallCheck(instance, Constructor) { \n  if (!_instanceof(instance, Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); }\n}\nvar Person = function Person() {\n  _classCallCheck(this, Person);\n};\n\n// 使用 @babel/plugin-transform-runtime 后\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar Person = function Person() {\n  (0, _classCallCheck2.default)(this, Person);\n};\n```\n\n8. @babel/runtime\n\n- @babel/runtime含有 Babel 编译所需的一些运行时 helpers 函数，供业务代码引入模块化的 Babel helpers 函数\n- 同时它提供了 regenerator-runtime，对 generator 和 async 函数进行编译降级\n\t@babel/plugin-transform-runtime 需要和 @babel/runtime 配合使用；\n\t@babel/plugin-transform-runtime 用于编译时，作为 devDependencies 使用；\n\t@babel/plugin-transform-runtime 将业务代码编译，引用 @babel/runtime 提供的 helpers，达到缩减编译产出体积的目的；\n\t@babel/runtime 用于运行时，作为 dependencies 使用\n- 除了可以对产出代码瘦身以外，还能避免污染全局作用域\n\n9. @babel/plugin\n\n- 是 Babel 插件集合\n\t@babel/plugin-syntax-* 是 Babel 的语法插件\n\t@babel/plugin-proposal-* 用于编译转换在提议阶段的语言特性\n\t@babel/plugin-transform-* 是 Babel 的转换插件\n\n10. @babel/template\n\n- 封装了基于 AST 的模板能力，可以将字符串代码转换为 AST\n\n11. @babel/node\n\n- 类似 Node.js Cli，@babel/node 提供在命令行执行高级语法的环境，也就是说，相比于 Node.js Cli，它加入了对更多特性的支持\n\n12. @babel/register\n\n- 为 require 增加了一个 hook，使用之后，所有被 Node.js 引用的文件都会先被 Babel 转码\n- 注意：@babel/node 和 @babel/register，都是在运行时进行编译转换，因此运行时性能上会有影响。在生产环境中，我们一般不直接使用\n\n13. @babel/eslint-parser\n\n- 配合 ESLint 检验合法 Babel 代码的解析器\n\n#### babel配置\n\n```\n```\n\n#### babel常用插件\n\n- @babel/plugin-proposal-optional-chaining\n可选链\n```javascript\na?.b?.c\n```\n\n### browserslist\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/[js]babel生态.md","raw":"---\ntitle: <js>babel生态\ndate: 2018-11-14 00:00:00\ntags: [ES6,js,Babel]\ncategories: ES6\n---\n\n### core-js\n\n- 由 Lerna 搭建的 Monorepo 风格的项目\n- core-js 将自身能力充分解耦，提供出的多个包都可以被其他项目所依赖\n\tcore-js-compact 可以被 Babel 生态使用，由 Babel 分析出根据环境需要按需加载的垫片；\n\tcore-js-builder 可以被 Node.js 服务使用，构建出不同场景的垫片包。\n\n#### core-js相关包\n\n1. core-js\n\n\n- core-js 实现的基础垫片能力，是整个 core-js 的逻辑核心\n\n2. core-js-pure\n\n- core-js-pure 提供了不污染全局变量的垫片能力\n\n```javascript\nimport _from from 'core-js-pure/features/array/from';\nimport _flat from 'core-js-pure/features/array/flat';\n```\n\n3. core-js-compact\n\n- core-js-compact 维护了按照browserslist规范的垫片需求数据\n\n```javascript\nconst {\n  list, // array of required modules\n  targets, // object with targets for each module\n} = require('core-js-compat')({\n  targets: '> 2.5%'\n});\n```\n\n4. core-js-builder\n\n- core-js-builder 可以结合 core-js-compact 以及 core-js，并利用 webpack 能力，根据需求打包出 core-js 代码\n\n```javascript\nrequire('core-js-builder')({\n  targets: '> 0.5%',\n  filename: './my-core-js-bundle.js',\n}).then(code => {}).catch(error => {});\n```\n\n5. core-js-bundle\n\n#### polyfill 方案\n\n- 核心原则：按照用户终端环境、按照业务代码使用情况\n\n1. 手动打补丁：\n\n- es5-shim 和 es6-shim 方案\n- 缺点：方案原始而难以维护，同时对于 polyfill 的实现要求较高\n\n2. babel-polyfill 方案：\n\n- babel-polyfill 融合了 core-js 和 regenerator-runtime\n- 缺点：如果粗暴地使用 babel-polyfill 一次性全量导入到项目中，会导致项目 size 过大\n\n3. babel-polyfill 结合 @babel/preset-env + useBuiltins（entry） + preset-env targets 的方案\n\n- @babel/preset-env 定义了 Babel 所需插件预设，同时由 Babel 根据 preset-env targets 配置的支持环境，自动按需加载 polyfills\n\n```javascript\n// babel配置\n{\n  \"presets\": [\n    [\"@babel/env\", {\n      useBuiltIns: 'entry',\n      targets: { chrome: 44 }\n    }]\n  ]\n}\n\n// 工程入口处\nimport '@babel/polyfill';\n\n// 编译后\nimport \"core-js/XXXX/XXXX\";\nimport \"core-js/XXXX/XXXXX\";\n```\n\n4. 在线动态打补丁\n\n- Polyfill.\n- 在高版本浏览器上，可能会返回空内容，因为该浏览器已经支持了 ES2015 特性。如果在低版本浏览器上，将会得到真实的 polyfills bundle\n\n```\n<script src=\"https://polyfill.io/v3/polyfill.min.js?features=es2015\"></script>\n```\n\n### babel\n\n- 是一个 JavaScript 的“编译器”\n- 功能：\n\t语法转换，一般是高级语言特性的降级；\n\tPolyfill（垫片/补丁）特性的实现和接入；\n\t源码转换，比如 JSX 等。\n- 理念\n\t可插拔（Pluggable）：Babel 需要有一套灵活的插件机制，召集第三方开发者力量，同时还需要方便接入各种工具\n\t可调式（Debuggable）：编译过程中提供 source map\n\t基于协定（Compact）：实现灵活的配置方式,帮助开发者在“尽量还原规范”和“更小的编译产出体积”之间，找到平衡\n\n#### babel相关包\n\n1. @babel/core\n\n- Babel 实现转换的核心，它可以根据配置，进行源码的编译转换\n\n```javascript\nvar babel = require(\"@babel/core\");\n\nbabel.transform(code, options, function(err, result) {\n  result; // => { code, map, ast }\n});\n```\n\n2. @babel/cli\n\n- Babel 提供的命令行，它可以在终端中通过命令行方式运行，编译文件或目录\n- @babel/cli 使用了 commander 库搭建基本的命令行开发\n- @babel/cli 负责获取配置内容，并最终依赖了 @babel/core 完成编译\n\n3. @babel/standalone\n\n- 在非 Node.js 环境（比如浏览器环境）自动编译含有 text/babel 或 text/jsx 的 type 值的 script 标签，并进行编译\n- 编译行为由 @babel/core 提供\n- @babel/standalone 可以在浏览器中直接执行，因此这个包对于浏览器环境动态插入高级语言特性的脚本、在线自动解析编译非常有意义\n- Babel 官网也用到了这个包，JSFiddle、JS Bin 等也都是 @babel/standalone 的受益者\n\n\n```javascript\n<script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n<script type=\"text/babel\">// 含有type=\"text/babel\"进行编译\n\tconst getMessage = () => \"Hello World\";\n\tdocument.getElementById('output').innerHTML = getMessage();\n</script>\n```\n\n4. @babel/parser、@babel/code-frame、@babel/generator、@babel/traverse、@babel/types\n\n- @babel/parser\n\tBabel 用来对 JavaScript 语言解析的解析器\n\trequire(\"@babel/parser\").parse()方法可以返回给我们一个针对源码编译得到的 AST\n\n- @babel/traverse\n\t可以对 babel AST 进行遍历，可以在遍历过程中进行修改\n\n- @babel/types\n\t包提供了对具体的 AST 节点的修改能力\n\n- @babel/generator\n\t对新的 AST 进行聚合并生成 JavaScript 代码\n\n5. @babel/preset-env\n\n- 直接暴露给开发者在业务中运用的包能力\n- @babel/preset-env 允许我们配置需要支持的目标环境（一般是浏览器范围或 Node.js 版本范围），利用 babel-polyfill 完成补丁的接入\n- 通过 targets 参数，按照 browserslist 规范，结 合core-js-compat，筛选出适配环境所需的 polyfills\n\n6. @babel/polyfill\n\n- @babel/polyfill 其实就是 core-js 和 regenerator-runtime 两个包的结合\n- @babel/polyfill 源码层面，通过 build-dist.sh 脚本，利用 browserify 进行打包\n- @babel/polyfill 目前已经计划废弃，新的 Babel 生态（@babel/preset-env V7.4.0 版本）鼓励开发者直接在代码中引入 core-js 和 regenerator-runtime\n\n7. @babel/plugin-transform-runtime\n\n- 可以重复使用 Babel 注入的 helpers 函数，达到节省代码大小的目的\n- 例如：将 _instanceof _classCallCheck 等helper函数，转换为引入\n- helper 函数由 @babel/runtime 给出\n\n```javascript\n// 源代码\nclass Person{}\n\n// 使用babel编译后\nfunction _instanceof(left, right) { \n  // ...\n}\nfunction _classCallCheck(instance, Constructor) { \n  if (!_instanceof(instance, Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); }\n}\nvar Person = function Person() {\n  _classCallCheck(this, Person);\n};\n\n// 使用 @babel/plugin-transform-runtime 后\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\nvar _classCallCheck2 = _interopRequireDefault(require(\"@babel/runtime/helpers/classCallCheck\"));\nvar Person = function Person() {\n  (0, _classCallCheck2.default)(this, Person);\n};\n```\n\n8. @babel/runtime\n\n- @babel/runtime含有 Babel 编译所需的一些运行时 helpers 函数，供业务代码引入模块化的 Babel helpers 函数\n- 同时它提供了 regenerator-runtime，对 generator 和 async 函数进行编译降级\n\t@babel/plugin-transform-runtime 需要和 @babel/runtime 配合使用；\n\t@babel/plugin-transform-runtime 用于编译时，作为 devDependencies 使用；\n\t@babel/plugin-transform-runtime 将业务代码编译，引用 @babel/runtime 提供的 helpers，达到缩减编译产出体积的目的；\n\t@babel/runtime 用于运行时，作为 dependencies 使用\n- 除了可以对产出代码瘦身以外，还能避免污染全局作用域\n\n9. @babel/plugin\n\n- 是 Babel 插件集合\n\t@babel/plugin-syntax-* 是 Babel 的语法插件\n\t@babel/plugin-proposal-* 用于编译转换在提议阶段的语言特性\n\t@babel/plugin-transform-* 是 Babel 的转换插件\n\n10. @babel/template\n\n- 封装了基于 AST 的模板能力，可以将字符串代码转换为 AST\n\n11. @babel/node\n\n- 类似 Node.js Cli，@babel/node 提供在命令行执行高级语法的环境，也就是说，相比于 Node.js Cli，它加入了对更多特性的支持\n\n12. @babel/register\n\n- 为 require 增加了一个 hook，使用之后，所有被 Node.js 引用的文件都会先被 Babel 转码\n- 注意：@babel/node 和 @babel/register，都是在运行时进行编译转换，因此运行时性能上会有影响。在生产环境中，我们一般不直接使用\n\n13. @babel/eslint-parser\n\n- 配合 ESLint 检验合法 Babel 代码的解析器\n\n#### babel配置\n\n```\n```\n\n#### babel常用插件\n\n- @babel/plugin-proposal-optional-chaining\n可选链\n```javascript\na?.b?.c\n```\n\n### browserslist\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"[js]babel生态","published":1,"updated":"2021-03-15T14:39:12.869Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dke001hwotjamve3ab2","content":"<h3 id=\"core-js\"><a href=\"#core-js\" class=\"headerlink\" title=\"core-js\"></a>core-js</h3><ul>\n<li>由 Lerna 搭建的 Monorepo 风格的项目</li>\n<li>core-js 将自身能力充分解耦，提供出的多个包都可以被其他项目所依赖<br>  core-js-compact 可以被 Babel 生态使用，由 Babel 分析出根据环境需要按需加载的垫片；<br>  core-js-builder 可以被 Node.js 服务使用，构建出不同场景的垫片包。</li>\n</ul>\n<h4 id=\"core-js相关包\"><a href=\"#core-js相关包\" class=\"headerlink\" title=\"core-js相关包\"></a>core-js相关包</h4><ol>\n<li>core-js</li>\n</ol>\n<ul>\n<li>core-js 实现的基础垫片能力，是整个 core-js 的逻辑核心</li>\n</ul>\n<ol start=\"2\">\n<li>core-js-pure</li>\n</ol>\n<ul>\n<li>core-js-pure 提供了不污染全局变量的垫片能力</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> _from <span class=\"keyword\">from</span> <span class=\"string\">&#x27;core-js-pure/features/array/from&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> _flat <span class=\"keyword\">from</span> <span class=\"string\">&#x27;core-js-pure/features/array/flat&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>core-js-compact</li>\n</ol>\n<ul>\n<li>core-js-compact 维护了按照browserslist规范的垫片需求数据</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  list, <span class=\"comment\">// array of required modules</span></span><br><span class=\"line\">  targets, <span class=\"comment\">// object with targets for each module</span></span><br><span class=\"line\">&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;core-js-compat&#x27;</span>)(&#123;</span><br><span class=\"line\">  targets: <span class=\"string\">&#x27;&gt; 2.5%&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>core-js-builder</li>\n</ol>\n<ul>\n<li>core-js-builder 可以结合 core-js-compact 以及 core-js，并利用 webpack 能力，根据需求打包出 core-js 代码</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;core-js-builder&#x27;</span>)(&#123;</span><br><span class=\"line\">  targets: <span class=\"string\">&#x27;&gt; 0.5%&#x27;</span>,</span><br><span class=\"line\">  filename: <span class=\"string\">&#x27;./my-core-js-bundle.js&#x27;</span>,</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">code</span> =&gt;</span> &#123;&#125;).catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>core-js-bundle</li>\n</ol>\n<h4 id=\"polyfill-方案\"><a href=\"#polyfill-方案\" class=\"headerlink\" title=\"polyfill 方案\"></a>polyfill 方案</h4><ul>\n<li>核心原则：按照用户终端环境、按照业务代码使用情况</li>\n</ul>\n<ol>\n<li>手动打补丁：</li>\n</ol>\n<ul>\n<li>es5-shim 和 es6-shim 方案</li>\n<li>缺点：方案原始而难以维护，同时对于 polyfill 的实现要求较高</li>\n</ul>\n<ol start=\"2\">\n<li>babel-polyfill 方案：</li>\n</ol>\n<ul>\n<li>babel-polyfill 融合了 core-js 和 regenerator-runtime</li>\n<li>缺点：如果粗暴地使用 babel-polyfill 一次性全量导入到项目中，会导致项目 size 过大</li>\n</ul>\n<ol start=\"3\">\n<li>babel-polyfill 结合 @babel/preset-env + useBuiltins（entry） + preset-env targets 的方案</li>\n</ol>\n<ul>\n<li>@babel/preset-env 定义了 Babel 所需插件预设，同时由 Babel 根据 preset-env targets 配置的支持环境，自动按需加载 polyfills</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// babel配置</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;presets&quot;</span>: [</span><br><span class=\"line\">    [<span class=\"string\">&quot;@babel/env&quot;</span>, &#123;</span><br><span class=\"line\">      useBuiltIns: <span class=\"string\">&#x27;entry&#x27;</span>,</span><br><span class=\"line\">      targets: &#123; <span class=\"attr\">chrome</span>: <span class=\"number\">44</span> &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工程入口处</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;@babel/polyfill&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译后</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;core-js/XXXX/XXXX&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;core-js/XXXX/XXXXX&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>在线动态打补丁</li>\n</ol>\n<ul>\n<li>Polyfill.</li>\n<li>在高版本浏览器上，可能会返回空内容，因为该浏览器已经支持了 ES2015 特性。如果在低版本浏览器上，将会得到真实的 polyfills bundle</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;polyfill.io&#x2F;v3&#x2F;polyfill.min.js?features&#x3D;es2015&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a>babel</h3><ul>\n<li>是一个 JavaScript 的“编译器”</li>\n<li>功能：<br>  语法转换，一般是高级语言特性的降级；<br>  Polyfill（垫片/补丁）特性的实现和接入；<br>  源码转换，比如 JSX 等。</li>\n<li>理念<br>  可插拔（Pluggable）：Babel 需要有一套灵活的插件机制，召集第三方开发者力量，同时还需要方便接入各种工具<br>  可调式（Debuggable）：编译过程中提供 source map<br>  基于协定（Compact）：实现灵活的配置方式,帮助开发者在“尽量还原规范”和“更小的编译产出体积”之间，找到平衡</li>\n</ul>\n<h4 id=\"babel相关包\"><a href=\"#babel相关包\" class=\"headerlink\" title=\"babel相关包\"></a>babel相关包</h4><ol>\n<li>@babel/core</li>\n</ol>\n<ul>\n<li>Babel 实现转换的核心，它可以根据配置，进行源码的编译转换</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> babel = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;@babel/core&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">babel.transform(code, options, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">  result; <span class=\"comment\">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>@babel/cli</li>\n</ol>\n<ul>\n<li>Babel 提供的命令行，它可以在终端中通过命令行方式运行，编译文件或目录</li>\n<li>@babel/cli 使用了 commander 库搭建基本的命令行开发</li>\n<li>@babel/cli 负责获取配置内容，并最终依赖了 @babel/core 完成编译</li>\n</ul>\n<ol start=\"3\">\n<li>@babel/standalone</li>\n</ol>\n<ul>\n<li>在非 Node.js 环境（比如浏览器环境）自动编译含有 text/babel 或 text/jsx 的 type 值的 script 标签，并进行编译</li>\n<li>编译行为由 @babel/core 提供</li>\n<li>@babel/standalone 可以在浏览器中直接执行，因此这个包对于浏览器环境动态插入高级语言特性的脚本、在线自动解析编译非常有意义</li>\n<li>Babel 官网也用到了这个包，JSFiddle、JS Bin 等也都是 @babel/standalone 的受益者</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=<span class=\"string\">&quot;text/babel&quot;</span>&gt;<span class=\"comment\">// 含有type=&quot;text/babel&quot;进行编译</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> getMessage = <span class=\"function\">() =&gt;</span> <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;output&#x27;</span>).innerHTML = getMessage();</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>@babel/parser、@babel/code-frame、@babel/generator、@babel/traverse、@babel/types</li>\n</ol>\n<ul>\n<li><p>@babel/parser<br>  Babel 用来对 JavaScript 语言解析的解析器<br>  require(“@babel/parser”).parse()方法可以返回给我们一个针对源码编译得到的 AST</p>\n</li>\n<li><p>@babel/traverse<br>  可以对 babel AST 进行遍历，可以在遍历过程中进行修改</p>\n</li>\n<li><p>@babel/types<br>  包提供了对具体的 AST 节点的修改能力</p>\n</li>\n<li><p>@babel/generator<br>  对新的 AST 进行聚合并生成 JavaScript 代码</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li>@babel/preset-env</li>\n</ol>\n<ul>\n<li>直接暴露给开发者在业务中运用的包能力</li>\n<li>@babel/preset-env 允许我们配置需要支持的目标环境（一般是浏览器范围或 Node.js 版本范围），利用 babel-polyfill 完成补丁的接入</li>\n<li>通过 targets 参数，按照 browserslist 规范，结 合core-js-compat，筛选出适配环境所需的 polyfills</li>\n</ul>\n<ol start=\"6\">\n<li>@babel/polyfill</li>\n</ol>\n<ul>\n<li>@babel/polyfill 其实就是 core-js 和 regenerator-runtime 两个包的结合</li>\n<li>@babel/polyfill 源码层面，通过 build-dist.sh 脚本，利用 browserify 进行打包</li>\n<li>@babel/polyfill 目前已经计划废弃，新的 Babel 生态（@babel/preset-env V7.4.0 版本）鼓励开发者直接在代码中引入 core-js 和 regenerator-runtime</li>\n</ul>\n<ol start=\"7\">\n<li>@babel/plugin-transform-runtime</li>\n</ol>\n<ul>\n<li>可以重复使用 Babel 注入的 helpers 函数，达到节省代码大小的目的</li>\n<li>例如：将 _instanceof _classCallCheck 等helper函数，转换为引入</li>\n<li>helper 函数由 @babel/runtime 给出</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源代码</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用babel编译后</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_instanceof</span>(<span class=\"params\">left, right</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_classCallCheck</span>(<span class=\"params\">instance, Constructor</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_instanceof(instance, Constructor)) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&quot;Cannot call a class as a function&quot;</span>); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  _classCallCheck(<span class=\"built_in\">this</span>, Person);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 @babel/plugin-transform-runtime 后</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _interopRequireDefault = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;@babel/runtime/helpers/interopRequireDefault&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> _classCallCheck2 = _interopRequireDefault(<span class=\"built_in\">require</span>(<span class=\"string\">&quot;@babel/runtime/helpers/classCallCheck&quot;</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  (<span class=\"number\">0</span>, _classCallCheck2.default)(<span class=\"built_in\">this</span>, Person);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>@babel/runtime</li>\n</ol>\n<ul>\n<li>@babel/runtime含有 Babel 编译所需的一些运行时 helpers 函数，供业务代码引入模块化的 Babel helpers 函数</li>\n<li>同时它提供了 regenerator-runtime，对 generator 和 async 函数进行编译降级<br>  @babel/plugin-transform-runtime 需要和 @babel/runtime 配合使用；<br>  @babel/plugin-transform-runtime 用于编译时，作为 devDependencies 使用；<br>  @babel/plugin-transform-runtime 将业务代码编译，引用 @babel/runtime 提供的 helpers，达到缩减编译产出体积的目的；<br>  @babel/runtime 用于运行时，作为 dependencies 使用</li>\n<li>除了可以对产出代码瘦身以外，还能避免污染全局作用域</li>\n</ul>\n<ol start=\"9\">\n<li>@babel/plugin</li>\n</ol>\n<ul>\n<li>是 Babel 插件集合<br>  @babel/plugin-syntax-* 是 Babel 的语法插件<br>  @babel/plugin-proposal-* 用于编译转换在提议阶段的语言特性<br>  @babel/plugin-transform-* 是 Babel 的转换插件</li>\n</ul>\n<ol start=\"10\">\n<li>@babel/template</li>\n</ol>\n<ul>\n<li>封装了基于 AST 的模板能力，可以将字符串代码转换为 AST</li>\n</ul>\n<ol start=\"11\">\n<li>@babel/node</li>\n</ol>\n<ul>\n<li>类似 Node.js Cli，@babel/node 提供在命令行执行高级语法的环境，也就是说，相比于 Node.js Cli，它加入了对更多特性的支持</li>\n</ul>\n<ol start=\"12\">\n<li>@babel/register</li>\n</ol>\n<ul>\n<li>为 require 增加了一个 hook，使用之后，所有被 Node.js 引用的文件都会先被 Babel 转码</li>\n<li>注意：@babel/node 和 @babel/register，都是在运行时进行编译转换，因此运行时性能上会有影响。在生产环境中，我们一般不直接使用</li>\n</ul>\n<ol start=\"13\">\n<li>@babel/eslint-parser</li>\n</ol>\n<ul>\n<li>配合 ESLint 检验合法 Babel 代码的解析器</li>\n</ul>\n<h4 id=\"babel配置\"><a href=\"#babel配置\" class=\"headerlink\" title=\"babel配置\"></a>babel配置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#96;&#96;&#96;</span><br><span class=\"line\"></span><br><span class=\"line\">#### babel常用插件</span><br><span class=\"line\"></span><br><span class=\"line\">- @babel&#x2F;plugin-proposal-optional-chaining</span><br><span class=\"line\">可选链</span><br><span class=\"line\">&#96;&#96;&#96;javascript</span><br><span class=\"line\">a?.b?.c</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"browserslist\"><a href=\"#browserslist\" class=\"headerlink\" title=\"browserslist\"></a>browserslist</h3>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"core-js\"><a href=\"#core-js\" class=\"headerlink\" title=\"core-js\"></a>core-js</h3><ul>\n<li>由 Lerna 搭建的 Monorepo 风格的项目</li>\n<li>core-js 将自身能力充分解耦，提供出的多个包都可以被其他项目所依赖<br>  core-js-compact 可以被 Babel 生态使用，由 Babel 分析出根据环境需要按需加载的垫片；<br>  core-js-builder 可以被 Node.js 服务使用，构建出不同场景的垫片包。</li>\n</ul>\n<h4 id=\"core-js相关包\"><a href=\"#core-js相关包\" class=\"headerlink\" title=\"core-js相关包\"></a>core-js相关包</h4><ol>\n<li>core-js</li>\n</ol>\n<ul>\n<li>core-js 实现的基础垫片能力，是整个 core-js 的逻辑核心</li>\n</ul>\n<ol start=\"2\">\n<li>core-js-pure</li>\n</ol>\n<ul>\n<li>core-js-pure 提供了不污染全局变量的垫片能力</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> _from <span class=\"keyword\">from</span> <span class=\"string\">&#x27;core-js-pure/features/array/from&#x27;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> _flat <span class=\"keyword\">from</span> <span class=\"string\">&#x27;core-js-pure/features/array/flat&#x27;</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>core-js-compact</li>\n</ol>\n<ul>\n<li>core-js-compact 维护了按照browserslist规范的垫片需求数据</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> &#123;</span><br><span class=\"line\">  list, <span class=\"comment\">// array of required modules</span></span><br><span class=\"line\">  targets, <span class=\"comment\">// object with targets for each module</span></span><br><span class=\"line\">&#125; = <span class=\"built_in\">require</span>(<span class=\"string\">&#x27;core-js-compat&#x27;</span>)(&#123;</span><br><span class=\"line\">  targets: <span class=\"string\">&#x27;&gt; 2.5%&#x27;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>core-js-builder</li>\n</ol>\n<ul>\n<li>core-js-builder 可以结合 core-js-compact 以及 core-js，并利用 webpack 能力，根据需求打包出 core-js 代码</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">require</span>(<span class=\"string\">&#x27;core-js-builder&#x27;</span>)(&#123;</span><br><span class=\"line\">  targets: <span class=\"string\">&#x27;&gt; 0.5%&#x27;</span>,</span><br><span class=\"line\">  filename: <span class=\"string\">&#x27;./my-core-js-bundle.js&#x27;</span>,</span><br><span class=\"line\">&#125;).then(<span class=\"function\"><span class=\"params\">code</span> =&gt;</span> &#123;&#125;).catch(<span class=\"function\"><span class=\"params\">error</span> =&gt;</span> &#123;&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>core-js-bundle</li>\n</ol>\n<h4 id=\"polyfill-方案\"><a href=\"#polyfill-方案\" class=\"headerlink\" title=\"polyfill 方案\"></a>polyfill 方案</h4><ul>\n<li>核心原则：按照用户终端环境、按照业务代码使用情况</li>\n</ul>\n<ol>\n<li>手动打补丁：</li>\n</ol>\n<ul>\n<li>es5-shim 和 es6-shim 方案</li>\n<li>缺点：方案原始而难以维护，同时对于 polyfill 的实现要求较高</li>\n</ul>\n<ol start=\"2\">\n<li>babel-polyfill 方案：</li>\n</ol>\n<ul>\n<li>babel-polyfill 融合了 core-js 和 regenerator-runtime</li>\n<li>缺点：如果粗暴地使用 babel-polyfill 一次性全量导入到项目中，会导致项目 size 过大</li>\n</ul>\n<ol start=\"3\">\n<li>babel-polyfill 结合 @babel/preset-env + useBuiltins（entry） + preset-env targets 的方案</li>\n</ol>\n<ul>\n<li>@babel/preset-env 定义了 Babel 所需插件预设，同时由 Babel 根据 preset-env targets 配置的支持环境，自动按需加载 polyfills</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// babel配置</span></span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">&quot;presets&quot;</span>: [</span><br><span class=\"line\">    [<span class=\"string\">&quot;@babel/env&quot;</span>, &#123;</span><br><span class=\"line\">      useBuiltIns: <span class=\"string\">&#x27;entry&#x27;</span>,</span><br><span class=\"line\">      targets: &#123; <span class=\"attr\">chrome</span>: <span class=\"number\">44</span> &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">  ]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 工程入口处</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&#x27;@babel/polyfill&#x27;</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 编译后</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;core-js/XXXX/XXXX&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">import</span> <span class=\"string\">&quot;core-js/XXXX/XXXXX&quot;</span>;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>在线动态打补丁</li>\n</ol>\n<ul>\n<li>Polyfill.</li>\n<li>在高版本浏览器上，可能会返回空内容，因为该浏览器已经支持了 ES2015 特性。如果在低版本浏览器上，将会得到真实的 polyfills bundle</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;polyfill.io&#x2F;v3&#x2F;polyfill.min.js?features&#x3D;es2015&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"babel\"><a href=\"#babel\" class=\"headerlink\" title=\"babel\"></a>babel</h3><ul>\n<li>是一个 JavaScript 的“编译器”</li>\n<li>功能：<br>  语法转换，一般是高级语言特性的降级；<br>  Polyfill（垫片/补丁）特性的实现和接入；<br>  源码转换，比如 JSX 等。</li>\n<li>理念<br>  可插拔（Pluggable）：Babel 需要有一套灵活的插件机制，召集第三方开发者力量，同时还需要方便接入各种工具<br>  可调式（Debuggable）：编译过程中提供 source map<br>  基于协定（Compact）：实现灵活的配置方式,帮助开发者在“尽量还原规范”和“更小的编译产出体积”之间，找到平衡</li>\n</ul>\n<h4 id=\"babel相关包\"><a href=\"#babel相关包\" class=\"headerlink\" title=\"babel相关包\"></a>babel相关包</h4><ol>\n<li>@babel/core</li>\n</ol>\n<ul>\n<li>Babel 实现转换的核心，它可以根据配置，进行源码的编译转换</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> babel = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;@babel/core&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">babel.transform(code, options, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">err, result</span>) </span>&#123;</span><br><span class=\"line\">  result; <span class=\"comment\">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>@babel/cli</li>\n</ol>\n<ul>\n<li>Babel 提供的命令行，它可以在终端中通过命令行方式运行，编译文件或目录</li>\n<li>@babel/cli 使用了 commander 库搭建基本的命令行开发</li>\n<li>@babel/cli 负责获取配置内容，并最终依赖了 @babel/core 完成编译</li>\n</ul>\n<ol start=\"3\">\n<li>@babel/standalone</li>\n</ol>\n<ul>\n<li>在非 Node.js 环境（比如浏览器环境）自动编译含有 text/babel 或 text/jsx 的 type 值的 script 标签，并进行编译</li>\n<li>编译行为由 @babel/core 提供</li>\n<li>@babel/standalone 可以在浏览器中直接执行，因此这个包对于浏览器环境动态插入高级语言特性的脚本、在线自动解析编译非常有意义</li>\n<li>Babel 官网也用到了这个包，JSFiddle、JS Bin 等也都是 @babel/standalone 的受益者</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;script src=<span class=\"string\">&quot;https://unpkg.com/@babel/standalone/babel.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class=\"line\">&lt;script type=<span class=\"string\">&quot;text/babel&quot;</span>&gt;<span class=\"comment\">// 含有type=&quot;text/babel&quot;进行编译</span></span><br><span class=\"line\">\t<span class=\"keyword\">const</span> getMessage = <span class=\"function\">() =&gt;</span> <span class=\"string\">&quot;Hello World&quot;</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">document</span>.getElementById(<span class=\"string\">&#x27;output&#x27;</span>).innerHTML = getMessage();</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>@babel/parser、@babel/code-frame、@babel/generator、@babel/traverse、@babel/types</li>\n</ol>\n<ul>\n<li><p>@babel/parser<br>  Babel 用来对 JavaScript 语言解析的解析器<br>  require(“@babel/parser”).parse()方法可以返回给我们一个针对源码编译得到的 AST</p>\n</li>\n<li><p>@babel/traverse<br>  可以对 babel AST 进行遍历，可以在遍历过程中进行修改</p>\n</li>\n<li><p>@babel/types<br>  包提供了对具体的 AST 节点的修改能力</p>\n</li>\n<li><p>@babel/generator<br>  对新的 AST 进行聚合并生成 JavaScript 代码</p>\n</li>\n</ul>\n<ol start=\"5\">\n<li>@babel/preset-env</li>\n</ol>\n<ul>\n<li>直接暴露给开发者在业务中运用的包能力</li>\n<li>@babel/preset-env 允许我们配置需要支持的目标环境（一般是浏览器范围或 Node.js 版本范围），利用 babel-polyfill 完成补丁的接入</li>\n<li>通过 targets 参数，按照 browserslist 规范，结 合core-js-compat，筛选出适配环境所需的 polyfills</li>\n</ul>\n<ol start=\"6\">\n<li>@babel/polyfill</li>\n</ol>\n<ul>\n<li>@babel/polyfill 其实就是 core-js 和 regenerator-runtime 两个包的结合</li>\n<li>@babel/polyfill 源码层面，通过 build-dist.sh 脚本，利用 browserify 进行打包</li>\n<li>@babel/polyfill 目前已经计划废弃，新的 Babel 生态（@babel/preset-env V7.4.0 版本）鼓励开发者直接在代码中引入 core-js 和 regenerator-runtime</li>\n</ul>\n<ol start=\"7\">\n<li>@babel/plugin-transform-runtime</li>\n</ol>\n<ul>\n<li>可以重复使用 Babel 注入的 helpers 函数，达到节省代码大小的目的</li>\n<li>例如：将 _instanceof _classCallCheck 等helper函数，转换为引入</li>\n<li>helper 函数由 @babel/runtime 给出</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 源代码</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Person</span></span>&#123;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用babel编译后</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_instanceof</span>(<span class=\"params\">left, right</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"comment\">// ...</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_classCallCheck</span>(<span class=\"params\">instance, Constructor</span>) </span>&#123; </span><br><span class=\"line\">  <span class=\"keyword\">if</span> (!_instanceof(instance, Constructor)) &#123; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&quot;Cannot call a class as a function&quot;</span>); &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  _classCallCheck(<span class=\"built_in\">this</span>, Person);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 使用 @babel/plugin-transform-runtime 后</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> _interopRequireDefault = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;@babel/runtime/helpers/interopRequireDefault&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">var</span> _classCallCheck2 = _interopRequireDefault(<span class=\"built_in\">require</span>(<span class=\"string\">&quot;@babel/runtime/helpers/classCallCheck&quot;</span>));</span><br><span class=\"line\"><span class=\"keyword\">var</span> Person = <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Person</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  (<span class=\"number\">0</span>, _classCallCheck2.default)(<span class=\"built_in\">this</span>, Person);</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"8\">\n<li>@babel/runtime</li>\n</ol>\n<ul>\n<li>@babel/runtime含有 Babel 编译所需的一些运行时 helpers 函数，供业务代码引入模块化的 Babel helpers 函数</li>\n<li>同时它提供了 regenerator-runtime，对 generator 和 async 函数进行编译降级<br>  @babel/plugin-transform-runtime 需要和 @babel/runtime 配合使用；<br>  @babel/plugin-transform-runtime 用于编译时，作为 devDependencies 使用；<br>  @babel/plugin-transform-runtime 将业务代码编译，引用 @babel/runtime 提供的 helpers，达到缩减编译产出体积的目的；<br>  @babel/runtime 用于运行时，作为 dependencies 使用</li>\n<li>除了可以对产出代码瘦身以外，还能避免污染全局作用域</li>\n</ul>\n<ol start=\"9\">\n<li>@babel/plugin</li>\n</ol>\n<ul>\n<li>是 Babel 插件集合<br>  @babel/plugin-syntax-* 是 Babel 的语法插件<br>  @babel/plugin-proposal-* 用于编译转换在提议阶段的语言特性<br>  @babel/plugin-transform-* 是 Babel 的转换插件</li>\n</ul>\n<ol start=\"10\">\n<li>@babel/template</li>\n</ol>\n<ul>\n<li>封装了基于 AST 的模板能力，可以将字符串代码转换为 AST</li>\n</ul>\n<ol start=\"11\">\n<li>@babel/node</li>\n</ol>\n<ul>\n<li>类似 Node.js Cli，@babel/node 提供在命令行执行高级语法的环境，也就是说，相比于 Node.js Cli，它加入了对更多特性的支持</li>\n</ul>\n<ol start=\"12\">\n<li>@babel/register</li>\n</ol>\n<ul>\n<li>为 require 增加了一个 hook，使用之后，所有被 Node.js 引用的文件都会先被 Babel 转码</li>\n<li>注意：@babel/node 和 @babel/register，都是在运行时进行编译转换，因此运行时性能上会有影响。在生产环境中，我们一般不直接使用</li>\n</ul>\n<ol start=\"13\">\n<li>@babel/eslint-parser</li>\n</ol>\n<ul>\n<li>配合 ESLint 检验合法 Babel 代码的解析器</li>\n</ul>\n<h4 id=\"babel配置\"><a href=\"#babel配置\" class=\"headerlink\" title=\"babel配置\"></a>babel配置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#96;&#96;&#96;</span><br><span class=\"line\"></span><br><span class=\"line\">#### babel常用插件</span><br><span class=\"line\"></span><br><span class=\"line\">- @babel&#x2F;plugin-proposal-optional-chaining</span><br><span class=\"line\">可选链</span><br><span class=\"line\">&#96;&#96;&#96;javascript</span><br><span class=\"line\">a?.b?.c</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"browserslist\"><a href=\"#browserslist\" class=\"headerlink\" title=\"browserslist\"></a>browserslist</h3>"},{"title":"<js>eventLoop","date":"2018-10-19T16:00:00.000Z","_content":"\n### Micro-Task 与 Macro-Task\n\n- 事件循环中的异步队列有两种：macro（宏任务）队列和\nmicro（微任务）队列。\n\n#### macro-task\n\n- setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等\n\n#### micro-task\n\n- process.nextTick、Promise、MutationObserver 等。\n\n### Event Loop 过程\n\n1. 初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。\n2. 全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。\n3. macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的，因此，一个 macro-task执行完成后，会清空 micro-task对列。\n4. 执行渲染操作，更新界面\n5. 检查是否存在 Web worker 任务，如果有，则对其进行处理 。\n\n### 例子\n\n```\nasync function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\n\nasync function async2() {\n    console.log('async2')\n}\n\nconsole.log('script start')\n\nsetTimeout(function () {\n    console.log('setTimeout')\n}, 0)\n\nasync1();\n\nnew Promise(function (resolve) {\n    console.log('promise1')\n    resolve();\n}).then(function () {\n    console.log('promise2')\n})\n\nconsole.log('script end')\n```\n\n- 执行script标签内容（script start）-> setTimeout 进入 Macro-Task 对列 -> 执行 async1（async1 start）-> 执行 async2 (async2) ->由于 await async2 进入等待 -> 执行 Promise （promise1）-> promise.then() 进入 Micro-Task 对列 -> script 执行结束（script end）->清空 Micro-Task 对列-> await 执行（async1 end）->（promise2）->执行新的 Macro-Task 任务（setTimeout）\n- 注意：node环境以及babel转换或者部分浏览器执行顺序有所不同\n","source":"_posts/[js]eventLoop.md","raw":"---\ntitle: <js>eventLoop\ndate: 2018-10-20 00:00:00\ntags: [js]\ncategories: js\n---\n\n### Micro-Task 与 Macro-Task\n\n- 事件循环中的异步队列有两种：macro（宏任务）队列和\nmicro（微任务）队列。\n\n#### macro-task\n\n- setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等\n\n#### micro-task\n\n- process.nextTick、Promise、MutationObserver 等。\n\n### Event Loop 过程\n\n1. 初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。\n2. 全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。\n3. macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的，因此，一个 macro-task执行完成后，会清空 micro-task对列。\n4. 执行渲染操作，更新界面\n5. 检查是否存在 Web worker 任务，如果有，则对其进行处理 。\n\n### 例子\n\n```\nasync function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\n\nasync function async2() {\n    console.log('async2')\n}\n\nconsole.log('script start')\n\nsetTimeout(function () {\n    console.log('setTimeout')\n}, 0)\n\nasync1();\n\nnew Promise(function (resolve) {\n    console.log('promise1')\n    resolve();\n}).then(function () {\n    console.log('promise2')\n})\n\nconsole.log('script end')\n```\n\n- 执行script标签内容（script start）-> setTimeout 进入 Macro-Task 对列 -> 执行 async1（async1 start）-> 执行 async2 (async2) ->由于 await async2 进入等待 -> 执行 Promise （promise1）-> promise.then() 进入 Micro-Task 对列 -> script 执行结束（script end）->清空 Micro-Task 对列-> await 执行（async1 end）->（promise2）->执行新的 Macro-Task 任务（setTimeout）\n- 注意：node环境以及babel转换或者部分浏览器执行顺序有所不同\n","slug":"[js]eventLoop","published":1,"updated":"2021-03-15T14:39:29.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dke001kwotjhr62c9r6","content":"<h3 id=\"Micro-Task-与-Macro-Task\"><a href=\"#Micro-Task-与-Macro-Task\" class=\"headerlink\" title=\"Micro-Task 与 Macro-Task\"></a>Micro-Task 与 Macro-Task</h3><ul>\n<li>事件循环中的异步队列有两种：macro（宏任务）队列和<br>micro（微任务）队列。</li>\n</ul>\n<h4 id=\"macro-task\"><a href=\"#macro-task\" class=\"headerlink\" title=\"macro-task\"></a>macro-task</h4><ul>\n<li>setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等</li>\n</ul>\n<h4 id=\"micro-task\"><a href=\"#micro-task\" class=\"headerlink\" title=\"micro-task\"></a>micro-task</h4><ul>\n<li>process.nextTick、Promise、MutationObserver 等。</li>\n</ul>\n<h3 id=\"Event-Loop-过程\"><a href=\"#Event-Loop-过程\" class=\"headerlink\" title=\"Event Loop 过程\"></a>Event Loop 过程</h3><ol>\n<li>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</li>\n<li>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</li>\n<li>macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的，因此，一个 macro-task执行完成后，会清空 micro-task对列。</li>\n<li>执行渲染操作，更新界面</li>\n<li>检查是否存在 Web worker 任务，如果有，则对其进行处理 。</li>\n</ol>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">    console.log(&#39;async1 start&#39;)</span><br><span class=\"line\">    await async2()</span><br><span class=\"line\">    console.log(&#39;async1 end&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">async function async2() &#123;</span><br><span class=\"line\">    console.log(&#39;async2&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#39;script start&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">    console.log(&#39;setTimeout&#39;)</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">async1();</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(function (resolve) &#123;</span><br><span class=\"line\">    console.log(&#39;promise1&#39;)</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function () &#123;</span><br><span class=\"line\">    console.log(&#39;promise2&#39;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#39;script end&#39;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行script标签内容（script start）-&gt; setTimeout 进入 Macro-Task 对列 -&gt; 执行 async1（async1 start）-&gt; 执行 async2 (async2) -&gt;由于 await async2 进入等待 -&gt; 执行 Promise （promise1）-&gt; promise.then() 进入 Micro-Task 对列 -&gt; script 执行结束（script end）-&gt;清空 Micro-Task 对列-&gt; await 执行（async1 end）-&gt;（promise2）-&gt;执行新的 Macro-Task 任务（setTimeout）</li>\n<li>注意：node环境以及babel转换或者部分浏览器执行顺序有所不同</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Micro-Task-与-Macro-Task\"><a href=\"#Micro-Task-与-Macro-Task\" class=\"headerlink\" title=\"Micro-Task 与 Macro-Task\"></a>Micro-Task 与 Macro-Task</h3><ul>\n<li>事件循环中的异步队列有两种：macro（宏任务）队列和<br>micro（微任务）队列。</li>\n</ul>\n<h4 id=\"macro-task\"><a href=\"#macro-task\" class=\"headerlink\" title=\"macro-task\"></a>macro-task</h4><ul>\n<li>setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等</li>\n</ul>\n<h4 id=\"micro-task\"><a href=\"#micro-task\" class=\"headerlink\" title=\"micro-task\"></a>micro-task</h4><ul>\n<li>process.nextTick、Promise、MutationObserver 等。</li>\n</ul>\n<h3 id=\"Event-Loop-过程\"><a href=\"#Event-Loop-过程\" class=\"headerlink\" title=\"Event Loop 过程\"></a>Event Loop 过程</h3><ol>\n<li>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</li>\n<li>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</li>\n<li>macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的，因此，一个 macro-task执行完成后，会清空 micro-task对列。</li>\n<li>执行渲染操作，更新界面</li>\n<li>检查是否存在 Web worker 任务，如果有，则对其进行处理 。</li>\n</ol>\n<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">    console.log(&#39;async1 start&#39;)</span><br><span class=\"line\">    await async2()</span><br><span class=\"line\">    console.log(&#39;async1 end&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">async function async2() &#123;</span><br><span class=\"line\">    console.log(&#39;async2&#39;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#39;script start&#39;)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">    console.log(&#39;setTimeout&#39;)</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">async1();</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(function (resolve) &#123;</span><br><span class=\"line\">    console.log(&#39;promise1&#39;)</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function () &#123;</span><br><span class=\"line\">    console.log(&#39;promise2&#39;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&#39;script end&#39;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>执行script标签内容（script start）-&gt; setTimeout 进入 Macro-Task 对列 -&gt; 执行 async1（async1 start）-&gt; 执行 async2 (async2) -&gt;由于 await async2 进入等待 -&gt; 执行 Promise （promise1）-&gt; promise.then() 进入 Micro-Task 对列 -&gt; script 执行结束（script end）-&gt;清空 Micro-Task 对列-&gt; await 执行（async1 end）-&gt;（promise2）-&gt;执行新的 Macro-Task 任务（setTimeout）</li>\n<li>注意：node环境以及babel转换或者部分浏览器执行顺序有所不同</li>\n</ul>\n"},{"title":"<js>decimal处理数字问题","date":"2019-01-30T16:00:00.000Z","_content":"\n### 简介\n\n- 数字货币交易所项目，需要处理大量小数、大数展示问题，使用decimal库处理js中的数字运算，包括大数展示为字符串、小数向上取整、小数向下取整、小数四舍五入、小数补零、加减乘除、取余运算。也可改为vue filter使用。\n\n### 安装依赖\n\n```\nnpm install --save decimal.js-light\n```\n\n### 基本配置\n\n```\nDecimal.set({\n    precision: 1e+9,//（计算结果）小数精度位数\n    rounding: Decimal.ROUND_HALF_UP,//小数舍去配置\n    minE: -9e15,//负指数极限（比较转换成指数后指数部分值<这个值转换为0）\n    maxE: 9e15,//正指数极限（比较转换成指数后指数部分值>这个值转换为Infinity）\n    toExpNeg: -9e15,//toString()负指数表示配置（比较转换成指数后指数部分值<=这个值用指数表示）\n    toExpPos: 9e15,//toString()正指数表示配置（比较转换成指数后指数部分值>=这个值用指数表示）\n});\n```\n\n### 代码\n\n```\nimport Decimal from 'decimal.js-light'\n\nDecimal.set({\n    precision: 20,\n    rounding: Decimal.ROUND_HALF_UP,//默认使用四舍五入\n    toExpNeg: -9e15,\n    toExpPos: 9e15,\n});\n\nexport default {\n    //数字转换为字符串显示\n    format(num){\n        num = num ? num : 0\n        return new Decimal(num).toString()\n    },\n    //保留小数向上取整\n    formatUp(num,len){\n        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_UP).toString()\n    },\n    //保留小数向下取整\n    formatDown(num,len){\n        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_DOWN).toString()\n    },\n    //保留小数四舍五入\n    formatHalf(num,len){\n        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_HALF_UP).toString()\n    },\n    //小数舍去0\n    remove0(num){\n        num = num ? num : 0\n        return new Decimal(num).toString()\n    },\n    //小数补零\n    add0(num,len){\n        return new Decimal(num).toFixed(len,Decimal.ROUND_DOWN).toString()\n    },\n    //加\n    add(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.plus(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //减\n    minus(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.minus(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //乘\n    mult(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.times(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //除\n    div(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.dividedBy(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //取余\n    mod(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.modulo(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    }\n}\n```\n","source":"_posts/[js]decimal处理数字问题.md","raw":"---\ntitle: <js>decimal处理数字问题\ndate: 2019-01-31 00:00:00\ntags: [大数,js,小数]\ncategories: decimal\n---\n\n### 简介\n\n- 数字货币交易所项目，需要处理大量小数、大数展示问题，使用decimal库处理js中的数字运算，包括大数展示为字符串、小数向上取整、小数向下取整、小数四舍五入、小数补零、加减乘除、取余运算。也可改为vue filter使用。\n\n### 安装依赖\n\n```\nnpm install --save decimal.js-light\n```\n\n### 基本配置\n\n```\nDecimal.set({\n    precision: 1e+9,//（计算结果）小数精度位数\n    rounding: Decimal.ROUND_HALF_UP,//小数舍去配置\n    minE: -9e15,//负指数极限（比较转换成指数后指数部分值<这个值转换为0）\n    maxE: 9e15,//正指数极限（比较转换成指数后指数部分值>这个值转换为Infinity）\n    toExpNeg: -9e15,//toString()负指数表示配置（比较转换成指数后指数部分值<=这个值用指数表示）\n    toExpPos: 9e15,//toString()正指数表示配置（比较转换成指数后指数部分值>=这个值用指数表示）\n});\n```\n\n### 代码\n\n```\nimport Decimal from 'decimal.js-light'\n\nDecimal.set({\n    precision: 20,\n    rounding: Decimal.ROUND_HALF_UP,//默认使用四舍五入\n    toExpNeg: -9e15,\n    toExpPos: 9e15,\n});\n\nexport default {\n    //数字转换为字符串显示\n    format(num){\n        num = num ? num : 0\n        return new Decimal(num).toString()\n    },\n    //保留小数向上取整\n    formatUp(num,len){\n        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_UP).toString()\n    },\n    //保留小数向下取整\n    formatDown(num,len){\n        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_DOWN).toString()\n    },\n    //保留小数四舍五入\n    formatHalf(num,len){\n        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_HALF_UP).toString()\n    },\n    //小数舍去0\n    remove0(num){\n        num = num ? num : 0\n        return new Decimal(num).toString()\n    },\n    //小数补零\n    add0(num,len){\n        return new Decimal(num).toFixed(len,Decimal.ROUND_DOWN).toString()\n    },\n    //加\n    add(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.plus(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //减\n    minus(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.minus(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //乘\n    mult(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.times(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //除\n    div(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.dividedBy(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //取余\n    mod(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.modulo(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    }\n}\n```\n","slug":"[js]decimal处理数字问题","published":1,"updated":"2021-03-15T14:39:21.377Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dkf001nwotjdow06e9y","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>数字货币交易所项目，需要处理大量小数、大数展示问题，使用decimal库处理js中的数字运算，包括大数展示为字符串、小数向上取整、小数向下取整、小数四舍五入、小数补零、加减乘除、取余运算。也可改为vue filter使用。</li>\n</ul>\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save decimal.js-light</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Decimal.set(&#123;</span><br><span class=\"line\">    precision: 1e+9,&#x2F;&#x2F;（计算结果）小数精度位数</span><br><span class=\"line\">    rounding: Decimal.ROUND_HALF_UP,&#x2F;&#x2F;小数舍去配置</span><br><span class=\"line\">    minE: -9e15,&#x2F;&#x2F;负指数极限（比较转换成指数后指数部分值&lt;这个值转换为0）</span><br><span class=\"line\">    maxE: 9e15,&#x2F;&#x2F;正指数极限（比较转换成指数后指数部分值&gt;这个值转换为Infinity）</span><br><span class=\"line\">    toExpNeg: -9e15,&#x2F;&#x2F;toString()负指数表示配置（比较转换成指数后指数部分值&lt;&#x3D;这个值用指数表示）</span><br><span class=\"line\">    toExpPos: 9e15,&#x2F;&#x2F;toString()正指数表示配置（比较转换成指数后指数部分值&gt;&#x3D;这个值用指数表示）</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Decimal from &#39;decimal.js-light&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">Decimal.set(&#123;</span><br><span class=\"line\">    precision: 20,</span><br><span class=\"line\">    rounding: Decimal.ROUND_HALF_UP,&#x2F;&#x2F;默认使用四舍五入</span><br><span class=\"line\">    toExpNeg: -9e15,</span><br><span class=\"line\">    toExpPos: 9e15,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;数字转换为字符串显示</span><br><span class=\"line\">    format(num)&#123;</span><br><span class=\"line\">        num &#x3D; num ? num : 0</span><br><span class=\"line\">        return new Decimal(num).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;保留小数向上取整</span><br><span class=\"line\">    formatUp(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_UP).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;保留小数向下取整</span><br><span class=\"line\">    formatDown(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_DOWN).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;保留小数四舍五入</span><br><span class=\"line\">    formatHalf(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_HALF_UP).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;小数舍去0</span><br><span class=\"line\">    remove0(num)&#123;</span><br><span class=\"line\">        num &#x3D; num ? num : 0</span><br><span class=\"line\">        return new Decimal(num).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;小数补零</span><br><span class=\"line\">    add0(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toFixed(len,Decimal.ROUND_DOWN).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;加</span><br><span class=\"line\">    add(num1, num2, len) &#123;</span><br><span class=\"line\">        let a &#x3D; new Decimal(num1)</span><br><span class=\"line\">        let b &#x3D; new Decimal(num2)</span><br><span class=\"line\">        let c &#x3D; a.plus(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;减</span><br><span class=\"line\">    minus(num1, num2, len) &#123;</span><br><span class=\"line\">        let a &#x3D; new Decimal(num1)</span><br><span class=\"line\">        let b &#x3D; new Decimal(num2)</span><br><span class=\"line\">        let c &#x3D; a.minus(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;乘</span><br><span class=\"line\">    mult(num1, num2, len) &#123;</span><br><span class=\"line\">        let a &#x3D; new Decimal(num1)</span><br><span class=\"line\">        let b &#x3D; new Decimal(num2)</span><br><span class=\"line\">        let c &#x3D; a.times(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;除</span><br><span class=\"line\">    div(num1, num2, len) &#123;</span><br><span class=\"line\">        let a &#x3D; new Decimal(num1)</span><br><span class=\"line\">        let b &#x3D; new Decimal(num2)</span><br><span class=\"line\">        let c &#x3D; a.dividedBy(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;取余</span><br><span class=\"line\">    mod(num1, num2, len) &#123;</span><br><span class=\"line\">        let a &#x3D; new Decimal(num1)</span><br><span class=\"line\">        let b &#x3D; new Decimal(num2)</span><br><span class=\"line\">        let c &#x3D; a.modulo(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>数字货币交易所项目，需要处理大量小数、大数展示问题，使用decimal库处理js中的数字运算，包括大数展示为字符串、小数向上取整、小数向下取整、小数四舍五入、小数补零、加减乘除、取余运算。也可改为vue filter使用。</li>\n</ul>\n<h3 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save decimal.js-light</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Decimal.set(&#123;</span><br><span class=\"line\">    precision: 1e+9,&#x2F;&#x2F;（计算结果）小数精度位数</span><br><span class=\"line\">    rounding: Decimal.ROUND_HALF_UP,&#x2F;&#x2F;小数舍去配置</span><br><span class=\"line\">    minE: -9e15,&#x2F;&#x2F;负指数极限（比较转换成指数后指数部分值&lt;这个值转换为0）</span><br><span class=\"line\">    maxE: 9e15,&#x2F;&#x2F;正指数极限（比较转换成指数后指数部分值&gt;这个值转换为Infinity）</span><br><span class=\"line\">    toExpNeg: -9e15,&#x2F;&#x2F;toString()负指数表示配置（比较转换成指数后指数部分值&lt;&#x3D;这个值用指数表示）</span><br><span class=\"line\">    toExpPos: 9e15,&#x2F;&#x2F;toString()正指数表示配置（比较转换成指数后指数部分值&gt;&#x3D;这个值用指数表示）</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Decimal from &#39;decimal.js-light&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">Decimal.set(&#123;</span><br><span class=\"line\">    precision: 20,</span><br><span class=\"line\">    rounding: Decimal.ROUND_HALF_UP,&#x2F;&#x2F;默认使用四舍五入</span><br><span class=\"line\">    toExpNeg: -9e15,</span><br><span class=\"line\">    toExpPos: 9e15,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;数字转换为字符串显示</span><br><span class=\"line\">    format(num)&#123;</span><br><span class=\"line\">        num &#x3D; num ? num : 0</span><br><span class=\"line\">        return new Decimal(num).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;保留小数向上取整</span><br><span class=\"line\">    formatUp(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_UP).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;保留小数向下取整</span><br><span class=\"line\">    formatDown(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_DOWN).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;保留小数四舍五入</span><br><span class=\"line\">    formatHalf(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_HALF_UP).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;小数舍去0</span><br><span class=\"line\">    remove0(num)&#123;</span><br><span class=\"line\">        num &#x3D; num ? num : 0</span><br><span class=\"line\">        return new Decimal(num).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;小数补零</span><br><span class=\"line\">    add0(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toFixed(len,Decimal.ROUND_DOWN).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;加</span><br><span class=\"line\">    add(num1, num2, len) &#123;</span><br><span class=\"line\">        let a &#x3D; new Decimal(num1)</span><br><span class=\"line\">        let b &#x3D; new Decimal(num2)</span><br><span class=\"line\">        let c &#x3D; a.plus(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;减</span><br><span class=\"line\">    minus(num1, num2, len) &#123;</span><br><span class=\"line\">        let a &#x3D; new Decimal(num1)</span><br><span class=\"line\">        let b &#x3D; new Decimal(num2)</span><br><span class=\"line\">        let c &#x3D; a.minus(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;乘</span><br><span class=\"line\">    mult(num1, num2, len) &#123;</span><br><span class=\"line\">        let a &#x3D; new Decimal(num1)</span><br><span class=\"line\">        let b &#x3D; new Decimal(num2)</span><br><span class=\"line\">        let c &#x3D; a.times(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;除</span><br><span class=\"line\">    div(num1, num2, len) &#123;</span><br><span class=\"line\">        let a &#x3D; new Decimal(num1)</span><br><span class=\"line\">        let b &#x3D; new Decimal(num2)</span><br><span class=\"line\">        let c &#x3D; a.dividedBy(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;取余</span><br><span class=\"line\">    mod(num1, num2, len) &#123;</span><br><span class=\"line\">        let a &#x3D; new Decimal(num1)</span><br><span class=\"line\">        let b &#x3D; new Decimal(num2)</span><br><span class=\"line\">        let c &#x3D; a.modulo(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"<js>file相关","date":"2019-01-30T16:00:00.000Z","_content":"\n### Blob对象\n\n- Blob对象表示一个不可变、原始数据的类文件对象。\n\n#### 属性：\n\n- Blob.size\n- Blob.type\n\n#### 方法：\n\n- Blob.slice([start,[ end ,[contentType]]])，返回一个新的 Blob对象，包含指定范围数据。\n\n### Blob()构造函数\n\n- 返回一个新的 Blob 对象。\n- var aBlob = new Blob( array, options );\n\n#### 参数：\n\n- array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。\n- options：type，默认值为 \"\"，它代表了将会被放入到blob中的数组内容的MIME类型。endings，默认值为\"transparent\"，用于指定包含行结束符\\n的字符串如何被写入。\n\n#### js创建并下载excel\n\n- 步骤\n\n1. 创建Blob对象\n2. 转换为dataURL或者ObjectURL\n3. 使用a标签download下载\n\n- 示例代码\n\n```\n<div id=\"myTable\">\n    <style media=\"screen\">\n        table {\n            border-collapse: collapse;\n        }\n        table th{\n            height: 50px;\n            font-size: 24px;\n            font-family: '微软雅黑';\n            font-weight: 700;\n        }\n        table th {\n            border: 1px #000 solid;\n            height: 40px;\n            background: #efefef;\n        }\n        table td {\n            padding: 0 40px;\n            border: 1px #000 solid;\n            height: 40px;\n            text-align: center;\n        }\n        table td {\n            font-size: 20px;\n            font-weight: 700;\n        }\n    </style>\n    <table>\n        <tr>\n            <th colspan=\"2\">主要信息</th>\n            <th colspan=\"2\">其它信息</th>\n        </tr>\n        <tr>\n            <th>姓名</th>\n            <th>性别</th>\n            <th>年龄</th>\n            <th>注册时间</th>\n        </tr>\n        <tr>\n            <td>张三</td>\n            <td>男</td>\n            <td>18</td>\n            <td>123</td>\n        </tr>\n        <tr>\n            <td>张三</td>\n            <td>男</td>\n            <td>18</td>\n            <td>123</td>\n        </tr>\n    </table>\n</div>\n<script>\n    let table = document.getElementById('myTable').outerHTML\n    var oMyBlob = new Blob([table], {type : 'application/vnd.ms-excel'});\n\n    //方法1：使用FileReader dataURL\n    let reader = new FileReader()\n    reader.onload = function () {\n        let a = document.createElement('a')\n        a.href = reader.result\n        a.download = 'a.xls'\n        a.click()\n    }\n    reader.readAsDataURL(oMyBlob)\n\n    //方法2：使用window.URL.createObjectURL\n    let objURL = window.URL.createObjectURL(oMyBlob)\n    let a = document.createElement('a')\n    a.href = objURL\n    a.download = 'a.xls'\n    a.click()\n\n</script>\n```\n\n### File对象\n\n- File 对象是特殊类型的 Blob。\n\n#### 获取方式\n\n- <input> 元素上选择文件后返回的 FileList 对象\n\n```\nlet fileInput = document.getElementById('myFile')\nfileInput.addEventListener('change',()=>{\n    console.log(fileInput.files)\n})\n```\n\n- 由拖放操作生成的 DataTransfer 对象\n\n```\n//可以是个div\nvar dropbox;\ndropbox = document.getElementById(\"dropbox\");\ndropbox.addEventListener(\"dragenter\", (e)=>{\n    e.stopPropagation();\n    e.preventDefault();\n});\ndropbox.addEventListener(\"dragover\", (e)=>{\n    e.stopPropagation();\n    e.preventDefault();\n});\ndropbox.addEventListener(\"drop\", (e)=>{\n    e.stopPropagation();\n    e.preventDefault();\n\n    var dt = e.dataTransfer;\n    var files = dt.files;\n    console.log(files)\n    console.log(files)\n});\n```\n\n- 来自 HTMLCanvasElement 上的 mozGetAsFile() API\n\n#### 属性\n\n- File.lastModified：文件最后修改时间\n- File.lastModifiedDate：文件最后修改时间的 Date 对象\n- File.name：名称\n- File.size：大小\n- File.type：类型\n- File.webkitRelativePath：路径（非标准的）\n\n```\n//input需要设置 webkitdirectory 属性（只允许选择文件夹）\n<input id=\"myFile\" webkitdirectory type=\"file\">\n```\n\n### File()构造器\n\n#### 语法\n\n- var myFile = new File(bits, name[, options]);\n\n#### 参数\n\n- bits：ArrayBuffer，ArrayBufferView，Blob，或者 DOMString 对象的 Array — 或者任何这些对象的组合。这是 UTF-8 编码的文件内容。\n- name：USVString，表示文件名称，或者文件路径。\n- options：type: DOMString，表示将要放到文件中的内容的 MIME 类型。默认值为 \"\" 。lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。\n- https://developer.mozilla.org/zh-CN/docs/Web/API/File/File\n\n```\nvar file = new File([\"foo\"], \"foo.txt\", {\n  type: \"text/plain\",\n});\n\n```\n\n### FileReader对象\n\n- https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\n- 允许Web应用程序异步读取存储在用户计算机上的文件\n- FileReader()返回一个新构造的FileReader\n#### 属性：\n- FileReader.error：读取文件发生错误\n- FileReader.readyState：状态数字 EMPTY（0）、LOADING（1）、DONE（2）\n- FileReader.result：文件的内容。该属性仅在读取操作完成后才有效。\n\n#### 事件：\n\n- 继承自EventTarget，所以所有这些事件也可以通过addEventListener方法使用。\n- FileReader.onabort：中断时触发\n- FileReader.onerror：错误时触发\n- FileReader.onload：读取操作完成时触发\n- FileReader.onloadstart：\n- FileReader.onloadend：\n- FileReader.onprogress：处理progress事件。该事件在读取Blob时触发。\n\n#### 方法：\n\n- FileReader.abort()：终止操作\n- FileReader.readAsArrayBuffer()\n- FileReader.readAsBinaryString()非标准的\n- FileReader.readAsDataURL()\n- FileReader.readAsText()\n\n#### 例子\n\n- input图片展示\n\n```\n<input type=\"file\" id=\"inputFile\">\n<script>\n    let inputFile = document.getElementById('inputFile')\n    inputFile.addEventListener('change', () => {\n        let file = inputFile.files[0]\n        let reader = new FileReader()\n        reader.onload = function () {\n            let img = document.createElement('img')\n            img.src = reader.result\n            document.documentElement.appendChild(img)\n        }\n        reader.readAsDataURL(file)\n    })\n</script>\n```\n\n### ObjectURL\n\n- https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\n- https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\n- objectURL = URL.createObjectURL(object);表示指定的File对象或Blob对象的url\n- window.URL.revokeObjectURL(objectURL);释放一个现有的对象URL\n\n```\n//选择图片并转换为对象URL显示\n<input type=\"file\" id=\"file1\">\n<script>\n    let inputFile = document.getElementById('file1')\n    inputFile.addEventListener('change',()=>{\n        let file = inputFile.files[0]\n        let url = window.URL.createObjectURL(file)\n\n        let img = document.createElement('img')\n        img.src = url\n        document.documentElement.appendChild(img)\n\n        img.onload = function() {\n            window.URL.revokeObjectURL(url)\n        }\n    })\n</script>\n```\n```\n//展示pdf\n<input type=\"file\" id=\"file2\">\n<iframe src=\"\" frameborder=\"0\" id=\"view\"></iframe>\n<script>\n    let pdfInput = document.getElementById('file2')\n    pdfInput.addEventListener('change',()=>{\n        let file = pdfInput.files[0]\n        let url = window.URL.createObjectURL(file)\n        var iframe = document.getElementById('view');\n        iframe.setAttribute('src', url);\n    })\n</script>\n```\n","source":"_posts/[js]file相关.md","raw":"---\ntitle: <js>file相关\ndate: 2019-01-31 00:00:00\ntags: [js,文件,file]\ncategories: file\n---\n\n### Blob对象\n\n- Blob对象表示一个不可变、原始数据的类文件对象。\n\n#### 属性：\n\n- Blob.size\n- Blob.type\n\n#### 方法：\n\n- Blob.slice([start,[ end ,[contentType]]])，返回一个新的 Blob对象，包含指定范围数据。\n\n### Blob()构造函数\n\n- 返回一个新的 Blob 对象。\n- var aBlob = new Blob( array, options );\n\n#### 参数：\n\n- array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。\n- options：type，默认值为 \"\"，它代表了将会被放入到blob中的数组内容的MIME类型。endings，默认值为\"transparent\"，用于指定包含行结束符\\n的字符串如何被写入。\n\n#### js创建并下载excel\n\n- 步骤\n\n1. 创建Blob对象\n2. 转换为dataURL或者ObjectURL\n3. 使用a标签download下载\n\n- 示例代码\n\n```\n<div id=\"myTable\">\n    <style media=\"screen\">\n        table {\n            border-collapse: collapse;\n        }\n        table th{\n            height: 50px;\n            font-size: 24px;\n            font-family: '微软雅黑';\n            font-weight: 700;\n        }\n        table th {\n            border: 1px #000 solid;\n            height: 40px;\n            background: #efefef;\n        }\n        table td {\n            padding: 0 40px;\n            border: 1px #000 solid;\n            height: 40px;\n            text-align: center;\n        }\n        table td {\n            font-size: 20px;\n            font-weight: 700;\n        }\n    </style>\n    <table>\n        <tr>\n            <th colspan=\"2\">主要信息</th>\n            <th colspan=\"2\">其它信息</th>\n        </tr>\n        <tr>\n            <th>姓名</th>\n            <th>性别</th>\n            <th>年龄</th>\n            <th>注册时间</th>\n        </tr>\n        <tr>\n            <td>张三</td>\n            <td>男</td>\n            <td>18</td>\n            <td>123</td>\n        </tr>\n        <tr>\n            <td>张三</td>\n            <td>男</td>\n            <td>18</td>\n            <td>123</td>\n        </tr>\n    </table>\n</div>\n<script>\n    let table = document.getElementById('myTable').outerHTML\n    var oMyBlob = new Blob([table], {type : 'application/vnd.ms-excel'});\n\n    //方法1：使用FileReader dataURL\n    let reader = new FileReader()\n    reader.onload = function () {\n        let a = document.createElement('a')\n        a.href = reader.result\n        a.download = 'a.xls'\n        a.click()\n    }\n    reader.readAsDataURL(oMyBlob)\n\n    //方法2：使用window.URL.createObjectURL\n    let objURL = window.URL.createObjectURL(oMyBlob)\n    let a = document.createElement('a')\n    a.href = objURL\n    a.download = 'a.xls'\n    a.click()\n\n</script>\n```\n\n### File对象\n\n- File 对象是特殊类型的 Blob。\n\n#### 获取方式\n\n- <input> 元素上选择文件后返回的 FileList 对象\n\n```\nlet fileInput = document.getElementById('myFile')\nfileInput.addEventListener('change',()=>{\n    console.log(fileInput.files)\n})\n```\n\n- 由拖放操作生成的 DataTransfer 对象\n\n```\n//可以是个div\nvar dropbox;\ndropbox = document.getElementById(\"dropbox\");\ndropbox.addEventListener(\"dragenter\", (e)=>{\n    e.stopPropagation();\n    e.preventDefault();\n});\ndropbox.addEventListener(\"dragover\", (e)=>{\n    e.stopPropagation();\n    e.preventDefault();\n});\ndropbox.addEventListener(\"drop\", (e)=>{\n    e.stopPropagation();\n    e.preventDefault();\n\n    var dt = e.dataTransfer;\n    var files = dt.files;\n    console.log(files)\n    console.log(files)\n});\n```\n\n- 来自 HTMLCanvasElement 上的 mozGetAsFile() API\n\n#### 属性\n\n- File.lastModified：文件最后修改时间\n- File.lastModifiedDate：文件最后修改时间的 Date 对象\n- File.name：名称\n- File.size：大小\n- File.type：类型\n- File.webkitRelativePath：路径（非标准的）\n\n```\n//input需要设置 webkitdirectory 属性（只允许选择文件夹）\n<input id=\"myFile\" webkitdirectory type=\"file\">\n```\n\n### File()构造器\n\n#### 语法\n\n- var myFile = new File(bits, name[, options]);\n\n#### 参数\n\n- bits：ArrayBuffer，ArrayBufferView，Blob，或者 DOMString 对象的 Array — 或者任何这些对象的组合。这是 UTF-8 编码的文件内容。\n- name：USVString，表示文件名称，或者文件路径。\n- options：type: DOMString，表示将要放到文件中的内容的 MIME 类型。默认值为 \"\" 。lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。\n- https://developer.mozilla.org/zh-CN/docs/Web/API/File/File\n\n```\nvar file = new File([\"foo\"], \"foo.txt\", {\n  type: \"text/plain\",\n});\n\n```\n\n### FileReader对象\n\n- https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\n- 允许Web应用程序异步读取存储在用户计算机上的文件\n- FileReader()返回一个新构造的FileReader\n#### 属性：\n- FileReader.error：读取文件发生错误\n- FileReader.readyState：状态数字 EMPTY（0）、LOADING（1）、DONE（2）\n- FileReader.result：文件的内容。该属性仅在读取操作完成后才有效。\n\n#### 事件：\n\n- 继承自EventTarget，所以所有这些事件也可以通过addEventListener方法使用。\n- FileReader.onabort：中断时触发\n- FileReader.onerror：错误时触发\n- FileReader.onload：读取操作完成时触发\n- FileReader.onloadstart：\n- FileReader.onloadend：\n- FileReader.onprogress：处理progress事件。该事件在读取Blob时触发。\n\n#### 方法：\n\n- FileReader.abort()：终止操作\n- FileReader.readAsArrayBuffer()\n- FileReader.readAsBinaryString()非标准的\n- FileReader.readAsDataURL()\n- FileReader.readAsText()\n\n#### 例子\n\n- input图片展示\n\n```\n<input type=\"file\" id=\"inputFile\">\n<script>\n    let inputFile = document.getElementById('inputFile')\n    inputFile.addEventListener('change', () => {\n        let file = inputFile.files[0]\n        let reader = new FileReader()\n        reader.onload = function () {\n            let img = document.createElement('img')\n            img.src = reader.result\n            document.documentElement.appendChild(img)\n        }\n        reader.readAsDataURL(file)\n    })\n</script>\n```\n\n### ObjectURL\n\n- https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\n- https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\n- objectURL = URL.createObjectURL(object);表示指定的File对象或Blob对象的url\n- window.URL.revokeObjectURL(objectURL);释放一个现有的对象URL\n\n```\n//选择图片并转换为对象URL显示\n<input type=\"file\" id=\"file1\">\n<script>\n    let inputFile = document.getElementById('file1')\n    inputFile.addEventListener('change',()=>{\n        let file = inputFile.files[0]\n        let url = window.URL.createObjectURL(file)\n\n        let img = document.createElement('img')\n        img.src = url\n        document.documentElement.appendChild(img)\n\n        img.onload = function() {\n            window.URL.revokeObjectURL(url)\n        }\n    })\n</script>\n```\n```\n//展示pdf\n<input type=\"file\" id=\"file2\">\n<iframe src=\"\" frameborder=\"0\" id=\"view\"></iframe>\n<script>\n    let pdfInput = document.getElementById('file2')\n    pdfInput.addEventListener('change',()=>{\n        let file = pdfInput.files[0]\n        let url = window.URL.createObjectURL(file)\n        var iframe = document.getElementById('view');\n        iframe.setAttribute('src', url);\n    })\n</script>\n```\n","slug":"[js]file相关","published":1,"updated":"2021-03-15T14:39:35.080Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dkg001qwotj9tkxa4aa","content":"<h3 id=\"Blob对象\"><a href=\"#Blob对象\" class=\"headerlink\" title=\"Blob对象\"></a>Blob对象</h3><ul>\n<li>Blob对象表示一个不可变、原始数据的类文件对象。</li>\n</ul>\n<h4 id=\"属性：\"><a href=\"#属性：\" class=\"headerlink\" title=\"属性：\"></a>属性：</h4><ul>\n<li>Blob.size</li>\n<li>Blob.type</li>\n</ul>\n<h4 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li>Blob.slice([start,[ end ,[contentType]]])，返回一个新的 Blob对象，包含指定范围数据。</li>\n</ul>\n<h3 id=\"Blob-构造函数\"><a href=\"#Blob-构造函数\" class=\"headerlink\" title=\"Blob()构造函数\"></a>Blob()构造函数</h3><ul>\n<li>返回一个新的 Blob 对象。</li>\n<li>var aBlob = new Blob( array, options );</li>\n</ul>\n<h4 id=\"参数：\"><a href=\"#参数：\" class=\"headerlink\" title=\"参数：\"></a>参数：</h4><ul>\n<li>array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。</li>\n<li>options：type，默认值为 “”，它代表了将会被放入到blob中的数组内容的MIME类型。endings，默认值为”transparent”，用于指定包含行结束符\\n的字符串如何被写入。</li>\n</ul>\n<h4 id=\"js创建并下载excel\"><a href=\"#js创建并下载excel\" class=\"headerlink\" title=\"js创建并下载excel\"></a>js创建并下载excel</h4><ul>\n<li>步骤</li>\n</ul>\n<ol>\n<li>创建Blob对象</li>\n<li>转换为dataURL或者ObjectURL</li>\n<li>使用a标签download下载</li>\n</ol>\n<ul>\n<li>示例代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;myTable&quot;&gt;</span><br><span class=\"line\">    &lt;style media&#x3D;&quot;screen&quot;&gt;</span><br><span class=\"line\">        table &#123;</span><br><span class=\"line\">            border-collapse: collapse;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table th&#123;</span><br><span class=\"line\">            height: 50px;</span><br><span class=\"line\">            font-size: 24px;</span><br><span class=\"line\">            font-family: &#39;微软雅黑&#39;;</span><br><span class=\"line\">            font-weight: 700;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table th &#123;</span><br><span class=\"line\">            border: 1px #000 solid;</span><br><span class=\"line\">            height: 40px;</span><br><span class=\"line\">            background: #efefef;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table td &#123;</span><br><span class=\"line\">            padding: 0 40px;</span><br><span class=\"line\">            border: 1px #000 solid;</span><br><span class=\"line\">            height: 40px;</span><br><span class=\"line\">            text-align: center;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table td &#123;</span><br><span class=\"line\">            font-size: 20px;</span><br><span class=\"line\">            font-weight: 700;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;&#x2F;style&gt;</span><br><span class=\"line\">    &lt;table&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;th colspan&#x3D;&quot;2&quot;&gt;主要信息&lt;&#x2F;th&gt;</span><br><span class=\"line\">            &lt;th colspan&#x3D;&quot;2&quot;&gt;其它信息&lt;&#x2F;th&gt;</span><br><span class=\"line\">        &lt;&#x2F;tr&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;th&gt;姓名&lt;&#x2F;th&gt;</span><br><span class=\"line\">            &lt;th&gt;性别&lt;&#x2F;th&gt;</span><br><span class=\"line\">            &lt;th&gt;年龄&lt;&#x2F;th&gt;</span><br><span class=\"line\">            &lt;th&gt;注册时间&lt;&#x2F;th&gt;</span><br><span class=\"line\">        &lt;&#x2F;tr&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;td&gt;张三&lt;&#x2F;td&gt;</span><br><span class=\"line\">            &lt;td&gt;男&lt;&#x2F;td&gt;</span><br><span class=\"line\">            &lt;td&gt;18&lt;&#x2F;td&gt;</span><br><span class=\"line\">            &lt;td&gt;123&lt;&#x2F;td&gt;</span><br><span class=\"line\">        &lt;&#x2F;tr&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;td&gt;张三&lt;&#x2F;td&gt;</span><br><span class=\"line\">            &lt;td&gt;男&lt;&#x2F;td&gt;</span><br><span class=\"line\">            &lt;td&gt;18&lt;&#x2F;td&gt;</span><br><span class=\"line\">            &lt;td&gt;123&lt;&#x2F;td&gt;</span><br><span class=\"line\">        &lt;&#x2F;tr&gt;</span><br><span class=\"line\">    &lt;&#x2F;table&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let table &#x3D; document.getElementById(&#39;myTable&#39;).outerHTML</span><br><span class=\"line\">    var oMyBlob &#x3D; new Blob([table], &#123;type : &#39;application&#x2F;vnd.ms-excel&#39;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;方法1：使用FileReader dataURL</span><br><span class=\"line\">    let reader &#x3D; new FileReader()</span><br><span class=\"line\">    reader.onload &#x3D; function () &#123;</span><br><span class=\"line\">        let a &#x3D; document.createElement(&#39;a&#39;)</span><br><span class=\"line\">        a.href &#x3D; reader.result</span><br><span class=\"line\">        a.download &#x3D; &#39;a.xls&#39;</span><br><span class=\"line\">        a.click()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reader.readAsDataURL(oMyBlob)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;方法2：使用window.URL.createObjectURL</span><br><span class=\"line\">    let objURL &#x3D; window.URL.createObjectURL(oMyBlob)</span><br><span class=\"line\">    let a &#x3D; document.createElement(&#39;a&#39;)</span><br><span class=\"line\">    a.href &#x3D; objURL</span><br><span class=\"line\">    a.download &#x3D; &#39;a.xls&#39;</span><br><span class=\"line\">    a.click()</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"File对象\"><a href=\"#File对象\" class=\"headerlink\" title=\"File对象\"></a>File对象</h3><ul>\n<li>File 对象是特殊类型的 Blob。</li>\n</ul>\n<h4 id=\"获取方式\"><a href=\"#获取方式\" class=\"headerlink\" title=\"获取方式\"></a>获取方式</h4><ul>\n<li><input> 元素上选择文件后返回的 FileList 对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fileInput &#x3D; document.getElementById(&#39;myFile&#39;)</span><br><span class=\"line\">fileInput.addEventListener(&#39;change&#39;,()&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(fileInput.files)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>由拖放操作生成的 DataTransfer 对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;可以是个div</span><br><span class=\"line\">var dropbox;</span><br><span class=\"line\">dropbox &#x3D; document.getElementById(&quot;dropbox&quot;);</span><br><span class=\"line\">dropbox.addEventListener(&quot;dragenter&quot;, (e)&#x3D;&gt;&#123;</span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dropbox.addEventListener(&quot;dragover&quot;, (e)&#x3D;&gt;&#123;</span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dropbox.addEventListener(&quot;drop&quot;, (e)&#x3D;&gt;&#123;</span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\"></span><br><span class=\"line\">    var dt &#x3D; e.dataTransfer;</span><br><span class=\"line\">    var files &#x3D; dt.files;</span><br><span class=\"line\">    console.log(files)</span><br><span class=\"line\">    console.log(files)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>来自 HTMLCanvasElement 上的 mozGetAsFile() API</li>\n</ul>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li>File.lastModified：文件最后修改时间</li>\n<li>File.lastModifiedDate：文件最后修改时间的 Date 对象</li>\n<li>File.name：名称</li>\n<li>File.size：大小</li>\n<li>File.type：类型</li>\n<li>File.webkitRelativePath：路径（非标准的）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;input需要设置 webkitdirectory 属性（只允许选择文件夹）</span><br><span class=\"line\">&lt;input id&#x3D;&quot;myFile&quot; webkitdirectory type&#x3D;&quot;file&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"File-构造器\"><a href=\"#File-构造器\" class=\"headerlink\" title=\"File()构造器\"></a>File()构造器</h3><h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><ul>\n<li>var myFile = new File(bits, name[, options]);</li>\n</ul>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><ul>\n<li>bits：ArrayBuffer，ArrayBufferView，Blob，或者 DOMString 对象的 Array — 或者任何这些对象的组合。这是 UTF-8 编码的文件内容。</li>\n<li>name：USVString，表示文件名称，或者文件路径。</li>\n<li>options：type: DOMString，表示将要放到文件中的内容的 MIME 类型。默认值为 “” 。lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/File/File\">https://developer.mozilla.org/zh-CN/docs/Web/API/File/File</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var file &#x3D; new File([&quot;foo&quot;], &quot;foo.txt&quot;, &#123;</span><br><span class=\"line\">  type: &quot;text&#x2F;plain&quot;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"FileReader对象\"><a href=\"#FileReader对象\" class=\"headerlink\" title=\"FileReader对象\"></a>FileReader对象</h3><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\">https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader</a></li>\n<li>允许Web应用程序异步读取存储在用户计算机上的文件</li>\n<li>FileReader()返回一个新构造的FileReader<h4 id=\"属性：-1\"><a href=\"#属性：-1\" class=\"headerlink\" title=\"属性：\"></a>属性：</h4></li>\n<li>FileReader.error：读取文件发生错误</li>\n<li>FileReader.readyState：状态数字 EMPTY（0）、LOADING（1）、DONE（2）</li>\n<li>FileReader.result：文件的内容。该属性仅在读取操作完成后才有效。</li>\n</ul>\n<h4 id=\"事件：\"><a href=\"#事件：\" class=\"headerlink\" title=\"事件：\"></a>事件：</h4><ul>\n<li>继承自EventTarget，所以所有这些事件也可以通过addEventListener方法使用。</li>\n<li>FileReader.onabort：中断时触发</li>\n<li>FileReader.onerror：错误时触发</li>\n<li>FileReader.onload：读取操作完成时触发</li>\n<li>FileReader.onloadstart：</li>\n<li>FileReader.onloadend：</li>\n<li>FileReader.onprogress：处理progress事件。该事件在读取Blob时触发。</li>\n</ul>\n<h4 id=\"方法：-1\"><a href=\"#方法：-1\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li>FileReader.abort()：终止操作</li>\n<li>FileReader.readAsArrayBuffer()</li>\n<li>FileReader.readAsBinaryString()非标准的</li>\n<li>FileReader.readAsDataURL()</li>\n<li>FileReader.readAsText()</li>\n</ul>\n<h4 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h4><ul>\n<li>input图片展示</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;inputFile&quot;&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let inputFile &#x3D; document.getElementById(&#39;inputFile&#39;)</span><br><span class=\"line\">    inputFile.addEventListener(&#39;change&#39;, () &#x3D;&gt; &#123;</span><br><span class=\"line\">        let file &#x3D; inputFile.files[0]</span><br><span class=\"line\">        let reader &#x3D; new FileReader()</span><br><span class=\"line\">        reader.onload &#x3D; function () &#123;</span><br><span class=\"line\">            let img &#x3D; document.createElement(&#39;img&#39;)</span><br><span class=\"line\">            img.src &#x3D; reader.result</span><br><span class=\"line\">            document.documentElement.appendChild(img)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reader.readAsDataURL(file)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ObjectURL\"><a href=\"#ObjectURL\" class=\"headerlink\" title=\"ObjectURL\"></a>ObjectURL</h3><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\">https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\">https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL</a></li>\n<li>objectURL = URL.createObjectURL(object);表示指定的File对象或Blob对象的url</li>\n<li>window.URL.revokeObjectURL(objectURL);释放一个现有的对象URL</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;选择图片并转换为对象URL显示</span><br><span class=\"line\">&lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;file1&quot;&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let inputFile &#x3D; document.getElementById(&#39;file1&#39;)</span><br><span class=\"line\">    inputFile.addEventListener(&#39;change&#39;,()&#x3D;&gt;&#123;</span><br><span class=\"line\">        let file &#x3D; inputFile.files[0]</span><br><span class=\"line\">        let url &#x3D; window.URL.createObjectURL(file)</span><br><span class=\"line\"></span><br><span class=\"line\">        let img &#x3D; document.createElement(&#39;img&#39;)</span><br><span class=\"line\">        img.src &#x3D; url</span><br><span class=\"line\">        document.documentElement.appendChild(img)</span><br><span class=\"line\"></span><br><span class=\"line\">        img.onload &#x3D; function() &#123;</span><br><span class=\"line\">            window.URL.revokeObjectURL(url)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;展示pdf</span><br><span class=\"line\">&lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;file2&quot;&gt;</span><br><span class=\"line\">&lt;iframe src&#x3D;&quot;&quot; frameborder&#x3D;&quot;0&quot; id&#x3D;&quot;view&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let pdfInput &#x3D; document.getElementById(&#39;file2&#39;)</span><br><span class=\"line\">    pdfInput.addEventListener(&#39;change&#39;,()&#x3D;&gt;&#123;</span><br><span class=\"line\">        let file &#x3D; pdfInput.files[0]</span><br><span class=\"line\">        let url &#x3D; window.URL.createObjectURL(file)</span><br><span class=\"line\">        var iframe &#x3D; document.getElementById(&#39;view&#39;);</span><br><span class=\"line\">        iframe.setAttribute(&#39;src&#39;, url);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Blob对象\"><a href=\"#Blob对象\" class=\"headerlink\" title=\"Blob对象\"></a>Blob对象</h3><ul>\n<li>Blob对象表示一个不可变、原始数据的类文件对象。</li>\n</ul>\n<h4 id=\"属性：\"><a href=\"#属性：\" class=\"headerlink\" title=\"属性：\"></a>属性：</h4><ul>\n<li>Blob.size</li>\n<li>Blob.type</li>\n</ul>\n<h4 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li>Blob.slice([start,[ end ,[contentType]]])，返回一个新的 Blob对象，包含指定范围数据。</li>\n</ul>\n<h3 id=\"Blob-构造函数\"><a href=\"#Blob-构造函数\" class=\"headerlink\" title=\"Blob()构造函数\"></a>Blob()构造函数</h3><ul>\n<li>返回一个新的 Blob 对象。</li>\n<li>var aBlob = new Blob( array, options );</li>\n</ul>\n<h4 id=\"参数：\"><a href=\"#参数：\" class=\"headerlink\" title=\"参数：\"></a>参数：</h4><ul>\n<li>array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。</li>\n<li>options：type，默认值为 “”，它代表了将会被放入到blob中的数组内容的MIME类型。endings，默认值为”transparent”，用于指定包含行结束符\\n的字符串如何被写入。</li>\n</ul>\n<h4 id=\"js创建并下载excel\"><a href=\"#js创建并下载excel\" class=\"headerlink\" title=\"js创建并下载excel\"></a>js创建并下载excel</h4><ul>\n<li>步骤</li>\n</ul>\n<ol>\n<li>创建Blob对象</li>\n<li>转换为dataURL或者ObjectURL</li>\n<li>使用a标签download下载</li>\n</ol>\n<ul>\n<li>示例代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id&#x3D;&quot;myTable&quot;&gt;</span><br><span class=\"line\">    &lt;style media&#x3D;&quot;screen&quot;&gt;</span><br><span class=\"line\">        table &#123;</span><br><span class=\"line\">            border-collapse: collapse;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table th&#123;</span><br><span class=\"line\">            height: 50px;</span><br><span class=\"line\">            font-size: 24px;</span><br><span class=\"line\">            font-family: &#39;微软雅黑&#39;;</span><br><span class=\"line\">            font-weight: 700;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table th &#123;</span><br><span class=\"line\">            border: 1px #000 solid;</span><br><span class=\"line\">            height: 40px;</span><br><span class=\"line\">            background: #efefef;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table td &#123;</span><br><span class=\"line\">            padding: 0 40px;</span><br><span class=\"line\">            border: 1px #000 solid;</span><br><span class=\"line\">            height: 40px;</span><br><span class=\"line\">            text-align: center;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table td &#123;</span><br><span class=\"line\">            font-size: 20px;</span><br><span class=\"line\">            font-weight: 700;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;&#x2F;style&gt;</span><br><span class=\"line\">    &lt;table&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;th colspan&#x3D;&quot;2&quot;&gt;主要信息&lt;&#x2F;th&gt;</span><br><span class=\"line\">            &lt;th colspan&#x3D;&quot;2&quot;&gt;其它信息&lt;&#x2F;th&gt;</span><br><span class=\"line\">        &lt;&#x2F;tr&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;th&gt;姓名&lt;&#x2F;th&gt;</span><br><span class=\"line\">            &lt;th&gt;性别&lt;&#x2F;th&gt;</span><br><span class=\"line\">            &lt;th&gt;年龄&lt;&#x2F;th&gt;</span><br><span class=\"line\">            &lt;th&gt;注册时间&lt;&#x2F;th&gt;</span><br><span class=\"line\">        &lt;&#x2F;tr&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;td&gt;张三&lt;&#x2F;td&gt;</span><br><span class=\"line\">            &lt;td&gt;男&lt;&#x2F;td&gt;</span><br><span class=\"line\">            &lt;td&gt;18&lt;&#x2F;td&gt;</span><br><span class=\"line\">            &lt;td&gt;123&lt;&#x2F;td&gt;</span><br><span class=\"line\">        &lt;&#x2F;tr&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;td&gt;张三&lt;&#x2F;td&gt;</span><br><span class=\"line\">            &lt;td&gt;男&lt;&#x2F;td&gt;</span><br><span class=\"line\">            &lt;td&gt;18&lt;&#x2F;td&gt;</span><br><span class=\"line\">            &lt;td&gt;123&lt;&#x2F;td&gt;</span><br><span class=\"line\">        &lt;&#x2F;tr&gt;</span><br><span class=\"line\">    &lt;&#x2F;table&gt;</span><br><span class=\"line\">&lt;&#x2F;div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let table &#x3D; document.getElementById(&#39;myTable&#39;).outerHTML</span><br><span class=\"line\">    var oMyBlob &#x3D; new Blob([table], &#123;type : &#39;application&#x2F;vnd.ms-excel&#39;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;方法1：使用FileReader dataURL</span><br><span class=\"line\">    let reader &#x3D; new FileReader()</span><br><span class=\"line\">    reader.onload &#x3D; function () &#123;</span><br><span class=\"line\">        let a &#x3D; document.createElement(&#39;a&#39;)</span><br><span class=\"line\">        a.href &#x3D; reader.result</span><br><span class=\"line\">        a.download &#x3D; &#39;a.xls&#39;</span><br><span class=\"line\">        a.click()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reader.readAsDataURL(oMyBlob)</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;方法2：使用window.URL.createObjectURL</span><br><span class=\"line\">    let objURL &#x3D; window.URL.createObjectURL(oMyBlob)</span><br><span class=\"line\">    let a &#x3D; document.createElement(&#39;a&#39;)</span><br><span class=\"line\">    a.href &#x3D; objURL</span><br><span class=\"line\">    a.download &#x3D; &#39;a.xls&#39;</span><br><span class=\"line\">    a.click()</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"File对象\"><a href=\"#File对象\" class=\"headerlink\" title=\"File对象\"></a>File对象</h3><ul>\n<li>File 对象是特殊类型的 Blob。</li>\n</ul>\n<h4 id=\"获取方式\"><a href=\"#获取方式\" class=\"headerlink\" title=\"获取方式\"></a>获取方式</h4><ul>\n<li><input> 元素上选择文件后返回的 FileList 对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fileInput &#x3D; document.getElementById(&#39;myFile&#39;)</span><br><span class=\"line\">fileInput.addEventListener(&#39;change&#39;,()&#x3D;&gt;&#123;</span><br><span class=\"line\">    console.log(fileInput.files)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>由拖放操作生成的 DataTransfer 对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;可以是个div</span><br><span class=\"line\">var dropbox;</span><br><span class=\"line\">dropbox &#x3D; document.getElementById(&quot;dropbox&quot;);</span><br><span class=\"line\">dropbox.addEventListener(&quot;dragenter&quot;, (e)&#x3D;&gt;&#123;</span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dropbox.addEventListener(&quot;dragover&quot;, (e)&#x3D;&gt;&#123;</span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dropbox.addEventListener(&quot;drop&quot;, (e)&#x3D;&gt;&#123;</span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\"></span><br><span class=\"line\">    var dt &#x3D; e.dataTransfer;</span><br><span class=\"line\">    var files &#x3D; dt.files;</span><br><span class=\"line\">    console.log(files)</span><br><span class=\"line\">    console.log(files)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>来自 HTMLCanvasElement 上的 mozGetAsFile() API</li>\n</ul>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4><ul>\n<li>File.lastModified：文件最后修改时间</li>\n<li>File.lastModifiedDate：文件最后修改时间的 Date 对象</li>\n<li>File.name：名称</li>\n<li>File.size：大小</li>\n<li>File.type：类型</li>\n<li>File.webkitRelativePath：路径（非标准的）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;input需要设置 webkitdirectory 属性（只允许选择文件夹）</span><br><span class=\"line\">&lt;input id&#x3D;&quot;myFile&quot; webkitdirectory type&#x3D;&quot;file&quot;&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"File-构造器\"><a href=\"#File-构造器\" class=\"headerlink\" title=\"File()构造器\"></a>File()构造器</h3><h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><ul>\n<li>var myFile = new File(bits, name[, options]);</li>\n</ul>\n<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4><ul>\n<li>bits：ArrayBuffer，ArrayBufferView，Blob，或者 DOMString 对象的 Array — 或者任何这些对象的组合。这是 UTF-8 编码的文件内容。</li>\n<li>name：USVString，表示文件名称，或者文件路径。</li>\n<li>options：type: DOMString，表示将要放到文件中的内容的 MIME 类型。默认值为 “” 。lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/File/File\">https://developer.mozilla.org/zh-CN/docs/Web/API/File/File</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var file &#x3D; new File([&quot;foo&quot;], &quot;foo.txt&quot;, &#123;</span><br><span class=\"line\">  type: &quot;text&#x2F;plain&quot;,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"FileReader对象\"><a href=\"#FileReader对象\" class=\"headerlink\" title=\"FileReader对象\"></a>FileReader对象</h3><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\">https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader</a></li>\n<li>允许Web应用程序异步读取存储在用户计算机上的文件</li>\n<li>FileReader()返回一个新构造的FileReader<h4 id=\"属性：-1\"><a href=\"#属性：-1\" class=\"headerlink\" title=\"属性：\"></a>属性：</h4></li>\n<li>FileReader.error：读取文件发生错误</li>\n<li>FileReader.readyState：状态数字 EMPTY（0）、LOADING（1）、DONE（2）</li>\n<li>FileReader.result：文件的内容。该属性仅在读取操作完成后才有效。</li>\n</ul>\n<h4 id=\"事件：\"><a href=\"#事件：\" class=\"headerlink\" title=\"事件：\"></a>事件：</h4><ul>\n<li>继承自EventTarget，所以所有这些事件也可以通过addEventListener方法使用。</li>\n<li>FileReader.onabort：中断时触发</li>\n<li>FileReader.onerror：错误时触发</li>\n<li>FileReader.onload：读取操作完成时触发</li>\n<li>FileReader.onloadstart：</li>\n<li>FileReader.onloadend：</li>\n<li>FileReader.onprogress：处理progress事件。该事件在读取Blob时触发。</li>\n</ul>\n<h4 id=\"方法：-1\"><a href=\"#方法：-1\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4><ul>\n<li>FileReader.abort()：终止操作</li>\n<li>FileReader.readAsArrayBuffer()</li>\n<li>FileReader.readAsBinaryString()非标准的</li>\n<li>FileReader.readAsDataURL()</li>\n<li>FileReader.readAsText()</li>\n</ul>\n<h4 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h4><ul>\n<li>input图片展示</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;inputFile&quot;&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let inputFile &#x3D; document.getElementById(&#39;inputFile&#39;)</span><br><span class=\"line\">    inputFile.addEventListener(&#39;change&#39;, () &#x3D;&gt; &#123;</span><br><span class=\"line\">        let file &#x3D; inputFile.files[0]</span><br><span class=\"line\">        let reader &#x3D; new FileReader()</span><br><span class=\"line\">        reader.onload &#x3D; function () &#123;</span><br><span class=\"line\">            let img &#x3D; document.createElement(&#39;img&#39;)</span><br><span class=\"line\">            img.src &#x3D; reader.result</span><br><span class=\"line\">            document.documentElement.appendChild(img)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reader.readAsDataURL(file)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ObjectURL\"><a href=\"#ObjectURL\" class=\"headerlink\" title=\"ObjectURL\"></a>ObjectURL</h3><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\">https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\">https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL</a></li>\n<li>objectURL = URL.createObjectURL(object);表示指定的File对象或Blob对象的url</li>\n<li>window.URL.revokeObjectURL(objectURL);释放一个现有的对象URL</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;选择图片并转换为对象URL显示</span><br><span class=\"line\">&lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;file1&quot;&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let inputFile &#x3D; document.getElementById(&#39;file1&#39;)</span><br><span class=\"line\">    inputFile.addEventListener(&#39;change&#39;,()&#x3D;&gt;&#123;</span><br><span class=\"line\">        let file &#x3D; inputFile.files[0]</span><br><span class=\"line\">        let url &#x3D; window.URL.createObjectURL(file)</span><br><span class=\"line\"></span><br><span class=\"line\">        let img &#x3D; document.createElement(&#39;img&#39;)</span><br><span class=\"line\">        img.src &#x3D; url</span><br><span class=\"line\">        document.documentElement.appendChild(img)</span><br><span class=\"line\"></span><br><span class=\"line\">        img.onload &#x3D; function() &#123;</span><br><span class=\"line\">            window.URL.revokeObjectURL(url)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;展示pdf</span><br><span class=\"line\">&lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;file2&quot;&gt;</span><br><span class=\"line\">&lt;iframe src&#x3D;&quot;&quot; frameborder&#x3D;&quot;0&quot; id&#x3D;&quot;view&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let pdfInput &#x3D; document.getElementById(&#39;file2&#39;)</span><br><span class=\"line\">    pdfInput.addEventListener(&#39;change&#39;,()&#x3D;&gt;&#123;</span><br><span class=\"line\">        let file &#x3D; pdfInput.files[0]</span><br><span class=\"line\">        let url &#x3D; window.URL.createObjectURL(file)</span><br><span class=\"line\">        var iframe &#x3D; document.getElementById(&#39;view&#39;);</span><br><span class=\"line\">        iframe.setAttribute(&#39;src&#39;, url);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"<js>new、call、apply、bind实现","date":"2021-01-10T16:00:00.000Z","_content":"\n### new\n\n- new执行步骤\n\n1. 创建新对象\n2. 将构造函数作用域赋给新对象（this指向新对象）\n3. 执行构造函数（添加对象属性）\n4. 返回新对象（如果构造函数return一个对象，new会返回这个对象）\n\n- new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象\n\n```javascript\nfunction _new(ctor, ...args) {\n  if (typeof ctor !== \"function\") {\n    throw \"ctor must be a function\";\n  }\n  const obj = Object.create({});\n  obj.__proto__ = Object.create(ctor.prototype);\n  const res = ctor.apply(obj, args);\n  const resType = typeof res;\n  return resType === \"object\" && res !== null ? res : obj;\n}\n\nfunction Child(name) {\n  this.name = name;\n}\nChild.prototype.say = function () {\n  console.log(this.name);\n};\nconst child = _new(Child, \"张三\");\n```\n\n### call、apply\n\n- 都是用来改变执行函数的 this 指向\n- 区别：call 从第 2 个至第 N 个都是给 func 的传参；apply 的第 2 个参数为数组；\n- 应用场景：\n1. 判断数据类型：Object.prototype.toString.call()\n2. 类数组借用方法：\n```javascript\nconst arrayLike = {\n  0: \"java\",\n  1: \"script\",\n  length: 2,\n};\nArray.prototype.push.call(arrayLike, \"jack\", \"lily\");\nconsole.log(typeof arrayLike); // 'object'\nconsole.log(arrayLike); // {0: \"java\", 1: \"script\", 2: \"jack\", 3: \"lily\", length: 4}\n```\n3. 获取数组的最大 / 最小值\n```javascript\nlet arr = [13, 6, 10, 11, 16];\nconst max = Math.max.apply(Math, arr);\nconst min = Math.min.apply(Math, arr);\nconsole.log(max); // 16\nconsole.log(min); // 6\n```\n4. 继承中使用 call\n- 实现 call、apply：结合方法“借用”原理\n\n```javascript\nFunction.prototype.call = function (ctx = window, ...args) {\n  const fun = Symbol();\n  ctx[fun] = this;\n  const res = ctx[fun](...args);\n  delete ctx[fun];\n  return res;\n};\nFunction.prototype.apply = function (ctx = window, args) {\n  const fun = Symbol();\n  ctx[fun] = this;\n  const res = ctx[fun](...args);\n  delete ctx[fun];\n  return res;\n};\n```\n\n### bind\n\n- bind 虽然改变了 func 的 this 指向，但不是马上执行\n- 新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数\n\n```javascript\nFunction.prototype.bind = function (ctx = window, ...args) {\n  const self = this;\n  const bindFun = function () {\n    return self.apply(\n      this instanceof self ? this : context, // 防止返回的bind函数再次调用call、apply、bind方法\n      args.concat(Array.prototype.slice.call(arguments)) // 聚合参数\n    );\n  };\n  if (this.prototype) {\n    bindFun.prototype = Object.create(this.prototype);\n  }\n  return bindFun;\n};\n```\n\n\n\n\n\n","source":"_posts/[js]new、call、apply、bind实现.md","raw":"---\ntitle: <js>new、call、apply、bind实现\ndate: 2021-01-11 00:00:00\ntags: [js]\ncategories: js\n---\n\n### new\n\n- new执行步骤\n\n1. 创建新对象\n2. 将构造函数作用域赋给新对象（this指向新对象）\n3. 执行构造函数（添加对象属性）\n4. 返回新对象（如果构造函数return一个对象，new会返回这个对象）\n\n- new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象\n\n```javascript\nfunction _new(ctor, ...args) {\n  if (typeof ctor !== \"function\") {\n    throw \"ctor must be a function\";\n  }\n  const obj = Object.create({});\n  obj.__proto__ = Object.create(ctor.prototype);\n  const res = ctor.apply(obj, args);\n  const resType = typeof res;\n  return resType === \"object\" && res !== null ? res : obj;\n}\n\nfunction Child(name) {\n  this.name = name;\n}\nChild.prototype.say = function () {\n  console.log(this.name);\n};\nconst child = _new(Child, \"张三\");\n```\n\n### call、apply\n\n- 都是用来改变执行函数的 this 指向\n- 区别：call 从第 2 个至第 N 个都是给 func 的传参；apply 的第 2 个参数为数组；\n- 应用场景：\n1. 判断数据类型：Object.prototype.toString.call()\n2. 类数组借用方法：\n```javascript\nconst arrayLike = {\n  0: \"java\",\n  1: \"script\",\n  length: 2,\n};\nArray.prototype.push.call(arrayLike, \"jack\", \"lily\");\nconsole.log(typeof arrayLike); // 'object'\nconsole.log(arrayLike); // {0: \"java\", 1: \"script\", 2: \"jack\", 3: \"lily\", length: 4}\n```\n3. 获取数组的最大 / 最小值\n```javascript\nlet arr = [13, 6, 10, 11, 16];\nconst max = Math.max.apply(Math, arr);\nconst min = Math.min.apply(Math, arr);\nconsole.log(max); // 16\nconsole.log(min); // 6\n```\n4. 继承中使用 call\n- 实现 call、apply：结合方法“借用”原理\n\n```javascript\nFunction.prototype.call = function (ctx = window, ...args) {\n  const fun = Symbol();\n  ctx[fun] = this;\n  const res = ctx[fun](...args);\n  delete ctx[fun];\n  return res;\n};\nFunction.prototype.apply = function (ctx = window, args) {\n  const fun = Symbol();\n  ctx[fun] = this;\n  const res = ctx[fun](...args);\n  delete ctx[fun];\n  return res;\n};\n```\n\n### bind\n\n- bind 虽然改变了 func 的 this 指向，但不是马上执行\n- 新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数\n\n```javascript\nFunction.prototype.bind = function (ctx = window, ...args) {\n  const self = this;\n  const bindFun = function () {\n    return self.apply(\n      this instanceof self ? this : context, // 防止返回的bind函数再次调用call、apply、bind方法\n      args.concat(Array.prototype.slice.call(arguments)) // 聚合参数\n    );\n  };\n  if (this.prototype) {\n    bindFun.prototype = Object.create(this.prototype);\n  }\n  return bindFun;\n};\n```\n\n\n\n\n\n","slug":"[js]new、call、apply、bind实现","published":1,"updated":"2021-03-15T14:39:52.598Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dkh001twotj6clv4cw1","content":"<h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><ul>\n<li>new执行步骤</li>\n</ul>\n<ol>\n<li>创建新对象</li>\n<li>将构造函数作用域赋给新对象（this指向新对象）</li>\n<li>执行构造函数（添加对象属性）</li>\n<li>返回新对象（如果构造函数return一个对象，new会返回这个对象）</li>\n</ol>\n<ul>\n<li>new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_new</span>(<span class=\"params\">ctor, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> ctor !== <span class=\"string\">&quot;function&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">&quot;ctor must be a function&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.create(&#123;&#125;);</span><br><span class=\"line\">  obj.__proto__ = <span class=\"built_in\">Object</span>.create(ctor.prototype);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = ctor.apply(obj, args);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> resType = <span class=\"keyword\">typeof</span> res;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> resType === <span class=\"string\">&quot;object&quot;</span> &amp;&amp; res !== <span class=\"literal\">null</span> ? res : obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> child = _new(Child, <span class=\"string\">&quot;张三&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"call、apply\"><a href=\"#call、apply\" class=\"headerlink\" title=\"call、apply\"></a>call、apply</h3><ul>\n<li>都是用来改变执行函数的 this 指向</li>\n<li>区别：call 从第 2 个至第 N 个都是给 func 的传参；apply 的第 2 个参数为数组；</li>\n<li>应用场景：</li>\n</ul>\n<ol>\n<li>判断数据类型：Object.prototype.toString.call()</li>\n<li>类数组借用方法：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrayLike = &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"string\">&quot;java&quot;</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"string\">&quot;script&quot;</span>,</span><br><span class=\"line\">  length: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.call(arrayLike, <span class=\"string\">&quot;jack&quot;</span>, <span class=\"string\">&quot;lily&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> arrayLike); <span class=\"comment\">// &#x27;object&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrayLike); <span class=\"comment\">// &#123;0: &quot;java&quot;, 1: &quot;script&quot;, 2: &quot;jack&quot;, 3: &quot;lily&quot;, length: 4&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>获取数组的最大 / 最小值<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">13</span>, <span class=\"number\">6</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">16</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> max = <span class=\"built_in\">Math</span>.max.apply(<span class=\"built_in\">Math</span>, arr);</span><br><span class=\"line\"><span class=\"keyword\">const</span> min = <span class=\"built_in\">Math</span>.min.apply(<span class=\"built_in\">Math</span>, arr);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(max); <span class=\"comment\">// 16</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(min); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure></li>\n<li>继承中使用 call</li>\n</ol>\n<ul>\n<li>实现 call、apply：结合方法“借用”原理</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.call = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ctx = <span class=\"built_in\">window</span>, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fun = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\">  ctx[fun] = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = ctx[fun](...args);</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> ctx[fun];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.apply = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ctx = <span class=\"built_in\">window</span>, args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fun = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\">  ctx[fun] = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = ctx[fun](...args);</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> ctx[fun];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h3><ul>\n<li>bind 虽然改变了 func 的 this 指向，但不是马上执行</li>\n<li>新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ctx = <span class=\"built_in\">window</span>, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> self = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> bindFun = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.apply(</span><br><span class=\"line\">      <span class=\"built_in\">this</span> <span class=\"keyword\">instanceof</span> self ? <span class=\"built_in\">this</span> : context, <span class=\"comment\">// 防止返回的bind函数再次调用call、apply、bind方法</span></span><br><span class=\"line\">      args.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)) <span class=\"comment\">// 聚合参数</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.prototype) &#123;</span><br><span class=\"line\">    bindFun.prototype = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">this</span>.prototype);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bindFun;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"new\"><a href=\"#new\" class=\"headerlink\" title=\"new\"></a>new</h3><ul>\n<li>new执行步骤</li>\n</ul>\n<ol>\n<li>创建新对象</li>\n<li>将构造函数作用域赋给新对象（this指向新对象）</li>\n<li>执行构造函数（添加对象属性）</li>\n<li>返回新对象（如果构造函数return一个对象，new会返回这个对象）</li>\n</ol>\n<ul>\n<li>new 关键词执行之后总是会返回一个对象，要么是实例对象，要么是 return 语句指定的对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_new</span>(<span class=\"params\">ctor, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> ctor !== <span class=\"string\">&quot;function&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"string\">&quot;ctor must be a function&quot;</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.create(&#123;&#125;);</span><br><span class=\"line\">  obj.__proto__ = <span class=\"built_in\">Object</span>.create(ctor.prototype);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = ctor.apply(obj, args);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> resType = <span class=\"keyword\">typeof</span> res;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> resType === <span class=\"string\">&quot;object&quot;</span> &amp;&amp; res !== <span class=\"literal\">null</span> ? res : obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.name);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> child = _new(Child, <span class=\"string\">&quot;张三&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"call、apply\"><a href=\"#call、apply\" class=\"headerlink\" title=\"call、apply\"></a>call、apply</h3><ul>\n<li>都是用来改变执行函数的 this 指向</li>\n<li>区别：call 从第 2 个至第 N 个都是给 func 的传参；apply 的第 2 个参数为数组；</li>\n<li>应用场景：</li>\n</ul>\n<ol>\n<li>判断数据类型：Object.prototype.toString.call()</li>\n<li>类数组借用方法：<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arrayLike = &#123;</span><br><span class=\"line\">  <span class=\"number\">0</span>: <span class=\"string\">&quot;java&quot;</span>,</span><br><span class=\"line\">  <span class=\"number\">1</span>: <span class=\"string\">&quot;script&quot;</span>,</span><br><span class=\"line\">  length: <span class=\"number\">2</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.push.call(arrayLike, <span class=\"string\">&quot;jack&quot;</span>, <span class=\"string\">&quot;lily&quot;</span>);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> arrayLike); <span class=\"comment\">// &#x27;object&#x27;</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arrayLike); <span class=\"comment\">// &#123;0: &quot;java&quot;, 1: &quot;script&quot;, 2: &quot;jack&quot;, 3: &quot;lily&quot;, length: 4&#125;</span></span><br></pre></td></tr></table></figure></li>\n<li>获取数组的最大 / 最小值<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">let</span> arr = [<span class=\"number\">13</span>, <span class=\"number\">6</span>, <span class=\"number\">10</span>, <span class=\"number\">11</span>, <span class=\"number\">16</span>];</span><br><span class=\"line\"><span class=\"keyword\">const</span> max = <span class=\"built_in\">Math</span>.max.apply(<span class=\"built_in\">Math</span>, arr);</span><br><span class=\"line\"><span class=\"keyword\">const</span> min = <span class=\"built_in\">Math</span>.min.apply(<span class=\"built_in\">Math</span>, arr);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(max); <span class=\"comment\">// 16</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(min); <span class=\"comment\">// 6</span></span><br></pre></td></tr></table></figure></li>\n<li>继承中使用 call</li>\n</ol>\n<ul>\n<li>实现 call、apply：结合方法“借用”原理</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.call = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ctx = <span class=\"built_in\">window</span>, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fun = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\">  ctx[fun] = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = ctx[fun](...args);</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> ctx[fun];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.apply = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ctx = <span class=\"built_in\">window</span>, args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> fun = <span class=\"built_in\">Symbol</span>();</span><br><span class=\"line\">  ctx[fun] = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> res = ctx[fun](...args);</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> ctx[fun];</span><br><span class=\"line\">  <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"bind\"><a href=\"#bind\" class=\"headerlink\" title=\"bind\"></a>bind</h3><ul>\n<li>bind 虽然改变了 func 的 this 指向，但不是马上执行</li>\n<li>新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Function</span>.prototype.bind = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">ctx = <span class=\"built_in\">window</span>, ...args</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> self = <span class=\"built_in\">this</span>;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> bindFun = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> self.apply(</span><br><span class=\"line\">      <span class=\"built_in\">this</span> <span class=\"keyword\">instanceof</span> self ? <span class=\"built_in\">this</span> : context, <span class=\"comment\">// 防止返回的bind函数再次调用call、apply、bind方法</span></span><br><span class=\"line\">      args.concat(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>)) <span class=\"comment\">// 聚合参数</span></span><br><span class=\"line\">    );</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.prototype) &#123;</span><br><span class=\"line\">    bindFun.prototype = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">this</span>.prototype);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> bindFun;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n"},{"title":"<js>requestAnimationFrame平滑生成大量div方法","date":"2019-04-17T16:00:00.000Z","_content":"\n\n### DocumentFragment\n\n- 创建没有父级的最小对象\n- 当请求把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。\n- 使用document.createDocumentFragment()创建\n\n### window.requestAnimationFrame()\n\n- 在浏览器下一次重绘之前执行\n- 回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。\n\n```\n//方法1\nfunction insertDiv(num) {\n    let frame = document.createDocumentFragment()\n    for(let i = 0;i<100;i++){\n        let div = document.createElement('div')\n        frame.appendChild(div)\n    }\n    document.body.appendChild(frame)\n    if(100*num<20000000000){\n        console.log(num)\n        setTimeout(function () {\n            insertDiv(num+1)\n        },17)\n    }\n}\nsetTimeout(function () {\n    insertDiv(1)\n},17)\n//方法2\nfunction insertDiv(num) {\n    let frame = document.createDocumentFragment()\n    for(let i = 0;i<100;i++){\n        let div = document.createElement('div')\n        frame.appendChild(div)\n    }\n    document.body.appendChild(frame)\n    if(100*num<20000000000){\n        window.requestAnimationFrame(function () {\n            insertDiv(num+1)\n        })\n    }\n}\nwindow.requestAnimationFrame(function () {\n    insertDiv(1)\n})\n```\n","source":"_posts/[js]requestAnimationFrame平滑生成大量div方法.md","raw":"---\ntitle: <js>requestAnimationFrame平滑生成大量div方法\ndate: 2019-04-18 00:00:00\ntags: [js]\ncategories: js\n---\n\n\n### DocumentFragment\n\n- 创建没有父级的最小对象\n- 当请求把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。\n- 使用document.createDocumentFragment()创建\n\n### window.requestAnimationFrame()\n\n- 在浏览器下一次重绘之前执行\n- 回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。\n\n```\n//方法1\nfunction insertDiv(num) {\n    let frame = document.createDocumentFragment()\n    for(let i = 0;i<100;i++){\n        let div = document.createElement('div')\n        frame.appendChild(div)\n    }\n    document.body.appendChild(frame)\n    if(100*num<20000000000){\n        console.log(num)\n        setTimeout(function () {\n            insertDiv(num+1)\n        },17)\n    }\n}\nsetTimeout(function () {\n    insertDiv(1)\n},17)\n//方法2\nfunction insertDiv(num) {\n    let frame = document.createDocumentFragment()\n    for(let i = 0;i<100;i++){\n        let div = document.createElement('div')\n        frame.appendChild(div)\n    }\n    document.body.appendChild(frame)\n    if(100*num<20000000000){\n        window.requestAnimationFrame(function () {\n            insertDiv(num+1)\n        })\n    }\n}\nwindow.requestAnimationFrame(function () {\n    insertDiv(1)\n})\n```\n","slug":"[js]requestAnimationFrame平滑生成大量div方法","published":1,"updated":"2021-03-15T14:39:59.354Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dki001wwotj4hx8egkn","content":"<h3 id=\"DocumentFragment\"><a href=\"#DocumentFragment\" class=\"headerlink\" title=\"DocumentFragment\"></a>DocumentFragment</h3><ul>\n<li>创建没有父级的最小对象</li>\n<li>当请求把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。</li>\n<li>使用document.createDocumentFragment()创建</li>\n</ul>\n<h3 id=\"window-requestAnimationFrame\"><a href=\"#window-requestAnimationFrame\" class=\"headerlink\" title=\"window.requestAnimationFrame()\"></a>window.requestAnimationFrame()</h3><ul>\n<li>在浏览器下一次重绘之前执行</li>\n<li>回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;方法1</span><br><span class=\"line\">function insertDiv(num) &#123;</span><br><span class=\"line\">    let frame &#x3D; document.createDocumentFragment()</span><br><span class=\"line\">    for(let i &#x3D; 0;i&lt;100;i++)&#123;</span><br><span class=\"line\">        let div &#x3D; document.createElement(&#39;div&#39;)</span><br><span class=\"line\">        frame.appendChild(div)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    document.body.appendChild(frame)</span><br><span class=\"line\">    if(100*num&lt;20000000000)&#123;</span><br><span class=\"line\">        console.log(num)</span><br><span class=\"line\">        setTimeout(function () &#123;</span><br><span class=\"line\">            insertDiv(num+1)</span><br><span class=\"line\">        &#125;,17)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">    insertDiv(1)</span><br><span class=\"line\">&#125;,17)</span><br><span class=\"line\">&#x2F;&#x2F;方法2</span><br><span class=\"line\">function insertDiv(num) &#123;</span><br><span class=\"line\">    let frame &#x3D; document.createDocumentFragment()</span><br><span class=\"line\">    for(let i &#x3D; 0;i&lt;100;i++)&#123;</span><br><span class=\"line\">        let div &#x3D; document.createElement(&#39;div&#39;)</span><br><span class=\"line\">        frame.appendChild(div)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    document.body.appendChild(frame)</span><br><span class=\"line\">    if(100*num&lt;20000000000)&#123;</span><br><span class=\"line\">        window.requestAnimationFrame(function () &#123;</span><br><span class=\"line\">            insertDiv(num+1)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.requestAnimationFrame(function () &#123;</span><br><span class=\"line\">    insertDiv(1)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"DocumentFragment\"><a href=\"#DocumentFragment\" class=\"headerlink\" title=\"DocumentFragment\"></a>DocumentFragment</h3><ul>\n<li>创建没有父级的最小对象</li>\n<li>当请求把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。</li>\n<li>使用document.createDocumentFragment()创建</li>\n</ul>\n<h3 id=\"window-requestAnimationFrame\"><a href=\"#window-requestAnimationFrame\" class=\"headerlink\" title=\"window.requestAnimationFrame()\"></a>window.requestAnimationFrame()</h3><ul>\n<li>在浏览器下一次重绘之前执行</li>\n<li>回调函数执行次数通常是每秒60次，但在大多数遵循W3C建议的浏览器中，回调函数执行次数通常与浏览器屏幕刷新次数相匹配。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;方法1</span><br><span class=\"line\">function insertDiv(num) &#123;</span><br><span class=\"line\">    let frame &#x3D; document.createDocumentFragment()</span><br><span class=\"line\">    for(let i &#x3D; 0;i&lt;100;i++)&#123;</span><br><span class=\"line\">        let div &#x3D; document.createElement(&#39;div&#39;)</span><br><span class=\"line\">        frame.appendChild(div)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    document.body.appendChild(frame)</span><br><span class=\"line\">    if(100*num&lt;20000000000)&#123;</span><br><span class=\"line\">        console.log(num)</span><br><span class=\"line\">        setTimeout(function () &#123;</span><br><span class=\"line\">            insertDiv(num+1)</span><br><span class=\"line\">        &#125;,17)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">    insertDiv(1)</span><br><span class=\"line\">&#125;,17)</span><br><span class=\"line\">&#x2F;&#x2F;方法2</span><br><span class=\"line\">function insertDiv(num) &#123;</span><br><span class=\"line\">    let frame &#x3D; document.createDocumentFragment()</span><br><span class=\"line\">    for(let i &#x3D; 0;i&lt;100;i++)&#123;</span><br><span class=\"line\">        let div &#x3D; document.createElement(&#39;div&#39;)</span><br><span class=\"line\">        frame.appendChild(div)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    document.body.appendChild(frame)</span><br><span class=\"line\">    if(100*num&lt;20000000000)&#123;</span><br><span class=\"line\">        window.requestAnimationFrame(function () &#123;</span><br><span class=\"line\">            insertDiv(num+1)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">window.requestAnimationFrame(function () &#123;</span><br><span class=\"line\">    insertDiv(1)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n"},{"title":"<js>scroll相关","date":"2019-04-16T16:00:00.000Z","_content":"\n\n### scroll-behavior\n\n- 平滑滚动css属性\n\n### scroll()、scrollTo()、scrollBy()\n\n- scrollBy()沿着坐标轴滚动的距离\n- 可以添加options对象\n\n```\nwindow.scrollTo({\n    top: 0,\n  \tleft: 0,\n  \tbehavior: 'smooth'\n})\n```\n\n### scrollIntoView()\n\n- 滚动到当前窗口可视区域\n\n```\n//滚动到视口顶端\nele.scrollIntoView()\n//滚动到视口底部\nele.scrollIntoView(false)\n//滚动到中间位置\nele.scrollIntoView({\n    behavior: 'smooth',\n    block: 'center'\n})\n```\n\n### overscroll-behavior\n\n- auto - 默认。元素的滚动会传播给祖先元素\n- contain - 阻止滚动链接，滚动不会传播给祖先\n- none - 和 contain 效果一样\n- [浏览器支持](https://caniuse.com/#search=overscroll-behavior)\n\n### Scroll snap\n\n- 规范滚动元素的定位\n- scroll-snap-type：https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-snap-type\n- scroll-snap-align：https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-snap-align\n\n### history.scrollRestoration\n\n- 设置返回页面是否返回原滚动位置\n\n### js实现平滑滚动\n\n```\nvar scrollSmoothTo = function (position) {\n    if (!window.requestAnimationFrame) {\n        window.requestAnimationFrame = function(callback, element) {\n            return setTimeout(callback, 17);\n        };\n    }\n    // 当前滚动高度\n    var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n    // 滚动step方法\n    var step = function () {\n        // 距离目标滚动距离\n        var distance = position - scrollTop;\n        // 目标滚动位置\n        scrollTop = scrollTop + distance / 5;\n        if (Math.abs(distance) < 1) {\n            window.scrollTo(0, position);\n        } else {\n            window.scrollTo(0, scrollTop);\n            requestAnimationFrame(step);\n        }\n    };\n    step();\n};\n\nif (typeof window.getComputedStyle(document.body).scrollBehavior == 'undefined') {\n   // 传统的JS平滑滚动处理代码...\n}\n```\n","source":"_posts/[js]scroll相关.md","raw":"---\ntitle: <js>scroll相关\ndate: 2019-04-17 00:00:00\ntags: [js,scroll]\ncategories: scroll\n---\n\n\n### scroll-behavior\n\n- 平滑滚动css属性\n\n### scroll()、scrollTo()、scrollBy()\n\n- scrollBy()沿着坐标轴滚动的距离\n- 可以添加options对象\n\n```\nwindow.scrollTo({\n    top: 0,\n  \tleft: 0,\n  \tbehavior: 'smooth'\n})\n```\n\n### scrollIntoView()\n\n- 滚动到当前窗口可视区域\n\n```\n//滚动到视口顶端\nele.scrollIntoView()\n//滚动到视口底部\nele.scrollIntoView(false)\n//滚动到中间位置\nele.scrollIntoView({\n    behavior: 'smooth',\n    block: 'center'\n})\n```\n\n### overscroll-behavior\n\n- auto - 默认。元素的滚动会传播给祖先元素\n- contain - 阻止滚动链接，滚动不会传播给祖先\n- none - 和 contain 效果一样\n- [浏览器支持](https://caniuse.com/#search=overscroll-behavior)\n\n### Scroll snap\n\n- 规范滚动元素的定位\n- scroll-snap-type：https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-snap-type\n- scroll-snap-align：https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-snap-align\n\n### history.scrollRestoration\n\n- 设置返回页面是否返回原滚动位置\n\n### js实现平滑滚动\n\n```\nvar scrollSmoothTo = function (position) {\n    if (!window.requestAnimationFrame) {\n        window.requestAnimationFrame = function(callback, element) {\n            return setTimeout(callback, 17);\n        };\n    }\n    // 当前滚动高度\n    var scrollTop = document.documentElement.scrollTop || document.body.scrollTop;\n    // 滚动step方法\n    var step = function () {\n        // 距离目标滚动距离\n        var distance = position - scrollTop;\n        // 目标滚动位置\n        scrollTop = scrollTop + distance / 5;\n        if (Math.abs(distance) < 1) {\n            window.scrollTo(0, position);\n        } else {\n            window.scrollTo(0, scrollTop);\n            requestAnimationFrame(step);\n        }\n    };\n    step();\n};\n\nif (typeof window.getComputedStyle(document.body).scrollBehavior == 'undefined') {\n   // 传统的JS平滑滚动处理代码...\n}\n```\n","slug":"[js]scroll相关","published":1,"updated":"2021-03-15T14:40:06.537Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dkj001zwotjesro4o7s","content":"<h3 id=\"scroll-behavior\"><a href=\"#scroll-behavior\" class=\"headerlink\" title=\"scroll-behavior\"></a>scroll-behavior</h3><ul>\n<li>平滑滚动css属性</li>\n</ul>\n<h3 id=\"scroll-、scrollTo-、scrollBy\"><a href=\"#scroll-、scrollTo-、scrollBy\" class=\"headerlink\" title=\"scroll()、scrollTo()、scrollBy()\"></a>scroll()、scrollTo()、scrollBy()</h3><ul>\n<li>scrollBy()沿着坐标轴滚动的距离</li>\n<li>可以添加options对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.scrollTo(&#123;</span><br><span class=\"line\">    top: 0,</span><br><span class=\"line\">  \tleft: 0,</span><br><span class=\"line\">  \tbehavior: &#39;smooth&#39;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"scrollIntoView\"><a href=\"#scrollIntoView\" class=\"headerlink\" title=\"scrollIntoView()\"></a>scrollIntoView()</h3><ul>\n<li>滚动到当前窗口可视区域</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;滚动到视口顶端</span><br><span class=\"line\">ele.scrollIntoView()</span><br><span class=\"line\">&#x2F;&#x2F;滚动到视口底部</span><br><span class=\"line\">ele.scrollIntoView(false)</span><br><span class=\"line\">&#x2F;&#x2F;滚动到中间位置</span><br><span class=\"line\">ele.scrollIntoView(&#123;</span><br><span class=\"line\">    behavior: &#39;smooth&#39;,</span><br><span class=\"line\">    block: &#39;center&#39;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"overscroll-behavior\"><a href=\"#overscroll-behavior\" class=\"headerlink\" title=\"overscroll-behavior\"></a>overscroll-behavior</h3><ul>\n<li>auto - 默认。元素的滚动会传播给祖先元素</li>\n<li>contain - 阻止滚动链接，滚动不会传播给祖先</li>\n<li>none - 和 contain 效果一样</li>\n<li><a href=\"https://caniuse.com/#search=overscroll-behavior\">浏览器支持</a></li>\n</ul>\n<h3 id=\"Scroll-snap\"><a href=\"#Scroll-snap\" class=\"headerlink\" title=\"Scroll snap\"></a>Scroll snap</h3><ul>\n<li>规范滚动元素的定位</li>\n<li>scroll-snap-type：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-snap-type\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-snap-type</a></li>\n<li>scroll-snap-align：<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-snap-align\">https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-snap-align</a></li>\n</ul>\n<h3 id=\"history-scrollRestoration\"><a href=\"#history-scrollRestoration\" class=\"headerlink\" title=\"history.scrollRestoration\"></a>history.scrollRestoration</h3><ul>\n<li>设置返回页面是否返回原滚动位置</li>\n</ul>\n<h3 id=\"js实现平滑滚动\"><a href=\"#js实现平滑滚动\" class=\"headerlink\" title=\"js实现平滑滚动\"></a>js实现平滑滚动</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var scrollSmoothTo &#x3D; function (position) &#123;</span><br><span class=\"line\">    if (!window.requestAnimationFrame) &#123;</span><br><span class=\"line\">        window.requestAnimationFrame &#x3D; function(callback, element) &#123;</span><br><span class=\"line\">            return setTimeout(callback, 17);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 当前滚动高度</span><br><span class=\"line\">    var scrollTop &#x3D; document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class=\"line\">    &#x2F;&#x2F; 滚动step方法</span><br><span class=\"line\">    var step &#x3D; function () &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 距离目标滚动距离</span><br><span class=\"line\">        var distance &#x3D; position - scrollTop;</span><br><span class=\"line\">        &#x2F;&#x2F; 目标滚动位置</span><br><span class=\"line\">        scrollTop &#x3D; scrollTop + distance &#x2F; 5;</span><br><span class=\"line\">        if (Math.abs(distance) &lt; 1) &#123;</span><br><span class=\"line\">            window.scrollTo(0, position);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            window.scrollTo(0, scrollTop);</span><br><span class=\"line\">            requestAnimationFrame(step);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    step();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">if (typeof window.getComputedStyle(document.body).scrollBehavior &#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class=\"line\">   &#x2F;&#x2F; 传统的JS平滑滚动处理代码...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"scroll-behavior\"><a href=\"#scroll-behavior\" class=\"headerlink\" title=\"scroll-behavior\"></a>scroll-behavior</h3><ul>\n<li>平滑滚动css属性</li>\n</ul>\n<h3 id=\"scroll-、scrollTo-、scrollBy\"><a href=\"#scroll-、scrollTo-、scrollBy\" class=\"headerlink\" title=\"scroll()、scrollTo()、scrollBy()\"></a>scroll()、scrollTo()、scrollBy()</h3><ul>\n<li>scrollBy()沿着坐标轴滚动的距离</li>\n<li>可以添加options对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.scrollTo(&#123;</span><br><span class=\"line\">    top: 0,</span><br><span class=\"line\">  \tleft: 0,</span><br><span class=\"line\">  \tbehavior: &#39;smooth&#39;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"scrollIntoView\"><a href=\"#scrollIntoView\" class=\"headerlink\" title=\"scrollIntoView()\"></a>scrollIntoView()</h3><ul>\n<li>滚动到当前窗口可视区域</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;滚动到视口顶端</span><br><span class=\"line\">ele.scrollIntoView()</span><br><span class=\"line\">&#x2F;&#x2F;滚动到视口底部</span><br><span class=\"line\">ele.scrollIntoView(false)</span><br><span class=\"line\">&#x2F;&#x2F;滚动到中间位置</span><br><span class=\"line\">ele.scrollIntoView(&#123;</span><br><span class=\"line\">    behavior: &#39;smooth&#39;,</span><br><span class=\"line\">    block: &#39;center&#39;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"overscroll-behavior\"><a href=\"#overscroll-behavior\" class=\"headerlink\" title=\"overscroll-behavior\"></a>overscroll-behavior</h3><ul>\n<li>auto - 默认。元素的滚动会传播给祖先元素</li>\n<li>contain - 阻止滚动链接，滚动不会传播给祖先</li>\n<li>none - 和 contain 效果一样</li>\n<li><a href=\"https://caniuse.com/#search=overscroll-behavior\">浏览器支持</a></li>\n</ul>\n<h3 id=\"Scroll-snap\"><a href=\"#Scroll-snap\" class=\"headerlink\" title=\"Scroll snap\"></a>Scroll snap</h3><ul>\n<li>规范滚动元素的定位</li>\n<li>scroll-snap-type：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-snap-type\">https://developer.mozilla.org/zh-CN/docs/Web/CSS/scroll-snap-type</a></li>\n<li>scroll-snap-align：<a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-snap-align\">https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-snap-align</a></li>\n</ul>\n<h3 id=\"history-scrollRestoration\"><a href=\"#history-scrollRestoration\" class=\"headerlink\" title=\"history.scrollRestoration\"></a>history.scrollRestoration</h3><ul>\n<li>设置返回页面是否返回原滚动位置</li>\n</ul>\n<h3 id=\"js实现平滑滚动\"><a href=\"#js实现平滑滚动\" class=\"headerlink\" title=\"js实现平滑滚动\"></a>js实现平滑滚动</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var scrollSmoothTo &#x3D; function (position) &#123;</span><br><span class=\"line\">    if (!window.requestAnimationFrame) &#123;</span><br><span class=\"line\">        window.requestAnimationFrame &#x3D; function(callback, element) &#123;</span><br><span class=\"line\">            return setTimeout(callback, 17);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    &#x2F;&#x2F; 当前滚动高度</span><br><span class=\"line\">    var scrollTop &#x3D; document.documentElement.scrollTop || document.body.scrollTop;</span><br><span class=\"line\">    &#x2F;&#x2F; 滚动step方法</span><br><span class=\"line\">    var step &#x3D; function () &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 距离目标滚动距离</span><br><span class=\"line\">        var distance &#x3D; position - scrollTop;</span><br><span class=\"line\">        &#x2F;&#x2F; 目标滚动位置</span><br><span class=\"line\">        scrollTop &#x3D; scrollTop + distance &#x2F; 5;</span><br><span class=\"line\">        if (Math.abs(distance) &lt; 1) &#123;</span><br><span class=\"line\">            window.scrollTo(0, position);</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            window.scrollTo(0, scrollTop);</span><br><span class=\"line\">            requestAnimationFrame(step);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    step();</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">if (typeof window.getComputedStyle(document.body).scrollBehavior &#x3D;&#x3D; &#39;undefined&#39;) &#123;</span><br><span class=\"line\">   &#x2F;&#x2F; 传统的JS平滑滚动处理代码...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"<js>一些前端dom取值","date":"2019-04-14T16:00:00.000Z","_content":"\n\n### css尺寸\n\n- $().outerWidth()==el.offsetWidth 即border box尺寸\n- $().innerWidth()==el.clientWidth 即padding box 尺寸\n- $().outerWidth(true) margin box 尺寸(可能会是负的，没有原生对应)\n- document.documentElement.offsetHeight和document.body.offsetHeight默认会包含滚动区域高度（没有设置height值）\n\n### offsetTop\n\n- 元素相对于 offsetParent 的边界框\n\n```\nfunction getOffset(obj) {\n    let offsetL = 0;\n    let offsetT = 0;\n    while (obj !== window.document.body && obj !== null) {\n        offsetL += obj.offsetLeft;\n        offsetT += obj.offsetTop;\n        obj = obj.offsetParent;\n    }\n    return {\n        top: offsetT,\n        left: offsetL\n    }\n}\n```\n\n### getBoundingClientRect()\n\n- 获取元素距离视口的距离el.getBoundingClientRect()\n- 返回元素的大小及其相对于视口的位置\n\n### scrollTop兼容写法\n\n```\nlet scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop\n```\n\n### scrollHeight\n\n- 包含padding\n\n### window.screen.height\n\n- 整个屏幕高\n\n### window.screen.availHeight\n\n- 可用工作区高度\n","source":"_posts/[js]一些前端dom取值.md","raw":"---\ntitle: <js>一些前端dom取值\ndate: 2019-04-15 00:00:00\ntags: [js,DOM,css]\ncategories: DOM取值\n---\n\n\n### css尺寸\n\n- $().outerWidth()==el.offsetWidth 即border box尺寸\n- $().innerWidth()==el.clientWidth 即padding box 尺寸\n- $().outerWidth(true) margin box 尺寸(可能会是负的，没有原生对应)\n- document.documentElement.offsetHeight和document.body.offsetHeight默认会包含滚动区域高度（没有设置height值）\n\n### offsetTop\n\n- 元素相对于 offsetParent 的边界框\n\n```\nfunction getOffset(obj) {\n    let offsetL = 0;\n    let offsetT = 0;\n    while (obj !== window.document.body && obj !== null) {\n        offsetL += obj.offsetLeft;\n        offsetT += obj.offsetTop;\n        obj = obj.offsetParent;\n    }\n    return {\n        top: offsetT,\n        left: offsetL\n    }\n}\n```\n\n### getBoundingClientRect()\n\n- 获取元素距离视口的距离el.getBoundingClientRect()\n- 返回元素的大小及其相对于视口的位置\n\n### scrollTop兼容写法\n\n```\nlet scrollTop = window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop\n```\n\n### scrollHeight\n\n- 包含padding\n\n### window.screen.height\n\n- 整个屏幕高\n\n### window.screen.availHeight\n\n- 可用工作区高度\n","slug":"[js]一些前端dom取值","published":1,"updated":"2021-03-15T14:38:54.402Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dkj0022wotj76wwaj0k","content":"<h3 id=\"css尺寸\"><a href=\"#css尺寸\" class=\"headerlink\" title=\"css尺寸\"></a>css尺寸</h3><ul>\n<li>$().outerWidth()==el.offsetWidth 即border box尺寸</li>\n<li>$().innerWidth()==el.clientWidth 即padding box 尺寸</li>\n<li>$().outerWidth(true) margin box 尺寸(可能会是负的，没有原生对应)</li>\n<li>document.documentElement.offsetHeight和document.body.offsetHeight默认会包含滚动区域高度（没有设置height值）</li>\n</ul>\n<h3 id=\"offsetTop\"><a href=\"#offsetTop\" class=\"headerlink\" title=\"offsetTop\"></a>offsetTop</h3><ul>\n<li>元素相对于 offsetParent 的边界框</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getOffset(obj) &#123;</span><br><span class=\"line\">    let offsetL &#x3D; 0;</span><br><span class=\"line\">    let offsetT &#x3D; 0;</span><br><span class=\"line\">    while (obj !&#x3D;&#x3D; window.document.body &amp;&amp; obj !&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">        offsetL +&#x3D; obj.offsetLeft;</span><br><span class=\"line\">        offsetT +&#x3D; obj.offsetTop;</span><br><span class=\"line\">        obj &#x3D; obj.offsetParent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        top: offsetT,</span><br><span class=\"line\">        left: offsetL</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"getBoundingClientRect\"><a href=\"#getBoundingClientRect\" class=\"headerlink\" title=\"getBoundingClientRect()\"></a>getBoundingClientRect()</h3><ul>\n<li>获取元素距离视口的距离el.getBoundingClientRect()</li>\n<li>返回元素的大小及其相对于视口的位置</li>\n</ul>\n<h3 id=\"scrollTop兼容写法\"><a href=\"#scrollTop兼容写法\" class=\"headerlink\" title=\"scrollTop兼容写法\"></a>scrollTop兼容写法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let scrollTop &#x3D; window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"scrollHeight\"><a href=\"#scrollHeight\" class=\"headerlink\" title=\"scrollHeight\"></a>scrollHeight</h3><ul>\n<li>包含padding</li>\n</ul>\n<h3 id=\"window-screen-height\"><a href=\"#window-screen-height\" class=\"headerlink\" title=\"window.screen.height\"></a>window.screen.height</h3><ul>\n<li>整个屏幕高</li>\n</ul>\n<h3 id=\"window-screen-availHeight\"><a href=\"#window-screen-availHeight\" class=\"headerlink\" title=\"window.screen.availHeight\"></a>window.screen.availHeight</h3><ul>\n<li>可用工作区高度</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"css尺寸\"><a href=\"#css尺寸\" class=\"headerlink\" title=\"css尺寸\"></a>css尺寸</h3><ul>\n<li>$().outerWidth()==el.offsetWidth 即border box尺寸</li>\n<li>$().innerWidth()==el.clientWidth 即padding box 尺寸</li>\n<li>$().outerWidth(true) margin box 尺寸(可能会是负的，没有原生对应)</li>\n<li>document.documentElement.offsetHeight和document.body.offsetHeight默认会包含滚动区域高度（没有设置height值）</li>\n</ul>\n<h3 id=\"offsetTop\"><a href=\"#offsetTop\" class=\"headerlink\" title=\"offsetTop\"></a>offsetTop</h3><ul>\n<li>元素相对于 offsetParent 的边界框</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function getOffset(obj) &#123;</span><br><span class=\"line\">    let offsetL &#x3D; 0;</span><br><span class=\"line\">    let offsetT &#x3D; 0;</span><br><span class=\"line\">    while (obj !&#x3D;&#x3D; window.document.body &amp;&amp; obj !&#x3D;&#x3D; null) &#123;</span><br><span class=\"line\">        offsetL +&#x3D; obj.offsetLeft;</span><br><span class=\"line\">        offsetT +&#x3D; obj.offsetTop;</span><br><span class=\"line\">        obj &#x3D; obj.offsetParent;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        top: offsetT,</span><br><span class=\"line\">        left: offsetL</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"getBoundingClientRect\"><a href=\"#getBoundingClientRect\" class=\"headerlink\" title=\"getBoundingClientRect()\"></a>getBoundingClientRect()</h3><ul>\n<li>获取元素距离视口的距离el.getBoundingClientRect()</li>\n<li>返回元素的大小及其相对于视口的位置</li>\n</ul>\n<h3 id=\"scrollTop兼容写法\"><a href=\"#scrollTop兼容写法\" class=\"headerlink\" title=\"scrollTop兼容写法\"></a>scrollTop兼容写法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let scrollTop &#x3D; window.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"scrollHeight\"><a href=\"#scrollHeight\" class=\"headerlink\" title=\"scrollHeight\"></a>scrollHeight</h3><ul>\n<li>包含padding</li>\n</ul>\n<h3 id=\"window-screen-height\"><a href=\"#window-screen-height\" class=\"headerlink\" title=\"window.screen.height\"></a>window.screen.height</h3><ul>\n<li>整个屏幕高</li>\n</ul>\n<h3 id=\"window-screen-availHeight\"><a href=\"#window-screen-availHeight\" class=\"headerlink\" title=\"window.screen.availHeight\"></a>window.screen.availHeight</h3><ul>\n<li>可用工作区高度</li>\n</ul>\n"},{"title":"<js>你不知道的js笔记","date":"2018-11-26T16:00:00.000Z","_content":"\n### 词法作用域\n\n- 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。词法作用域意味着作用域是由书写代码时函数声明的位置来决定。\n\n```\nlet c = 2\nfunction a() {\n    let c = 1\n    b()//2\n}\nfunction b() {\n    console.log(c)\n}\nb()//2\na()\n```\n\n- 在严格模式的程序中，eval(..)在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。\n\n```\nfunction c(str) {\n    eval(str)\n    console.log(b)//1\n}\nc('var b = 1')\nfunction a(str) {\n    'use strict'\n    eval(str)\n    console.log(b)//ReferenceError\n}\na('var b = 1')\n```\n\n- setTimeout(..)和setInterval(..)的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。\n- with 使用注意\n\n```\nfunction f1(obj) {\n    with (obj){\n        a = 2\n    }\n}\nvar o1 = {\n    a: 1\n}\nvar o2 = {\n    b: 1\n}\nf1(o1)\nf1(o2)\nconsole.log(o1)//{a:2}\nconsole.log(o2)//{b:1}\nconsole.log(a)//2,因为o2中没有a，所以a被泄露到全局了\n//o2的作用域、foo(..)的作用域和全局作用域中都没有找到标识符a，因此当a＝2执行时，自动创建了一个全局变量（因为是非严格模式）。\n```\n\n### 作用域\n\n- 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。\n- 区分函数声明和表达式最简单的方法是function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。\n- 提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使let进行的声明不会在块作用域中进行提升。\n\n### 作用域提升\n\n- 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。\n\n```\nconsole.log(a)//undefined\nvar a = 1\n```\n\n- 函数声明会被提升，但是函数表达式却不会被提升。\n\n```\nf1()//1\nf2()//TypeError: f2 is not a function\nfunction f1() {\n    console.log(1)\n}\nvar f2 = function () {\n    console.log(2)\n}\n```\n\n- 即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中。\n\n```\nf1()//TypeError\nf2()//ReferenceError\nvar f1 = function f2() {\n}\n//可以理解为\n// var f1\n// f1()\n// f2()\n// f1 = function () {\n//     var f2 = ...self...\n// }\n```\n\n- 函数优先提升，一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。\n\n```\na()//1\nvar a = 1\nfunction a() {\n    console.log(1)\n}\n```\n\n- 尽管重复var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。\n\n```\na()//2\nfunction a() {\n    console.log(1)\n}\nfunction a() {\n    console.log(2)\n}\n```\n\n- 一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下的代码暗示的那样可以被条件判断所控制。**但是需要注意这个行为并不可靠，JavaScript未来的版本中有可能发生改变，因此应该尽可能避免在块内部声明函数。**\n\n```\na()//TypeError: a is not a function,**这个demo和书里面的就不一样了书里面说会log 2**\nvar b = true\nif(b){\n    function a() {\n        console.log(1)\n    }\n}else {\n    function a() {\n        console.log(2)\n    }\n}\n```\n\n### 闭包\n\n- 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。\n- 模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。\n\n### this\n\n- 学this的第一步是明this既不指向函数自身也不指向函数的词法作用域，\n- this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。\n#### 调用位置\n- 调用位置就是函数在代码中被调用的位置（而不是声明的位置）。\n\n### this绑定规则\n\n#### 默认规则\n\n- 独立函数调用，，函数调用时应用this的默认绑定，因this指向全局对象。\n- 严格模式下this为undefined\n\n#### 隐式绑定\n\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\nvar obj = {\n    data: 2,\n    fn: a\n}\na()//1\nobj.fn()//2\n```\n\n- 隐式丢失\n\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\nvar obj = {\n    data: 2,\n    fn: a\n}\nvar fn1 = obj.fn\nfn1()//1\nvar f2\n(f2 = obj.fn)()//2\n```\n\n#### 显示绑定\n\n- JavaScript提供的绝大多数函数以及你自己创建的所有函数都可以使call(..)apply(..)bind(...)方法。\n\n#### new绑定使\n\n- new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。\n\n1. 创建（或者说构造）一个全新的对象。\n2. 这个新对象会被执[[原]]连接。\n3. 这个新对象会绑定到函数调用this。\n4. 如果函数没有返回其他对象，那new表达式中的函数调用会自动返回这个新对象。\n\n#### 优先级\n\n- new > 显示 > 隐式 > 默认\n\n#### 被忽略的this\n\n- 如果你null或undefined作this的绑定对象传call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。\n\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\na.apply(null)//1\n```\n\n#### 更安全的this\n\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\nvar ø = Object.create(null)\na.apply(ø)//1\n```\n\n#### 软绑定\n\n```\nif (!Function.prototype.softBind) {\n    Function.prototype.softBind = function (obj) {\n        var fn = this;\n        // 捕获所有 curried 参数\n        var curried = [].slice.call(arguments, 1);\n        var bound = function () {\n            return fn.apply(\n                (!this || this === (window || global)) ? obj : this,\n                curried.concat.apply(curried, arguments)\n            )\n        };\n        bound.prototype = Object.create(fn.prototype);\n        return bound;\n    };\n}\nvar data = 2\n\nfunction a() {\n    console.log(data)\n}\n\nvar b = a.softBind({data: 1})\na()//2\nb()//1\n```\n\n#### 箭头函数\n\n- 箭头函数不使this的四种标准规则，而是根据外层（函数或者全局）作用域来决this。\n\n```\nfunction a() {\n    //返回箭头函数\n    return ()=>{\n        //this继承自a()\n        console.log(this.data)\n    }\n\n    //ES5的实现\n    // let self = this\n    // return function () {\n    //     console.log(self.data)\n    // }\n}\nlet b = a.call({data:1})\nb.call({data:2})//1\n```\n","source":"_posts/[js]你不知道的js笔记.md","raw":"---\ntitle: <js>你不知道的js笔记\ndate: 2018-11-27 00:00:00\ntags: [js]\ncategories: js\n---\n\n### 词法作用域\n\n- 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。词法作用域意味着作用域是由书写代码时函数声明的位置来决定。\n\n```\nlet c = 2\nfunction a() {\n    let c = 1\n    b()//2\n}\nfunction b() {\n    console.log(c)\n}\nb()//2\na()\n```\n\n- 在严格模式的程序中，eval(..)在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。\n\n```\nfunction c(str) {\n    eval(str)\n    console.log(b)//1\n}\nc('var b = 1')\nfunction a(str) {\n    'use strict'\n    eval(str)\n    console.log(b)//ReferenceError\n}\na('var b = 1')\n```\n\n- setTimeout(..)和setInterval(..)的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。\n- with 使用注意\n\n```\nfunction f1(obj) {\n    with (obj){\n        a = 2\n    }\n}\nvar o1 = {\n    a: 1\n}\nvar o2 = {\n    b: 1\n}\nf1(o1)\nf1(o2)\nconsole.log(o1)//{a:2}\nconsole.log(o2)//{b:1}\nconsole.log(a)//2,因为o2中没有a，所以a被泄露到全局了\n//o2的作用域、foo(..)的作用域和全局作用域中都没有找到标识符a，因此当a＝2执行时，自动创建了一个全局变量（因为是非严格模式）。\n```\n\n### 作用域\n\n- 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。\n- 区分函数声明和表达式最简单的方法是function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。\n- 提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使let进行的声明不会在块作用域中进行提升。\n\n### 作用域提升\n\n- 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。\n\n```\nconsole.log(a)//undefined\nvar a = 1\n```\n\n- 函数声明会被提升，但是函数表达式却不会被提升。\n\n```\nf1()//1\nf2()//TypeError: f2 is not a function\nfunction f1() {\n    console.log(1)\n}\nvar f2 = function () {\n    console.log(2)\n}\n```\n\n- 即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中。\n\n```\nf1()//TypeError\nf2()//ReferenceError\nvar f1 = function f2() {\n}\n//可以理解为\n// var f1\n// f1()\n// f2()\n// f1 = function () {\n//     var f2 = ...self...\n// }\n```\n\n- 函数优先提升，一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。\n\n```\na()//1\nvar a = 1\nfunction a() {\n    console.log(1)\n}\n```\n\n- 尽管重复var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。\n\n```\na()//2\nfunction a() {\n    console.log(1)\n}\nfunction a() {\n    console.log(2)\n}\n```\n\n- 一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下的代码暗示的那样可以被条件判断所控制。**但是需要注意这个行为并不可靠，JavaScript未来的版本中有可能发生改变，因此应该尽可能避免在块内部声明函数。**\n\n```\na()//TypeError: a is not a function,**这个demo和书里面的就不一样了书里面说会log 2**\nvar b = true\nif(b){\n    function a() {\n        console.log(1)\n    }\n}else {\n    function a() {\n        console.log(2)\n    }\n}\n```\n\n### 闭包\n\n- 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。\n- 模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。\n\n### this\n\n- 学this的第一步是明this既不指向函数自身也不指向函数的词法作用域，\n- this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。\n#### 调用位置\n- 调用位置就是函数在代码中被调用的位置（而不是声明的位置）。\n\n### this绑定规则\n\n#### 默认规则\n\n- 独立函数调用，，函数调用时应用this的默认绑定，因this指向全局对象。\n- 严格模式下this为undefined\n\n#### 隐式绑定\n\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\nvar obj = {\n    data: 2,\n    fn: a\n}\na()//1\nobj.fn()//2\n```\n\n- 隐式丢失\n\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\nvar obj = {\n    data: 2,\n    fn: a\n}\nvar fn1 = obj.fn\nfn1()//1\nvar f2\n(f2 = obj.fn)()//2\n```\n\n#### 显示绑定\n\n- JavaScript提供的绝大多数函数以及你自己创建的所有函数都可以使call(..)apply(..)bind(...)方法。\n\n#### new绑定使\n\n- new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。\n\n1. 创建（或者说构造）一个全新的对象。\n2. 这个新对象会被执[[原]]连接。\n3. 这个新对象会绑定到函数调用this。\n4. 如果函数没有返回其他对象，那new表达式中的函数调用会自动返回这个新对象。\n\n#### 优先级\n\n- new > 显示 > 隐式 > 默认\n\n#### 被忽略的this\n\n- 如果你null或undefined作this的绑定对象传call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。\n\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\na.apply(null)//1\n```\n\n#### 更安全的this\n\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\nvar ø = Object.create(null)\na.apply(ø)//1\n```\n\n#### 软绑定\n\n```\nif (!Function.prototype.softBind) {\n    Function.prototype.softBind = function (obj) {\n        var fn = this;\n        // 捕获所有 curried 参数\n        var curried = [].slice.call(arguments, 1);\n        var bound = function () {\n            return fn.apply(\n                (!this || this === (window || global)) ? obj : this,\n                curried.concat.apply(curried, arguments)\n            )\n        };\n        bound.prototype = Object.create(fn.prototype);\n        return bound;\n    };\n}\nvar data = 2\n\nfunction a() {\n    console.log(data)\n}\n\nvar b = a.softBind({data: 1})\na()//2\nb()//1\n```\n\n#### 箭头函数\n\n- 箭头函数不使this的四种标准规则，而是根据外层（函数或者全局）作用域来决this。\n\n```\nfunction a() {\n    //返回箭头函数\n    return ()=>{\n        //this继承自a()\n        console.log(this.data)\n    }\n\n    //ES5的实现\n    // let self = this\n    // return function () {\n    //     console.log(self.data)\n    // }\n}\nlet b = a.call({data:1})\nb.call({data:2})//1\n```\n","slug":"[js]你不知道的js笔记","published":1,"updated":"2021-03-15T14:37:50.732Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dkk0025wotjcs2a4usa","content":"<h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3><ul>\n<li>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。词法作用域意味着作用域是由书写代码时函数声明的位置来决定。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let c &#x3D; 2</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    let c &#x3D; 1</span><br><span class=\"line\">    b()&#x2F;&#x2F;2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function b() &#123;</span><br><span class=\"line\">    console.log(c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">b()&#x2F;&#x2F;2</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在严格模式的程序中，eval(..)在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function c(str) &#123;</span><br><span class=\"line\">    eval(str)</span><br><span class=\"line\">    console.log(b)&#x2F;&#x2F;1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">c(&#39;var b &#x3D; 1&#39;)</span><br><span class=\"line\">function a(str) &#123;</span><br><span class=\"line\">    &#39;use strict&#39;</span><br><span class=\"line\">    eval(str)</span><br><span class=\"line\">    console.log(b)&#x2F;&#x2F;ReferenceError</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(&#39;var b &#x3D; 1&#39;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>setTimeout(..)和setInterval(..)的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。</li>\n<li>with 使用注意</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1(obj) &#123;</span><br><span class=\"line\">    with (obj)&#123;</span><br><span class=\"line\">        a &#x3D; 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var o1 &#x3D; &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var o2 &#x3D; &#123;</span><br><span class=\"line\">    b: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f1(o1)</span><br><span class=\"line\">f1(o2)</span><br><span class=\"line\">console.log(o1)&#x2F;&#x2F;&#123;a:2&#125;</span><br><span class=\"line\">console.log(o2)&#x2F;&#x2F;&#123;b:1&#125;</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;2,因为o2中没有a，所以a被泄露到全局了</span><br><span class=\"line\">&#x2F;&#x2F;o2的作用域、foo(..)的作用域和全局作用域中都没有找到标识符a，因此当a＝2执行时，自动创建了一个全局变量（因为是非严格模式）。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><ul>\n<li>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。</li>\n<li>区分函数声明和表达式最简单的方法是function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</li>\n<li>提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使let进行的声明不会在块作用域中进行提升。</li>\n</ul>\n<h3 id=\"作用域提升\"><a href=\"#作用域提升\" class=\"headerlink\" title=\"作用域提升\"></a>作用域提升</h3><ul>\n<li>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a)&#x2F;&#x2F;undefined</span><br><span class=\"line\">var a &#x3D; 1</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>函数声明会被提升，但是函数表达式却不会被提升。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1()&#x2F;&#x2F;1</span><br><span class=\"line\">f2()&#x2F;&#x2F;TypeError: f2 is not a function</span><br><span class=\"line\">function f1() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var f2 &#x3D; function () &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1()&#x2F;&#x2F;TypeError</span><br><span class=\"line\">f2()&#x2F;&#x2F;ReferenceError</span><br><span class=\"line\">var f1 &#x3D; function f2() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;可以理解为</span><br><span class=\"line\">&#x2F;&#x2F; var f1</span><br><span class=\"line\">&#x2F;&#x2F; f1()</span><br><span class=\"line\">&#x2F;&#x2F; f2()</span><br><span class=\"line\">&#x2F;&#x2F; f1 &#x3D; function () &#123;</span><br><span class=\"line\">&#x2F;&#x2F;     var f2 &#x3D; ...self...</span><br><span class=\"line\">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>函数优先提升，一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a()&#x2F;&#x2F;1</span><br><span class=\"line\">var a &#x3D; 1</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>尽管重复var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a()&#x2F;&#x2F;2</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下的代码暗示的那样可以被条件判断所控制。<strong>但是需要注意这个行为并不可靠，JavaScript未来的版本中有可能发生改变，因此应该尽可能避免在块内部声明函数。</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a()&#x2F;&#x2F;TypeError: a is not a function,**这个demo和书里面的就不一样了书里面说会log 2**</span><br><span class=\"line\">var b &#x3D; true</span><br><span class=\"line\">if(b)&#123;</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\">        console.log(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;else &#123;</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\">        console.log(2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><ul>\n<li>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</li>\n<li>模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</li>\n</ul>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h3><ul>\n<li>学this的第一步是明this既不指向函数自身也不指向函数的词法作用域，</li>\n<li>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。<h4 id=\"调用位置\"><a href=\"#调用位置\" class=\"headerlink\" title=\"调用位置\"></a>调用位置</h4></li>\n<li>调用位置就是函数在代码中被调用的位置（而不是声明的位置）。</li>\n</ul>\n<h3 id=\"this绑定规则\"><a href=\"#this绑定规则\" class=\"headerlink\" title=\"this绑定规则\"></a>this绑定规则</h3><h4 id=\"默认规则\"><a href=\"#默认规则\" class=\"headerlink\" title=\"默认规则\"></a>默认规则</h4><ul>\n<li>独立函数调用，，函数调用时应用this的默认绑定，因this指向全局对象。</li>\n<li>严格模式下this为undefined</li>\n</ul>\n<h4 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data &#x3D; 1</span><br><span class=\"line\">var obj &#x3D; &#123;</span><br><span class=\"line\">    data: 2,</span><br><span class=\"line\">    fn: a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()&#x2F;&#x2F;1</span><br><span class=\"line\">obj.fn()&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>隐式丢失</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data &#x3D; 1</span><br><span class=\"line\">var obj &#x3D; &#123;</span><br><span class=\"line\">    data: 2,</span><br><span class=\"line\">    fn: a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var fn1 &#x3D; obj.fn</span><br><span class=\"line\">fn1()&#x2F;&#x2F;1</span><br><span class=\"line\">var f2</span><br><span class=\"line\">(f2 &#x3D; obj.fn)()&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"显示绑定\"><a href=\"#显示绑定\" class=\"headerlink\" title=\"显示绑定\"></a>显示绑定</h4><ul>\n<li>JavaScript提供的绝大多数函数以及你自己创建的所有函数都可以使call(..)apply(..)bind(…)方法。</li>\n</ul>\n<h4 id=\"new绑定使\"><a href=\"#new绑定使\" class=\"headerlink\" title=\"new绑定使\"></a>new绑定使</h4><ul>\n<li>new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</li>\n</ul>\n<ol>\n<li>创建（或者说构造）一个全新的对象。</li>\n<li>这个新对象会被执[[原]]连接。</li>\n<li>这个新对象会绑定到函数调用this。</li>\n<li>如果函数没有返回其他对象，那new表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4><ul>\n<li>new &gt; 显示 &gt; 隐式 &gt; 默认</li>\n</ul>\n<h4 id=\"被忽略的this\"><a href=\"#被忽略的this\" class=\"headerlink\" title=\"被忽略的this\"></a>被忽略的this</h4><ul>\n<li>如果你null或undefined作this的绑定对象传call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data &#x3D; 1</span><br><span class=\"line\">a.apply(null)&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更安全的this\"><a href=\"#更安全的this\" class=\"headerlink\" title=\"更安全的this\"></a>更安全的this</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data &#x3D; 1</span><br><span class=\"line\">var ø &#x3D; Object.create(null)</span><br><span class=\"line\">a.apply(ø)&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"软绑定\"><a href=\"#软绑定\" class=\"headerlink\" title=\"软绑定\"></a>软绑定</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!Function.prototype.softBind) &#123;</span><br><span class=\"line\">    Function.prototype.softBind &#x3D; function (obj) &#123;</span><br><span class=\"line\">        var fn &#x3D; this;</span><br><span class=\"line\">        &#x2F;&#x2F; 捕获所有 curried 参数</span><br><span class=\"line\">        var curried &#x3D; [].slice.call(arguments, 1);</span><br><span class=\"line\">        var bound &#x3D; function () &#123;</span><br><span class=\"line\">            return fn.apply(</span><br><span class=\"line\">                (!this || this &#x3D;&#x3D;&#x3D; (window || global)) ? obj : this,</span><br><span class=\"line\">                curried.concat.apply(curried, arguments)</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        bound.prototype &#x3D; Object.create(fn.prototype);</span><br><span class=\"line\">        return bound;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data &#x3D; 2</span><br><span class=\"line\"></span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var b &#x3D; a.softBind(&#123;data: 1&#125;)</span><br><span class=\"line\">a()&#x2F;&#x2F;2</span><br><span class=\"line\">b()&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h4><ul>\n<li>箭头函数不使this的四种标准规则，而是根据外层（函数或者全局）作用域来决this。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;返回箭头函数</span><br><span class=\"line\">    return ()&#x3D;&gt;&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;this继承自a()</span><br><span class=\"line\">        console.log(this.data)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;ES5的实现</span><br><span class=\"line\">    &#x2F;&#x2F; let self &#x3D; this</span><br><span class=\"line\">    &#x2F;&#x2F; return function () &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;     console.log(self.data)</span><br><span class=\"line\">    &#x2F;&#x2F; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let b &#x3D; a.call(&#123;data:1&#125;)</span><br><span class=\"line\">b.call(&#123;data:2&#125;)&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3><ul>\n<li>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。词法作用域意味着作用域是由书写代码时函数声明的位置来决定。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let c &#x3D; 2</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    let c &#x3D; 1</span><br><span class=\"line\">    b()&#x2F;&#x2F;2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function b() &#123;</span><br><span class=\"line\">    console.log(c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">b()&#x2F;&#x2F;2</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>在严格模式的程序中，eval(..)在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function c(str) &#123;</span><br><span class=\"line\">    eval(str)</span><br><span class=\"line\">    console.log(b)&#x2F;&#x2F;1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">c(&#39;var b &#x3D; 1&#39;)</span><br><span class=\"line\">function a(str) &#123;</span><br><span class=\"line\">    &#39;use strict&#39;</span><br><span class=\"line\">    eval(str)</span><br><span class=\"line\">    console.log(b)&#x2F;&#x2F;ReferenceError</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(&#39;var b &#x3D; 1&#39;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>setTimeout(..)和setInterval(..)的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。</li>\n<li>with 使用注意</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1(obj) &#123;</span><br><span class=\"line\">    with (obj)&#123;</span><br><span class=\"line\">        a &#x3D; 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var o1 &#x3D; &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var o2 &#x3D; &#123;</span><br><span class=\"line\">    b: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f1(o1)</span><br><span class=\"line\">f1(o2)</span><br><span class=\"line\">console.log(o1)&#x2F;&#x2F;&#123;a:2&#125;</span><br><span class=\"line\">console.log(o2)&#x2F;&#x2F;&#123;b:1&#125;</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;2,因为o2中没有a，所以a被泄露到全局了</span><br><span class=\"line\">&#x2F;&#x2F;o2的作用域、foo(..)的作用域和全局作用域中都没有找到标识符a，因此当a＝2执行时，自动创建了一个全局变量（因为是非严格模式）。</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><ul>\n<li>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。</li>\n<li>区分函数声明和表达式最简单的方法是function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</li>\n<li>提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使let进行的声明不会在块作用域中进行提升。</li>\n</ul>\n<h3 id=\"作用域提升\"><a href=\"#作用域提升\" class=\"headerlink\" title=\"作用域提升\"></a>作用域提升</h3><ul>\n<li>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a)&#x2F;&#x2F;undefined</span><br><span class=\"line\">var a &#x3D; 1</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>函数声明会被提升，但是函数表达式却不会被提升。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1()&#x2F;&#x2F;1</span><br><span class=\"line\">f2()&#x2F;&#x2F;TypeError: f2 is not a function</span><br><span class=\"line\">function f1() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var f2 &#x3D; function () &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1()&#x2F;&#x2F;TypeError</span><br><span class=\"line\">f2()&#x2F;&#x2F;ReferenceError</span><br><span class=\"line\">var f1 &#x3D; function f2() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;可以理解为</span><br><span class=\"line\">&#x2F;&#x2F; var f1</span><br><span class=\"line\">&#x2F;&#x2F; f1()</span><br><span class=\"line\">&#x2F;&#x2F; f2()</span><br><span class=\"line\">&#x2F;&#x2F; f1 &#x3D; function () &#123;</span><br><span class=\"line\">&#x2F;&#x2F;     var f2 &#x3D; ...self...</span><br><span class=\"line\">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>函数优先提升，一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a()&#x2F;&#x2F;1</span><br><span class=\"line\">var a &#x3D; 1</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>尽管重复var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a()&#x2F;&#x2F;2</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下的代码暗示的那样可以被条件判断所控制。<strong>但是需要注意这个行为并不可靠，JavaScript未来的版本中有可能发生改变，因此应该尽可能避免在块内部声明函数。</strong></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a()&#x2F;&#x2F;TypeError: a is not a function,**这个demo和书里面的就不一样了书里面说会log 2**</span><br><span class=\"line\">var b &#x3D; true</span><br><span class=\"line\">if(b)&#123;</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\">        console.log(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;else &#123;</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\">        console.log(2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><ul>\n<li>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</li>\n<li>模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。</li>\n</ul>\n<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h3><ul>\n<li>学this的第一步是明this既不指向函数自身也不指向函数的词法作用域，</li>\n<li>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。<h4 id=\"调用位置\"><a href=\"#调用位置\" class=\"headerlink\" title=\"调用位置\"></a>调用位置</h4></li>\n<li>调用位置就是函数在代码中被调用的位置（而不是声明的位置）。</li>\n</ul>\n<h3 id=\"this绑定规则\"><a href=\"#this绑定规则\" class=\"headerlink\" title=\"this绑定规则\"></a>this绑定规则</h3><h4 id=\"默认规则\"><a href=\"#默认规则\" class=\"headerlink\" title=\"默认规则\"></a>默认规则</h4><ul>\n<li>独立函数调用，，函数调用时应用this的默认绑定，因this指向全局对象。</li>\n<li>严格模式下this为undefined</li>\n</ul>\n<h4 id=\"隐式绑定\"><a href=\"#隐式绑定\" class=\"headerlink\" title=\"隐式绑定\"></a>隐式绑定</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data &#x3D; 1</span><br><span class=\"line\">var obj &#x3D; &#123;</span><br><span class=\"line\">    data: 2,</span><br><span class=\"line\">    fn: a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()&#x2F;&#x2F;1</span><br><span class=\"line\">obj.fn()&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>隐式丢失</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data &#x3D; 1</span><br><span class=\"line\">var obj &#x3D; &#123;</span><br><span class=\"line\">    data: 2,</span><br><span class=\"line\">    fn: a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var fn1 &#x3D; obj.fn</span><br><span class=\"line\">fn1()&#x2F;&#x2F;1</span><br><span class=\"line\">var f2</span><br><span class=\"line\">(f2 &#x3D; obj.fn)()&#x2F;&#x2F;2</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"显示绑定\"><a href=\"#显示绑定\" class=\"headerlink\" title=\"显示绑定\"></a>显示绑定</h4><ul>\n<li>JavaScript提供的绝大多数函数以及你自己创建的所有函数都可以使call(..)apply(..)bind(…)方法。</li>\n</ul>\n<h4 id=\"new绑定使\"><a href=\"#new绑定使\" class=\"headerlink\" title=\"new绑定使\"></a>new绑定使</h4><ul>\n<li>new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</li>\n</ul>\n<ol>\n<li>创建（或者说构造）一个全新的对象。</li>\n<li>这个新对象会被执[[原]]连接。</li>\n<li>这个新对象会绑定到函数调用this。</li>\n<li>如果函数没有返回其他对象，那new表达式中的函数调用会自动返回这个新对象。</li>\n</ol>\n<h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4><ul>\n<li>new &gt; 显示 &gt; 隐式 &gt; 默认</li>\n</ul>\n<h4 id=\"被忽略的this\"><a href=\"#被忽略的this\" class=\"headerlink\" title=\"被忽略的this\"></a>被忽略的this</h4><ul>\n<li>如果你null或undefined作this的绑定对象传call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data &#x3D; 1</span><br><span class=\"line\">a.apply(null)&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"更安全的this\"><a href=\"#更安全的this\" class=\"headerlink\" title=\"更安全的this\"></a>更安全的this</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data &#x3D; 1</span><br><span class=\"line\">var ø &#x3D; Object.create(null)</span><br><span class=\"line\">a.apply(ø)&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"软绑定\"><a href=\"#软绑定\" class=\"headerlink\" title=\"软绑定\"></a>软绑定</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!Function.prototype.softBind) &#123;</span><br><span class=\"line\">    Function.prototype.softBind &#x3D; function (obj) &#123;</span><br><span class=\"line\">        var fn &#x3D; this;</span><br><span class=\"line\">        &#x2F;&#x2F; 捕获所有 curried 参数</span><br><span class=\"line\">        var curried &#x3D; [].slice.call(arguments, 1);</span><br><span class=\"line\">        var bound &#x3D; function () &#123;</span><br><span class=\"line\">            return fn.apply(</span><br><span class=\"line\">                (!this || this &#x3D;&#x3D;&#x3D; (window || global)) ? obj : this,</span><br><span class=\"line\">                curried.concat.apply(curried, arguments)</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        bound.prototype &#x3D; Object.create(fn.prototype);</span><br><span class=\"line\">        return bound;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data &#x3D; 2</span><br><span class=\"line\"></span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var b &#x3D; a.softBind(&#123;data: 1&#125;)</span><br><span class=\"line\">a()&#x2F;&#x2F;2</span><br><span class=\"line\">b()&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h4><ul>\n<li>箭头函数不使this的四种标准规则，而是根据外层（函数或者全局）作用域来决this。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;返回箭头函数</span><br><span class=\"line\">    return ()&#x3D;&gt;&#123;</span><br><span class=\"line\">        &#x2F;&#x2F;this继承自a()</span><br><span class=\"line\">        console.log(this.data)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;ES5的实现</span><br><span class=\"line\">    &#x2F;&#x2F; let self &#x3D; this</span><br><span class=\"line\">    &#x2F;&#x2F; return function () &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;     console.log(self.data)</span><br><span class=\"line\">    &#x2F;&#x2F; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let b &#x3D; a.call(&#123;data:1&#125;)</span><br><span class=\"line\">b.call(&#123;data:2&#125;)&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n"},{"title":"<js>数组","date":"2019-10-19T16:00:00.000Z","_content":"\n### 数组构造器\n\n- new Array()，传入一个数值参数时，参数为数组长度，其他情况参数为数组各项\n- Array.of()，将参数依次转化为数组中的一项，然后返回这个新数组\n- Array.from()，从一个类似数组的可迭代对象中创建一个新的数组实例\n\t3个参数：类数组对象、加工函数、加工函数的this\n\n```javascript\nconsole.log(new Array(4)); // [empty × 4]，一个数字参数，表示数组长度\nconsole.log(new Array(\"1\")); // [\"1\"]，非数字参数\nconsole.log(new Array(\"a\")); // [\"a\"]，非数字参数\nconsole.log(new Array(1, 2, 3)); // [1, 2, 3]，数组项\nconsole.log(Array.of(4)); // [4]，一个数字参数，数组项，与 new Array 不同\nconsole.log(Array.of(1, 2, 3)); // [1, 2, 3]\nconsole.log(Array.from({ 0: 1, 1: 1, 2: 1, length: 3 })); // [1, 1, 1]，类数组\n```\n\n### 数组方法\n\n#### 改变自身方法\n\n- pop\n- push\n- reverse\n- shift\n- sort\n- splice\n- uhshift\n- copyWithin\n- fill\n\n#### 不改变自身方法\n\n- concat\n- join\n- slice\n- toString\n- toLocateString\n- indexOf\n- lastIndexOf\n- includes\n- toSource\n- flat，数组扁平化\n\n#### 遍历方法（不改变自身）\n\n- forEach\n- every\n- some\n- filter\n- map\n- reduce\n- reduceRight\n- entries\n- find\n- findIndex\n- keys\n- values\n\n### 类数组\n\n#### 常见类数组\n\n1. arguments\n\n- arguments 只定义在函数体中\n- 包括函数的参数和其他属性\n- 存在 callee 属性指向函数自身\n\n```javascript\nfunction fun(a, b, c) {\n  console.log(arguments);\n  console.log(typeof arguments); // object\n  console.log(Object.prototype.toString.call(arguments)); // '[object Arguments]'\n}\nfun(1, 2, 3);\n```\n\n2. HTMLCollection\n\n- 是 HTML DOM 对象的一个接口，这个接口包含了获取到的 DOM 元素集合，返回的类型是类数组对象\n\n```javascript\nconst elm = document.forms[0]\nconsole.log(elm)\nconsole.log(typeof elm) // object\nconsole.log(Object.prototype.toString.call(elm)) // '[object HTMLFormElement]'\n```\n\n3. NodeList\n\n- 节点的集合，通常由 querySlector  返回\n\n#### 类数组应用场景\n\n1. 通过arguments遍历函数参数\n2. 通过arguments传递函数参数\n\n#### 类数组转换成数组\n\n- 因为类数组不是真正数组，没有数组自带方法\n- Array.prototype.slice.call()\n- Array.prototype.concat.apply()\n- Array.from()\n\n```javascript\nfunction fun(a, b, c) {\n  console.log(Array.prototype.slice.call(arguments));\n  console.log(Array.prototype.concat.apply([], arguments));\n  console.log(Array.from(arguments));\n}\nfun(1, 2, 3);\n```\n\n### 数组扁平化\n\n1. 递归实现\n\n```javascript\nfunction flatten(arr = []) {\n  const newArr = [];\n  for (const d of arr) {\n    if (Array.isArray(d)) {\n      return newArr.concat(flatten(d));\n    } else {\n      newArr.push(d);\n    }\n  }\n  return newArr;\n}\n```\n\n2. reduce + 递归实现\n\n```javascript\nfunction flatten(arr = []) {\n  return arr.reduce((a, b) => {\n    return a.concat(Array.isArray(b) ? flatten(b) : b);\n  }, []);\n}\n```\n\n3. 扩展运算符 + concat 实现\n\n```javascript\nfunction flatten(arr = []) {\n  while (arr.some((a) => Array.isArray(a))) {\n    arr = [].concat(...arr);\n  }\n}\n```\n\n4. toString + split 实现\n\n- 数字会转换成字符串\n\n```javascript\nfunction flatten(arr = []) {\n  return arr.toString().split(\",\");\n}\n```\n\n5. es6 flat 实现\n\n```javascript\nfunction flatten(arr = []) {\n  return arr.flat(Infinity);\n}\n```\n\n6. JSON.stringify 替换字符后 JSON.parse 实现\n\n```javascript\nfunction flatten(arr = []) {\n  return JSON.parse(`[${JSON.stringify(arr).replace(/[\\[\\]]/g, \"\")}]`);\n}\n```\n\n### js实现数组排序方法\n\n### 数组sort排序\n\n- arr.sort([compareFunction])\n  compareFunction（a, b）< 0，a 排到 b 之前\n  compareFunction（a, b）= 0，a、b 位置不变\n  compareFunction（a, b）> 0，b 排到 a 之前\n\n```javascript\n// 从小到大排序\nconst arr = [3, 6, 7, 2, 9, 1, 0];\narr.sort((a, b) => {\n  return a < b ? -1 : 1;\n});\narr.sort((a, b) => {\n  return a - b;\n});\nconsole.log(arr);\n```\n\n- 底层实现\n  当 n <= 10 时，采用插入排序，插入排序在最好的情况下时间复杂度是 O(n)\n  当 n > 10 时，采用三路快速排序\n    10 < n <=1000，采用中位数作为哨兵元素\n    n > 1000，每隔 200 ~ 215 个元素挑出一个元素，放到一个新数组中，然后对它排序，找到中间位置的数，以此作为中位数\n\n### 数组方法底层实现\n\n```javascript\n// pop\nArray.prototype.pop = function () {\n  let O = Object(this);\n  let len = this.length >>> 0;\n  if (len === 0) {\n    O.length = 0;\n    return undefined;\n  }\n  len--;\n  let value = O[len];\n  delete O[len];\n  O.length = len;\n  return value;\n};\n\n// map\nArray.prototype.map = function (callbackFn, thisArg) {\n  if (this === null || this === undefined) {\n    throw new TypeError(\"Cannot read property 'map' of null\");\n  }\n  if (Object.prototype.toString.call(callbackfn) != \"[object Function]\") {\n    throw new TypeError(callbackfn + \" is not a function\");\n  }\n  let O = Object(this);\n  let T = thisArg;\n\n  let len = O.length >>> 0;\n  let A = new Array(len);\n  for (let k = 0; k < len; k++) {\n    if (k in O) {\n      let kValue = O[k];\n      // 依次传入this, 当前项，当前索引，整个数组\n      let mappedValue = callbackfn.call(T, KValue, k, O);\n      A[k] = mappedValue;\n    }\n  }\n  return A;\n};\n\n// reduce\nArray.prototype.reduce = function (callbackfn, initialValue) {\n  // 异常处理，和 map 类似\n  if (this === null || this === undefined) {\n    throw new TypeError(\"Cannot read property 'reduce' of null\");\n  }\n  // 处理回调类型异常\n  if (Object.prototype.toString.call(callbackfn) != \"[object Function]\") {\n    throw new TypeError(callbackfn + \" is not a function\");\n  }\n  let O = Object(this);\n  let len = O.length >>> 0;\n  let k = 0;\n  let accumulator = initialValue; // reduce方法第二个参数作为累加器的初始值\n  if (accumulator === undefined) {\n    // 初始值不传的处理\n    for (; k < len; k++) {\n      if (k in O) { // 判断是否是 O 的属性\n        accumulator = O[k];\n        k++;\n        break;\n      }\n    }\n  }\n  for (; k < len; k++) {\n    if (k in O) {\n      // 注意 reduce 的核心累加器\n      accumulator = callbackfn.call(undefined, accumulator, O[k], O);\n    }\n  }\n  return accumulator;\n};\n```\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/[js]数组.md","raw":"---\ntitle: <js>数组\ndate: 2019-10-20 00:00:00\ntags: [js,数组]\ncategories: js\n---\n\n### 数组构造器\n\n- new Array()，传入一个数值参数时，参数为数组长度，其他情况参数为数组各项\n- Array.of()，将参数依次转化为数组中的一项，然后返回这个新数组\n- Array.from()，从一个类似数组的可迭代对象中创建一个新的数组实例\n\t3个参数：类数组对象、加工函数、加工函数的this\n\n```javascript\nconsole.log(new Array(4)); // [empty × 4]，一个数字参数，表示数组长度\nconsole.log(new Array(\"1\")); // [\"1\"]，非数字参数\nconsole.log(new Array(\"a\")); // [\"a\"]，非数字参数\nconsole.log(new Array(1, 2, 3)); // [1, 2, 3]，数组项\nconsole.log(Array.of(4)); // [4]，一个数字参数，数组项，与 new Array 不同\nconsole.log(Array.of(1, 2, 3)); // [1, 2, 3]\nconsole.log(Array.from({ 0: 1, 1: 1, 2: 1, length: 3 })); // [1, 1, 1]，类数组\n```\n\n### 数组方法\n\n#### 改变自身方法\n\n- pop\n- push\n- reverse\n- shift\n- sort\n- splice\n- uhshift\n- copyWithin\n- fill\n\n#### 不改变自身方法\n\n- concat\n- join\n- slice\n- toString\n- toLocateString\n- indexOf\n- lastIndexOf\n- includes\n- toSource\n- flat，数组扁平化\n\n#### 遍历方法（不改变自身）\n\n- forEach\n- every\n- some\n- filter\n- map\n- reduce\n- reduceRight\n- entries\n- find\n- findIndex\n- keys\n- values\n\n### 类数组\n\n#### 常见类数组\n\n1. arguments\n\n- arguments 只定义在函数体中\n- 包括函数的参数和其他属性\n- 存在 callee 属性指向函数自身\n\n```javascript\nfunction fun(a, b, c) {\n  console.log(arguments);\n  console.log(typeof arguments); // object\n  console.log(Object.prototype.toString.call(arguments)); // '[object Arguments]'\n}\nfun(1, 2, 3);\n```\n\n2. HTMLCollection\n\n- 是 HTML DOM 对象的一个接口，这个接口包含了获取到的 DOM 元素集合，返回的类型是类数组对象\n\n```javascript\nconst elm = document.forms[0]\nconsole.log(elm)\nconsole.log(typeof elm) // object\nconsole.log(Object.prototype.toString.call(elm)) // '[object HTMLFormElement]'\n```\n\n3. NodeList\n\n- 节点的集合，通常由 querySlector  返回\n\n#### 类数组应用场景\n\n1. 通过arguments遍历函数参数\n2. 通过arguments传递函数参数\n\n#### 类数组转换成数组\n\n- 因为类数组不是真正数组，没有数组自带方法\n- Array.prototype.slice.call()\n- Array.prototype.concat.apply()\n- Array.from()\n\n```javascript\nfunction fun(a, b, c) {\n  console.log(Array.prototype.slice.call(arguments));\n  console.log(Array.prototype.concat.apply([], arguments));\n  console.log(Array.from(arguments));\n}\nfun(1, 2, 3);\n```\n\n### 数组扁平化\n\n1. 递归实现\n\n```javascript\nfunction flatten(arr = []) {\n  const newArr = [];\n  for (const d of arr) {\n    if (Array.isArray(d)) {\n      return newArr.concat(flatten(d));\n    } else {\n      newArr.push(d);\n    }\n  }\n  return newArr;\n}\n```\n\n2. reduce + 递归实现\n\n```javascript\nfunction flatten(arr = []) {\n  return arr.reduce((a, b) => {\n    return a.concat(Array.isArray(b) ? flatten(b) : b);\n  }, []);\n}\n```\n\n3. 扩展运算符 + concat 实现\n\n```javascript\nfunction flatten(arr = []) {\n  while (arr.some((a) => Array.isArray(a))) {\n    arr = [].concat(...arr);\n  }\n}\n```\n\n4. toString + split 实现\n\n- 数字会转换成字符串\n\n```javascript\nfunction flatten(arr = []) {\n  return arr.toString().split(\",\");\n}\n```\n\n5. es6 flat 实现\n\n```javascript\nfunction flatten(arr = []) {\n  return arr.flat(Infinity);\n}\n```\n\n6. JSON.stringify 替换字符后 JSON.parse 实现\n\n```javascript\nfunction flatten(arr = []) {\n  return JSON.parse(`[${JSON.stringify(arr).replace(/[\\[\\]]/g, \"\")}]`);\n}\n```\n\n### js实现数组排序方法\n\n### 数组sort排序\n\n- arr.sort([compareFunction])\n  compareFunction（a, b）< 0，a 排到 b 之前\n  compareFunction（a, b）= 0，a、b 位置不变\n  compareFunction（a, b）> 0，b 排到 a 之前\n\n```javascript\n// 从小到大排序\nconst arr = [3, 6, 7, 2, 9, 1, 0];\narr.sort((a, b) => {\n  return a < b ? -1 : 1;\n});\narr.sort((a, b) => {\n  return a - b;\n});\nconsole.log(arr);\n```\n\n- 底层实现\n  当 n <= 10 时，采用插入排序，插入排序在最好的情况下时间复杂度是 O(n)\n  当 n > 10 时，采用三路快速排序\n    10 < n <=1000，采用中位数作为哨兵元素\n    n > 1000，每隔 200 ~ 215 个元素挑出一个元素，放到一个新数组中，然后对它排序，找到中间位置的数，以此作为中位数\n\n### 数组方法底层实现\n\n```javascript\n// pop\nArray.prototype.pop = function () {\n  let O = Object(this);\n  let len = this.length >>> 0;\n  if (len === 0) {\n    O.length = 0;\n    return undefined;\n  }\n  len--;\n  let value = O[len];\n  delete O[len];\n  O.length = len;\n  return value;\n};\n\n// map\nArray.prototype.map = function (callbackFn, thisArg) {\n  if (this === null || this === undefined) {\n    throw new TypeError(\"Cannot read property 'map' of null\");\n  }\n  if (Object.prototype.toString.call(callbackfn) != \"[object Function]\") {\n    throw new TypeError(callbackfn + \" is not a function\");\n  }\n  let O = Object(this);\n  let T = thisArg;\n\n  let len = O.length >>> 0;\n  let A = new Array(len);\n  for (let k = 0; k < len; k++) {\n    if (k in O) {\n      let kValue = O[k];\n      // 依次传入this, 当前项，当前索引，整个数组\n      let mappedValue = callbackfn.call(T, KValue, k, O);\n      A[k] = mappedValue;\n    }\n  }\n  return A;\n};\n\n// reduce\nArray.prototype.reduce = function (callbackfn, initialValue) {\n  // 异常处理，和 map 类似\n  if (this === null || this === undefined) {\n    throw new TypeError(\"Cannot read property 'reduce' of null\");\n  }\n  // 处理回调类型异常\n  if (Object.prototype.toString.call(callbackfn) != \"[object Function]\") {\n    throw new TypeError(callbackfn + \" is not a function\");\n  }\n  let O = Object(this);\n  let len = O.length >>> 0;\n  let k = 0;\n  let accumulator = initialValue; // reduce方法第二个参数作为累加器的初始值\n  if (accumulator === undefined) {\n    // 初始值不传的处理\n    for (; k < len; k++) {\n      if (k in O) { // 判断是否是 O 的属性\n        accumulator = O[k];\n        k++;\n        break;\n      }\n    }\n  }\n  for (; k < len; k++) {\n    if (k in O) {\n      // 注意 reduce 的核心累加器\n      accumulator = callbackfn.call(undefined, accumulator, O[k], O);\n    }\n  }\n  return accumulator;\n};\n```\n\n\n\n\n\n\n\n\n\n\n","slug":"[js]数组","published":1,"updated":"2021-03-15T14:38:48.835Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dkn0028wotjelj9bo7e","content":"<h3 id=\"数组构造器\"><a href=\"#数组构造器\" class=\"headerlink\" title=\"数组构造器\"></a>数组构造器</h3><ul>\n<li>new Array()，传入一个数值参数时，参数为数组长度，其他情况参数为数组各项</li>\n<li>Array.of()，将参数依次转化为数组中的一项，然后返回这个新数组</li>\n<li>Array.from()，从一个类似数组的可迭代对象中创建一个新的数组实例<br>  3个参数：类数组对象、加工函数、加工函数的this</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">4</span>)); <span class=\"comment\">// [empty × 4]，一个数字参数，表示数组长度</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">&quot;1&quot;</span>)); <span class=\"comment\">// [&quot;1&quot;]，非数字参数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">&quot;a&quot;</span>)); <span class=\"comment\">// [&quot;a&quot;]，非数字参数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)); <span class=\"comment\">// [1, 2, 3]，数组项</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.of(<span class=\"number\">4</span>)); <span class=\"comment\">// [4]，一个数字参数，数组项，与 new Array 不同</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)); <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(&#123; <span class=\"number\">0</span>: <span class=\"number\">1</span>, <span class=\"number\">1</span>: <span class=\"number\">1</span>, <span class=\"number\">2</span>: <span class=\"number\">1</span>, <span class=\"attr\">length</span>: <span class=\"number\">3</span> &#125;)); <span class=\"comment\">// [1, 1, 1]，类数组</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组方法\"><a href=\"#数组方法\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h3><h4 id=\"改变自身方法\"><a href=\"#改变自身方法\" class=\"headerlink\" title=\"改变自身方法\"></a>改变自身方法</h4><ul>\n<li>pop</li>\n<li>push</li>\n<li>reverse</li>\n<li>shift</li>\n<li>sort</li>\n<li>splice</li>\n<li>uhshift</li>\n<li>copyWithin</li>\n<li>fill</li>\n</ul>\n<h4 id=\"不改变自身方法\"><a href=\"#不改变自身方法\" class=\"headerlink\" title=\"不改变自身方法\"></a>不改变自身方法</h4><ul>\n<li>concat</li>\n<li>join</li>\n<li>slice</li>\n<li>toString</li>\n<li>toLocateString</li>\n<li>indexOf</li>\n<li>lastIndexOf</li>\n<li>includes</li>\n<li>toSource</li>\n<li>flat，数组扁平化</li>\n</ul>\n<h4 id=\"遍历方法（不改变自身）\"><a href=\"#遍历方法（不改变自身）\" class=\"headerlink\" title=\"遍历方法（不改变自身）\"></a>遍历方法（不改变自身）</h4><ul>\n<li>forEach</li>\n<li>every</li>\n<li>some</li>\n<li>filter</li>\n<li>map</li>\n<li>reduce</li>\n<li>reduceRight</li>\n<li>entries</li>\n<li>find</li>\n<li>findIndex</li>\n<li>keys</li>\n<li>values</li>\n</ul>\n<h3 id=\"类数组\"><a href=\"#类数组\" class=\"headerlink\" title=\"类数组\"></a>类数组</h3><h4 id=\"常见类数组\"><a href=\"#常见类数组\" class=\"headerlink\" title=\"常见类数组\"></a>常见类数组</h4><ol>\n<li>arguments</li>\n</ol>\n<ul>\n<li>arguments 只定义在函数体中</li>\n<li>包括函数的参数和其他属性</li>\n<li>存在 callee 属性指向函数自身</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"built_in\">arguments</span>); <span class=\"comment\">// object</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"built_in\">arguments</span>)); <span class=\"comment\">// &#x27;[object Arguments]&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>HTMLCollection</li>\n</ol>\n<ul>\n<li>是 HTML DOM 对象的一个接口，这个接口包含了获取到的 DOM 元素集合，返回的类型是类数组对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> elm = <span class=\"built_in\">document</span>.forms[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(elm)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> elm) <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype.toString.call(elm)) <span class=\"comment\">// &#x27;[object HTMLFormElement]&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>NodeList</li>\n</ol>\n<ul>\n<li>节点的集合，通常由 querySlector  返回</li>\n</ul>\n<h4 id=\"类数组应用场景\"><a href=\"#类数组应用场景\" class=\"headerlink\" title=\"类数组应用场景\"></a>类数组应用场景</h4><ol>\n<li>通过arguments遍历函数参数</li>\n<li>通过arguments传递函数参数</li>\n</ol>\n<h4 id=\"类数组转换成数组\"><a href=\"#类数组转换成数组\" class=\"headerlink\" title=\"类数组转换成数组\"></a>类数组转换成数组</h4><ul>\n<li>因为类数组不是真正数组，没有数组自带方法</li>\n<li>Array.prototype.slice.call()</li>\n<li>Array.prototype.concat.apply()</li>\n<li>Array.from()</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.prototype.concat.apply([], <span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组扁平化\"><a href=\"#数组扁平化\" class=\"headerlink\" title=\"数组扁平化\"></a>数组扁平化</h3><ol>\n<li>递归实现</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newArr = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> d <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(d)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> newArr.concat(flatten(d));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      newArr.push(d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>reduce + 递归实现</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.concat(<span class=\"built_in\">Array</span>.isArray(b) ? flatten(b) : b);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>扩展运算符 + concat 实现</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (arr.some(<span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> <span class=\"built_in\">Array</span>.isArray(a))) &#123;</span><br><span class=\"line\">    arr = [].concat(...arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>toString + split 实现</li>\n</ol>\n<ul>\n<li>数字会转换成字符串</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.toString().split(<span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>es6 flat 实现</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.flat(<span class=\"literal\">Infinity</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>JSON.stringify 替换字符后 JSON.parse 实现</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(<span class=\"string\">`[<span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(arr).replace(<span class=\"regexp\">/[\\[\\]]/g</span>, <span class=\"string\">&quot;&quot;</span>)&#125;</span>]`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"js实现数组排序方法\"><a href=\"#js实现数组排序方法\" class=\"headerlink\" title=\"js实现数组排序方法\"></a>js实现数组排序方法</h3><h3 id=\"数组sort排序\"><a href=\"#数组sort排序\" class=\"headerlink\" title=\"数组sort排序\"></a>数组sort排序</h3><ul>\n<li>arr.sort([compareFunction])<br>compareFunction（a, b）&lt; 0，a 排到 b 之前<br>compareFunction（a, b）= 0，a、b 位置不变<br>compareFunction（a, b）&gt; 0，b 排到 a 之前</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从小到大排序</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>];</span><br><span class=\"line\">arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a &lt; b ? -<span class=\"number\">1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>底层实现<br>当 n &lt;= 10 时，采用插入排序，插入排序在最好的情况下时间复杂度是 O(n)<br>当 n &gt; 10 时，采用三路快速排序<br>  10 &lt; n &lt;=1000，采用中位数作为哨兵元素<br>  n &gt; 1000，每隔 200 ~ 215 个元素挑出一个元素，放到一个新数组中，然后对它排序，找到中间位置的数，以此作为中位数</li>\n</ul>\n<h3 id=\"数组方法底层实现\"><a href=\"#数组方法底层实现\" class=\"headerlink\" title=\"数组方法底层实现\"></a>数组方法底层实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pop</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.pop = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> O = <span class=\"built_in\">Object</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = <span class=\"built_in\">this</span>.length &gt;&gt;&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    O.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  len--;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> value = O[len];</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> O[len];</span><br><span class=\"line\">  O.length = len;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callbackFn, thisArg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> === <span class=\"literal\">null</span> || <span class=\"built_in\">this</span> === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&quot;Cannot read property &#x27;map&#x27; of null&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(callbackfn) != <span class=\"string\">&quot;[object Function]&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(callbackfn + <span class=\"string\">&quot; is not a function&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> O = <span class=\"built_in\">Object</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> T = thisArg;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = O.length &gt;&gt;&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> A = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(len);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">0</span>; k &lt; len; k++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k <span class=\"keyword\">in</span> O) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> kValue = O[k];</span><br><span class=\"line\">      <span class=\"comment\">// 依次传入this, 当前项，当前索引，整个数组</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> mappedValue = callbackfn.call(T, KValue, k, O);</span><br><span class=\"line\">      A[k] = mappedValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> A;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// reduce</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.reduce = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callbackfn, initialValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 异常处理，和 map 类似</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> === <span class=\"literal\">null</span> || <span class=\"built_in\">this</span> === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&quot;Cannot read property &#x27;reduce&#x27; of null&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 处理回调类型异常</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(callbackfn) != <span class=\"string\">&quot;[object Function]&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(callbackfn + <span class=\"string\">&quot; is not a function&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> O = <span class=\"built_in\">Object</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = O.length &gt;&gt;&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> accumulator = initialValue; <span class=\"comment\">// reduce方法第二个参数作为累加器的初始值</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (accumulator === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始值不传的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; k &lt; len; k++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (k <span class=\"keyword\">in</span> O) &#123; <span class=\"comment\">// 判断是否是 O 的属性</span></span><br><span class=\"line\">        accumulator = O[k];</span><br><span class=\"line\">        k++;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (; k &lt; len; k++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k <span class=\"keyword\">in</span> O) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 注意 reduce 的核心累加器</span></span><br><span class=\"line\">      accumulator = callbackfn.call(<span class=\"literal\">undefined</span>, accumulator, O[k], O);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> accumulator;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"数组构造器\"><a href=\"#数组构造器\" class=\"headerlink\" title=\"数组构造器\"></a>数组构造器</h3><ul>\n<li>new Array()，传入一个数值参数时，参数为数组长度，其他情况参数为数组各项</li>\n<li>Array.of()，将参数依次转化为数组中的一项，然后返回这个新数组</li>\n<li>Array.from()，从一个类似数组的可迭代对象中创建一个新的数组实例<br>  3个参数：类数组对象、加工函数、加工函数的this</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">4</span>)); <span class=\"comment\">// [empty × 4]，一个数字参数，表示数组长度</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">&quot;1&quot;</span>)); <span class=\"comment\">// [&quot;1&quot;]，非数字参数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"string\">&quot;a&quot;</span>)); <span class=\"comment\">// [&quot;a&quot;]，非数字参数</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)); <span class=\"comment\">// [1, 2, 3]，数组项</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.of(<span class=\"number\">4</span>)); <span class=\"comment\">// [4]，一个数字参数，数组项，与 new Array 不同</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.of(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>)); <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(&#123; <span class=\"number\">0</span>: <span class=\"number\">1</span>, <span class=\"number\">1</span>: <span class=\"number\">1</span>, <span class=\"number\">2</span>: <span class=\"number\">1</span>, <span class=\"attr\">length</span>: <span class=\"number\">3</span> &#125;)); <span class=\"comment\">// [1, 1, 1]，类数组</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组方法\"><a href=\"#数组方法\" class=\"headerlink\" title=\"数组方法\"></a>数组方法</h3><h4 id=\"改变自身方法\"><a href=\"#改变自身方法\" class=\"headerlink\" title=\"改变自身方法\"></a>改变自身方法</h4><ul>\n<li>pop</li>\n<li>push</li>\n<li>reverse</li>\n<li>shift</li>\n<li>sort</li>\n<li>splice</li>\n<li>uhshift</li>\n<li>copyWithin</li>\n<li>fill</li>\n</ul>\n<h4 id=\"不改变自身方法\"><a href=\"#不改变自身方法\" class=\"headerlink\" title=\"不改变自身方法\"></a>不改变自身方法</h4><ul>\n<li>concat</li>\n<li>join</li>\n<li>slice</li>\n<li>toString</li>\n<li>toLocateString</li>\n<li>indexOf</li>\n<li>lastIndexOf</li>\n<li>includes</li>\n<li>toSource</li>\n<li>flat，数组扁平化</li>\n</ul>\n<h4 id=\"遍历方法（不改变自身）\"><a href=\"#遍历方法（不改变自身）\" class=\"headerlink\" title=\"遍历方法（不改变自身）\"></a>遍历方法（不改变自身）</h4><ul>\n<li>forEach</li>\n<li>every</li>\n<li>some</li>\n<li>filter</li>\n<li>map</li>\n<li>reduce</li>\n<li>reduceRight</li>\n<li>entries</li>\n<li>find</li>\n<li>findIndex</li>\n<li>keys</li>\n<li>values</li>\n</ul>\n<h3 id=\"类数组\"><a href=\"#类数组\" class=\"headerlink\" title=\"类数组\"></a>类数组</h3><h4 id=\"常见类数组\"><a href=\"#常见类数组\" class=\"headerlink\" title=\"常见类数组\"></a>常见类数组</h4><ol>\n<li>arguments</li>\n</ol>\n<ul>\n<li>arguments 只定义在函数体中</li>\n<li>包括函数的参数和其他属性</li>\n<li>存在 callee 属性指向函数自身</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">arguments</span>);</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> <span class=\"built_in\">arguments</span>); <span class=\"comment\">// object</span></span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"built_in\">arguments</span>)); <span class=\"comment\">// &#x27;[object Arguments]&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>HTMLCollection</li>\n</ol>\n<ul>\n<li>是 HTML DOM 对象的一个接口，这个接口包含了获取到的 DOM 元素集合，返回的类型是类数组对象</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> elm = <span class=\"built_in\">document</span>.forms[<span class=\"number\">0</span>]</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(elm)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"keyword\">typeof</span> elm) <span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Object</span>.prototype.toString.call(elm)) <span class=\"comment\">// &#x27;[object HTMLFormElement]&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>NodeList</li>\n</ol>\n<ul>\n<li>节点的集合，通常由 querySlector  返回</li>\n</ul>\n<h4 id=\"类数组应用场景\"><a href=\"#类数组应用场景\" class=\"headerlink\" title=\"类数组应用场景\"></a>类数组应用场景</h4><ol>\n<li>通过arguments遍历函数参数</li>\n<li>通过arguments传递函数参数</li>\n</ol>\n<h4 id=\"类数组转换成数组\"><a href=\"#类数组转换成数组\" class=\"headerlink\" title=\"类数组转换成数组\"></a>类数组转换成数组</h4><ul>\n<li>因为类数组不是真正数组，没有数组自带方法</li>\n<li>Array.prototype.slice.call()</li>\n<li>Array.prototype.concat.apply()</li>\n<li>Array.from()</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\">a, b, c</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.prototype.slice.call(<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.prototype.concat.apply([], <span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">Array</span>.from(<span class=\"built_in\">arguments</span>));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>);</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"数组扁平化\"><a href=\"#数组扁平化\" class=\"headerlink\" title=\"数组扁平化\"></a>数组扁平化</h3><ol>\n<li>递归实现</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> newArr = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> d <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(d)) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> newArr.concat(flatten(d));</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      newArr.push(d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> newArr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>reduce + 递归实现</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> a.concat(<span class=\"built_in\">Array</span>.isArray(b) ? flatten(b) : b);</span><br><span class=\"line\">  &#125;, []);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>扩展运算符 + concat 实现</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (arr.some(<span class=\"function\">(<span class=\"params\">a</span>) =&gt;</span> <span class=\"built_in\">Array</span>.isArray(a))) &#123;</span><br><span class=\"line\">    arr = [].concat(...arr);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>toString + split 实现</li>\n</ol>\n<ul>\n<li>数字会转换成字符串</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.toString().split(<span class=\"string\">&quot;,&quot;</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>es6 flat 实现</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr.flat(<span class=\"literal\">Infinity</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"6\">\n<li>JSON.stringify 替换字符后 JSON.parse 实现</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">flatten</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(<span class=\"string\">`[<span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(arr).replace(<span class=\"regexp\">/[\\[\\]]/g</span>, <span class=\"string\">&quot;&quot;</span>)&#125;</span>]`</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"js实现数组排序方法\"><a href=\"#js实现数组排序方法\" class=\"headerlink\" title=\"js实现数组排序方法\"></a>js实现数组排序方法</h3><h3 id=\"数组sort排序\"><a href=\"#数组sort排序\" class=\"headerlink\" title=\"数组sort排序\"></a>数组sort排序</h3><ul>\n<li>arr.sort([compareFunction])<br>compareFunction（a, b）&lt; 0，a 排到 b 之前<br>compareFunction（a, b）= 0，a、b 位置不变<br>compareFunction（a, b）&gt; 0，b 排到 a 之前</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 从小到大排序</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> arr = [<span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>, <span class=\"number\">2</span>, <span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">0</span>];</span><br><span class=\"line\">arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a &lt; b ? -<span class=\"number\">1</span> : <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">arr.sort(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> a - b;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(arr);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>底层实现<br>当 n &lt;= 10 时，采用插入排序，插入排序在最好的情况下时间复杂度是 O(n)<br>当 n &gt; 10 时，采用三路快速排序<br>  10 &lt; n &lt;=1000，采用中位数作为哨兵元素<br>  n &gt; 1000，每隔 200 ~ 215 个元素挑出一个元素，放到一个新数组中，然后对它排序，找到中间位置的数，以此作为中位数</li>\n</ul>\n<h3 id=\"数组方法底层实现\"><a href=\"#数组方法底层实现\" class=\"headerlink\" title=\"数组方法底层实现\"></a>数组方法底层实现</h3><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pop</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.pop = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> O = <span class=\"built_in\">Object</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = <span class=\"built_in\">this</span>.length &gt;&gt;&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    O.length = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  len--;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> value = O[len];</span><br><span class=\"line\">  <span class=\"keyword\">delete</span> O[len];</span><br><span class=\"line\">  O.length = len;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// map</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.map = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callbackFn, thisArg</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> === <span class=\"literal\">null</span> || <span class=\"built_in\">this</span> === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&quot;Cannot read property &#x27;map&#x27; of null&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(callbackfn) != <span class=\"string\">&quot;[object Function]&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(callbackfn + <span class=\"string\">&quot; is not a function&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> O = <span class=\"built_in\">Object</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> T = thisArg;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = O.length &gt;&gt;&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> A = <span class=\"keyword\">new</span> <span class=\"built_in\">Array</span>(len);</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> k = <span class=\"number\">0</span>; k &lt; len; k++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k <span class=\"keyword\">in</span> O) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> kValue = O[k];</span><br><span class=\"line\">      <span class=\"comment\">// 依次传入this, 当前项，当前索引，整个数组</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> mappedValue = callbackfn.call(T, KValue, k, O);</span><br><span class=\"line\">      A[k] = mappedValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> A;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// reduce</span></span><br><span class=\"line\"><span class=\"built_in\">Array</span>.prototype.reduce = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">callbackfn, initialValue</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 异常处理，和 map 类似</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span> === <span class=\"literal\">null</span> || <span class=\"built_in\">this</span> === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(<span class=\"string\">&quot;Cannot read property &#x27;reduce&#x27; of null&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 处理回调类型异常</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Object</span>.prototype.toString.call(callbackfn) != <span class=\"string\">&quot;[object Function]&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">TypeError</span>(callbackfn + <span class=\"string\">&quot; is not a function&quot;</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> O = <span class=\"built_in\">Object</span>(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = O.length &gt;&gt;&gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> k = <span class=\"number\">0</span>;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> accumulator = initialValue; <span class=\"comment\">// reduce方法第二个参数作为累加器的初始值</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (accumulator === <span class=\"literal\">undefined</span>) &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 初始值不传的处理</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (; k &lt; len; k++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (k <span class=\"keyword\">in</span> O) &#123; <span class=\"comment\">// 判断是否是 O 的属性</span></span><br><span class=\"line\">        accumulator = O[k];</span><br><span class=\"line\">        k++;</span><br><span class=\"line\">        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (; k &lt; len; k++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (k <span class=\"keyword\">in</span> O) &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 注意 reduce 的核心累加器</span></span><br><span class=\"line\">      accumulator = callbackfn.call(<span class=\"literal\">undefined</span>, accumulator, O[k], O);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> accumulator;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n"},{"title":"<js>数据类型","date":"2021-03-02T16:00:00.000Z","_content":"\n### 内置类型\n\n- string、number、boolean、null、undefined、symbol、bigInt、object\n\n#### 基本类型\n\n- 基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量\n- string、number、boolean、null、undefined、symbol、bigInt\n\n#### 引用类型\n\n- 引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址\n- object，引用类型又分为以下常见的数据类型：Array - 数组对象、RegExp - 正则对象、Date - 日期对象、Math - 数学函数、Function - 函数对象\n\n### 数据类型检测\n\n- typeof 可以判断基本数据类型（null）除外，引用类型除了 Function 外其他不能判断\n- instanceof 可以准确判断复杂引用数据类型，不能确定基本类型\n\n#### typeof\n\n```javascript\ntypeof 1 // 'number'\ntypeof '1' // 'string'\ntypeof undefined // 'undefined'\ntypeof true // 'boolean'\ntypeof Symbol() // 'symbol'\ntypeof [] // 'object'\ntypeof {} // 'object'\ntypeof console // 'object'\n// 特殊情况\ntypeof console.log // 'function' ***\ntypeof null // 'object' ***\ntypeof new Number(1) // 'object' ***\ntypeof Number(1) // 'number' ***\n```\n\n#### Array.isArray()\n\n- es6检测数据类型\n\n#### '==='严格运算符\n\n- 用于判断 null 和 undefined，因为这两种类型的值都是唯一的\n\n```javascript\nconst a = null\ntypeof a // object\na === null // true\n```\n\n#### instanceof\n\n- instanceof 通过原型链判断类型\n\n```javascript\n1 instanceof Number // false\nNumber(1) instanceof Number // false\nnew Number(1) instanceof Number // true\nnew Number(1) instanceof Object // true\n```\n\n#### constructor\n\n- 与instanceof类似，通过原型链检测\n- constructor还可以检测基本类型\n- 只能检测父级原型链类型\n\n```javascript\n[].constructor === Array // true\n('a').constructor === String // true\n[].constructor === Object // false\n```\n\n#### Object.prototype.toString\n\n- toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串，其中 Xxx 就是对象的类型\n- 对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息\n\n```javascript\nObject.prototype.toString({})       // \"[object Object]\"\nObject.prototype.toString.call({})  // \"[object Object]\" 同上结果，加上call也ok\nObject.prototype.toString.call(1)    // \"[object Number]\"\nObject.prototype.toString.call('1')  // \"[object String]\"\nObject.prototype.toString.call(true)  // \"[object Boolean]\"\nObject.prototype.toString.call(function(){})  // \"[object Function]\"\nObject.prototype.toString.call(null)   //\"[object Null]\"\nObject.prototype.toString.call(undefined) //\"[object Undefined]\"\nObject.prototype.toString.call(/123/g)    //\"[object RegExp]\"\nObject.prototype.toString.call(new Date()) //\"[object Date]\"\nObject.prototype.toString.call([])       //\"[object Array]\"\n// 特殊情况\nObject.prototype.toString.call(window)   //\"[object Window]\"\nObject.prototype.toString.call(document)  //\"[object HTMLDocument]\" ***\n```\n\n- 全局通用的数据类型判断方法\n\n```javascript\nfunction getType(obj){\n  let type  = typeof obj;\n  // typeof 判断不是 object 直接返回\n  if (type !== \"object\") {\n    return type;\n  }\n  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果\n  return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/, '$1').toLowerCase();\n}\n```\n\n### 类型转换\n\n#### 强制类型转换\n\n- 强制类型转换方式包括 Number()、parseInt()、parseFloat()、toString()、String()、Boolean()\n\n##### Number()方法规则\n\n- 如果是布尔值，true->1，false->0\n- 如果是数字，返回数字自身\n- 如果是 null，返回 0\n- 如果是 undefined，返回 NaN\n- 如果是字符串：字符串中只包含数字（或者是 0X、0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN；\n- 如果是 Symbol，抛出错误\n- 如果是对象，依次判断是否有 [Symbol.toPrimitive]、valueOf()、toString() 方法，如果存在，依据前面的规则转换方法返回的值\n\n```javascript\nNumber(true);        // 1\nNumber(false);       // 0\nNumber('0111');      // 111\nNumber(null);        // 0\nNumber(undefined);   // NaN\nNumber('');          // 0\nNumber('1a');        // NaN\nNumber(-0X11);       // -17\nNumber('0x11')       // 17\nNumber(Symbol())     // TypeError: Cannot convert a Symbol value to a number\n```\n\n```javascript\nconst obj1 = {};\nobj1[Symbol.toPrimitive] = () => {\n  return true;\n};\nconsole.log(Number(obj1)); // 1\n\nconst obj2 = {};\nobj2.valueOf = () => {\n  return true;\n};\nconsole.log(Number(obj2)); // 1\n\nconst obj3 = {};\nobj3.toString = () => {\n  return true;\n};\nconsole.log(Number(obj3)); //1\n```\n\n##### Boolean()方法规则\n\n- 除了 undefined、null、false、0（-0、+0）、''、NaN 转换为false，其他都是 true\n\n```javascript\nBoolean(0)          // false\nBoolean('')         // false\nBoolean(-0)         // false\nBoolean(null)       // false\nBoolean(undefined)  // false\nBoolean(NaN)        // false\n\nBoolean(1)          // true\nBoolean(13)         // true\nBoolean('12')       // true\n```\n\n#### 隐式类型转换\n\n- 逻辑运算符 (&&、 ||、 !)、运算符 (+、-、*、/)、关系操作符 (>、 <、 <= 、>=)、相等运算符 (==)、条件操作 (if、while)\n- 以上操作，遇到数据类型不一致，会发生隐式类型转换\n\n#### object转换规则\n\n- 依次判断是否有 [Symbol.toPrimitive]、valueOf()、toString() 方法，调用返回\n\n##### '=='规则\n\n- 值相同，不进行转换\n- 其中一个值是 null 或 undefined，另一个值必须是 null 或 undefined 才返回 true，否则返回 false\n- 其中一个是 Symbol 类型，那么返回 false\n- 两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number\n- 如果一个操作值是 boolean，那么转换成 number\n- 如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（[Symbol.toPrimitive]、valueOf()、toString()）\n\n```javascript\n// null 与 undefined\nnull == undefined // true\nnull == null // true\nnull == 0 // false\n\n// Symbol\nSymbol() == false // false\n\n// 数字与字符串比较\n1 == '1' // true，都转换为数字 -> 1 == 1 -> true\n\n// boolean\nfalse == '' // true，false 转换为 0 -> 0 == ''-> 0 == 0 -> true\n\n// object\nconst obj = {};\nobj.valueOf = () => {\n  return 1;\n};\nconsole.log(obj == 1); // true，obj valueOf 转为 1 -> 1 == 1 -> true\n\n// NaN 比较\nNaN == NaN // false\n```\n\n##### '+'规则\n\n- 数字 + 数字，加法运算\n- 字符串 + 字符串，拼接\n- 数字 + 字符串，拼接\n- 字符串 + （null、undefined）,toString 后拼接\n- 数字 + （null、undefined）,转换成数字后加法运算\n- 数字 + object，根据 Object 转换规则转换后运算\n- 字符串 + object，根据 Object 转换规则转换后运算\n\n```javascript\n1 + 1 // 2\n'1' + 1 // '11'\n'1' + '1' // '11'\n'1' + null // '1null'\n1 + undefined // NaN，Number(undefined) -> NaN\n1 + null  // 1\n\n// obj\nconst obj = {}\nobj.toString = ()=>{\n\treturn '1'\n}\n1 + obj // '11'\n```\n\n##### ‘<’、'>'比较\n\n- 都是字符串，按字母顺序比较\n- 其他情况：比较双方首先调用ToPrimitive，如果结果出现非字符串，就根据ToNumber规则将双方强制类型转换为数字来进行比较\n\n##### '<='、'>='比较\n\n- a <= b 被处理为b < a，然后将结果反转\n- JavaScript 中<= 是“不大于”的意思（即!(a > b)，处理为!(b < a)）。同理a >= b 处理为b <= a\n\n### 其他参考\n\n- https://crazyaguai.github.io/2019/03/03/[js]%E7%B1%BB%E5%9E%8B/\n\n\n\n\n\n\n","source":"_posts/[js]数据类型.md","raw":"---\ntitle: <js>数据类型\ndate: 2021-03-03 00:00:00\ntags: [js,js类型]\ncategories: js\n---\n\n### 内置类型\n\n- string、number、boolean、null、undefined、symbol、bigInt、object\n\n#### 基本类型\n\n- 基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量\n- string、number、boolean、null、undefined、symbol、bigInt\n\n#### 引用类型\n\n- 引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址\n- object，引用类型又分为以下常见的数据类型：Array - 数组对象、RegExp - 正则对象、Date - 日期对象、Math - 数学函数、Function - 函数对象\n\n### 数据类型检测\n\n- typeof 可以判断基本数据类型（null）除外，引用类型除了 Function 外其他不能判断\n- instanceof 可以准确判断复杂引用数据类型，不能确定基本类型\n\n#### typeof\n\n```javascript\ntypeof 1 // 'number'\ntypeof '1' // 'string'\ntypeof undefined // 'undefined'\ntypeof true // 'boolean'\ntypeof Symbol() // 'symbol'\ntypeof [] // 'object'\ntypeof {} // 'object'\ntypeof console // 'object'\n// 特殊情况\ntypeof console.log // 'function' ***\ntypeof null // 'object' ***\ntypeof new Number(1) // 'object' ***\ntypeof Number(1) // 'number' ***\n```\n\n#### Array.isArray()\n\n- es6检测数据类型\n\n#### '==='严格运算符\n\n- 用于判断 null 和 undefined，因为这两种类型的值都是唯一的\n\n```javascript\nconst a = null\ntypeof a // object\na === null // true\n```\n\n#### instanceof\n\n- instanceof 通过原型链判断类型\n\n```javascript\n1 instanceof Number // false\nNumber(1) instanceof Number // false\nnew Number(1) instanceof Number // true\nnew Number(1) instanceof Object // true\n```\n\n#### constructor\n\n- 与instanceof类似，通过原型链检测\n- constructor还可以检测基本类型\n- 只能检测父级原型链类型\n\n```javascript\n[].constructor === Array // true\n('a').constructor === String // true\n[].constructor === Object // false\n```\n\n#### Object.prototype.toString\n\n- toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串，其中 Xxx 就是对象的类型\n- 对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息\n\n```javascript\nObject.prototype.toString({})       // \"[object Object]\"\nObject.prototype.toString.call({})  // \"[object Object]\" 同上结果，加上call也ok\nObject.prototype.toString.call(1)    // \"[object Number]\"\nObject.prototype.toString.call('1')  // \"[object String]\"\nObject.prototype.toString.call(true)  // \"[object Boolean]\"\nObject.prototype.toString.call(function(){})  // \"[object Function]\"\nObject.prototype.toString.call(null)   //\"[object Null]\"\nObject.prototype.toString.call(undefined) //\"[object Undefined]\"\nObject.prototype.toString.call(/123/g)    //\"[object RegExp]\"\nObject.prototype.toString.call(new Date()) //\"[object Date]\"\nObject.prototype.toString.call([])       //\"[object Array]\"\n// 特殊情况\nObject.prototype.toString.call(window)   //\"[object Window]\"\nObject.prototype.toString.call(document)  //\"[object HTMLDocument]\" ***\n```\n\n- 全局通用的数据类型判断方法\n\n```javascript\nfunction getType(obj){\n  let type  = typeof obj;\n  // typeof 判断不是 object 直接返回\n  if (type !== \"object\") {\n    return type;\n  }\n  // 对于typeof返回结果是object的，再进行如下的判断，正则返回结果\n  return Object.prototype.toString.call(obj).replace(/^\\[object (\\S+)\\]$/, '$1').toLowerCase();\n}\n```\n\n### 类型转换\n\n#### 强制类型转换\n\n- 强制类型转换方式包括 Number()、parseInt()、parseFloat()、toString()、String()、Boolean()\n\n##### Number()方法规则\n\n- 如果是布尔值，true->1，false->0\n- 如果是数字，返回数字自身\n- 如果是 null，返回 0\n- 如果是 undefined，返回 NaN\n- 如果是字符串：字符串中只包含数字（或者是 0X、0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN；\n- 如果是 Symbol，抛出错误\n- 如果是对象，依次判断是否有 [Symbol.toPrimitive]、valueOf()、toString() 方法，如果存在，依据前面的规则转换方法返回的值\n\n```javascript\nNumber(true);        // 1\nNumber(false);       // 0\nNumber('0111');      // 111\nNumber(null);        // 0\nNumber(undefined);   // NaN\nNumber('');          // 0\nNumber('1a');        // NaN\nNumber(-0X11);       // -17\nNumber('0x11')       // 17\nNumber(Symbol())     // TypeError: Cannot convert a Symbol value to a number\n```\n\n```javascript\nconst obj1 = {};\nobj1[Symbol.toPrimitive] = () => {\n  return true;\n};\nconsole.log(Number(obj1)); // 1\n\nconst obj2 = {};\nobj2.valueOf = () => {\n  return true;\n};\nconsole.log(Number(obj2)); // 1\n\nconst obj3 = {};\nobj3.toString = () => {\n  return true;\n};\nconsole.log(Number(obj3)); //1\n```\n\n##### Boolean()方法规则\n\n- 除了 undefined、null、false、0（-0、+0）、''、NaN 转换为false，其他都是 true\n\n```javascript\nBoolean(0)          // false\nBoolean('')         // false\nBoolean(-0)         // false\nBoolean(null)       // false\nBoolean(undefined)  // false\nBoolean(NaN)        // false\n\nBoolean(1)          // true\nBoolean(13)         // true\nBoolean('12')       // true\n```\n\n#### 隐式类型转换\n\n- 逻辑运算符 (&&、 ||、 !)、运算符 (+、-、*、/)、关系操作符 (>、 <、 <= 、>=)、相等运算符 (==)、条件操作 (if、while)\n- 以上操作，遇到数据类型不一致，会发生隐式类型转换\n\n#### object转换规则\n\n- 依次判断是否有 [Symbol.toPrimitive]、valueOf()、toString() 方法，调用返回\n\n##### '=='规则\n\n- 值相同，不进行转换\n- 其中一个值是 null 或 undefined，另一个值必须是 null 或 undefined 才返回 true，否则返回 false\n- 其中一个是 Symbol 类型，那么返回 false\n- 两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number\n- 如果一个操作值是 boolean，那么转换成 number\n- 如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（[Symbol.toPrimitive]、valueOf()、toString()）\n\n```javascript\n// null 与 undefined\nnull == undefined // true\nnull == null // true\nnull == 0 // false\n\n// Symbol\nSymbol() == false // false\n\n// 数字与字符串比较\n1 == '1' // true，都转换为数字 -> 1 == 1 -> true\n\n// boolean\nfalse == '' // true，false 转换为 0 -> 0 == ''-> 0 == 0 -> true\n\n// object\nconst obj = {};\nobj.valueOf = () => {\n  return 1;\n};\nconsole.log(obj == 1); // true，obj valueOf 转为 1 -> 1 == 1 -> true\n\n// NaN 比较\nNaN == NaN // false\n```\n\n##### '+'规则\n\n- 数字 + 数字，加法运算\n- 字符串 + 字符串，拼接\n- 数字 + 字符串，拼接\n- 字符串 + （null、undefined）,toString 后拼接\n- 数字 + （null、undefined）,转换成数字后加法运算\n- 数字 + object，根据 Object 转换规则转换后运算\n- 字符串 + object，根据 Object 转换规则转换后运算\n\n```javascript\n1 + 1 // 2\n'1' + 1 // '11'\n'1' + '1' // '11'\n'1' + null // '1null'\n1 + undefined // NaN，Number(undefined) -> NaN\n1 + null  // 1\n\n// obj\nconst obj = {}\nobj.toString = ()=>{\n\treturn '1'\n}\n1 + obj // '11'\n```\n\n##### ‘<’、'>'比较\n\n- 都是字符串，按字母顺序比较\n- 其他情况：比较双方首先调用ToPrimitive，如果结果出现非字符串，就根据ToNumber规则将双方强制类型转换为数字来进行比较\n\n##### '<='、'>='比较\n\n- a <= b 被处理为b < a，然后将结果反转\n- JavaScript 中<= 是“不大于”的意思（即!(a > b)，处理为!(b < a)）。同理a >= b 处理为b <= a\n\n### 其他参考\n\n- https://crazyaguai.github.io/2019/03/03/[js]%E7%B1%BB%E5%9E%8B/\n\n\n\n\n\n\n","slug":"[js]数据类型","published":1,"updated":"2021-03-15T14:38:43.132Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dkn002bwotj62c686gg","content":"<h3 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h3><ul>\n<li>string、number、boolean、null、undefined、symbol、bigInt、object</li>\n</ul>\n<h4 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h4><ul>\n<li>基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量</li>\n<li>string、number、boolean、null、undefined、symbol、bigInt</li>\n</ul>\n<h4 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h4><ul>\n<li>引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址</li>\n<li>object，引用类型又分为以下常见的数据类型：Array - 数组对象、RegExp - 正则对象、Date - 日期对象、Math - 数学函数、Function - 函数对象</li>\n</ul>\n<h3 id=\"数据类型检测\"><a href=\"#数据类型检测\" class=\"headerlink\" title=\"数据类型检测\"></a>数据类型检测</h3><ul>\n<li>typeof 可以判断基本数据类型（null）除外，引用类型除了 Function 外其他不能判断</li>\n<li>instanceof 可以准确判断复杂引用数据类型，不能确定基本类型</li>\n</ul>\n<h4 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">1</span> <span class=\"comment\">// &#x27;number&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;1&#x27;</span> <span class=\"comment\">// &#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> <span class=\"comment\">// &#x27;boolean&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span>() <span class=\"comment\">// &#x27;symbol&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> [] <span class=\"comment\">// &#x27;object&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> &#123;&#125; <span class=\"comment\">// &#x27;object&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">console</span> <span class=\"comment\">// &#x27;object&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 特殊情况</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">console</span>.log <span class=\"comment\">// &#x27;function&#x27; ***</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> <span class=\"comment\">// &#x27;object&#x27; ***</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">1</span>) <span class=\"comment\">// &#x27;object&#x27; ***</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Number</span>(<span class=\"number\">1</span>) <span class=\"comment\">// &#x27;number&#x27; ***</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Array-isArray\"><a href=\"#Array-isArray\" class=\"headerlink\" title=\"Array.isArray()\"></a>Array.isArray()</h4><ul>\n<li>es6检测数据类型</li>\n</ul>\n<h4 id=\"‘-’严格运算符\"><a href=\"#‘-’严格运算符\" class=\"headerlink\" title=\"‘===’严格运算符\"></a>‘===’严格运算符</h4><ul>\n<li>用于判断 null 和 undefined，因为这两种类型的值都是唯一的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a <span class=\"comment\">// object</span></span><br><span class=\"line\">a === <span class=\"literal\">null</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h4><ul>\n<li>instanceof 通过原型链判断类型</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Number</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"number\">1</span>) <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Number</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">1</span>) <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Number</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">1</span>) <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h4><ul>\n<li>与instanceof类似，通过原型链检测</li>\n<li>constructor还可以检测基本类型</li>\n<li>只能检测父级原型链类型</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].constructor === <span class=\"built_in\">Array</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">(<span class=\"string\">&#x27;a&#x27;</span>).constructor === <span class=\"built_in\">String</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">[].constructor === <span class=\"built_in\">Object</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Object-prototype-toString\"><a href=\"#Object-prototype-toString\" class=\"headerlink\" title=\"Object.prototype.toString\"></a>Object.prototype.toString</h4><ul>\n<li>toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串，其中 Xxx 就是对象的类型</li>\n<li>对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString(&#123;&#125;)       <span class=\"comment\">// &quot;[object Object]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(&#123;&#125;)  <span class=\"comment\">// &quot;[object Object]&quot; 同上结果，加上call也ok</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"number\">1</span>)    <span class=\"comment\">// &quot;[object Number]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"string\">&#x27;1&#x27;</span>)  <span class=\"comment\">// &quot;[object String]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">true</span>)  <span class=\"comment\">// &quot;[object Boolean]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)  <span class=\"comment\">// &quot;[object Function]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">null</span>)   <span class=\"comment\">//&quot;[object Null]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">undefined</span>) <span class=\"comment\">//&quot;[object Undefined]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"regexp\">/123/g</span>)    <span class=\"comment\">//&quot;[object RegExp]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()) <span class=\"comment\">//&quot;[object Date]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call([])       <span class=\"comment\">//&quot;[object Array]&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 特殊情况</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"built_in\">window</span>)   <span class=\"comment\">//&quot;[object Window]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"built_in\">document</span>)  <span class=\"comment\">//&quot;[object HTMLDocument]&quot; ***</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>全局通用的数据类型判断方法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getType</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> type  = <span class=\"keyword\">typeof</span> obj;</span><br><span class=\"line\">  <span class=\"comment\">// typeof 判断不是 object 直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type !== <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> type;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(obj).replace(<span class=\"regexp\">/^\\[object (\\S+)\\]$/</span>, <span class=\"string\">&#x27;$1&#x27;</span>).toLowerCase();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><h4 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h4><ul>\n<li>强制类型转换方式包括 Number()、parseInt()、parseFloat()、toString()、String()、Boolean()</li>\n</ul>\n<h5 id=\"Number-方法规则\"><a href=\"#Number-方法规则\" class=\"headerlink\" title=\"Number()方法规则\"></a>Number()方法规则</h5><ul>\n<li>如果是布尔值，true-&gt;1，false-&gt;0</li>\n<li>如果是数字，返回数字自身</li>\n<li>如果是 null，返回 0</li>\n<li>如果是 undefined，返回 NaN</li>\n<li>如果是字符串：字符串中只包含数字（或者是 0X、0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN；</li>\n<li>如果是 Symbol，抛出错误</li>\n<li>如果是对象，依次判断是否有 [Symbol.toPrimitive]、valueOf()、toString() 方法，如果存在，依据前面的规则转换方法返回的值</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">true</span>);        <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">false</span>);       <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">&#x27;0111&#x27;</span>);      <span class=\"comment\">// 111</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">null</span>);        <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">undefined</span>);   <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">&#x27;&#x27;</span>);          <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">&#x27;1a&#x27;</span>);        <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(-<span class=\"number\">0X11</span>);       <span class=\"comment\">// -17</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">&#x27;0x11&#x27;</span>)       <span class=\"comment\">// 17</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"built_in\">Symbol</span>())     <span class=\"comment\">// TypeError: Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;&#125;;</span><br><span class=\"line\">obj1[<span class=\"built_in\">Symbol</span>.toPrimitive] = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj1)); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;&#125;;</span><br><span class=\"line\">obj2.valueOf = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj2)); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj3 = &#123;&#125;;</span><br><span class=\"line\">obj3.toString = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj3)); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Boolean-方法规则\"><a href=\"#Boolean-方法规则\" class=\"headerlink\" title=\"Boolean()方法规则\"></a>Boolean()方法规则</h5><ul>\n<li>除了 undefined、null、false、0（-0、+0）、’’、NaN 转换为false，其他都是 true</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"number\">0</span>)          <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"string\">&#x27;&#x27;</span>)         <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(-<span class=\"number\">0</span>)         <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"literal\">null</span>)       <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"literal\">undefined</span>)  <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"literal\">NaN</span>)        <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>)          <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"number\">13</span>)         <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"string\">&#x27;12&#x27;</span>)       <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"隐式类型转换\"><a href=\"#隐式类型转换\" class=\"headerlink\" title=\"隐式类型转换\"></a>隐式类型转换</h4><ul>\n<li>逻辑运算符 (&amp;&amp;、 ||、 !)、运算符 (+、-、*、/)、关系操作符 (&gt;、 &lt;、 &lt;= 、&gt;=)、相等运算符 (==)、条件操作 (if、while)</li>\n<li>以上操作，遇到数据类型不一致，会发生隐式类型转换</li>\n</ul>\n<h4 id=\"object转换规则\"><a href=\"#object转换规则\" class=\"headerlink\" title=\"object转换规则\"></a>object转换规则</h4><ul>\n<li>依次判断是否有 [Symbol.toPrimitive]、valueOf()、toString() 方法，调用返回</li>\n</ul>\n<h5 id=\"‘-’规则\"><a href=\"#‘-’规则\" class=\"headerlink\" title=\"‘==’规则\"></a>‘==’规则</h5><ul>\n<li>值相同，不进行转换</li>\n<li>其中一个值是 null 或 undefined，另一个值必须是 null 或 undefined 才返回 true，否则返回 false</li>\n<li>其中一个是 Symbol 类型，那么返回 false</li>\n<li>两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number</li>\n<li>如果一个操作值是 boolean，那么转换成 number</li>\n<li>如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（[Symbol.toPrimitive]、valueOf()、toString()）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// null 与 undefined</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">null</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Symbol</span></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>() == <span class=\"literal\">false</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数字与字符串比较</span></span><br><span class=\"line\"><span class=\"number\">1</span> == <span class=\"string\">&#x27;1&#x27;</span> <span class=\"comment\">// true，都转换为数字 -&gt; 1 == 1 -&gt; true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// boolean</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// true，false 转换为 0 -&gt; 0 == &#x27;&#x27;-&gt; 0 == 0 -&gt; true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.valueOf = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj == <span class=\"number\">1</span>); <span class=\"comment\">// true，obj valueOf 转为 1 -&gt; 1 == 1 -&gt; true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NaN 比较</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"‘-’规则-1\"><a href=\"#‘-’规则-1\" class=\"headerlink\" title=\"‘+’规则\"></a>‘+’规则</h5><ul>\n<li>数字 + 数字，加法运算</li>\n<li>字符串 + 字符串，拼接</li>\n<li>数字 + 字符串，拼接</li>\n<li>字符串 + （null、undefined）,toString 后拼接</li>\n<li>数字 + （null、undefined）,转换成数字后加法运算</li>\n<li>数字 + object，根据 Object 转换规则转换后运算</li>\n<li>字符串 + object，根据 Object 转换规则转换后运算</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">1</span> <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"string\">&#x27;1&#x27;</span> + <span class=\"number\">1</span> <span class=\"comment\">// &#x27;11&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;1&#x27;</span> + <span class=\"string\">&#x27;1&#x27;</span> <span class=\"comment\">// &#x27;11&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;1&#x27;</span> + <span class=\"literal\">null</span> <span class=\"comment\">// &#x27;1null&#x27;</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN，Number(undefined) -&gt; NaN</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"literal\">null</span>  <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// obj</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;</span><br><span class=\"line\">obj.toString = <span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&#x27;1&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1</span> + obj <span class=\"comment\">// &#x27;11&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"‘-lt-’、’-gt-’比较\"><a href=\"#‘-lt-’、’-gt-’比较\" class=\"headerlink\" title=\"‘&lt;’、’&gt;’比较\"></a>‘&lt;’、’&gt;’比较</h5><ul>\n<li>都是字符串，按字母顺序比较</li>\n<li>其他情况：比较双方首先调用ToPrimitive，如果结果出现非字符串，就根据ToNumber规则将双方强制类型转换为数字来进行比较</li>\n</ul>\n<h5 id=\"‘-lt-’、’-gt-’比较-1\"><a href=\"#‘-lt-’、’-gt-’比较-1\" class=\"headerlink\" title=\"‘&lt;=’、’&gt;=’比较\"></a>‘&lt;=’、’&gt;=’比较</h5><ul>\n<li>a &lt;= b 被处理为b &lt; a，然后将结果反转</li>\n<li>JavaScript 中&lt;= 是“不大于”的意思（即!(a &gt; b)，处理为!(b &lt; a)）。同理a &gt;= b 处理为b &lt;= a</li>\n</ul>\n<h3 id=\"其他参考\"><a href=\"#其他参考\" class=\"headerlink\" title=\"其他参考\"></a>其他参考</h3><ul>\n<li><a href=\"https://crazyaguai.github.io/2019/03/03/[js]%E7%B1%BB%E5%9E%8B/\">https://crazyaguai.github.io/2019/03/03/[js]%E7%B1%BB%E5%9E%8B/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h3><ul>\n<li>string、number、boolean、null、undefined、symbol、bigInt、object</li>\n</ul>\n<h4 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h4><ul>\n<li>基础类型存储在栈内存，被引用或拷贝时，会创建一个完全相等的变量</li>\n<li>string、number、boolean、null、undefined、symbol、bigInt</li>\n</ul>\n<h4 id=\"引用类型\"><a href=\"#引用类型\" class=\"headerlink\" title=\"引用类型\"></a>引用类型</h4><ul>\n<li>引用类型存储在堆内存，存储的是地址，多个引用指向同一个地址</li>\n<li>object，引用类型又分为以下常见的数据类型：Array - 数组对象、RegExp - 正则对象、Date - 日期对象、Math - 数学函数、Function - 函数对象</li>\n</ul>\n<h3 id=\"数据类型检测\"><a href=\"#数据类型检测\" class=\"headerlink\" title=\"数据类型检测\"></a>数据类型检测</h3><ul>\n<li>typeof 可以判断基本数据类型（null）除外，引用类型除了 Function 外其他不能判断</li>\n<li>instanceof 可以准确判断复杂引用数据类型，不能确定基本类型</li>\n</ul>\n<h4 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"number\">1</span> <span class=\"comment\">// &#x27;number&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"string\">&#x27;1&#x27;</span> <span class=\"comment\">// &#x27;string&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">undefined</span> <span class=\"comment\">// &#x27;undefined&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">true</span> <span class=\"comment\">// &#x27;boolean&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Symbol</span>() <span class=\"comment\">// &#x27;symbol&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> [] <span class=\"comment\">// &#x27;object&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> &#123;&#125; <span class=\"comment\">// &#x27;object&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">console</span> <span class=\"comment\">// &#x27;object&#x27;</span></span><br><span class=\"line\"><span class=\"comment\">// 特殊情况</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">console</span>.log <span class=\"comment\">// &#x27;function&#x27; ***</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"literal\">null</span> <span class=\"comment\">// &#x27;object&#x27; ***</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">1</span>) <span class=\"comment\">// &#x27;object&#x27; ***</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> <span class=\"built_in\">Number</span>(<span class=\"number\">1</span>) <span class=\"comment\">// &#x27;number&#x27; ***</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Array-isArray\"><a href=\"#Array-isArray\" class=\"headerlink\" title=\"Array.isArray()\"></a>Array.isArray()</h4><ul>\n<li>es6检测数据类型</li>\n</ul>\n<h4 id=\"‘-’严格运算符\"><a href=\"#‘-’严格运算符\" class=\"headerlink\" title=\"‘===’严格运算符\"></a>‘===’严格运算符</h4><ul>\n<li>用于判断 null 和 undefined，因为这两种类型的值都是唯一的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> a = <span class=\"literal\">null</span></span><br><span class=\"line\"><span class=\"keyword\">typeof</span> a <span class=\"comment\">// object</span></span><br><span class=\"line\">a === <span class=\"literal\">null</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h4><ul>\n<li>instanceof 通过原型链判断类型</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Number</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"number\">1</span>) <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Number</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">1</span>) <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Number</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"keyword\">new</span> <span class=\"built_in\">Number</span>(<span class=\"number\">1</span>) <span class=\"keyword\">instanceof</span> <span class=\"built_in\">Object</span> <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h4><ul>\n<li>与instanceof类似，通过原型链检测</li>\n<li>constructor还可以检测基本类型</li>\n<li>只能检测父级原型链类型</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[].constructor === <span class=\"built_in\">Array</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">(<span class=\"string\">&#x27;a&#x27;</span>).constructor === <span class=\"built_in\">String</span> <span class=\"comment\">// true</span></span><br><span class=\"line\">[].constructor === <span class=\"built_in\">Object</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Object-prototype-toString\"><a href=\"#Object-prototype-toString\" class=\"headerlink\" title=\"Object.prototype.toString\"></a>Object.prototype.toString</h4><ul>\n<li>toString() 是 Object 的原型方法，调用该方法，可以统一返回格式为 “[object Xxx]” 的字符串，其中 Xxx 就是对象的类型</li>\n<li>对于 Object 对象，直接调用 toString() 就能返回 [object Object]；而对于其他对象，则需要通过 call 来调用，才能返回正确的类型信息</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString(&#123;&#125;)       <span class=\"comment\">// &quot;[object Object]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(&#123;&#125;)  <span class=\"comment\">// &quot;[object Object]&quot; 同上结果，加上call也ok</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"number\">1</span>)    <span class=\"comment\">// &quot;[object Number]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"string\">&#x27;1&#x27;</span>)  <span class=\"comment\">// &quot;[object String]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">true</span>)  <span class=\"comment\">// &quot;[object Boolean]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\"></span>)</span>&#123;&#125;)  <span class=\"comment\">// &quot;[object Function]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">null</span>)   <span class=\"comment\">//&quot;[object Null]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"literal\">undefined</span>) <span class=\"comment\">//&quot;[object Undefined]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"regexp\">/123/g</span>)    <span class=\"comment\">//&quot;[object RegExp]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>()) <span class=\"comment\">//&quot;[object Date]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call([])       <span class=\"comment\">//&quot;[object Array]&quot;</span></span><br><span class=\"line\"><span class=\"comment\">// 特殊情况</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"built_in\">window</span>)   <span class=\"comment\">//&quot;[object Window]&quot;</span></span><br><span class=\"line\"><span class=\"built_in\">Object</span>.prototype.toString.call(<span class=\"built_in\">document</span>)  <span class=\"comment\">//&quot;[object HTMLDocument]&quot; ***</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>全局通用的数据类型判断方法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getType</span>(<span class=\"params\">obj</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> type  = <span class=\"keyword\">typeof</span> obj;</span><br><span class=\"line\">  <span class=\"comment\">// typeof 判断不是 object 直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (type !== <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> type;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 对于typeof返回结果是object的，再进行如下的判断，正则返回结果</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">Object</span>.prototype.toString.call(obj).replace(<span class=\"regexp\">/^\\[object (\\S+)\\]$/</span>, <span class=\"string\">&#x27;$1&#x27;</span>).toLowerCase();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"类型转换\"><a href=\"#类型转换\" class=\"headerlink\" title=\"类型转换\"></a>类型转换</h3><h4 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h4><ul>\n<li>强制类型转换方式包括 Number()、parseInt()、parseFloat()、toString()、String()、Boolean()</li>\n</ul>\n<h5 id=\"Number-方法规则\"><a href=\"#Number-方法规则\" class=\"headerlink\" title=\"Number()方法规则\"></a>Number()方法规则</h5><ul>\n<li>如果是布尔值，true-&gt;1，false-&gt;0</li>\n<li>如果是数字，返回数字自身</li>\n<li>如果是 null，返回 0</li>\n<li>如果是 undefined，返回 NaN</li>\n<li>如果是字符串：字符串中只包含数字（或者是 0X、0x 开头的十六进制数字字符串，允许包含正负号），则将其转换为十进制；如果字符串中包含有效的浮点格式，将其转换为浮点数值；如果是空字符串，将其转换为 0；如果不是以上格式的字符串，均返回 NaN；</li>\n<li>如果是 Symbol，抛出错误</li>\n<li>如果是对象，依次判断是否有 [Symbol.toPrimitive]、valueOf()、toString() 方法，如果存在，依据前面的规则转换方法返回的值</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">true</span>);        <span class=\"comment\">// 1</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">false</span>);       <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">&#x27;0111&#x27;</span>);      <span class=\"comment\">// 111</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">null</span>);        <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"literal\">undefined</span>);   <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">&#x27;&#x27;</span>);          <span class=\"comment\">// 0</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">&#x27;1a&#x27;</span>);        <span class=\"comment\">// NaN</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(-<span class=\"number\">0X11</span>);       <span class=\"comment\">// -17</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"string\">&#x27;0x11&#x27;</span>)       <span class=\"comment\">// 17</span></span><br><span class=\"line\"><span class=\"built_in\">Number</span>(<span class=\"built_in\">Symbol</span>())     <span class=\"comment\">// TypeError: Cannot convert a Symbol value to a number</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;&#125;;</span><br><span class=\"line\">obj1[<span class=\"built_in\">Symbol</span>.toPrimitive] = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj1)); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;&#125;;</span><br><span class=\"line\">obj2.valueOf = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj2)); <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj3 = &#123;&#125;;</span><br><span class=\"line\">obj3.toString = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">Number</span>(obj3)); <span class=\"comment\">//1</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"Boolean-方法规则\"><a href=\"#Boolean-方法规则\" class=\"headerlink\" title=\"Boolean()方法规则\"></a>Boolean()方法规则</h5><ul>\n<li>除了 undefined、null、false、0（-0、+0）、’’、NaN 转换为false，其他都是 true</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"number\">0</span>)          <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"string\">&#x27;&#x27;</span>)         <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(-<span class=\"number\">0</span>)         <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"literal\">null</span>)       <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"literal\">undefined</span>)  <span class=\"comment\">// false</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"literal\">NaN</span>)        <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"number\">1</span>)          <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"number\">13</span>)         <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"built_in\">Boolean</span>(<span class=\"string\">&#x27;12&#x27;</span>)       <span class=\"comment\">// true</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"隐式类型转换\"><a href=\"#隐式类型转换\" class=\"headerlink\" title=\"隐式类型转换\"></a>隐式类型转换</h4><ul>\n<li>逻辑运算符 (&amp;&amp;、 ||、 !)、运算符 (+、-、*、/)、关系操作符 (&gt;、 &lt;、 &lt;= 、&gt;=)、相等运算符 (==)、条件操作 (if、while)</li>\n<li>以上操作，遇到数据类型不一致，会发生隐式类型转换</li>\n</ul>\n<h4 id=\"object转换规则\"><a href=\"#object转换规则\" class=\"headerlink\" title=\"object转换规则\"></a>object转换规则</h4><ul>\n<li>依次判断是否有 [Symbol.toPrimitive]、valueOf()、toString() 方法，调用返回</li>\n</ul>\n<h5 id=\"‘-’规则\"><a href=\"#‘-’规则\" class=\"headerlink\" title=\"‘==’规则\"></a>‘==’规则</h5><ul>\n<li>值相同，不进行转换</li>\n<li>其中一个值是 null 或 undefined，另一个值必须是 null 或 undefined 才返回 true，否则返回 false</li>\n<li>其中一个是 Symbol 类型，那么返回 false</li>\n<li>两个操作值如果为 string 和 number 类型，那么就会将字符串转换为 number</li>\n<li>如果一个操作值是 boolean，那么转换成 number</li>\n<li>如果一个操作值为 object 且另一方为 string、number 或者 symbol，就会把 object 转为原始类型再进行判断（[Symbol.toPrimitive]、valueOf()、toString()）</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// null 与 undefined</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">undefined</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"literal\">null</span> <span class=\"comment\">// true</span></span><br><span class=\"line\"><span class=\"literal\">null</span> == <span class=\"number\">0</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Symbol</span></span><br><span class=\"line\"><span class=\"built_in\">Symbol</span>() == <span class=\"literal\">false</span> <span class=\"comment\">// false</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 数字与字符串比较</span></span><br><span class=\"line\"><span class=\"number\">1</span> == <span class=\"string\">&#x27;1&#x27;</span> <span class=\"comment\">// true，都转换为数字 -&gt; 1 == 1 -&gt; true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// boolean</span></span><br><span class=\"line\"><span class=\"literal\">false</span> == <span class=\"string\">&#x27;&#x27;</span> <span class=\"comment\">// true，false 转换为 0 -&gt; 0 == &#x27;&#x27;-&gt; 0 == 0 -&gt; true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// object</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;;</span><br><span class=\"line\">obj.valueOf = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(obj == <span class=\"number\">1</span>); <span class=\"comment\">// true，obj valueOf 转为 1 -&gt; 1 == 1 -&gt; true</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// NaN 比较</span></span><br><span class=\"line\"><span class=\"literal\">NaN</span> == <span class=\"literal\">NaN</span> <span class=\"comment\">// false</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"‘-’规则-1\"><a href=\"#‘-’规则-1\" class=\"headerlink\" title=\"‘+’规则\"></a>‘+’规则</h5><ul>\n<li>数字 + 数字，加法运算</li>\n<li>字符串 + 字符串，拼接</li>\n<li>数字 + 字符串，拼接</li>\n<li>字符串 + （null、undefined）,toString 后拼接</li>\n<li>数字 + （null、undefined）,转换成数字后加法运算</li>\n<li>数字 + object，根据 Object 转换规则转换后运算</li>\n<li>字符串 + object，根据 Object 转换规则转换后运算</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span> + <span class=\"number\">1</span> <span class=\"comment\">// 2</span></span><br><span class=\"line\"><span class=\"string\">&#x27;1&#x27;</span> + <span class=\"number\">1</span> <span class=\"comment\">// &#x27;11&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;1&#x27;</span> + <span class=\"string\">&#x27;1&#x27;</span> <span class=\"comment\">// &#x27;11&#x27;</span></span><br><span class=\"line\"><span class=\"string\">&#x27;1&#x27;</span> + <span class=\"literal\">null</span> <span class=\"comment\">// &#x27;1null&#x27;</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"literal\">undefined</span> <span class=\"comment\">// NaN，Number(undefined) -&gt; NaN</span></span><br><span class=\"line\"><span class=\"number\">1</span> + <span class=\"literal\">null</span>  <span class=\"comment\">// 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// obj</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;&#125;</span><br><span class=\"line\">obj.toString = <span class=\"function\">()=&gt;</span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"string\">&#x27;1&#x27;</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"number\">1</span> + obj <span class=\"comment\">// &#x27;11&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<h5 id=\"‘-lt-’、’-gt-’比较\"><a href=\"#‘-lt-’、’-gt-’比较\" class=\"headerlink\" title=\"‘&lt;’、’&gt;’比较\"></a>‘&lt;’、’&gt;’比较</h5><ul>\n<li>都是字符串，按字母顺序比较</li>\n<li>其他情况：比较双方首先调用ToPrimitive，如果结果出现非字符串，就根据ToNumber规则将双方强制类型转换为数字来进行比较</li>\n</ul>\n<h5 id=\"‘-lt-’、’-gt-’比较-1\"><a href=\"#‘-lt-’、’-gt-’比较-1\" class=\"headerlink\" title=\"‘&lt;=’、’&gt;=’比较\"></a>‘&lt;=’、’&gt;=’比较</h5><ul>\n<li>a &lt;= b 被处理为b &lt; a，然后将结果反转</li>\n<li>JavaScript 中&lt;= 是“不大于”的意思（即!(a &gt; b)，处理为!(b &lt; a)）。同理a &gt;= b 处理为b &lt;= a</li>\n</ul>\n<h3 id=\"其他参考\"><a href=\"#其他参考\" class=\"headerlink\" title=\"其他参考\"></a>其他参考</h3><ul>\n<li><a href=\"https://crazyaguai.github.io/2019/03/03/[js]%E7%B1%BB%E5%9E%8B/\">https://crazyaguai.github.io/2019/03/03/[js]%E7%B1%BB%E5%9E%8B/</a></li>\n</ul>\n"},{"title":"<js>正则表达式","date":"2019-03-19T16:00:00.000Z","_content":"\n### 模糊匹配\n\n- 横向模糊匹配：长度不固定，比如{m,n}最少出现m次最多出现n次\n- 纵向模糊匹配：某一位置字符多种可能，比如[\\w]\n\n\n### 修饰符\n\n- g全局匹配\n- i不区分大小写，默认大小写敏感\n- m匹配多行\n\n```\nlet str =\n`aA\nA\n`.replace(/a/igm,'B')\nconsole.log(str)\n// `BB\n// b`\n```\n\n### 元字符\n- \\t 水平制表符tab\n- \\v 垂直制表符\n- \\n 换行符\n- \\r 回车符\n- \\0 空字符\n- \\f 换页符\n- \\cX ctrl+X\n\n### 字符类（字符组）\n\n- 使用[]创建一个字符类\n\n```\nconsole.log('1b2'.replace(/[abc]/g,'3'))//132\n```\n\n- 使用^符号（脱字符）字符类取反，即排除字符组\n\n```\nconsole.log('1b2'.replace(/[^abc]/g,'3'))//3b3\n```\n\n### 范围类\n\n- [a-zA-Z0-9]\n- 范围类中想包含-符号[a-z-]\n\n```\nconsole.log('a-'.replace(/[a-z-]/g,'1'))//11\n```\n\n### 预定义的范围类\n\n- . 除了回车和换行符之外的所有字符--[^\\n\\r]\n- \\d 数字字符--[0-9]，digit（数字）\n- \\D 非数字字符--[^0-9]\n- \\s 空白符--[\\t\\n\\x0B\\f\\r]，space（空格）\n- \\S 非空白符--[^\\t\\n\\x0B\\f\\r]\n- \\w 单词字符，字母、数字、下划线--[a-zA-Z_0-9]，word（单词）\n- \\W 非单词字符--[^a-zA-Z_0-9]\n- . 通配符[^\\n\\t\\u2028\\u2029]，表示换行符、回车符、行分隔符、段分隔符之外的任意字符\n\n- 如果想**匹配任意字符**可以使用：[\\d\\D],[\\w\\W],[\\s\\S],[^]中任意一个\n\n### 位置匹配\n\n- 位置（锚）是指相邻字符串之间的位置\n- ES5中有6个锚：^,$,\\b,\\B,(?=p),(?!p)\n\n#### 边界\n\n- ^ 以XXX开始\n\n```\nconsole.log('abc'.replace(/^[abc]/,'A'))//Abc\n```\n\n- $ 以XXX结束\n\n```\nconsole.log('abc'.replace(/[abc]$/,'A'))//abA\n```\n\n- \\b 单词边界\n\n```\nconsole.log('Are you youOK'.replace(/you\\b/,'YOU'))//Are YOU youOK\n```\n\n- \\B 非单词边界\n\n```\nconsole.log('Are you youOK'.replace(/you\\B/,'YOU'))//Are you YOUOK\n```\n\n#### 前瞻&后顾\n\n- (?=p) 表示p前面的位置，该位置后边的字符匹配p，可以理解为存在一个位置，该位置后边的字符与p匹配，正向先行断言\n- (?!p) 是(?=p)反面的意思，负向先行断言\n- 正则表达式从文本头部向尾部解析，文本尾部称为'前'，前瞻就是匹配规则时候向前（尾部方向）检查是否断言\n- js正则不支持后顾\n- exp(?=asset) 正向前瞻（符合断言）\n\n```\nconsole.log('a2aa'.replace(/\\w(?=\\d)/g,'X'))//X2aa\n```\n\n- exp(?!asset) 负向前瞻（不符合断言）\n\n```\nconsole.log('a2aa'.replace(/\\w(?!\\d)/g,'X'))//aXXX\n```\n\n### 量词\n\n- ? 出现0次或者一次（最多一次）\n- \\+ 出现一次或者多次（最少出现一次）\n- \\* 0次或者多次（任意次）\n- {n} 出现n次\n- {n,m} n-m次\n- {n,} 最少出现n次\n\n```\nconsole.log('aabbcc'.replace(/[abc]{2}/g,'A'))//AAA\n```\n\n### 贪婪模式与非贪婪模式\n\n- 贪婪模式，js正则默认贪婪模式\n\n```\nconsole.log('aaa'.replace(/a+/g,'A'))//A\n```\n\n- 非贪婪模式，尽可能少的匹配，一旦匹配成功就不再进行尝试\n- 非贪婪模式需要在量词后边加 ?\n- {m.n}?,{m,}?,+?,*?,??\n\n```\nconsole.log('aaa'.replace(/a+?/g,'A'))//AAA\n```\n\n### 分组\n\n- 使用()可以实现分组\n\n```\nconsole.log('ababc'.replace(/(ab){2}/g,'A'))//Ac\n```\n\n#### 或（多选分支）\n\n- |\n\n- 分支结构是惰性的，前边的匹配之后，后边的就不在尝试了\n\n```\nconsole.log('abcadc'.replace(/a(b|d)c/g,'A'))//AA\n```\n\n#### 反向引用\n\n- 分组后使用$1、$2...\n\n```\nconsole.log('2012-11-01'.replace(/(\\d{4})-(\\d{2})-(\\d{2})/,'$3/$2/$1'))//01/11/2012\n```\n\n- 正则表达式中使用\\1,\\2,\\3引用分组\n- \\10表示第十个分组，如果想匹配\\1和0使用(?:\\1)0,\\1(?:0)\n- 引用不存在的分组不会报错，会匹配反向引用字符串本身\n\n```\nconsole.log('aa'.replace(/([a])\\1/,'b'))//b\n```\n\n#### 分组括号嵌套\n\n```\nvar regex = /^((\\d)(\\d(\\d)))\\1\\2\\3\\4$/;\nvar string = \"1231231233\";\nconsole.log( regex.test(string) ); // true\nconsole.log( RegExp.$1 ); // 123,第一个括号对应的\nconsole.log( RegExp.$2 ); // 1，第二个括号对应的\nconsole.log( RegExp.$3 ); // 23，。。。\nconsole.log( RegExp.$4 ); // 3，。。。\n```\n\n#### 忽略分组（非捕获括号）\n\n- 在分组内加上 ?: 即(?:)\n\n```\nconsole.log('2012-11-01'.replace(/(?:\\d{4})-(\\d{2})-(\\d{2})/,'$3/$2/$1'))//$3/11/2012\n```\n\n#### 分组后边有量词\n\n- 分组后边有量词，分组最终捕获最后一次的匹配\n\n```\nlet r = /(\\d){1,4}/\nconsole.log('123456'.match(r))// [\"1234\", \"4\", index: 0, input: \"123456\", groups: undefined]\n```\n\n### 正则表达式回溯法\n\n- 尝试匹配失败时，会退回之前的一步，本质是深度优先算法\n\n#### 产生回溯\n\n- 贪婪量词，{2,4}因为是贪婪的，所以先会尝试尽可能多的匹配\n- 惰性量词，匹配少了，不够会回溯，'12345'.match(/^(\\d{1,3}?)(\\d{1,3})$/)，第一个分组会先尝试匹配一个，但是第二个就不能匹配，于是尝试两个、三个。。。\n- 分支结构，'123'.match(/^(12|123)$/)\n\n### 拆分正则\n\n#### 优先级\n\n- 转义符\\  >  括号和方括号  >  量词  >  位置和序列（位置、一般字符）  >  管道符\n\n#### 注意要点\n\n- 匹配字符串整体/^(a|b)$/而不是/^a|b&/\n- 量词连续：/[abc]{3}+/会报错，应该写成/([abc]{3})+/\n- 元字符转义问题：^,$,.,*,+,?,|,\\,/,(,),[,],{,},=,!,:,-\n\n### 对象属性\n\n- global\\ignoreCase\\multiline\\lastIndex\\source\n\n```\nlet reg1 = /\\w/igm\nconsole.log(reg1.global)//true\nconsole.log(reg1.ignoreCase)//true\nconsole.log(reg1.multiline)//true\nconsole.log(reg1.lastIndex)//0 当前匹配结果最后一个字符的下一个字符\nconsole.log(reg1.source)//\\w\n```\n\n### 正则表达式方法\n\n#### test()\n\n- RegExp.prototype.test(str) 检测字符串参数中是否存在匹配正则表达式模式的字符串\n- 存在返回true不存在返回false\n- 注意如果包含全局匹配g那么结果会受到lastIndex影响\n\n```\nlet reg2 = /\\w/g\nconsole.log(reg2.test('ab'))//true\nconsole.log(reg2.lastIndex)//1\nconsole.log(reg2.test('ab'))//true\nconsole.log(reg2.lastIndex)//2\nconsole.log(reg2.test('ab'))//false\nconsole.log(reg2.lastIndex)//0\n```\n\n#### exec()\n\n- RegExp.prototype.exec(str)\n- 使用正则表达式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果\n- 如果没有匹配文本返回null，否则返回一个结果的数组\n- 返回的数组有两个属性index声明第一个匹配字符的位置、input存放被检索的字符串string\n- 非全局调用返回的数组：第一项是与正则表达式匹配的文本、第二项（以及以后项）是与分组匹配的文本\n- 非全局匹配lastindex为0，全局匹配每次调用lastIndex会增加\n\n```\nlet reg3 = /\\d(\\w)(\\w)\\d/\nlet res1 = reg3.exec('1aa21aa2')//第一次\nconsole.log(res1.index + '\\t' + reg3.lastIndex + '\\t' + res1.toString())//0\t0\t1aa2,a,a\nlet res2 = reg3.exec('1aa21aa2')//第二次，lastIndex没有变化\nconsole.log(res2.index + '\\t' + reg3.lastIndex + '\\t' + res2.toString())//0\t0\t1aa2,a,a\n```\n\n- 全局搜索\n\n```\nlet reg4 = /\\d(\\w)(\\w)\\d/g\nlet r1 = reg4.exec('1aa23bb4')//第一次\nconsole.log(r1.index + '\\t' + reg4.lastIndex + '\\t' + r1.toString())//0\t0\t1aa2,a,a\nlet r2 = reg4.exec('1aa23bb4')//第二次\nconsole.log(r2.index + '\\t' + reg4.lastIndex + '\\t' + r2.toString())//4\t0\t3bb4,b,b\nlet r3 = reg4.exec('1aa23bb4')//第三次\nconsole.log(reg4.lastIndex,r3)//0 null\n```\n\n### 字符串对象的方法\n\n#### search()\n\n- String.prototype.search(reg)，返回第一个匹配结果的index，查找不到返回-1，忽略g标志，总是从开始匹配。\n- search会把字符串转换为正则匹配\n\n```\nconsole.log('aaa'.search('.'))//0，转换为正则匹配\nconsole.log('abc'.search(/[abc]/g))//0\nconsole.log('abc'.search(/[abc]/g))//0\n```\n\n#### match()\n\n- String.prototype.match(reg) 检索字符串，以找到一个或者多个与正则匹配的文本 是否有标志g对结果影响很大\n- match会把字符串转换为正则匹配\n- 非全局调用，返回数组第一个元素存放匹配的文本，其余元素是与正则的子表达式匹配的文本，还有两个对象属性index、input\n\n```\nlet str1 = '1aa21aa2'\nlet reg5 = /\\d(\\w)(\\w)\\d/\nlet re1 = str1.match(reg5)//第一次\nconsole.log(re1.index + '\\t' + reg5.lastIndex + '\\t' + re1.toString())//0\t0\t1aa2,a,a\nlet re2 = str1.match(reg5)//第二次\nconsole.log(re2.index + '\\t' + reg5.lastIndex + '\\t' + re2.toString())//0\t0\t1aa2,a,a\n```\n\n- 全局调用，返回数组中包含所有匹配的字符串，没有找到返回null，没有index、input属性\n\n```\nlet str2 = '1aa21aa2'\nlet reg6 = /\\d(\\w)(\\w)\\d/g\nlet re3 = str1.match(reg6)\nconsole.log(re3.index + '\\t' + reg6.lastIndex + '\\t' + re3.toString())//undefined\t0\t1aa2,1aa2\n```\n\n#### split()\n\n- String.prototype.split(reg)\n- 存在第二个参数，表示结果数组最大长度\n\n```\nconsole.log('1a2b3c4d'.split(/\\d/g))//['',a,b,c,d]\n```\n\n- 正则使用分组时，结果包含分隔符\n\n```\nconsole.log('abc'.split(/(\\w)/g))// [\"\", \"a\", \"\", \"b\", \"\", \"c\", \"\"]\n```\n\n#### replace()\n\n- String.prototype.replace(reg)\n\n```\nconsole.log('aabc'.replace('a','1'))//1abc 转换为/a/正则\nconsole.log('aabc'.replace(/a/g,'1'))//11bc\n```\n\n- 传第二个函数参数function有四个参数：匹配字符串、正则表达式分组内容(没有分组就没这个参数)、匹配项的index、原字符串\n\n```\nconsole.log('a1b2c3d4'.replace(/\\d/g,function (match,index,str) {\n    return parseInt(match) + 1\n}))//a2b3c4d5\nconsole.log('a1b2c3d4'.replace(/(\\d)/g,function (match,group,index,str) {\n    console.log(group)\n    return parseInt(match) + 1\n}))//a2b3c4d5\n//有分组情况\n'abc'.replace(/(\\w)(\\w)/g,function (match,$1,$2,index,str) {\n    return match\n})\n```\n","source":"_posts/[js]正则表达式.md","raw":"---\ntitle: <js>正则表达式\ndate: 2019-03-20 00:00:00\ntags: [js,正则表达式]\ncategories: js\n---\n\n### 模糊匹配\n\n- 横向模糊匹配：长度不固定，比如{m,n}最少出现m次最多出现n次\n- 纵向模糊匹配：某一位置字符多种可能，比如[\\w]\n\n\n### 修饰符\n\n- g全局匹配\n- i不区分大小写，默认大小写敏感\n- m匹配多行\n\n```\nlet str =\n`aA\nA\n`.replace(/a/igm,'B')\nconsole.log(str)\n// `BB\n// b`\n```\n\n### 元字符\n- \\t 水平制表符tab\n- \\v 垂直制表符\n- \\n 换行符\n- \\r 回车符\n- \\0 空字符\n- \\f 换页符\n- \\cX ctrl+X\n\n### 字符类（字符组）\n\n- 使用[]创建一个字符类\n\n```\nconsole.log('1b2'.replace(/[abc]/g,'3'))//132\n```\n\n- 使用^符号（脱字符）字符类取反，即排除字符组\n\n```\nconsole.log('1b2'.replace(/[^abc]/g,'3'))//3b3\n```\n\n### 范围类\n\n- [a-zA-Z0-9]\n- 范围类中想包含-符号[a-z-]\n\n```\nconsole.log('a-'.replace(/[a-z-]/g,'1'))//11\n```\n\n### 预定义的范围类\n\n- . 除了回车和换行符之外的所有字符--[^\\n\\r]\n- \\d 数字字符--[0-9]，digit（数字）\n- \\D 非数字字符--[^0-9]\n- \\s 空白符--[\\t\\n\\x0B\\f\\r]，space（空格）\n- \\S 非空白符--[^\\t\\n\\x0B\\f\\r]\n- \\w 单词字符，字母、数字、下划线--[a-zA-Z_0-9]，word（单词）\n- \\W 非单词字符--[^a-zA-Z_0-9]\n- . 通配符[^\\n\\t\\u2028\\u2029]，表示换行符、回车符、行分隔符、段分隔符之外的任意字符\n\n- 如果想**匹配任意字符**可以使用：[\\d\\D],[\\w\\W],[\\s\\S],[^]中任意一个\n\n### 位置匹配\n\n- 位置（锚）是指相邻字符串之间的位置\n- ES5中有6个锚：^,$,\\b,\\B,(?=p),(?!p)\n\n#### 边界\n\n- ^ 以XXX开始\n\n```\nconsole.log('abc'.replace(/^[abc]/,'A'))//Abc\n```\n\n- $ 以XXX结束\n\n```\nconsole.log('abc'.replace(/[abc]$/,'A'))//abA\n```\n\n- \\b 单词边界\n\n```\nconsole.log('Are you youOK'.replace(/you\\b/,'YOU'))//Are YOU youOK\n```\n\n- \\B 非单词边界\n\n```\nconsole.log('Are you youOK'.replace(/you\\B/,'YOU'))//Are you YOUOK\n```\n\n#### 前瞻&后顾\n\n- (?=p) 表示p前面的位置，该位置后边的字符匹配p，可以理解为存在一个位置，该位置后边的字符与p匹配，正向先行断言\n- (?!p) 是(?=p)反面的意思，负向先行断言\n- 正则表达式从文本头部向尾部解析，文本尾部称为'前'，前瞻就是匹配规则时候向前（尾部方向）检查是否断言\n- js正则不支持后顾\n- exp(?=asset) 正向前瞻（符合断言）\n\n```\nconsole.log('a2aa'.replace(/\\w(?=\\d)/g,'X'))//X2aa\n```\n\n- exp(?!asset) 负向前瞻（不符合断言）\n\n```\nconsole.log('a2aa'.replace(/\\w(?!\\d)/g,'X'))//aXXX\n```\n\n### 量词\n\n- ? 出现0次或者一次（最多一次）\n- \\+ 出现一次或者多次（最少出现一次）\n- \\* 0次或者多次（任意次）\n- {n} 出现n次\n- {n,m} n-m次\n- {n,} 最少出现n次\n\n```\nconsole.log('aabbcc'.replace(/[abc]{2}/g,'A'))//AAA\n```\n\n### 贪婪模式与非贪婪模式\n\n- 贪婪模式，js正则默认贪婪模式\n\n```\nconsole.log('aaa'.replace(/a+/g,'A'))//A\n```\n\n- 非贪婪模式，尽可能少的匹配，一旦匹配成功就不再进行尝试\n- 非贪婪模式需要在量词后边加 ?\n- {m.n}?,{m,}?,+?,*?,??\n\n```\nconsole.log('aaa'.replace(/a+?/g,'A'))//AAA\n```\n\n### 分组\n\n- 使用()可以实现分组\n\n```\nconsole.log('ababc'.replace(/(ab){2}/g,'A'))//Ac\n```\n\n#### 或（多选分支）\n\n- |\n\n- 分支结构是惰性的，前边的匹配之后，后边的就不在尝试了\n\n```\nconsole.log('abcadc'.replace(/a(b|d)c/g,'A'))//AA\n```\n\n#### 反向引用\n\n- 分组后使用$1、$2...\n\n```\nconsole.log('2012-11-01'.replace(/(\\d{4})-(\\d{2})-(\\d{2})/,'$3/$2/$1'))//01/11/2012\n```\n\n- 正则表达式中使用\\1,\\2,\\3引用分组\n- \\10表示第十个分组，如果想匹配\\1和0使用(?:\\1)0,\\1(?:0)\n- 引用不存在的分组不会报错，会匹配反向引用字符串本身\n\n```\nconsole.log('aa'.replace(/([a])\\1/,'b'))//b\n```\n\n#### 分组括号嵌套\n\n```\nvar regex = /^((\\d)(\\d(\\d)))\\1\\2\\3\\4$/;\nvar string = \"1231231233\";\nconsole.log( regex.test(string) ); // true\nconsole.log( RegExp.$1 ); // 123,第一个括号对应的\nconsole.log( RegExp.$2 ); // 1，第二个括号对应的\nconsole.log( RegExp.$3 ); // 23，。。。\nconsole.log( RegExp.$4 ); // 3，。。。\n```\n\n#### 忽略分组（非捕获括号）\n\n- 在分组内加上 ?: 即(?:)\n\n```\nconsole.log('2012-11-01'.replace(/(?:\\d{4})-(\\d{2})-(\\d{2})/,'$3/$2/$1'))//$3/11/2012\n```\n\n#### 分组后边有量词\n\n- 分组后边有量词，分组最终捕获最后一次的匹配\n\n```\nlet r = /(\\d){1,4}/\nconsole.log('123456'.match(r))// [\"1234\", \"4\", index: 0, input: \"123456\", groups: undefined]\n```\n\n### 正则表达式回溯法\n\n- 尝试匹配失败时，会退回之前的一步，本质是深度优先算法\n\n#### 产生回溯\n\n- 贪婪量词，{2,4}因为是贪婪的，所以先会尝试尽可能多的匹配\n- 惰性量词，匹配少了，不够会回溯，'12345'.match(/^(\\d{1,3}?)(\\d{1,3})$/)，第一个分组会先尝试匹配一个，但是第二个就不能匹配，于是尝试两个、三个。。。\n- 分支结构，'123'.match(/^(12|123)$/)\n\n### 拆分正则\n\n#### 优先级\n\n- 转义符\\  >  括号和方括号  >  量词  >  位置和序列（位置、一般字符）  >  管道符\n\n#### 注意要点\n\n- 匹配字符串整体/^(a|b)$/而不是/^a|b&/\n- 量词连续：/[abc]{3}+/会报错，应该写成/([abc]{3})+/\n- 元字符转义问题：^,$,.,*,+,?,|,\\,/,(,),[,],{,},=,!,:,-\n\n### 对象属性\n\n- global\\ignoreCase\\multiline\\lastIndex\\source\n\n```\nlet reg1 = /\\w/igm\nconsole.log(reg1.global)//true\nconsole.log(reg1.ignoreCase)//true\nconsole.log(reg1.multiline)//true\nconsole.log(reg1.lastIndex)//0 当前匹配结果最后一个字符的下一个字符\nconsole.log(reg1.source)//\\w\n```\n\n### 正则表达式方法\n\n#### test()\n\n- RegExp.prototype.test(str) 检测字符串参数中是否存在匹配正则表达式模式的字符串\n- 存在返回true不存在返回false\n- 注意如果包含全局匹配g那么结果会受到lastIndex影响\n\n```\nlet reg2 = /\\w/g\nconsole.log(reg2.test('ab'))//true\nconsole.log(reg2.lastIndex)//1\nconsole.log(reg2.test('ab'))//true\nconsole.log(reg2.lastIndex)//2\nconsole.log(reg2.test('ab'))//false\nconsole.log(reg2.lastIndex)//0\n```\n\n#### exec()\n\n- RegExp.prototype.exec(str)\n- 使用正则表达式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果\n- 如果没有匹配文本返回null，否则返回一个结果的数组\n- 返回的数组有两个属性index声明第一个匹配字符的位置、input存放被检索的字符串string\n- 非全局调用返回的数组：第一项是与正则表达式匹配的文本、第二项（以及以后项）是与分组匹配的文本\n- 非全局匹配lastindex为0，全局匹配每次调用lastIndex会增加\n\n```\nlet reg3 = /\\d(\\w)(\\w)\\d/\nlet res1 = reg3.exec('1aa21aa2')//第一次\nconsole.log(res1.index + '\\t' + reg3.lastIndex + '\\t' + res1.toString())//0\t0\t1aa2,a,a\nlet res2 = reg3.exec('1aa21aa2')//第二次，lastIndex没有变化\nconsole.log(res2.index + '\\t' + reg3.lastIndex + '\\t' + res2.toString())//0\t0\t1aa2,a,a\n```\n\n- 全局搜索\n\n```\nlet reg4 = /\\d(\\w)(\\w)\\d/g\nlet r1 = reg4.exec('1aa23bb4')//第一次\nconsole.log(r1.index + '\\t' + reg4.lastIndex + '\\t' + r1.toString())//0\t0\t1aa2,a,a\nlet r2 = reg4.exec('1aa23bb4')//第二次\nconsole.log(r2.index + '\\t' + reg4.lastIndex + '\\t' + r2.toString())//4\t0\t3bb4,b,b\nlet r3 = reg4.exec('1aa23bb4')//第三次\nconsole.log(reg4.lastIndex,r3)//0 null\n```\n\n### 字符串对象的方法\n\n#### search()\n\n- String.prototype.search(reg)，返回第一个匹配结果的index，查找不到返回-1，忽略g标志，总是从开始匹配。\n- search会把字符串转换为正则匹配\n\n```\nconsole.log('aaa'.search('.'))//0，转换为正则匹配\nconsole.log('abc'.search(/[abc]/g))//0\nconsole.log('abc'.search(/[abc]/g))//0\n```\n\n#### match()\n\n- String.prototype.match(reg) 检索字符串，以找到一个或者多个与正则匹配的文本 是否有标志g对结果影响很大\n- match会把字符串转换为正则匹配\n- 非全局调用，返回数组第一个元素存放匹配的文本，其余元素是与正则的子表达式匹配的文本，还有两个对象属性index、input\n\n```\nlet str1 = '1aa21aa2'\nlet reg5 = /\\d(\\w)(\\w)\\d/\nlet re1 = str1.match(reg5)//第一次\nconsole.log(re1.index + '\\t' + reg5.lastIndex + '\\t' + re1.toString())//0\t0\t1aa2,a,a\nlet re2 = str1.match(reg5)//第二次\nconsole.log(re2.index + '\\t' + reg5.lastIndex + '\\t' + re2.toString())//0\t0\t1aa2,a,a\n```\n\n- 全局调用，返回数组中包含所有匹配的字符串，没有找到返回null，没有index、input属性\n\n```\nlet str2 = '1aa21aa2'\nlet reg6 = /\\d(\\w)(\\w)\\d/g\nlet re3 = str1.match(reg6)\nconsole.log(re3.index + '\\t' + reg6.lastIndex + '\\t' + re3.toString())//undefined\t0\t1aa2,1aa2\n```\n\n#### split()\n\n- String.prototype.split(reg)\n- 存在第二个参数，表示结果数组最大长度\n\n```\nconsole.log('1a2b3c4d'.split(/\\d/g))//['',a,b,c,d]\n```\n\n- 正则使用分组时，结果包含分隔符\n\n```\nconsole.log('abc'.split(/(\\w)/g))// [\"\", \"a\", \"\", \"b\", \"\", \"c\", \"\"]\n```\n\n#### replace()\n\n- String.prototype.replace(reg)\n\n```\nconsole.log('aabc'.replace('a','1'))//1abc 转换为/a/正则\nconsole.log('aabc'.replace(/a/g,'1'))//11bc\n```\n\n- 传第二个函数参数function有四个参数：匹配字符串、正则表达式分组内容(没有分组就没这个参数)、匹配项的index、原字符串\n\n```\nconsole.log('a1b2c3d4'.replace(/\\d/g,function (match,index,str) {\n    return parseInt(match) + 1\n}))//a2b3c4d5\nconsole.log('a1b2c3d4'.replace(/(\\d)/g,function (match,group,index,str) {\n    console.log(group)\n    return parseInt(match) + 1\n}))//a2b3c4d5\n//有分组情况\n'abc'.replace(/(\\w)(\\w)/g,function (match,$1,$2,index,str) {\n    return match\n})\n```\n","slug":"[js]正则表达式","published":1,"updated":"2021-03-15T14:39:00.455Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dks002fwotjbxbwbjbn","content":"<h3 id=\"模糊匹配\"><a href=\"#模糊匹配\" class=\"headerlink\" title=\"模糊匹配\"></a>模糊匹配</h3><ul>\n<li>横向模糊匹配：长度不固定，比如{m,n}最少出现m次最多出现n次</li>\n<li>纵向模糊匹配：某一位置字符多种可能，比如[\\w]</li>\n</ul>\n<h3 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h3><ul>\n<li>g全局匹配</li>\n<li>i不区分大小写，默认大小写敏感</li>\n<li>m匹配多行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str &#x3D;</span><br><span class=\"line\">&#96;aA</span><br><span class=\"line\">A</span><br><span class=\"line\">&#96;.replace(&#x2F;a&#x2F;igm,&#39;B&#39;)</span><br><span class=\"line\">console.log(str)</span><br><span class=\"line\">&#x2F;&#x2F; &#96;BB</span><br><span class=\"line\">&#x2F;&#x2F; b&#96;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><ul>\n<li>\\t 水平制表符tab</li>\n<li>\\v 垂直制表符</li>\n<li>\\n 换行符</li>\n<li>\\r 回车符</li>\n<li>\\0 空字符</li>\n<li>\\f 换页符</li>\n<li>\\cX ctrl+X</li>\n</ul>\n<h3 id=\"字符类（字符组）\"><a href=\"#字符类（字符组）\" class=\"headerlink\" title=\"字符类（字符组）\"></a>字符类（字符组）</h3><ul>\n<li>使用[]创建一个字符类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;1b2&#39;.replace(&#x2F;[abc]&#x2F;g,&#39;3&#39;))&#x2F;&#x2F;132</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用^符号（脱字符）字符类取反，即排除字符组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;1b2&#39;.replace(&#x2F;[^abc]&#x2F;g,&#39;3&#39;))&#x2F;&#x2F;3b3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"范围类\"><a href=\"#范围类\" class=\"headerlink\" title=\"范围类\"></a>范围类</h3><ul>\n<li>[a-zA-Z0-9]</li>\n<li>范围类中想包含-符号[a-z-]</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;a-&#39;.replace(&#x2F;[a-z-]&#x2F;g,&#39;1&#39;))&#x2F;&#x2F;11</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"预定义的范围类\"><a href=\"#预定义的范围类\" class=\"headerlink\" title=\"预定义的范围类\"></a>预定义的范围类</h3><ul>\n<li><p>. 除了回车和换行符之外的所有字符–[^\\n\\r]</p>\n</li>\n<li><p>\\d 数字字符–[0-9]，digit（数字）</p>\n</li>\n<li><p>\\D 非数字字符–[^0-9]</p>\n</li>\n<li><p>\\s 空白符–[\\t\\n\\x0B\\f\\r]，space（空格）</p>\n</li>\n<li><p>\\S 非空白符–[^\\t\\n\\x0B\\f\\r]</p>\n</li>\n<li><p>\\w 单词字符，字母、数字、下划线–[a-zA-Z_0-9]，word（单词）</p>\n</li>\n<li><p>\\W 非单词字符–[^a-zA-Z_0-9]</p>\n</li>\n<li><p>. 通配符[^\\n\\t\\u2028\\u2029]，表示换行符、回车符、行分隔符、段分隔符之外的任意字符</p>\n</li>\n<li><p>如果想<strong>匹配任意字符</strong>可以使用：[\\d\\D],[\\w\\W],[\\s\\S],[^]中任意一个</p>\n</li>\n</ul>\n<h3 id=\"位置匹配\"><a href=\"#位置匹配\" class=\"headerlink\" title=\"位置匹配\"></a>位置匹配</h3><ul>\n<li>位置（锚）是指相邻字符串之间的位置</li>\n<li>ES5中有6个锚：^,$,\\b,\\B,(?=p),(?!p)</li>\n</ul>\n<h4 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h4><ul>\n<li>^ 以XXX开始</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;abc&#39;.replace(&#x2F;^[abc]&#x2F;,&#39;A&#39;))&#x2F;&#x2F;Abc</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>$ 以XXX结束</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;abc&#39;.replace(&#x2F;[abc]$&#x2F;,&#39;A&#39;))&#x2F;&#x2F;abA</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>\\b 单词边界</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;Are you youOK&#39;.replace(&#x2F;you\\b&#x2F;,&#39;YOU&#39;))&#x2F;&#x2F;Are YOU youOK</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>\\B 非单词边界</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;Are you youOK&#39;.replace(&#x2F;you\\B&#x2F;,&#39;YOU&#39;))&#x2F;&#x2F;Are you YOUOK</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"前瞻-amp-后顾\"><a href=\"#前瞻-amp-后顾\" class=\"headerlink\" title=\"前瞻&amp;后顾\"></a>前瞻&amp;后顾</h4><ul>\n<li>(?=p) 表示p前面的位置，该位置后边的字符匹配p，可以理解为存在一个位置，该位置后边的字符与p匹配，正向先行断言</li>\n<li>(?!p) 是(?=p)反面的意思，负向先行断言</li>\n<li>正则表达式从文本头部向尾部解析，文本尾部称为’前’，前瞻就是匹配规则时候向前（尾部方向）检查是否断言</li>\n<li>js正则不支持后顾</li>\n<li>exp(?=asset) 正向前瞻（符合断言）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;a2aa&#39;.replace(&#x2F;\\w(?&#x3D;\\d)&#x2F;g,&#39;X&#39;))&#x2F;&#x2F;X2aa</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>exp(?!asset) 负向前瞻（不符合断言）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;a2aa&#39;.replace(&#x2F;\\w(?!\\d)&#x2F;g,&#39;X&#39;))&#x2F;&#x2F;aXXX</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h3><ul>\n<li>? 出现0次或者一次（最多一次）</li>\n<li>+ 出现一次或者多次（最少出现一次）</li>\n<li>* 0次或者多次（任意次）</li>\n<li>{n} 出现n次</li>\n<li>{n,m} n-m次</li>\n<li>{n,} 最少出现n次</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;aabbcc&#39;.replace(&#x2F;[abc]&#123;2&#125;&#x2F;g,&#39;A&#39;))&#x2F;&#x2F;AAA</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"贪婪模式与非贪婪模式\"><a href=\"#贪婪模式与非贪婪模式\" class=\"headerlink\" title=\"贪婪模式与非贪婪模式\"></a>贪婪模式与非贪婪模式</h3><ul>\n<li>贪婪模式，js正则默认贪婪模式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;aaa&#39;.replace(&#x2F;a+&#x2F;g,&#39;A&#39;))&#x2F;&#x2F;A</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>非贪婪模式，尽可能少的匹配，一旦匹配成功就不再进行尝试</li>\n<li>非贪婪模式需要在量词后边加 ?</li>\n<li>{m.n}?,{m,}?,+?,*?,??</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;aaa&#39;.replace(&#x2F;a+?&#x2F;g,&#39;A&#39;))&#x2F;&#x2F;AAA</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><ul>\n<li>使用()可以实现分组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;ababc&#39;.replace(&#x2F;(ab)&#123;2&#125;&#x2F;g,&#39;A&#39;))&#x2F;&#x2F;Ac</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"或（多选分支）\"><a href=\"#或（多选分支）\" class=\"headerlink\" title=\"或（多选分支）\"></a>或（多选分支）</h4><ul>\n<li><p>|</p>\n</li>\n<li><p>分支结构是惰性的，前边的匹配之后，后边的就不在尝试了</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;abcadc&#39;.replace(&#x2F;a(b|d)c&#x2F;g,&#39;A&#39;))&#x2F;&#x2F;AA</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"反向引用\"><a href=\"#反向引用\" class=\"headerlink\" title=\"反向引用\"></a>反向引用</h4><ul>\n<li>分组后使用$1、$2…</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;2012-11-01&#39;.replace(&#x2F;(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&#x2F;,&#39;$3&#x2F;$2&#x2F;$1&#39;))&#x2F;&#x2F;01&#x2F;11&#x2F;2012</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>正则表达式中使用\\1,\\2,\\3引用分组</li>\n<li>\\10表示第十个分组，如果想匹配\\1和0使用(?:\\1)0,\\1(?:0)</li>\n<li>引用不存在的分组不会报错，会匹配反向引用字符串本身</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;aa&#39;.replace(&#x2F;([a])\\1&#x2F;,&#39;b&#39;))&#x2F;&#x2F;b</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"分组括号嵌套\"><a href=\"#分组括号嵌套\" class=\"headerlink\" title=\"分组括号嵌套\"></a>分组括号嵌套</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var regex &#x3D; &#x2F;^((\\d)(\\d(\\d)))\\1\\2\\3\\4$&#x2F;;</span><br><span class=\"line\">var string &#x3D; &quot;1231231233&quot;;</span><br><span class=\"line\">console.log( regex.test(string) ); &#x2F;&#x2F; true</span><br><span class=\"line\">console.log( RegExp.$1 ); &#x2F;&#x2F; 123,第一个括号对应的</span><br><span class=\"line\">console.log( RegExp.$2 ); &#x2F;&#x2F; 1，第二个括号对应的</span><br><span class=\"line\">console.log( RegExp.$3 ); &#x2F;&#x2F; 23，。。。</span><br><span class=\"line\">console.log( RegExp.$4 ); &#x2F;&#x2F; 3，。。。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"忽略分组（非捕获括号）\"><a href=\"#忽略分组（非捕获括号）\" class=\"headerlink\" title=\"忽略分组（非捕获括号）\"></a>忽略分组（非捕获括号）</h4><ul>\n<li>在分组内加上 ?: 即(?:)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;2012-11-01&#39;.replace(&#x2F;(?:\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&#x2F;,&#39;$3&#x2F;$2&#x2F;$1&#39;))&#x2F;&#x2F;$3&#x2F;11&#x2F;2012</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"分组后边有量词\"><a href=\"#分组后边有量词\" class=\"headerlink\" title=\"分组后边有量词\"></a>分组后边有量词</h4><ul>\n<li>分组后边有量词，分组最终捕获最后一次的匹配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let r &#x3D; &#x2F;(\\d)&#123;1,4&#125;&#x2F;</span><br><span class=\"line\">console.log(&#39;123456&#39;.match(r))&#x2F;&#x2F; [&quot;1234&quot;, &quot;4&quot;, index: 0, input: &quot;123456&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"正则表达式回溯法\"><a href=\"#正则表达式回溯法\" class=\"headerlink\" title=\"正则表达式回溯法\"></a>正则表达式回溯法</h3><ul>\n<li>尝试匹配失败时，会退回之前的一步，本质是深度优先算法</li>\n</ul>\n<h4 id=\"产生回溯\"><a href=\"#产生回溯\" class=\"headerlink\" title=\"产生回溯\"></a>产生回溯</h4><ul>\n<li>贪婪量词，{2,4}因为是贪婪的，所以先会尝试尽可能多的匹配</li>\n<li>惰性量词，匹配少了，不够会回溯，’12345’.match(/^(\\d{1,3}?)(\\d{1,3})$/)，第一个分组会先尝试匹配一个，但是第二个就不能匹配，于是尝试两个、三个。。。</li>\n<li>分支结构，’123’.match(/^(12|123)$/)</li>\n</ul>\n<h3 id=\"拆分正则\"><a href=\"#拆分正则\" class=\"headerlink\" title=\"拆分正则\"></a>拆分正则</h3><h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4><ul>\n<li>转义符\\  &gt;  括号和方括号  &gt;  量词  &gt;  位置和序列（位置、一般字符）  &gt;  管道符</li>\n</ul>\n<h4 id=\"注意要点\"><a href=\"#注意要点\" class=\"headerlink\" title=\"注意要点\"></a>注意要点</h4><ul>\n<li>匹配字符串整体/^(a|b)$/而不是/^a|b&amp;/</li>\n<li>量词连续：/[abc]{3}+/会报错，应该写成/([abc]{3})+/</li>\n<li>元字符转义问题：^,$,.,*,+,?,|,,/,(,),[,],{,},=,!,:,-</li>\n</ul>\n<h3 id=\"对象属性\"><a href=\"#对象属性\" class=\"headerlink\" title=\"对象属性\"></a>对象属性</h3><ul>\n<li>global\\ignoreCase\\multiline\\lastIndex\\source</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg1 &#x3D; &#x2F;\\w&#x2F;igm</span><br><span class=\"line\">console.log(reg1.global)&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(reg1.ignoreCase)&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(reg1.multiline)&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(reg1.lastIndex)&#x2F;&#x2F;0 当前匹配结果最后一个字符的下一个字符</span><br><span class=\"line\">console.log(reg1.source)&#x2F;&#x2F;\\w</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"正则表达式方法\"><a href=\"#正则表达式方法\" class=\"headerlink\" title=\"正则表达式方法\"></a>正则表达式方法</h3><h4 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test()\"></a>test()</h4><ul>\n<li>RegExp.prototype.test(str) 检测字符串参数中是否存在匹配正则表达式模式的字符串</li>\n<li>存在返回true不存在返回false</li>\n<li>注意如果包含全局匹配g那么结果会受到lastIndex影响</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg2 &#x3D; &#x2F;\\w&#x2F;g</span><br><span class=\"line\">console.log(reg2.test(&#39;ab&#39;))&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(reg2.lastIndex)&#x2F;&#x2F;1</span><br><span class=\"line\">console.log(reg2.test(&#39;ab&#39;))&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(reg2.lastIndex)&#x2F;&#x2F;2</span><br><span class=\"line\">console.log(reg2.test(&#39;ab&#39;))&#x2F;&#x2F;false</span><br><span class=\"line\">console.log(reg2.lastIndex)&#x2F;&#x2F;0</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec()\"></a>exec()</h4><ul>\n<li>RegExp.prototype.exec(str)</li>\n<li>使用正则表达式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果</li>\n<li>如果没有匹配文本返回null，否则返回一个结果的数组</li>\n<li>返回的数组有两个属性index声明第一个匹配字符的位置、input存放被检索的字符串string</li>\n<li>非全局调用返回的数组：第一项是与正则表达式匹配的文本、第二项（以及以后项）是与分组匹配的文本</li>\n<li>非全局匹配lastindex为0，全局匹配每次调用lastIndex会增加</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg3 &#x3D; &#x2F;\\d(\\w)(\\w)\\d&#x2F;</span><br><span class=\"line\">let res1 &#x3D; reg3.exec(&#39;1aa21aa2&#39;)&#x2F;&#x2F;第一次</span><br><span class=\"line\">console.log(res1.index + &#39;\\t&#39; + reg3.lastIndex + &#39;\\t&#39; + res1.toString())&#x2F;&#x2F;0\t0\t1aa2,a,a</span><br><span class=\"line\">let res2 &#x3D; reg3.exec(&#39;1aa21aa2&#39;)&#x2F;&#x2F;第二次，lastIndex没有变化</span><br><span class=\"line\">console.log(res2.index + &#39;\\t&#39; + reg3.lastIndex + &#39;\\t&#39; + res2.toString())&#x2F;&#x2F;0\t0\t1aa2,a,a</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>全局搜索</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg4 &#x3D; &#x2F;\\d(\\w)(\\w)\\d&#x2F;g</span><br><span class=\"line\">let r1 &#x3D; reg4.exec(&#39;1aa23bb4&#39;)&#x2F;&#x2F;第一次</span><br><span class=\"line\">console.log(r1.index + &#39;\\t&#39; + reg4.lastIndex + &#39;\\t&#39; + r1.toString())&#x2F;&#x2F;0\t0\t1aa2,a,a</span><br><span class=\"line\">let r2 &#x3D; reg4.exec(&#39;1aa23bb4&#39;)&#x2F;&#x2F;第二次</span><br><span class=\"line\">console.log(r2.index + &#39;\\t&#39; + reg4.lastIndex + &#39;\\t&#39; + r2.toString())&#x2F;&#x2F;4\t0\t3bb4,b,b</span><br><span class=\"line\">let r3 &#x3D; reg4.exec(&#39;1aa23bb4&#39;)&#x2F;&#x2F;第三次</span><br><span class=\"line\">console.log(reg4.lastIndex,r3)&#x2F;&#x2F;0 null</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串对象的方法\"><a href=\"#字符串对象的方法\" class=\"headerlink\" title=\"字符串对象的方法\"></a>字符串对象的方法</h3><h4 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search()\"></a>search()</h4><ul>\n<li>String.prototype.search(reg)，返回第一个匹配结果的index，查找不到返回-1，忽略g标志，总是从开始匹配。</li>\n<li>search会把字符串转换为正则匹配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;aaa&#39;.search(&#39;.&#39;))&#x2F;&#x2F;0，转换为正则匹配</span><br><span class=\"line\">console.log(&#39;abc&#39;.search(&#x2F;[abc]&#x2F;g))&#x2F;&#x2F;0</span><br><span class=\"line\">console.log(&#39;abc&#39;.search(&#x2F;[abc]&#x2F;g))&#x2F;&#x2F;0</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match()\"></a>match()</h4><ul>\n<li>String.prototype.match(reg) 检索字符串，以找到一个或者多个与正则匹配的文本 是否有标志g对结果影响很大</li>\n<li>match会把字符串转换为正则匹配</li>\n<li>非全局调用，返回数组第一个元素存放匹配的文本，其余元素是与正则的子表达式匹配的文本，还有两个对象属性index、input</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str1 &#x3D; &#39;1aa21aa2&#39;</span><br><span class=\"line\">let reg5 &#x3D; &#x2F;\\d(\\w)(\\w)\\d&#x2F;</span><br><span class=\"line\">let re1 &#x3D; str1.match(reg5)&#x2F;&#x2F;第一次</span><br><span class=\"line\">console.log(re1.index + &#39;\\t&#39; + reg5.lastIndex + &#39;\\t&#39; + re1.toString())&#x2F;&#x2F;0\t0\t1aa2,a,a</span><br><span class=\"line\">let re2 &#x3D; str1.match(reg5)&#x2F;&#x2F;第二次</span><br><span class=\"line\">console.log(re2.index + &#39;\\t&#39; + reg5.lastIndex + &#39;\\t&#39; + re2.toString())&#x2F;&#x2F;0\t0\t1aa2,a,a</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>全局调用，返回数组中包含所有匹配的字符串，没有找到返回null，没有index、input属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str2 &#x3D; &#39;1aa21aa2&#39;</span><br><span class=\"line\">let reg6 &#x3D; &#x2F;\\d(\\w)(\\w)\\d&#x2F;g</span><br><span class=\"line\">let re3 &#x3D; str1.match(reg6)</span><br><span class=\"line\">console.log(re3.index + &#39;\\t&#39; + reg6.lastIndex + &#39;\\t&#39; + re3.toString())&#x2F;&#x2F;undefined\t0\t1aa2,1aa2</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h4><ul>\n<li>String.prototype.split(reg)</li>\n<li>存在第二个参数，表示结果数组最大长度</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;1a2b3c4d&#39;.split(&#x2F;\\d&#x2F;g))&#x2F;&#x2F;[&#39;&#39;,a,b,c,d]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>正则使用分组时，结果包含分隔符</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;abc&#39;.split(&#x2F;(\\w)&#x2F;g))&#x2F;&#x2F; [&quot;&quot;, &quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot;, &quot;&quot;]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace()\"></a>replace()</h4><ul>\n<li>String.prototype.replace(reg)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;aabc&#39;.replace(&#39;a&#39;,&#39;1&#39;))&#x2F;&#x2F;1abc 转换为&#x2F;a&#x2F;正则</span><br><span class=\"line\">console.log(&#39;aabc&#39;.replace(&#x2F;a&#x2F;g,&#39;1&#39;))&#x2F;&#x2F;11bc</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>传第二个函数参数function有四个参数：匹配字符串、正则表达式分组内容(没有分组就没这个参数)、匹配项的index、原字符串</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;a1b2c3d4&#39;.replace(&#x2F;\\d&#x2F;g,function (match,index,str) &#123;</span><br><span class=\"line\">    return parseInt(match) + 1</span><br><span class=\"line\">&#125;))&#x2F;&#x2F;a2b3c4d5</span><br><span class=\"line\">console.log(&#39;a1b2c3d4&#39;.replace(&#x2F;(\\d)&#x2F;g,function (match,group,index,str) &#123;</span><br><span class=\"line\">    console.log(group)</span><br><span class=\"line\">    return parseInt(match) + 1</span><br><span class=\"line\">&#125;))&#x2F;&#x2F;a2b3c4d5</span><br><span class=\"line\">&#x2F;&#x2F;有分组情况</span><br><span class=\"line\">&#39;abc&#39;.replace(&#x2F;(\\w)(\\w)&#x2F;g,function (match,$1,$2,index,str) &#123;</span><br><span class=\"line\">    return match</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"模糊匹配\"><a href=\"#模糊匹配\" class=\"headerlink\" title=\"模糊匹配\"></a>模糊匹配</h3><ul>\n<li>横向模糊匹配：长度不固定，比如{m,n}最少出现m次最多出现n次</li>\n<li>纵向模糊匹配：某一位置字符多种可能，比如[\\w]</li>\n</ul>\n<h3 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h3><ul>\n<li>g全局匹配</li>\n<li>i不区分大小写，默认大小写敏感</li>\n<li>m匹配多行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str &#x3D;</span><br><span class=\"line\">&#96;aA</span><br><span class=\"line\">A</span><br><span class=\"line\">&#96;.replace(&#x2F;a&#x2F;igm,&#39;B&#39;)</span><br><span class=\"line\">console.log(str)</span><br><span class=\"line\">&#x2F;&#x2F; &#96;BB</span><br><span class=\"line\">&#x2F;&#x2F; b&#96;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><ul>\n<li>\\t 水平制表符tab</li>\n<li>\\v 垂直制表符</li>\n<li>\\n 换行符</li>\n<li>\\r 回车符</li>\n<li>\\0 空字符</li>\n<li>\\f 换页符</li>\n<li>\\cX ctrl+X</li>\n</ul>\n<h3 id=\"字符类（字符组）\"><a href=\"#字符类（字符组）\" class=\"headerlink\" title=\"字符类（字符组）\"></a>字符类（字符组）</h3><ul>\n<li>使用[]创建一个字符类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;1b2&#39;.replace(&#x2F;[abc]&#x2F;g,&#39;3&#39;))&#x2F;&#x2F;132</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用^符号（脱字符）字符类取反，即排除字符组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;1b2&#39;.replace(&#x2F;[^abc]&#x2F;g,&#39;3&#39;))&#x2F;&#x2F;3b3</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"范围类\"><a href=\"#范围类\" class=\"headerlink\" title=\"范围类\"></a>范围类</h3><ul>\n<li>[a-zA-Z0-9]</li>\n<li>范围类中想包含-符号[a-z-]</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;a-&#39;.replace(&#x2F;[a-z-]&#x2F;g,&#39;1&#39;))&#x2F;&#x2F;11</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"预定义的范围类\"><a href=\"#预定义的范围类\" class=\"headerlink\" title=\"预定义的范围类\"></a>预定义的范围类</h3><ul>\n<li><p>. 除了回车和换行符之外的所有字符–[^\\n\\r]</p>\n</li>\n<li><p>\\d 数字字符–[0-9]，digit（数字）</p>\n</li>\n<li><p>\\D 非数字字符–[^0-9]</p>\n</li>\n<li><p>\\s 空白符–[\\t\\n\\x0B\\f\\r]，space（空格）</p>\n</li>\n<li><p>\\S 非空白符–[^\\t\\n\\x0B\\f\\r]</p>\n</li>\n<li><p>\\w 单词字符，字母、数字、下划线–[a-zA-Z_0-9]，word（单词）</p>\n</li>\n<li><p>\\W 非单词字符–[^a-zA-Z_0-9]</p>\n</li>\n<li><p>. 通配符[^\\n\\t\\u2028\\u2029]，表示换行符、回车符、行分隔符、段分隔符之外的任意字符</p>\n</li>\n<li><p>如果想<strong>匹配任意字符</strong>可以使用：[\\d\\D],[\\w\\W],[\\s\\S],[^]中任意一个</p>\n</li>\n</ul>\n<h3 id=\"位置匹配\"><a href=\"#位置匹配\" class=\"headerlink\" title=\"位置匹配\"></a>位置匹配</h3><ul>\n<li>位置（锚）是指相邻字符串之间的位置</li>\n<li>ES5中有6个锚：^,$,\\b,\\B,(?=p),(?!p)</li>\n</ul>\n<h4 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h4><ul>\n<li>^ 以XXX开始</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;abc&#39;.replace(&#x2F;^[abc]&#x2F;,&#39;A&#39;))&#x2F;&#x2F;Abc</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>$ 以XXX结束</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;abc&#39;.replace(&#x2F;[abc]$&#x2F;,&#39;A&#39;))&#x2F;&#x2F;abA</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>\\b 单词边界</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;Are you youOK&#39;.replace(&#x2F;you\\b&#x2F;,&#39;YOU&#39;))&#x2F;&#x2F;Are YOU youOK</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>\\B 非单词边界</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;Are you youOK&#39;.replace(&#x2F;you\\B&#x2F;,&#39;YOU&#39;))&#x2F;&#x2F;Are you YOUOK</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"前瞻-amp-后顾\"><a href=\"#前瞻-amp-后顾\" class=\"headerlink\" title=\"前瞻&amp;后顾\"></a>前瞻&amp;后顾</h4><ul>\n<li>(?=p) 表示p前面的位置，该位置后边的字符匹配p，可以理解为存在一个位置，该位置后边的字符与p匹配，正向先行断言</li>\n<li>(?!p) 是(?=p)反面的意思，负向先行断言</li>\n<li>正则表达式从文本头部向尾部解析，文本尾部称为’前’，前瞻就是匹配规则时候向前（尾部方向）检查是否断言</li>\n<li>js正则不支持后顾</li>\n<li>exp(?=asset) 正向前瞻（符合断言）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;a2aa&#39;.replace(&#x2F;\\w(?&#x3D;\\d)&#x2F;g,&#39;X&#39;))&#x2F;&#x2F;X2aa</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>exp(?!asset) 负向前瞻（不符合断言）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;a2aa&#39;.replace(&#x2F;\\w(?!\\d)&#x2F;g,&#39;X&#39;))&#x2F;&#x2F;aXXX</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h3><ul>\n<li>? 出现0次或者一次（最多一次）</li>\n<li>+ 出现一次或者多次（最少出现一次）</li>\n<li>* 0次或者多次（任意次）</li>\n<li>{n} 出现n次</li>\n<li>{n,m} n-m次</li>\n<li>{n,} 最少出现n次</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;aabbcc&#39;.replace(&#x2F;[abc]&#123;2&#125;&#x2F;g,&#39;A&#39;))&#x2F;&#x2F;AAA</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"贪婪模式与非贪婪模式\"><a href=\"#贪婪模式与非贪婪模式\" class=\"headerlink\" title=\"贪婪模式与非贪婪模式\"></a>贪婪模式与非贪婪模式</h3><ul>\n<li>贪婪模式，js正则默认贪婪模式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;aaa&#39;.replace(&#x2F;a+&#x2F;g,&#39;A&#39;))&#x2F;&#x2F;A</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>非贪婪模式，尽可能少的匹配，一旦匹配成功就不再进行尝试</li>\n<li>非贪婪模式需要在量词后边加 ?</li>\n<li>{m.n}?,{m,}?,+?,*?,??</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;aaa&#39;.replace(&#x2F;a+?&#x2F;g,&#39;A&#39;))&#x2F;&#x2F;AAA</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><ul>\n<li>使用()可以实现分组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;ababc&#39;.replace(&#x2F;(ab)&#123;2&#125;&#x2F;g,&#39;A&#39;))&#x2F;&#x2F;Ac</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"或（多选分支）\"><a href=\"#或（多选分支）\" class=\"headerlink\" title=\"或（多选分支）\"></a>或（多选分支）</h4><ul>\n<li><p>|</p>\n</li>\n<li><p>分支结构是惰性的，前边的匹配之后，后边的就不在尝试了</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;abcadc&#39;.replace(&#x2F;a(b|d)c&#x2F;g,&#39;A&#39;))&#x2F;&#x2F;AA</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"反向引用\"><a href=\"#反向引用\" class=\"headerlink\" title=\"反向引用\"></a>反向引用</h4><ul>\n<li>分组后使用$1、$2…</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;2012-11-01&#39;.replace(&#x2F;(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&#x2F;,&#39;$3&#x2F;$2&#x2F;$1&#39;))&#x2F;&#x2F;01&#x2F;11&#x2F;2012</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>正则表达式中使用\\1,\\2,\\3引用分组</li>\n<li>\\10表示第十个分组，如果想匹配\\1和0使用(?:\\1)0,\\1(?:0)</li>\n<li>引用不存在的分组不会报错，会匹配反向引用字符串本身</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;aa&#39;.replace(&#x2F;([a])\\1&#x2F;,&#39;b&#39;))&#x2F;&#x2F;b</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"分组括号嵌套\"><a href=\"#分组括号嵌套\" class=\"headerlink\" title=\"分组括号嵌套\"></a>分组括号嵌套</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var regex &#x3D; &#x2F;^((\\d)(\\d(\\d)))\\1\\2\\3\\4$&#x2F;;</span><br><span class=\"line\">var string &#x3D; &quot;1231231233&quot;;</span><br><span class=\"line\">console.log( regex.test(string) ); &#x2F;&#x2F; true</span><br><span class=\"line\">console.log( RegExp.$1 ); &#x2F;&#x2F; 123,第一个括号对应的</span><br><span class=\"line\">console.log( RegExp.$2 ); &#x2F;&#x2F; 1，第二个括号对应的</span><br><span class=\"line\">console.log( RegExp.$3 ); &#x2F;&#x2F; 23，。。。</span><br><span class=\"line\">console.log( RegExp.$4 ); &#x2F;&#x2F; 3，。。。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"忽略分组（非捕获括号）\"><a href=\"#忽略分组（非捕获括号）\" class=\"headerlink\" title=\"忽略分组（非捕获括号）\"></a>忽略分组（非捕获括号）</h4><ul>\n<li>在分组内加上 ?: 即(?:)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;2012-11-01&#39;.replace(&#x2F;(?:\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)&#x2F;,&#39;$3&#x2F;$2&#x2F;$1&#39;))&#x2F;&#x2F;$3&#x2F;11&#x2F;2012</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"分组后边有量词\"><a href=\"#分组后边有量词\" class=\"headerlink\" title=\"分组后边有量词\"></a>分组后边有量词</h4><ul>\n<li>分组后边有量词，分组最终捕获最后一次的匹配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let r &#x3D; &#x2F;(\\d)&#123;1,4&#125;&#x2F;</span><br><span class=\"line\">console.log(&#39;123456&#39;.match(r))&#x2F;&#x2F; [&quot;1234&quot;, &quot;4&quot;, index: 0, input: &quot;123456&quot;, groups: undefined]</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"正则表达式回溯法\"><a href=\"#正则表达式回溯法\" class=\"headerlink\" title=\"正则表达式回溯法\"></a>正则表达式回溯法</h3><ul>\n<li>尝试匹配失败时，会退回之前的一步，本质是深度优先算法</li>\n</ul>\n<h4 id=\"产生回溯\"><a href=\"#产生回溯\" class=\"headerlink\" title=\"产生回溯\"></a>产生回溯</h4><ul>\n<li>贪婪量词，{2,4}因为是贪婪的，所以先会尝试尽可能多的匹配</li>\n<li>惰性量词，匹配少了，不够会回溯，’12345’.match(/^(\\d{1,3}?)(\\d{1,3})$/)，第一个分组会先尝试匹配一个，但是第二个就不能匹配，于是尝试两个、三个。。。</li>\n<li>分支结构，’123’.match(/^(12|123)$/)</li>\n</ul>\n<h3 id=\"拆分正则\"><a href=\"#拆分正则\" class=\"headerlink\" title=\"拆分正则\"></a>拆分正则</h3><h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4><ul>\n<li>转义符\\  &gt;  括号和方括号  &gt;  量词  &gt;  位置和序列（位置、一般字符）  &gt;  管道符</li>\n</ul>\n<h4 id=\"注意要点\"><a href=\"#注意要点\" class=\"headerlink\" title=\"注意要点\"></a>注意要点</h4><ul>\n<li>匹配字符串整体/^(a|b)$/而不是/^a|b&amp;/</li>\n<li>量词连续：/[abc]{3}+/会报错，应该写成/([abc]{3})+/</li>\n<li>元字符转义问题：^,$,.,*,+,?,|,,/,(,),[,],{,},=,!,:,-</li>\n</ul>\n<h3 id=\"对象属性\"><a href=\"#对象属性\" class=\"headerlink\" title=\"对象属性\"></a>对象属性</h3><ul>\n<li>global\\ignoreCase\\multiline\\lastIndex\\source</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg1 &#x3D; &#x2F;\\w&#x2F;igm</span><br><span class=\"line\">console.log(reg1.global)&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(reg1.ignoreCase)&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(reg1.multiline)&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(reg1.lastIndex)&#x2F;&#x2F;0 当前匹配结果最后一个字符的下一个字符</span><br><span class=\"line\">console.log(reg1.source)&#x2F;&#x2F;\\w</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"正则表达式方法\"><a href=\"#正则表达式方法\" class=\"headerlink\" title=\"正则表达式方法\"></a>正则表达式方法</h3><h4 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test()\"></a>test()</h4><ul>\n<li>RegExp.prototype.test(str) 检测字符串参数中是否存在匹配正则表达式模式的字符串</li>\n<li>存在返回true不存在返回false</li>\n<li>注意如果包含全局匹配g那么结果会受到lastIndex影响</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg2 &#x3D; &#x2F;\\w&#x2F;g</span><br><span class=\"line\">console.log(reg2.test(&#39;ab&#39;))&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(reg2.lastIndex)&#x2F;&#x2F;1</span><br><span class=\"line\">console.log(reg2.test(&#39;ab&#39;))&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(reg2.lastIndex)&#x2F;&#x2F;2</span><br><span class=\"line\">console.log(reg2.test(&#39;ab&#39;))&#x2F;&#x2F;false</span><br><span class=\"line\">console.log(reg2.lastIndex)&#x2F;&#x2F;0</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec()\"></a>exec()</h4><ul>\n<li>RegExp.prototype.exec(str)</li>\n<li>使用正则表达式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果</li>\n<li>如果没有匹配文本返回null，否则返回一个结果的数组</li>\n<li>返回的数组有两个属性index声明第一个匹配字符的位置、input存放被检索的字符串string</li>\n<li>非全局调用返回的数组：第一项是与正则表达式匹配的文本、第二项（以及以后项）是与分组匹配的文本</li>\n<li>非全局匹配lastindex为0，全局匹配每次调用lastIndex会增加</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg3 &#x3D; &#x2F;\\d(\\w)(\\w)\\d&#x2F;</span><br><span class=\"line\">let res1 &#x3D; reg3.exec(&#39;1aa21aa2&#39;)&#x2F;&#x2F;第一次</span><br><span class=\"line\">console.log(res1.index + &#39;\\t&#39; + reg3.lastIndex + &#39;\\t&#39; + res1.toString())&#x2F;&#x2F;0\t0\t1aa2,a,a</span><br><span class=\"line\">let res2 &#x3D; reg3.exec(&#39;1aa21aa2&#39;)&#x2F;&#x2F;第二次，lastIndex没有变化</span><br><span class=\"line\">console.log(res2.index + &#39;\\t&#39; + reg3.lastIndex + &#39;\\t&#39; + res2.toString())&#x2F;&#x2F;0\t0\t1aa2,a,a</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>全局搜索</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg4 &#x3D; &#x2F;\\d(\\w)(\\w)\\d&#x2F;g</span><br><span class=\"line\">let r1 &#x3D; reg4.exec(&#39;1aa23bb4&#39;)&#x2F;&#x2F;第一次</span><br><span class=\"line\">console.log(r1.index + &#39;\\t&#39; + reg4.lastIndex + &#39;\\t&#39; + r1.toString())&#x2F;&#x2F;0\t0\t1aa2,a,a</span><br><span class=\"line\">let r2 &#x3D; reg4.exec(&#39;1aa23bb4&#39;)&#x2F;&#x2F;第二次</span><br><span class=\"line\">console.log(r2.index + &#39;\\t&#39; + reg4.lastIndex + &#39;\\t&#39; + r2.toString())&#x2F;&#x2F;4\t0\t3bb4,b,b</span><br><span class=\"line\">let r3 &#x3D; reg4.exec(&#39;1aa23bb4&#39;)&#x2F;&#x2F;第三次</span><br><span class=\"line\">console.log(reg4.lastIndex,r3)&#x2F;&#x2F;0 null</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字符串对象的方法\"><a href=\"#字符串对象的方法\" class=\"headerlink\" title=\"字符串对象的方法\"></a>字符串对象的方法</h3><h4 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search()\"></a>search()</h4><ul>\n<li>String.prototype.search(reg)，返回第一个匹配结果的index，查找不到返回-1，忽略g标志，总是从开始匹配。</li>\n<li>search会把字符串转换为正则匹配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;aaa&#39;.search(&#39;.&#39;))&#x2F;&#x2F;0，转换为正则匹配</span><br><span class=\"line\">console.log(&#39;abc&#39;.search(&#x2F;[abc]&#x2F;g))&#x2F;&#x2F;0</span><br><span class=\"line\">console.log(&#39;abc&#39;.search(&#x2F;[abc]&#x2F;g))&#x2F;&#x2F;0</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match()\"></a>match()</h4><ul>\n<li>String.prototype.match(reg) 检索字符串，以找到一个或者多个与正则匹配的文本 是否有标志g对结果影响很大</li>\n<li>match会把字符串转换为正则匹配</li>\n<li>非全局调用，返回数组第一个元素存放匹配的文本，其余元素是与正则的子表达式匹配的文本，还有两个对象属性index、input</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str1 &#x3D; &#39;1aa21aa2&#39;</span><br><span class=\"line\">let reg5 &#x3D; &#x2F;\\d(\\w)(\\w)\\d&#x2F;</span><br><span class=\"line\">let re1 &#x3D; str1.match(reg5)&#x2F;&#x2F;第一次</span><br><span class=\"line\">console.log(re1.index + &#39;\\t&#39; + reg5.lastIndex + &#39;\\t&#39; + re1.toString())&#x2F;&#x2F;0\t0\t1aa2,a,a</span><br><span class=\"line\">let re2 &#x3D; str1.match(reg5)&#x2F;&#x2F;第二次</span><br><span class=\"line\">console.log(re2.index + &#39;\\t&#39; + reg5.lastIndex + &#39;\\t&#39; + re2.toString())&#x2F;&#x2F;0\t0\t1aa2,a,a</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>全局调用，返回数组中包含所有匹配的字符串，没有找到返回null，没有index、input属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str2 &#x3D; &#39;1aa21aa2&#39;</span><br><span class=\"line\">let reg6 &#x3D; &#x2F;\\d(\\w)(\\w)\\d&#x2F;g</span><br><span class=\"line\">let re3 &#x3D; str1.match(reg6)</span><br><span class=\"line\">console.log(re3.index + &#39;\\t&#39; + reg6.lastIndex + &#39;\\t&#39; + re3.toString())&#x2F;&#x2F;undefined\t0\t1aa2,1aa2</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h4><ul>\n<li>String.prototype.split(reg)</li>\n<li>存在第二个参数，表示结果数组最大长度</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;1a2b3c4d&#39;.split(&#x2F;\\d&#x2F;g))&#x2F;&#x2F;[&#39;&#39;,a,b,c,d]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>正则使用分组时，结果包含分隔符</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;abc&#39;.split(&#x2F;(\\w)&#x2F;g))&#x2F;&#x2F; [&quot;&quot;, &quot;a&quot;, &quot;&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot;, &quot;&quot;]</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace()\"></a>replace()</h4><ul>\n<li>String.prototype.replace(reg)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;aabc&#39;.replace(&#39;a&#39;,&#39;1&#39;))&#x2F;&#x2F;1abc 转换为&#x2F;a&#x2F;正则</span><br><span class=\"line\">console.log(&#39;aabc&#39;.replace(&#x2F;a&#x2F;g,&#39;1&#39;))&#x2F;&#x2F;11bc</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>传第二个函数参数function有四个参数：匹配字符串、正则表达式分组内容(没有分组就没这个参数)、匹配项的index、原字符串</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&#39;a1b2c3d4&#39;.replace(&#x2F;\\d&#x2F;g,function (match,index,str) &#123;</span><br><span class=\"line\">    return parseInt(match) + 1</span><br><span class=\"line\">&#125;))&#x2F;&#x2F;a2b3c4d5</span><br><span class=\"line\">console.log(&#39;a1b2c3d4&#39;.replace(&#x2F;(\\d)&#x2F;g,function (match,group,index,str) &#123;</span><br><span class=\"line\">    console.log(group)</span><br><span class=\"line\">    return parseInt(match) + 1</span><br><span class=\"line\">&#125;))&#x2F;&#x2F;a2b3c4d5</span><br><span class=\"line\">&#x2F;&#x2F;有分组情况</span><br><span class=\"line\">&#39;abc&#39;.replace(&#x2F;(\\w)(\\w)&#x2F;g,function (match,$1,$2,index,str) &#123;</span><br><span class=\"line\">    return match</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n"},{"title":"<js>浅拷贝","date":"2019-01-05T16:00:00.000Z","_content":"\n### 概念\n\n- https://mp.weixin.qq.com/s/scz9gRJeh7PM6GJ7wvnTsA\n\n### 浅拷贝\n\n#### Object.assign()\n\n```javascript\nconst obj1 = {a:1}\nconst obj2 = {b:{c:1}}\nObject.assign(obj1,obj2)\nconsole.log(JSON.stringify(obj1)) // {\"a\":1,\"b\":{\"c\":1}}\nobj2.b.c = 2\nconsole.log(JSON.stringify(obj1)) // {\"a\":1,\"b\":{\"c\":2}}\n```\n\n#### 扩展运算符\n\n```javascript\nconst obj1 = { a: { c: 2 }, b: 1 };\nobj2 = { ...obj1 };\nobj1.a.c = 1;\nconsole.log(JSON.stringify(obj2)); // {\"a\":{\"c\":1},\"b\":1}\n```\n\n#### conact拷贝数组\n\n```javascript\nconst arr1 = [1,2,{a: 1}]\nconst arr2 = arr1.concat()\narr1[2].a = 2\narr2[0] = 3\nconsole.log(JSON.stringify(arr2)) // [3,2,{\"a\":2}]\n```\n\n#### slice拷贝数组\n\n```javascript\nconst arr1 = [1,2,{a: 1}]\nconst arr2 = arr1.slice()\narr1[2].a = 2\narr2[0] = 3\nconsole.log(JSON.stringify(arr2)) // [3,2,{\"a\":2}]\n```\n\n#### 代码实现浅拷贝\n\n```javascript\nfunction clone(target) {\n  if (typeof target === \"object\" && target !== null) {\n    const cloneData = Array.isArray(target) ? [] : {};\n    for (const k in target) {\n      if (target.hasOwnProperty(k)) {\n        cloneData[k] = target[k];\n      }\n    }\n    return cloneData;\n  }\n  return target;\n}\n```\n\n### 深拷贝\n\n#### JSON.stringfy\n\n- 存在问题：\n1. 函数、undefined、symbol 会消失\n2. Date 引用类型会变成字符串\n3. 不可枚举属性无法拷贝\n4. 无法拷贝对象的原型链\n5. 拷贝 RegExp 引用类型会变成空对象\n6. 有 NaN、Infinity 以及 -Infinity 会变成 null\n7. 无法拷贝对象的循环应用，即对象成环 (obj[key] = obj) 错误信息：Uncaught TypeError: Converting circular structure to JSON\n\n```javascript\nfunction deepClone(target) {\n  return JSON.parse(JSON.stringify(target));\n}\nconst obj = {\n  fun: function () {},\n  date: new Date(),\n  reg: /\\d/gim,\n  d1: Symbol(),\n  d2: null,\n  d3: undefined,\n  d4: NaN,\n};\nconsole.log(JSON.stringify(deepClone(obj))); // {\"date\":\"2021-03-09T08:40:02.381Z\",\"reg\":{},\"d2\":null,\"d4\":null}\n```\n\n#### 递归实现\n\n```javascript\nfunction clone(value) {\n  if (Array.isArray(value)) {\n    return value.map(clone);\n  } else if (value && typeof value === \"object\") {\n    const res = {};\n    for (const key in value) {\n      if (target.hasOwnProperty(k)) {\n        res[key] = clone(value[key]);\n      }\n    }\n    return res;\n  } else {\n    return value;\n  }\n}\n```\n\n#### 考虑循环嵌套情况\n\n```javascript\nfunction deepClone(target, cache = new WeakMap()) {\n  if (cache.has(target)) {\n    return cache.get(target);\n  }\n  if (typeof target === \"object\" && target !== null) {\n    if (target.constructor === Date) {\n      return new Date(target);\n    }\n    if (target.constructor === RegExp) {\n      return new RegExp(target);\n    }\n    // ...\n    cache.set(target, target);\n    const cloneTarget = Array.isArray(target) ? [] : {};\n    for (const k in target) {\n      if (target.hasOwnProperty(k)) {\n        cloneTarget[k] = deepClone(target[k], cache);\n      }\n    }\n    return cloneTarget;\n  }\n  return target;\n}\n```\n\n```javascript\nconst deepClone = function (obj, hash = new WeakMap()) {\n  if (obj.constructor === Date) \n  return new Date(obj)       // 日期对象直接返回一个新的日期对象\n  if (obj.constructor === RegExp)\n  return new RegExp(obj)     //正则对象直接返回一个新的正则对象\n  //如果循环引用了就用 weakMap 来解决\n  if (hash.has(obj)) return hash.get(obj)\n  let allDesc = Object.getOwnPropertyDescriptors(obj)\n  //遍历传入参数所有键的特性\n  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)\n  //继承原型链\n  hash.set(obj, cloneObj)\n  for (let key of Reflect.ownKeys(obj)) { \n    cloneObj[key] = (isComplexDataType(obj[key]) && typeof obj[key] !== 'function') ? deepClone(obj[key], hash) : obj[key]\n  }\n  return cloneObj\n}\n```\n","source":"_posts/[js]深浅拷贝.md","raw":"---\ntitle: <js>浅拷贝\ndate: 2019-01-06 00:00:00\ntags: [js,深拷贝]\ncategories: js\n---\n\n### 概念\n\n- https://mp.weixin.qq.com/s/scz9gRJeh7PM6GJ7wvnTsA\n\n### 浅拷贝\n\n#### Object.assign()\n\n```javascript\nconst obj1 = {a:1}\nconst obj2 = {b:{c:1}}\nObject.assign(obj1,obj2)\nconsole.log(JSON.stringify(obj1)) // {\"a\":1,\"b\":{\"c\":1}}\nobj2.b.c = 2\nconsole.log(JSON.stringify(obj1)) // {\"a\":1,\"b\":{\"c\":2}}\n```\n\n#### 扩展运算符\n\n```javascript\nconst obj1 = { a: { c: 2 }, b: 1 };\nobj2 = { ...obj1 };\nobj1.a.c = 1;\nconsole.log(JSON.stringify(obj2)); // {\"a\":{\"c\":1},\"b\":1}\n```\n\n#### conact拷贝数组\n\n```javascript\nconst arr1 = [1,2,{a: 1}]\nconst arr2 = arr1.concat()\narr1[2].a = 2\narr2[0] = 3\nconsole.log(JSON.stringify(arr2)) // [3,2,{\"a\":2}]\n```\n\n#### slice拷贝数组\n\n```javascript\nconst arr1 = [1,2,{a: 1}]\nconst arr2 = arr1.slice()\narr1[2].a = 2\narr2[0] = 3\nconsole.log(JSON.stringify(arr2)) // [3,2,{\"a\":2}]\n```\n\n#### 代码实现浅拷贝\n\n```javascript\nfunction clone(target) {\n  if (typeof target === \"object\" && target !== null) {\n    const cloneData = Array.isArray(target) ? [] : {};\n    for (const k in target) {\n      if (target.hasOwnProperty(k)) {\n        cloneData[k] = target[k];\n      }\n    }\n    return cloneData;\n  }\n  return target;\n}\n```\n\n### 深拷贝\n\n#### JSON.stringfy\n\n- 存在问题：\n1. 函数、undefined、symbol 会消失\n2. Date 引用类型会变成字符串\n3. 不可枚举属性无法拷贝\n4. 无法拷贝对象的原型链\n5. 拷贝 RegExp 引用类型会变成空对象\n6. 有 NaN、Infinity 以及 -Infinity 会变成 null\n7. 无法拷贝对象的循环应用，即对象成环 (obj[key] = obj) 错误信息：Uncaught TypeError: Converting circular structure to JSON\n\n```javascript\nfunction deepClone(target) {\n  return JSON.parse(JSON.stringify(target));\n}\nconst obj = {\n  fun: function () {},\n  date: new Date(),\n  reg: /\\d/gim,\n  d1: Symbol(),\n  d2: null,\n  d3: undefined,\n  d4: NaN,\n};\nconsole.log(JSON.stringify(deepClone(obj))); // {\"date\":\"2021-03-09T08:40:02.381Z\",\"reg\":{},\"d2\":null,\"d4\":null}\n```\n\n#### 递归实现\n\n```javascript\nfunction clone(value) {\n  if (Array.isArray(value)) {\n    return value.map(clone);\n  } else if (value && typeof value === \"object\") {\n    const res = {};\n    for (const key in value) {\n      if (target.hasOwnProperty(k)) {\n        res[key] = clone(value[key]);\n      }\n    }\n    return res;\n  } else {\n    return value;\n  }\n}\n```\n\n#### 考虑循环嵌套情况\n\n```javascript\nfunction deepClone(target, cache = new WeakMap()) {\n  if (cache.has(target)) {\n    return cache.get(target);\n  }\n  if (typeof target === \"object\" && target !== null) {\n    if (target.constructor === Date) {\n      return new Date(target);\n    }\n    if (target.constructor === RegExp) {\n      return new RegExp(target);\n    }\n    // ...\n    cache.set(target, target);\n    const cloneTarget = Array.isArray(target) ? [] : {};\n    for (const k in target) {\n      if (target.hasOwnProperty(k)) {\n        cloneTarget[k] = deepClone(target[k], cache);\n      }\n    }\n    return cloneTarget;\n  }\n  return target;\n}\n```\n\n```javascript\nconst deepClone = function (obj, hash = new WeakMap()) {\n  if (obj.constructor === Date) \n  return new Date(obj)       // 日期对象直接返回一个新的日期对象\n  if (obj.constructor === RegExp)\n  return new RegExp(obj)     //正则对象直接返回一个新的正则对象\n  //如果循环引用了就用 weakMap 来解决\n  if (hash.has(obj)) return hash.get(obj)\n  let allDesc = Object.getOwnPropertyDescriptors(obj)\n  //遍历传入参数所有键的特性\n  let cloneObj = Object.create(Object.getPrototypeOf(obj), allDesc)\n  //继承原型链\n  hash.set(obj, cloneObj)\n  for (let key of Reflect.ownKeys(obj)) { \n    cloneObj[key] = (isComplexDataType(obj[key]) && typeof obj[key] !== 'function') ? deepClone(obj[key], hash) : obj[key]\n  }\n  return cloneObj\n}\n```\n","slug":"[js]深浅拷贝","published":1,"updated":"2021-03-15T14:38:36.320Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dks002iwotj56bc8h14","content":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/scz9gRJeh7PM6GJ7wvnTsA\">https://mp.weixin.qq.com/s/scz9gRJeh7PM6GJ7wvnTsA</a></li>\n</ul>\n<h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><h4 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;<span class=\"attr\">b</span>:&#123;<span class=\"attr\">c</span>:<span class=\"number\">1</span>&#125;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(obj1,obj2)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(obj1)) <span class=\"comment\">// &#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:1&#125;&#125;</span></span><br><span class=\"line\">obj2.b.c = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(obj1)) <span class=\"comment\">// &#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:2&#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123; <span class=\"attr\">a</span>: &#123; <span class=\"attr\">c</span>: <span class=\"number\">2</span> &#125;, <span class=\"attr\">b</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">obj2 = &#123; ...obj1 &#125;;</span><br><span class=\"line\">obj1.a.c = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(obj2)); <span class=\"comment\">// &#123;&quot;a&quot;:&#123;&quot;c&quot;:1&#125;,&quot;b&quot;:1&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"conact拷贝数组\"><a href=\"#conact拷贝数组\" class=\"headerlink\" title=\"conact拷贝数组\"></a>conact拷贝数组</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,&#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;]</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr2 = arr1.concat()</span><br><span class=\"line\">arr1[<span class=\"number\">2</span>].a = <span class=\"number\">2</span></span><br><span class=\"line\">arr2[<span class=\"number\">0</span>] = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(arr2)) <span class=\"comment\">// [3,2,&#123;&quot;a&quot;:2&#125;]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"slice拷贝数组\"><a href=\"#slice拷贝数组\" class=\"headerlink\" title=\"slice拷贝数组\"></a>slice拷贝数组</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,&#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;]</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr2 = arr1.slice()</span><br><span class=\"line\">arr1[<span class=\"number\">2</span>].a = <span class=\"number\">2</span></span><br><span class=\"line\">arr2[<span class=\"number\">0</span>] = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(arr2)) <span class=\"comment\">// [3,2,&#123;&quot;a&quot;:2&#125;]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"代码实现浅拷贝\"><a href=\"#代码实现浅拷贝\" class=\"headerlink\" title=\"代码实现浅拷贝\"></a>代码实现浅拷贝</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> target === <span class=\"string\">&quot;object&quot;</span> &amp;&amp; target !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cloneData = <span class=\"built_in\">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">        cloneData[k] = target[k];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cloneData;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><h4 id=\"JSON-stringfy\"><a href=\"#JSON-stringfy\" class=\"headerlink\" title=\"JSON.stringfy\"></a>JSON.stringfy</h4><ul>\n<li>存在问题：</li>\n</ul>\n<ol>\n<li>函数、undefined、symbol 会消失</li>\n<li>Date 引用类型会变成字符串</li>\n<li>不可枚举属性无法拷贝</li>\n<li>无法拷贝对象的原型链</li>\n<li>拷贝 RegExp 引用类型会变成空对象</li>\n<li>有 NaN、Infinity 以及 -Infinity 会变成 null</li>\n<li>无法拷贝对象的循环应用，即对象成环 (obj[key] = obj) 错误信息：Uncaught TypeError: Converting circular structure to JSON</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(target));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  fun: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  date: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">  reg: <span class=\"regexp\">/\\d/gim</span>,</span><br><span class=\"line\">  d1: <span class=\"built_in\">Symbol</span>(),</span><br><span class=\"line\">  d2: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  d3: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">  d4: <span class=\"literal\">NaN</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(deepClone(obj))); <span class=\"comment\">// &#123;&quot;date&quot;:&quot;2021-03-09T08:40:02.381Z&quot;,&quot;reg&quot;:&#123;&#125;,&quot;d2&quot;:null,&quot;d4&quot;:null&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"递归实现\"><a href=\"#递归实现\" class=\"headerlink\" title=\"递归实现\"></a>递归实现</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value.map(clone);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value &amp;&amp; <span class=\"keyword\">typeof</span> value === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> value) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">        res[key] = clone(value[key]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"考虑循环嵌套情况\"><a href=\"#考虑循环嵌套情况\" class=\"headerlink\" title=\"考虑循环嵌套情况\"></a>考虑循环嵌套情况</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">target, cache = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>()</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cache.has(target)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache.get(target);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> target === <span class=\"string\">&quot;object&quot;</span> &amp;&amp; target !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target.constructor === <span class=\"built_in\">Date</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target.constructor === <span class=\"built_in\">RegExp</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    cache.set(target, target);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cloneTarget = <span class=\"built_in\">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">        cloneTarget[k] = deepClone(target[k], cache);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cloneTarget;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> deepClone = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj, hash = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>()</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.constructor === <span class=\"built_in\">Date</span>) </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(obj)       <span class=\"comment\">// 日期对象直接返回一个新的日期对象</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.constructor === <span class=\"built_in\">RegExp</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(obj)     <span class=\"comment\">//正则对象直接返回一个新的正则对象</span></span><br><span class=\"line\">  <span class=\"comment\">//如果循环引用了就用 weakMap 来解决</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hash.has(obj)) <span class=\"keyword\">return</span> hash.get(obj)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> allDesc = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class=\"line\">  <span class=\"comment\">//遍历传入参数所有键的特性</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> cloneObj = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">Object</span>.getPrototypeOf(obj), allDesc)</span><br><span class=\"line\">  <span class=\"comment\">//继承原型链</span></span><br><span class=\"line\">  hash.set(obj, cloneObj)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">of</span> <span class=\"built_in\">Reflect</span>.ownKeys(obj)) &#123; </span><br><span class=\"line\">    cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] !== <span class=\"string\">&#x27;function&#x27;</span>) ? deepClone(obj[key], hash) : obj[key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cloneObj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h3><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/scz9gRJeh7PM6GJ7wvnTsA\">https://mp.weixin.qq.com/s/scz9gRJeh7PM6GJ7wvnTsA</a></li>\n</ul>\n<h3 id=\"浅拷贝\"><a href=\"#浅拷贝\" class=\"headerlink\" title=\"浅拷贝\"></a>浅拷贝</h3><h4 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123;<span class=\"attr\">a</span>:<span class=\"number\">1</span>&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj2 = &#123;<span class=\"attr\">b</span>:&#123;<span class=\"attr\">c</span>:<span class=\"number\">1</span>&#125;&#125;</span><br><span class=\"line\"><span class=\"built_in\">Object</span>.assign(obj1,obj2)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(obj1)) <span class=\"comment\">// &#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:1&#125;&#125;</span></span><br><span class=\"line\">obj2.b.c = <span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(obj1)) <span class=\"comment\">// &#123;&quot;a&quot;:1,&quot;b&quot;:&#123;&quot;c&quot;:2&#125;&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"扩展运算符\"><a href=\"#扩展运算符\" class=\"headerlink\" title=\"扩展运算符\"></a>扩展运算符</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> obj1 = &#123; <span class=\"attr\">a</span>: &#123; <span class=\"attr\">c</span>: <span class=\"number\">2</span> &#125;, <span class=\"attr\">b</span>: <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">obj2 = &#123; ...obj1 &#125;;</span><br><span class=\"line\">obj1.a.c = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(obj2)); <span class=\"comment\">// &#123;&quot;a&quot;:&#123;&quot;c&quot;:1&#125;,&quot;b&quot;:1&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"conact拷贝数组\"><a href=\"#conact拷贝数组\" class=\"headerlink\" title=\"conact拷贝数组\"></a>conact拷贝数组</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,&#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;]</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr2 = arr1.concat()</span><br><span class=\"line\">arr1[<span class=\"number\">2</span>].a = <span class=\"number\">2</span></span><br><span class=\"line\">arr2[<span class=\"number\">0</span>] = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(arr2)) <span class=\"comment\">// [3,2,&#123;&quot;a&quot;:2&#125;]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"slice拷贝数组\"><a href=\"#slice拷贝数组\" class=\"headerlink\" title=\"slice拷贝数组\"></a>slice拷贝数组</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> arr1 = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,&#123;<span class=\"attr\">a</span>: <span class=\"number\">1</span>&#125;]</span><br><span class=\"line\"><span class=\"keyword\">const</span> arr2 = arr1.slice()</span><br><span class=\"line\">arr1[<span class=\"number\">2</span>].a = <span class=\"number\">2</span></span><br><span class=\"line\">arr2[<span class=\"number\">0</span>] = <span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(arr2)) <span class=\"comment\">// [3,2,&#123;&quot;a&quot;:2&#125;]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"代码实现浅拷贝\"><a href=\"#代码实现浅拷贝\" class=\"headerlink\" title=\"代码实现浅拷贝\"></a>代码实现浅拷贝</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> target === <span class=\"string\">&quot;object&quot;</span> &amp;&amp; target !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cloneData = <span class=\"built_in\">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">        cloneData[k] = target[k];</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cloneData;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"深拷贝\"><a href=\"#深拷贝\" class=\"headerlink\" title=\"深拷贝\"></a>深拷贝</h3><h4 id=\"JSON-stringfy\"><a href=\"#JSON-stringfy\" class=\"headerlink\" title=\"JSON.stringfy\"></a>JSON.stringfy</h4><ul>\n<li>存在问题：</li>\n</ul>\n<ol>\n<li>函数、undefined、symbol 会消失</li>\n<li>Date 引用类型会变成字符串</li>\n<li>不可枚举属性无法拷贝</li>\n<li>无法拷贝对象的原型链</li>\n<li>拷贝 RegExp 引用类型会变成空对象</li>\n<li>有 NaN、Infinity 以及 -Infinity 会变成 null</li>\n<li>无法拷贝对象的循环应用，即对象成环 (obj[key] = obj) 错误信息：Uncaught TypeError: Converting circular structure to JSON</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">target</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"built_in\">JSON</span>.parse(<span class=\"built_in\">JSON</span>.stringify(target));</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> obj = &#123;</span><br><span class=\"line\">  fun: <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;&#125;,</span><br><span class=\"line\">  date: <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(),</span><br><span class=\"line\">  reg: <span class=\"regexp\">/\\d/gim</span>,</span><br><span class=\"line\">  d1: <span class=\"built_in\">Symbol</span>(),</span><br><span class=\"line\">  d2: <span class=\"literal\">null</span>,</span><br><span class=\"line\">  d3: <span class=\"literal\">undefined</span>,</span><br><span class=\"line\">  d4: <span class=\"literal\">NaN</span>,</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"built_in\">JSON</span>.stringify(deepClone(obj))); <span class=\"comment\">// &#123;&quot;date&quot;:&quot;2021-03-09T08:40:02.381Z&quot;,&quot;reg&quot;:&#123;&#125;,&quot;d2&quot;:null,&quot;d4&quot;:null&#125;</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"递归实现\"><a href=\"#递归实现\" class=\"headerlink\" title=\"递归实现\"></a>递归实现</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">value</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"built_in\">Array</span>.isArray(value)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value.map(clone);</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (value &amp;&amp; <span class=\"keyword\">typeof</span> value === <span class=\"string\">&quot;object&quot;</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> res = &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> key <span class=\"keyword\">in</span> value) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">        res[key] = clone(value[key]);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> res;</span><br><span class=\"line\">  &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"考虑循环嵌套情况\"><a href=\"#考虑循环嵌套情况\" class=\"headerlink\" title=\"考虑循环嵌套情况\"></a>考虑循环嵌套情况</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">deepClone</span>(<span class=\"params\">target, cache = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>()</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (cache.has(target)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cache.get(target);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> target === <span class=\"string\">&quot;object&quot;</span> &amp;&amp; target !== <span class=\"literal\">null</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target.constructor === <span class=\"built_in\">Date</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (target.constructor === <span class=\"built_in\">RegExp</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(target);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// ...</span></span><br><span class=\"line\">    cache.set(target, target);</span><br><span class=\"line\">    <span class=\"keyword\">const</span> cloneTarget = <span class=\"built_in\">Array</span>.isArray(target) ? [] : &#123;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">const</span> k <span class=\"keyword\">in</span> target) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (target.hasOwnProperty(k)) &#123;</span><br><span class=\"line\">        cloneTarget[k] = deepClone(target[k], cache);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> cloneTarget;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> target;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> deepClone = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">obj, hash = <span class=\"keyword\">new</span> <span class=\"built_in\">WeakMap</span>()</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.constructor === <span class=\"built_in\">Date</span>) </span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Date</span>(obj)       <span class=\"comment\">// 日期对象直接返回一个新的日期对象</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (obj.constructor === <span class=\"built_in\">RegExp</span>)</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> <span class=\"built_in\">RegExp</span>(obj)     <span class=\"comment\">//正则对象直接返回一个新的正则对象</span></span><br><span class=\"line\">  <span class=\"comment\">//如果循环引用了就用 weakMap 来解决</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (hash.has(obj)) <span class=\"keyword\">return</span> hash.get(obj)</span><br><span class=\"line\">  <span class=\"keyword\">let</span> allDesc = <span class=\"built_in\">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class=\"line\">  <span class=\"comment\">//遍历传入参数所有键的特性</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> cloneObj = <span class=\"built_in\">Object</span>.create(<span class=\"built_in\">Object</span>.getPrototypeOf(obj), allDesc)</span><br><span class=\"line\">  <span class=\"comment\">//继承原型链</span></span><br><span class=\"line\">  hash.set(obj, cloneObj)</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> key <span class=\"keyword\">of</span> <span class=\"built_in\">Reflect</span>.ownKeys(obj)) &#123; </span><br><span class=\"line\">    cloneObj[key] = (isComplexDataType(obj[key]) &amp;&amp; <span class=\"keyword\">typeof</span> obj[key] !== <span class=\"string\">&#x27;function&#x27;</span>) ? deepClone(obj[key], hash) : obj[key]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> cloneObj</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"<js>继承","date":"2029-03-02T16:00:00.000Z","_content":"\n#### 原型链继承\n\n- 构造函数、原型、实例的关系：构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针\n- 原型链继承问题：实例使用同一个原型对象，更改原型对象上的属性会影响所有实例\n\n```javascript\nfunction Father(){\n  this.arr = [1,2,3]\n}\nfunction Child(lastName = ''){\n}\n\nChild.prototype = new Father()\nChild.prototype.constructor = Child\n\nconst child1 = new Child()\nconst child2 = new Child()\n\nchild1.arr.push(4)\nconsole.log(child2.arr) // [1, 2, 3, 4]\n```\n\n#### 构造函数继承(call)\n\n- 存在问题：子类无法继承父类原型中存在的方法\n\n```javascript\nfunction Father() {\n  this.arr = [1, 2, 3];\n}\nFather.prototype.say = function () {\n  console.log(this.arr);\n};\nfunction Child(name) {\n  Father.call(this);\n  this.name = name;\n}\nconst child = new Child();\nconsole.log(child.arr); // [1, 2, 3]\nchild.say(); // 会报错，没有继承该属性\n```\n\n#### 组合继承\n\n- 原型继承 + 构造函数继承\n- 存在问题：父构造函数会执行两次\n\n```javascript\nfunction Father() {\n  this.arr = [1, 2, 3];\n}\nFather.prototype.say = function () {\n  console.log(this.arr);\n};\nfunction Child(name) {\n  Father.call(this); // 执行一次\n  this.name = name;\n}\nChild.prototype = new Father() // 执行一次\nChild.prototype.constructor = Child\n\nconst child = new Child();\nconsole.log(child.arr); // [1, 2, 3]\nchild.say();\n```\n\n#### 原型式继承Object.create\n\n- Object.create，两个参数：新对象的原型对象、对象的属性类型参照Object.defineProperties()的第二个参数（可选）\n- 存在问题：使用浅拷贝方式复制属性，引用类型属性共用\n\n```javascript\nconst parent = {\n  arr: [1,2,3]\n}\nconst parent1 = Object.create(parent)\nparent1.name = '1'\nparent1.arr.push(4)\n\nconsole.log(parent.arr) // [1, 2, 3, 4]\nconsole.log(parent.name) // undefined\nconsole.log(parent1.arr) // [1, 2, 3, 4]\n```\n\n#### 寄生式继承\n\n- 可以在父类基础上添加方法\n- 存在问题：父类引用类型共用\n\n```javascript\nconst parent = {\n  arr: [1, 2, 3],\n};\nfunction clone() {\n  const obj = Object.create(parent);\n  // 在父类基础上添加方法\n  obj.say = function () {\n    console.log(this.arr);\n  };\n  return obj;\n}\nconst parent1 = clone(parent);\n```\n\n#### 组合寄生式继承\n\n- 通过寄生方式较少父类构造函数调用，通过组合方式避免父类引用类型互相影响\n- es6 extends关键字使用类似方式实现\n\n```javascript\n// 通过寄生方式较少父类构造函数调用\nfunction clone(parent, child) {\n  child.prototype = Object.create(parent.prototype);\n  child.prototype.constructor = child;\n}\nfunction Father() {\n  this.arr = [1, 2, 3];\n}\nFather.prototype.say = function () {\n  console.log(this.arr);\n};\nfunction Child(name) {\n  Father.call(this); // 父构造函数只执行一遍\n  this.name = name;\n}\nclone(Father, Child);\n\nconst child1 = new Child(\"张三\");\nconst child2 = new Child(\"李四\");\n\nchild1.arr.push(4);\nchild2.say(); // [1, 2, 3] 不会改变\n```\n\n\n\n\n\n","source":"_posts/[js]继承.md","raw":"---\ntitle: <js>继承\ndate: 2029-03-03 00:00:00\ntags: [js,js继承]\ncategories: js\n---\n\n#### 原型链继承\n\n- 构造函数、原型、实例的关系：构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针\n- 原型链继承问题：实例使用同一个原型对象，更改原型对象上的属性会影响所有实例\n\n```javascript\nfunction Father(){\n  this.arr = [1,2,3]\n}\nfunction Child(lastName = ''){\n}\n\nChild.prototype = new Father()\nChild.prototype.constructor = Child\n\nconst child1 = new Child()\nconst child2 = new Child()\n\nchild1.arr.push(4)\nconsole.log(child2.arr) // [1, 2, 3, 4]\n```\n\n#### 构造函数继承(call)\n\n- 存在问题：子类无法继承父类原型中存在的方法\n\n```javascript\nfunction Father() {\n  this.arr = [1, 2, 3];\n}\nFather.prototype.say = function () {\n  console.log(this.arr);\n};\nfunction Child(name) {\n  Father.call(this);\n  this.name = name;\n}\nconst child = new Child();\nconsole.log(child.arr); // [1, 2, 3]\nchild.say(); // 会报错，没有继承该属性\n```\n\n#### 组合继承\n\n- 原型继承 + 构造函数继承\n- 存在问题：父构造函数会执行两次\n\n```javascript\nfunction Father() {\n  this.arr = [1, 2, 3];\n}\nFather.prototype.say = function () {\n  console.log(this.arr);\n};\nfunction Child(name) {\n  Father.call(this); // 执行一次\n  this.name = name;\n}\nChild.prototype = new Father() // 执行一次\nChild.prototype.constructor = Child\n\nconst child = new Child();\nconsole.log(child.arr); // [1, 2, 3]\nchild.say();\n```\n\n#### 原型式继承Object.create\n\n- Object.create，两个参数：新对象的原型对象、对象的属性类型参照Object.defineProperties()的第二个参数（可选）\n- 存在问题：使用浅拷贝方式复制属性，引用类型属性共用\n\n```javascript\nconst parent = {\n  arr: [1,2,3]\n}\nconst parent1 = Object.create(parent)\nparent1.name = '1'\nparent1.arr.push(4)\n\nconsole.log(parent.arr) // [1, 2, 3, 4]\nconsole.log(parent.name) // undefined\nconsole.log(parent1.arr) // [1, 2, 3, 4]\n```\n\n#### 寄生式继承\n\n- 可以在父类基础上添加方法\n- 存在问题：父类引用类型共用\n\n```javascript\nconst parent = {\n  arr: [1, 2, 3],\n};\nfunction clone() {\n  const obj = Object.create(parent);\n  // 在父类基础上添加方法\n  obj.say = function () {\n    console.log(this.arr);\n  };\n  return obj;\n}\nconst parent1 = clone(parent);\n```\n\n#### 组合寄生式继承\n\n- 通过寄生方式较少父类构造函数调用，通过组合方式避免父类引用类型互相影响\n- es6 extends关键字使用类似方式实现\n\n```javascript\n// 通过寄生方式较少父类构造函数调用\nfunction clone(parent, child) {\n  child.prototype = Object.create(parent.prototype);\n  child.prototype.constructor = child;\n}\nfunction Father() {\n  this.arr = [1, 2, 3];\n}\nFather.prototype.say = function () {\n  console.log(this.arr);\n};\nfunction Child(name) {\n  Father.call(this); // 父构造函数只执行一遍\n  this.name = name;\n}\nclone(Father, Child);\n\nconst child1 = new Child(\"张三\");\nconst child2 = new Child(\"李四\");\n\nchild1.arr.push(4);\nchild2.say(); // [1, 2, 3] 不会改变\n```\n\n\n\n\n\n","slug":"[js]继承","published":1,"updated":"2021-03-15T14:37:32.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dkt002lwotj0qm2eti5","content":"<h4 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h4><ul>\n<li>构造函数、原型、实例的关系：构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针</li>\n<li>原型链继承问题：实例使用同一个原型对象，更改原型对象上的属性会影响所有实例</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Father</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">lastName = <span class=\"string\">&#x27;&#x27;</span></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Father()</span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Child()</span><br><span class=\"line\"><span class=\"keyword\">const</span> child2 = <span class=\"keyword\">new</span> Child()</span><br><span class=\"line\"></span><br><span class=\"line\">child1.arr.push(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.arr) <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"构造函数继承-call\"><a href=\"#构造函数继承-call\" class=\"headerlink\" title=\"构造函数继承(call)\"></a>构造函数继承(call)</h4><ul>\n<li>存在问题：子类无法继承父类原型中存在的方法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Father</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Father.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Father.call(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.arr); <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\">child.say(); <span class=\"comment\">// 会报错，没有继承该属性</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h4><ul>\n<li>原型继承 + 构造函数继承</li>\n<li>存在问题：父构造函数会执行两次</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Father</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Father.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Father.call(<span class=\"built_in\">this</span>); <span class=\"comment\">// 执行一次</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Father() <span class=\"comment\">// 执行一次</span></span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.arr); <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\">child.say();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原型式继承Object-create\"><a href=\"#原型式继承Object-create\" class=\"headerlink\" title=\"原型式继承Object.create\"></a>原型式继承Object.create</h4><ul>\n<li>Object.create，两个参数：新对象的原型对象、对象的属性类型参照Object.defineProperties()的第二个参数（可选）</li>\n<li>存在问题：使用浅拷贝方式复制属性，引用类型属性共用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> parent = &#123;</span><br><span class=\"line\">  arr: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> parent1 = <span class=\"built_in\">Object</span>.create(parent)</span><br><span class=\"line\">parent1.name = <span class=\"string\">&#x27;1&#x27;</span></span><br><span class=\"line\">parent1.arr.push(<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(parent.arr) <span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(parent.name) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(parent1.arr) <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h4><ul>\n<li>可以在父类基础上添加方法</li>\n<li>存在问题：父类引用类型共用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> parent = &#123;</span><br><span class=\"line\">  arr: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.create(parent);</span><br><span class=\"line\">  <span class=\"comment\">// 在父类基础上添加方法</span></span><br><span class=\"line\">  obj.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> parent1 = clone(parent);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"组合寄生式继承\"><a href=\"#组合寄生式继承\" class=\"headerlink\" title=\"组合寄生式继承\"></a>组合寄生式继承</h4><ul>\n<li>通过寄生方式较少父类构造函数调用，通过组合方式避免父类引用类型互相影响</li>\n<li>es6 extends关键字使用类似方式实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过寄生方式较少父类构造函数调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">parent, child</span>) </span>&#123;</span><br><span class=\"line\">  child.prototype = <span class=\"built_in\">Object</span>.create(parent.prototype);</span><br><span class=\"line\">  child.prototype.constructor = child;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Father</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Father.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Father.call(<span class=\"built_in\">this</span>); <span class=\"comment\">// 父构造函数只执行一遍</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">clone(Father, Child);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;李四&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">child1.arr.push(<span class=\"number\">4</span>);</span><br><span class=\"line\">child2.say(); <span class=\"comment\">// [1, 2, 3] 不会改变</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"原型链继承\"><a href=\"#原型链继承\" class=\"headerlink\" title=\"原型链继承\"></a>原型链继承</h4><ul>\n<li>构造函数、原型、实例的关系：构造函数都有一个原型对象，原型对象又包含一个指向构造函数的指针，而实例则包含一个原型对象的指针</li>\n<li>原型链继承问题：实例使用同一个原型对象，更改原型对象上的属性会影响所有实例</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Father</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">lastName = <span class=\"string\">&#x27;&#x27;</span></span>)</span>&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Father()</span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Child()</span><br><span class=\"line\"><span class=\"keyword\">const</span> child2 = <span class=\"keyword\">new</span> Child()</span><br><span class=\"line\"></span><br><span class=\"line\">child1.arr.push(<span class=\"number\">4</span>)</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child2.arr) <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"构造函数继承-call\"><a href=\"#构造函数继承-call\" class=\"headerlink\" title=\"构造函数继承(call)\"></a>构造函数继承(call)</h4><ul>\n<li>存在问题：子类无法继承父类原型中存在的方法</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Father</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Father.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Father.call(<span class=\"built_in\">this</span>);</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.arr); <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\">child.say(); <span class=\"comment\">// 会报错，没有继承该属性</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"组合继承\"><a href=\"#组合继承\" class=\"headerlink\" title=\"组合继承\"></a>组合继承</h4><ul>\n<li>原型继承 + 构造函数继承</li>\n<li>存在问题：父构造函数会执行两次</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Father</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Father.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Father.call(<span class=\"built_in\">this</span>); <span class=\"comment\">// 执行一次</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Child.prototype = <span class=\"keyword\">new</span> Father() <span class=\"comment\">// 执行一次</span></span><br><span class=\"line\">Child.prototype.constructor = Child</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child = <span class=\"keyword\">new</span> Child();</span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(child.arr); <span class=\"comment\">// [1, 2, 3]</span></span><br><span class=\"line\">child.say();</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原型式继承Object-create\"><a href=\"#原型式继承Object-create\" class=\"headerlink\" title=\"原型式继承Object.create\"></a>原型式继承Object.create</h4><ul>\n<li>Object.create，两个参数：新对象的原型对象、对象的属性类型参照Object.defineProperties()的第二个参数（可选）</li>\n<li>存在问题：使用浅拷贝方式复制属性，引用类型属性共用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> parent = &#123;</span><br><span class=\"line\">  arr: [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> parent1 = <span class=\"built_in\">Object</span>.create(parent)</span><br><span class=\"line\">parent1.name = <span class=\"string\">&#x27;1&#x27;</span></span><br><span class=\"line\">parent1.arr.push(<span class=\"number\">4</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(parent.arr) <span class=\"comment\">// [1, 2, 3, 4]</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(parent.name) <span class=\"comment\">// undefined</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(parent1.arr) <span class=\"comment\">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"寄生式继承\"><a href=\"#寄生式继承\" class=\"headerlink\" title=\"寄生式继承\"></a>寄生式继承</h4><ul>\n<li>可以在父类基础上添加方法</li>\n<li>存在问题：父类引用类型共用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> parent = &#123;</span><br><span class=\"line\">  arr: [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>],</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> obj = <span class=\"built_in\">Object</span>.create(parent);</span><br><span class=\"line\">  <span class=\"comment\">// 在父类基础上添加方法</span></span><br><span class=\"line\">  obj.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> parent1 = clone(parent);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"组合寄生式继承\"><a href=\"#组合寄生式继承\" class=\"headerlink\" title=\"组合寄生式继承\"></a>组合寄生式继承</h4><ul>\n<li>通过寄生方式较少父类构造函数调用，通过组合方式避免父类引用类型互相影响</li>\n<li>es6 extends关键字使用类似方式实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 通过寄生方式较少父类构造函数调用</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">clone</span>(<span class=\"params\">parent, child</span>) </span>&#123;</span><br><span class=\"line\">  child.prototype = <span class=\"built_in\">Object</span>.create(parent.prototype);</span><br><span class=\"line\">  child.prototype.constructor = child;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Father</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">this</span>.arr = [<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Father.prototype.say = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"built_in\">this</span>.arr);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">Child</span>(<span class=\"params\">name</span>) </span>&#123;</span><br><span class=\"line\">  Father.call(<span class=\"built_in\">this</span>); <span class=\"comment\">// 父构造函数只执行一遍</span></span><br><span class=\"line\">  <span class=\"built_in\">this</span>.name = name;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">clone(Father, Child);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> child1 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;张三&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> child2 = <span class=\"keyword\">new</span> Child(<span class=\"string\">&quot;李四&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">child1.arr.push(<span class=\"number\">4</span>);</span><br><span class=\"line\">child2.say(); <span class=\"comment\">// [1, 2, 3] 不会改变</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n"},{"title":"<node>pm2使用","date":"2020-09-10T16:00:00.000Z","_content":"### 安装 \n\n```\nnpm install pm2@latest -g\nyarn global add pm2\n```\n\n### 更新\n\n```\nnpm install pm2@latest -g\npm2 update\n```\n\n### 命令\n\n```\n// 启动\npm2 start app.js\npm2 start app.js --watch --ignore-watch=\"node_modules\"\n\n# Specify an app name\n--name <app_name>\n# Watch and Restart app when files change\n--watch\n# Set memory threshold for app reload\n--max-memory-restart <200MB>\n# Specify log file\n--log <log_path>\n# Pass extra arguments to the script\n-- arg1 arg2 arg3\n# Delay between automatic restarts\n--restart-delay <delay in ms>\n# Prefix logs with time\n--time\n# Do not auto restart app\n--no-autorestart\n# Specify cron for forced restart\n--cron <cron_pattern>\n# Attach to application log\n--no-daemon\n\n// 重启\npm2 restart <app_name,all,id>\npm2 reload <app_name,all,id>\n// 停止\npm2 stop <app_name,all,id>\n// 删除\npm2 delete <app_name,all,id>\n// 信息\npm2 [list|ls|status|jlist|prettylist]\n// 日志\npm2 logs\npm2 logs --lines 200\n// 清空日志\npm2 flush\n// 监控信息\npm2 monit\npm2 plus\n```\n\n### 配置文件\n\n- 生成示例配置文件：pm2 ecosystem\n- 配置文件支持 script、json、YAML 格式，js文件必须以.config.js结束\n- pm2.config.json示例\n\n```javascript\nmodule.exports = {\n  apps : [{\n    name: 'demo',\n    script: 'demo.js',\n    args: '-a 1 -b 2',// 可以通过 process.env.args 获取\n    instances: 1,// 实例数\n    exec_mode: 'cluster',// 运行模式\n    max_memory_restart: '2G', // '100M'\n    watch: true,\n    ignore_watch: [\"[\\/\\\\]\\./\", \"node_modules\"],\n    max_memory_restart: '1G',\n    env: {\n      NODE_ENV: 'development'\n    },\n    // 启动时可以使用 --env production切换环境变量\n    env_production: {\n      NODE_ENV: 'production'\n    },\n    // 日志配置\n    log_date_format: \"YYYY-MM-DD HH:mm:ss\",\n    error_file: './logs/server-error.log',\n    out_file: './logs/server-data.log',\n    listen_timeout: 8000,// 监听程序等待的时间，超过时间未监听到会重启\n    kill_timeout: 1000,// kill程序之前等待时间\n    max_restarts: 10,// 错误重启次数\n    restart_delay: 80000,// 重启崩溃应用前等待时间\n    autorestart: true,// 错误自动重启配置\n    cron_restart: '0 15 1 ? * *',// 自动重启，实例每天1点15触发\n  }],\n};\n```\n\n### 集群模式\n\n```\npm2 start app.js -i max\n```\n\n### docker部署\n\n- 使用pm2-runtime：npm install pm2 -g\n\n```\nCMD [\"pm2-runtime\", \"pm2.config.js\"]\n```","source":"_posts/[node]pm2使用.md","raw":"---\ntitle: <node>pm2使用\ndate: 2020-09-11 00:00:00\ntags: [pm2,node]\ncategories:  node\n---\n### 安装 \n\n```\nnpm install pm2@latest -g\nyarn global add pm2\n```\n\n### 更新\n\n```\nnpm install pm2@latest -g\npm2 update\n```\n\n### 命令\n\n```\n// 启动\npm2 start app.js\npm2 start app.js --watch --ignore-watch=\"node_modules\"\n\n# Specify an app name\n--name <app_name>\n# Watch and Restart app when files change\n--watch\n# Set memory threshold for app reload\n--max-memory-restart <200MB>\n# Specify log file\n--log <log_path>\n# Pass extra arguments to the script\n-- arg1 arg2 arg3\n# Delay between automatic restarts\n--restart-delay <delay in ms>\n# Prefix logs with time\n--time\n# Do not auto restart app\n--no-autorestart\n# Specify cron for forced restart\n--cron <cron_pattern>\n# Attach to application log\n--no-daemon\n\n// 重启\npm2 restart <app_name,all,id>\npm2 reload <app_name,all,id>\n// 停止\npm2 stop <app_name,all,id>\n// 删除\npm2 delete <app_name,all,id>\n// 信息\npm2 [list|ls|status|jlist|prettylist]\n// 日志\npm2 logs\npm2 logs --lines 200\n// 清空日志\npm2 flush\n// 监控信息\npm2 monit\npm2 plus\n```\n\n### 配置文件\n\n- 生成示例配置文件：pm2 ecosystem\n- 配置文件支持 script、json、YAML 格式，js文件必须以.config.js结束\n- pm2.config.json示例\n\n```javascript\nmodule.exports = {\n  apps : [{\n    name: 'demo',\n    script: 'demo.js',\n    args: '-a 1 -b 2',// 可以通过 process.env.args 获取\n    instances: 1,// 实例数\n    exec_mode: 'cluster',// 运行模式\n    max_memory_restart: '2G', // '100M'\n    watch: true,\n    ignore_watch: [\"[\\/\\\\]\\./\", \"node_modules\"],\n    max_memory_restart: '1G',\n    env: {\n      NODE_ENV: 'development'\n    },\n    // 启动时可以使用 --env production切换环境变量\n    env_production: {\n      NODE_ENV: 'production'\n    },\n    // 日志配置\n    log_date_format: \"YYYY-MM-DD HH:mm:ss\",\n    error_file: './logs/server-error.log',\n    out_file: './logs/server-data.log',\n    listen_timeout: 8000,// 监听程序等待的时间，超过时间未监听到会重启\n    kill_timeout: 1000,// kill程序之前等待时间\n    max_restarts: 10,// 错误重启次数\n    restart_delay: 80000,// 重启崩溃应用前等待时间\n    autorestart: true,// 错误自动重启配置\n    cron_restart: '0 15 1 ? * *',// 自动重启，实例每天1点15触发\n  }],\n};\n```\n\n### 集群模式\n\n```\npm2 start app.js -i max\n```\n\n### docker部署\n\n- 使用pm2-runtime：npm install pm2 -g\n\n```\nCMD [\"pm2-runtime\", \"pm2.config.js\"]\n```","slug":"[node]pm2使用","published":1,"updated":"2021-03-15T14:40:25.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dku002owotj29ti6f9n","content":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install pm2@latest -g</span><br><span class=\"line\">yarn global add pm2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install pm2@latest -g</span><br><span class=\"line\">pm2 update</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 启动</span><br><span class=\"line\">pm2 start app.js</span><br><span class=\"line\">pm2 start app.js --watch --ignore-watch&#x3D;&quot;node_modules&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># Specify an app name</span><br><span class=\"line\">--name &lt;app_name&gt;</span><br><span class=\"line\"># Watch and Restart app when files change</span><br><span class=\"line\">--watch</span><br><span class=\"line\"># Set memory threshold for app reload</span><br><span class=\"line\">--max-memory-restart &lt;200MB&gt;</span><br><span class=\"line\"># Specify log file</span><br><span class=\"line\">--log &lt;log_path&gt;</span><br><span class=\"line\"># Pass extra arguments to the script</span><br><span class=\"line\">-- arg1 arg2 arg3</span><br><span class=\"line\"># Delay between automatic restarts</span><br><span class=\"line\">--restart-delay &lt;delay in ms&gt;</span><br><span class=\"line\"># Prefix logs with time</span><br><span class=\"line\">--time</span><br><span class=\"line\"># Do not auto restart app</span><br><span class=\"line\">--no-autorestart</span><br><span class=\"line\"># Specify cron for forced restart</span><br><span class=\"line\">--cron &lt;cron_pattern&gt;</span><br><span class=\"line\"># Attach to application log</span><br><span class=\"line\">--no-daemon</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 重启</span><br><span class=\"line\">pm2 restart &lt;app_name,all,id&gt;</span><br><span class=\"line\">pm2 reload &lt;app_name,all,id&gt;</span><br><span class=\"line\">&#x2F;&#x2F; 停止</span><br><span class=\"line\">pm2 stop &lt;app_name,all,id&gt;</span><br><span class=\"line\">&#x2F;&#x2F; 删除</span><br><span class=\"line\">pm2 delete &lt;app_name,all,id&gt;</span><br><span class=\"line\">&#x2F;&#x2F; 信息</span><br><span class=\"line\">pm2 [list|ls|status|jlist|prettylist]</span><br><span class=\"line\">&#x2F;&#x2F; 日志</span><br><span class=\"line\">pm2 logs</span><br><span class=\"line\">pm2 logs --lines 200</span><br><span class=\"line\">&#x2F;&#x2F; 清空日志</span><br><span class=\"line\">pm2 flush</span><br><span class=\"line\">&#x2F;&#x2F; 监控信息</span><br><span class=\"line\">pm2 monit</span><br><span class=\"line\">pm2 plus</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><ul>\n<li>生成示例配置文件：pm2 ecosystem</li>\n<li>配置文件支持 script、json、YAML 格式，js文件必须以.config.js结束</li>\n<li>pm2.config.json示例</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  apps : [&#123;</span><br><span class=\"line\">    name: <span class=\"string\">&#x27;demo&#x27;</span>,</span><br><span class=\"line\">    script: <span class=\"string\">&#x27;demo.js&#x27;</span>,</span><br><span class=\"line\">    args: <span class=\"string\">&#x27;-a 1 -b 2&#x27;</span>,<span class=\"comment\">// 可以通过 process.env.args 获取</span></span><br><span class=\"line\">    instances: <span class=\"number\">1</span>,<span class=\"comment\">// 实例数</span></span><br><span class=\"line\">    exec_mode: <span class=\"string\">&#x27;cluster&#x27;</span>,<span class=\"comment\">// 运行模式</span></span><br><span class=\"line\">    max_memory_restart: <span class=\"string\">&#x27;2G&#x27;</span>, <span class=\"comment\">// &#x27;100M&#x27;</span></span><br><span class=\"line\">    watch: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    ignore_watch: [<span class=\"string\">&quot;[\\/\\\\]\\./&quot;</span>, <span class=\"string\">&quot;node_modules&quot;</span>],</span><br><span class=\"line\">    max_memory_restart: <span class=\"string\">&#x27;1G&#x27;</span>,</span><br><span class=\"line\">    env: &#123;</span><br><span class=\"line\">      NODE_ENV: <span class=\"string\">&#x27;development&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 启动时可以使用 --env production切换环境变量</span></span><br><span class=\"line\">    env_production: &#123;</span><br><span class=\"line\">      NODE_ENV: <span class=\"string\">&#x27;production&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 日志配置</span></span><br><span class=\"line\">    log_date_format: <span class=\"string\">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>,</span><br><span class=\"line\">    error_file: <span class=\"string\">&#x27;./logs/server-error.log&#x27;</span>,</span><br><span class=\"line\">    out_file: <span class=\"string\">&#x27;./logs/server-data.log&#x27;</span>,</span><br><span class=\"line\">    listen_timeout: <span class=\"number\">8000</span>,<span class=\"comment\">// 监听程序等待的时间，超过时间未监听到会重启</span></span><br><span class=\"line\">    kill_timeout: <span class=\"number\">1000</span>,<span class=\"comment\">// kill程序之前等待时间</span></span><br><span class=\"line\">    max_restarts: <span class=\"number\">10</span>,<span class=\"comment\">// 错误重启次数</span></span><br><span class=\"line\">    restart_delay: <span class=\"number\">80000</span>,<span class=\"comment\">// 重启崩溃应用前等待时间</span></span><br><span class=\"line\">    autorestart: <span class=\"literal\">true</span>,<span class=\"comment\">// 错误自动重启配置</span></span><br><span class=\"line\">    cron_restart: <span class=\"string\">&#x27;0 15 1 ? * *&#x27;</span>,<span class=\"comment\">// 自动重启，实例每天1点15触发</span></span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"集群模式\"><a href=\"#集群模式\" class=\"headerlink\" title=\"集群模式\"></a>集群模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 start app.js -i max</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"docker部署\"><a href=\"#docker部署\" class=\"headerlink\" title=\"docker部署\"></a>docker部署</h3><ul>\n<li>使用pm2-runtime：npm install pm2 -g</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMD [&quot;pm2-runtime&quot;, &quot;pm2.config.js&quot;]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install pm2@latest -g</span><br><span class=\"line\">yarn global add pm2</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"更新\"><a href=\"#更新\" class=\"headerlink\" title=\"更新\"></a>更新</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install pm2@latest -g</span><br><span class=\"line\">pm2 update</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 启动</span><br><span class=\"line\">pm2 start app.js</span><br><span class=\"line\">pm2 start app.js --watch --ignore-watch&#x3D;&quot;node_modules&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"># Specify an app name</span><br><span class=\"line\">--name &lt;app_name&gt;</span><br><span class=\"line\"># Watch and Restart app when files change</span><br><span class=\"line\">--watch</span><br><span class=\"line\"># Set memory threshold for app reload</span><br><span class=\"line\">--max-memory-restart &lt;200MB&gt;</span><br><span class=\"line\"># Specify log file</span><br><span class=\"line\">--log &lt;log_path&gt;</span><br><span class=\"line\"># Pass extra arguments to the script</span><br><span class=\"line\">-- arg1 arg2 arg3</span><br><span class=\"line\"># Delay between automatic restarts</span><br><span class=\"line\">--restart-delay &lt;delay in ms&gt;</span><br><span class=\"line\"># Prefix logs with time</span><br><span class=\"line\">--time</span><br><span class=\"line\"># Do not auto restart app</span><br><span class=\"line\">--no-autorestart</span><br><span class=\"line\"># Specify cron for forced restart</span><br><span class=\"line\">--cron &lt;cron_pattern&gt;</span><br><span class=\"line\"># Attach to application log</span><br><span class=\"line\">--no-daemon</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 重启</span><br><span class=\"line\">pm2 restart &lt;app_name,all,id&gt;</span><br><span class=\"line\">pm2 reload &lt;app_name,all,id&gt;</span><br><span class=\"line\">&#x2F;&#x2F; 停止</span><br><span class=\"line\">pm2 stop &lt;app_name,all,id&gt;</span><br><span class=\"line\">&#x2F;&#x2F; 删除</span><br><span class=\"line\">pm2 delete &lt;app_name,all,id&gt;</span><br><span class=\"line\">&#x2F;&#x2F; 信息</span><br><span class=\"line\">pm2 [list|ls|status|jlist|prettylist]</span><br><span class=\"line\">&#x2F;&#x2F; 日志</span><br><span class=\"line\">pm2 logs</span><br><span class=\"line\">pm2 logs --lines 200</span><br><span class=\"line\">&#x2F;&#x2F; 清空日志</span><br><span class=\"line\">pm2 flush</span><br><span class=\"line\">&#x2F;&#x2F; 监控信息</span><br><span class=\"line\">pm2 monit</span><br><span class=\"line\">pm2 plus</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置文件\"><a href=\"#配置文件\" class=\"headerlink\" title=\"配置文件\"></a>配置文件</h3><ul>\n<li>生成示例配置文件：pm2 ecosystem</li>\n<li>配置文件支持 script、json、YAML 格式，js文件必须以.config.js结束</li>\n<li>pm2.config.json示例</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">module</span>.exports = &#123;</span><br><span class=\"line\">  apps : [&#123;</span><br><span class=\"line\">    name: <span class=\"string\">&#x27;demo&#x27;</span>,</span><br><span class=\"line\">    script: <span class=\"string\">&#x27;demo.js&#x27;</span>,</span><br><span class=\"line\">    args: <span class=\"string\">&#x27;-a 1 -b 2&#x27;</span>,<span class=\"comment\">// 可以通过 process.env.args 获取</span></span><br><span class=\"line\">    instances: <span class=\"number\">1</span>,<span class=\"comment\">// 实例数</span></span><br><span class=\"line\">    exec_mode: <span class=\"string\">&#x27;cluster&#x27;</span>,<span class=\"comment\">// 运行模式</span></span><br><span class=\"line\">    max_memory_restart: <span class=\"string\">&#x27;2G&#x27;</span>, <span class=\"comment\">// &#x27;100M&#x27;</span></span><br><span class=\"line\">    watch: <span class=\"literal\">true</span>,</span><br><span class=\"line\">    ignore_watch: [<span class=\"string\">&quot;[\\/\\\\]\\./&quot;</span>, <span class=\"string\">&quot;node_modules&quot;</span>],</span><br><span class=\"line\">    max_memory_restart: <span class=\"string\">&#x27;1G&#x27;</span>,</span><br><span class=\"line\">    env: &#123;</span><br><span class=\"line\">      NODE_ENV: <span class=\"string\">&#x27;development&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 启动时可以使用 --env production切换环境变量</span></span><br><span class=\"line\">    env_production: &#123;</span><br><span class=\"line\">      NODE_ENV: <span class=\"string\">&#x27;production&#x27;</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"comment\">// 日志配置</span></span><br><span class=\"line\">    log_date_format: <span class=\"string\">&quot;YYYY-MM-DD HH:mm:ss&quot;</span>,</span><br><span class=\"line\">    error_file: <span class=\"string\">&#x27;./logs/server-error.log&#x27;</span>,</span><br><span class=\"line\">    out_file: <span class=\"string\">&#x27;./logs/server-data.log&#x27;</span>,</span><br><span class=\"line\">    listen_timeout: <span class=\"number\">8000</span>,<span class=\"comment\">// 监听程序等待的时间，超过时间未监听到会重启</span></span><br><span class=\"line\">    kill_timeout: <span class=\"number\">1000</span>,<span class=\"comment\">// kill程序之前等待时间</span></span><br><span class=\"line\">    max_restarts: <span class=\"number\">10</span>,<span class=\"comment\">// 错误重启次数</span></span><br><span class=\"line\">    restart_delay: <span class=\"number\">80000</span>,<span class=\"comment\">// 重启崩溃应用前等待时间</span></span><br><span class=\"line\">    autorestart: <span class=\"literal\">true</span>,<span class=\"comment\">// 错误自动重启配置</span></span><br><span class=\"line\">    cron_restart: <span class=\"string\">&#x27;0 15 1 ? * *&#x27;</span>,<span class=\"comment\">// 自动重启，实例每天1点15触发</span></span><br><span class=\"line\">  &#125;],</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"集群模式\"><a href=\"#集群模式\" class=\"headerlink\" title=\"集群模式\"></a>集群模式</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pm2 start app.js -i max</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"docker部署\"><a href=\"#docker部署\" class=\"headerlink\" title=\"docker部署\"></a>docker部署</h3><ul>\n<li>使用pm2-runtime：npm install pm2 -g</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">CMD [&quot;pm2-runtime&quot;, &quot;pm2.config.js&quot;]</span><br></pre></td></tr></table></figure>"},{"title":"<js>节流与防抖","date":"2018-11-14T16:00:00.000Z","_content":"\n### 节流(throttle)\n\n- 在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。\n\n1. 简单的一定时间内只执行一次\n\n```\nfunction throttle(fn, interval = 2000) {\n    let lastTime = 0\n    return function () {\n        let context = this\n        let args = arguments\n        let nowTime = +new Date()\n\n        if (nowTime - lastTime > interval) {\n            fn.apply(context, args)\n            lastTime = nowTime\n        }\n    }\n}\n```\n\n2. 添加leading参数，配置true在周期开始执行，false在周期结束执行\n\n```\nfunction throttle(fn, interval = 2000, leading = true) {\n    let lastTime = 0\n    return function () {\n        let context = this\n        let args = arguments\n        let nowTime = +new Date()\n\n        if (nowTime - lastTime > interval) {\n            if (leading) {\n                fn.apply(context, args)\n            } else {\n                setTimeout(() => {\n                    fn.apply(context, args)\n                }, interval)\n            }\n            lastTime = nowTime\n        }\n    }\n}\n```\n\n### 防抖\n\n- 在某段时间内，如果有新的出发那么更新时间，不管你触发了多少次回调，我都只认最后一次。\n\n1. 简单的\n\n```\n//2秒内只要有事件，就重新计时\nfunction debounce(fn, delay = 2000) {\n    let timer = null\n    return function () {\n        let context = this\n        let args = arguments\n\n        if (timer) {\n            clearTimeout(timer)\n        }\n        timer = setTimeout(() => {\n            fn.apply(context, args)\n        }, delay)\n    }\n}\n```\n\n2. 添加leading参数，配置true在周期开始执行，false在周期结束执行\n\n```\nfunction debounce(fn, delay = 2000, leading = true) {\n    let timer = null\n    let leadOpen = null\n    return function () {\n        let context = this\n        let args = arguments\n\n        if (leading) {\n            if (!leadOpen) {\n                leadOpen = true\n                fn.apply(context, args)\n            } else {\n                clearTimeout(timer)\n            }\n            timer = setTimeout(() => {\n                leadOpen = false\n            }, delay)\n        } else {\n            if (timer) {\n                clearTimeout(timer)\n            }\n            timer = setTimeout(() => {\n                fn.apply(context, args)\n            }, delay)\n        }\n    }\n}\n```\n\n3. 添加 maxWait 参数，maxWait 时间一定执行一次\n\n```\nfunction debounceWithMaxWait(fn, delay = 2000, maxWait = 3000, leading = true) {\n    let timer = null\n    let lastTime = null\n    let leadOpen = null\n    return function () {\n        let context = this\n        let args = arguments\n\n        if (!lastTime) {\n            lastTime = +new Date()\n        }\n\n        let newTime = +new Date()\n\n        if(leading){\n            if (newTime - lastTime < maxWait) {\n                if (!leadOpen) {\n                    leadOpen = true\n                    fn.apply(context, args)\n                } else {\n                    clearTimeout(timer)\n                }\n                timer = setTimeout(() => {\n                    lastTime = null\n                    leadOpen = false\n                }, delay)\n            } else {\n                lastTime = null\n                leadOpen = false\n                clearTimeout(timer)\n            }\n        }else {\n            if (newTime - lastTime < maxWait) {\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                timer = setTimeout(() => {\n                    lastTime = null\n                    fn.apply(context, args)\n                }, delay)\n            } else {\n                lastTime = null\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                fn.apply(context, args)\n            }\n        }\n    }\n}\n```\n\n### lodash的使用\n\n1. throttle\n\n```\ndocument.querySelector('#lodash_throttle').addEventListener('click', _.throttle(() => {\n    console.log('lodash throttle')\n}, 2000, {\n    leading: false,\n    // trailing: true\n}))\n```\n\n2. debounce\n\n```\ndocument.querySelector('#lodash_debounce').addEventListener('click', _.debounce(() => {\n    console.log('lodash debounce')\n}, 2000, {\n    maxWait: 3000,\n    leading: false,\n    // trailing: true\n}))\n```\n","source":"_posts/[js]节流与防抖.md","raw":"---\ntitle: <js>节流与防抖\ndate: 2018-11-15 00:00:00\ntags: [js,节流与防抖]\ncategories: js\n---\n\n### 节流(throttle)\n\n- 在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。\n\n1. 简单的一定时间内只执行一次\n\n```\nfunction throttle(fn, interval = 2000) {\n    let lastTime = 0\n    return function () {\n        let context = this\n        let args = arguments\n        let nowTime = +new Date()\n\n        if (nowTime - lastTime > interval) {\n            fn.apply(context, args)\n            lastTime = nowTime\n        }\n    }\n}\n```\n\n2. 添加leading参数，配置true在周期开始执行，false在周期结束执行\n\n```\nfunction throttle(fn, interval = 2000, leading = true) {\n    let lastTime = 0\n    return function () {\n        let context = this\n        let args = arguments\n        let nowTime = +new Date()\n\n        if (nowTime - lastTime > interval) {\n            if (leading) {\n                fn.apply(context, args)\n            } else {\n                setTimeout(() => {\n                    fn.apply(context, args)\n                }, interval)\n            }\n            lastTime = nowTime\n        }\n    }\n}\n```\n\n### 防抖\n\n- 在某段时间内，如果有新的出发那么更新时间，不管你触发了多少次回调，我都只认最后一次。\n\n1. 简单的\n\n```\n//2秒内只要有事件，就重新计时\nfunction debounce(fn, delay = 2000) {\n    let timer = null\n    return function () {\n        let context = this\n        let args = arguments\n\n        if (timer) {\n            clearTimeout(timer)\n        }\n        timer = setTimeout(() => {\n            fn.apply(context, args)\n        }, delay)\n    }\n}\n```\n\n2. 添加leading参数，配置true在周期开始执行，false在周期结束执行\n\n```\nfunction debounce(fn, delay = 2000, leading = true) {\n    let timer = null\n    let leadOpen = null\n    return function () {\n        let context = this\n        let args = arguments\n\n        if (leading) {\n            if (!leadOpen) {\n                leadOpen = true\n                fn.apply(context, args)\n            } else {\n                clearTimeout(timer)\n            }\n            timer = setTimeout(() => {\n                leadOpen = false\n            }, delay)\n        } else {\n            if (timer) {\n                clearTimeout(timer)\n            }\n            timer = setTimeout(() => {\n                fn.apply(context, args)\n            }, delay)\n        }\n    }\n}\n```\n\n3. 添加 maxWait 参数，maxWait 时间一定执行一次\n\n```\nfunction debounceWithMaxWait(fn, delay = 2000, maxWait = 3000, leading = true) {\n    let timer = null\n    let lastTime = null\n    let leadOpen = null\n    return function () {\n        let context = this\n        let args = arguments\n\n        if (!lastTime) {\n            lastTime = +new Date()\n        }\n\n        let newTime = +new Date()\n\n        if(leading){\n            if (newTime - lastTime < maxWait) {\n                if (!leadOpen) {\n                    leadOpen = true\n                    fn.apply(context, args)\n                } else {\n                    clearTimeout(timer)\n                }\n                timer = setTimeout(() => {\n                    lastTime = null\n                    leadOpen = false\n                }, delay)\n            } else {\n                lastTime = null\n                leadOpen = false\n                clearTimeout(timer)\n            }\n        }else {\n            if (newTime - lastTime < maxWait) {\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                timer = setTimeout(() => {\n                    lastTime = null\n                    fn.apply(context, args)\n                }, delay)\n            } else {\n                lastTime = null\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                fn.apply(context, args)\n            }\n        }\n    }\n}\n```\n\n### lodash的使用\n\n1. throttle\n\n```\ndocument.querySelector('#lodash_throttle').addEventListener('click', _.throttle(() => {\n    console.log('lodash throttle')\n}, 2000, {\n    leading: false,\n    // trailing: true\n}))\n```\n\n2. debounce\n\n```\ndocument.querySelector('#lodash_debounce').addEventListener('click', _.debounce(() => {\n    console.log('lodash debounce')\n}, 2000, {\n    maxWait: 3000,\n    leading: false,\n    // trailing: true\n}))\n```\n","slug":"[js]节流与防抖","published":1,"updated":"2021-03-15T14:37:38.505Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dky002swotj0g080vme","content":"<h3 id=\"节流-throttle\"><a href=\"#节流-throttle\" class=\"headerlink\" title=\"节流(throttle)\"></a>节流(throttle)</h3><ul>\n<li>在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。</li>\n</ul>\n<ol>\n<li>简单的一定时间内只执行一次</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(fn, interval &#x3D; 2000) &#123;</span><br><span class=\"line\">    let lastTime &#x3D; 0</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context &#x3D; this</span><br><span class=\"line\">        let args &#x3D; arguments</span><br><span class=\"line\">        let nowTime &#x3D; +new Date()</span><br><span class=\"line\"></span><br><span class=\"line\">        if (nowTime - lastTime &gt; interval) &#123;</span><br><span class=\"line\">            fn.apply(context, args)</span><br><span class=\"line\">            lastTime &#x3D; nowTime</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>添加leading参数，配置true在周期开始执行，false在周期结束执行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(fn, interval &#x3D; 2000, leading &#x3D; true) &#123;</span><br><span class=\"line\">    let lastTime &#x3D; 0</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context &#x3D; this</span><br><span class=\"line\">        let args &#x3D; arguments</span><br><span class=\"line\">        let nowTime &#x3D; +new Date()</span><br><span class=\"line\"></span><br><span class=\"line\">        if (nowTime - lastTime &gt; interval) &#123;</span><br><span class=\"line\">            if (leading) &#123;</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">                    fn.apply(context, args)</span><br><span class=\"line\">                &#125;, interval)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            lastTime &#x3D; nowTime</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><ul>\n<li>在某段时间内，如果有新的出发那么更新时间，不管你触发了多少次回调，我都只认最后一次。</li>\n</ul>\n<ol>\n<li>简单的</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;2秒内只要有事件，就重新计时</span><br><span class=\"line\">function debounce(fn, delay &#x3D; 2000) &#123;</span><br><span class=\"line\">    let timer &#x3D; null</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context &#x3D; this</span><br><span class=\"line\">        let args &#x3D; arguments</span><br><span class=\"line\"></span><br><span class=\"line\">        if (timer) &#123;</span><br><span class=\"line\">            clearTimeout(timer)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">            fn.apply(context, args)</span><br><span class=\"line\">        &#125;, delay)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>添加leading参数，配置true在周期开始执行，false在周期结束执行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(fn, delay &#x3D; 2000, leading &#x3D; true) &#123;</span><br><span class=\"line\">    let timer &#x3D; null</span><br><span class=\"line\">    let leadOpen &#x3D; null</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context &#x3D; this</span><br><span class=\"line\">        let args &#x3D; arguments</span><br><span class=\"line\"></span><br><span class=\"line\">        if (leading) &#123;</span><br><span class=\"line\">            if (!leadOpen) &#123;</span><br><span class=\"line\">                leadOpen &#x3D; true</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                clearTimeout(timer)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">                leadOpen &#x3D; false</span><br><span class=\"line\">            &#125;, delay)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (timer) &#123;</span><br><span class=\"line\">                clearTimeout(timer)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125;, delay)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>添加 maxWait 参数，maxWait 时间一定执行一次</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounceWithMaxWait(fn, delay &#x3D; 2000, maxWait &#x3D; 3000, leading &#x3D; true) &#123;</span><br><span class=\"line\">    let timer &#x3D; null</span><br><span class=\"line\">    let lastTime &#x3D; null</span><br><span class=\"line\">    let leadOpen &#x3D; null</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context &#x3D; this</span><br><span class=\"line\">        let args &#x3D; arguments</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!lastTime) &#123;</span><br><span class=\"line\">            lastTime &#x3D; +new Date()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        let newTime &#x3D; +new Date()</span><br><span class=\"line\"></span><br><span class=\"line\">        if(leading)&#123;</span><br><span class=\"line\">            if (newTime - lastTime &lt; maxWait) &#123;</span><br><span class=\"line\">                if (!leadOpen) &#123;</span><br><span class=\"line\">                    leadOpen &#x3D; true</span><br><span class=\"line\">                    fn.apply(context, args)</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    clearTimeout(timer)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">                    lastTime &#x3D; null</span><br><span class=\"line\">                    leadOpen &#x3D; false</span><br><span class=\"line\">                &#125;, delay)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                lastTime &#x3D; null</span><br><span class=\"line\">                leadOpen &#x3D; false</span><br><span class=\"line\">                clearTimeout(timer)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            if (newTime - lastTime &lt; maxWait) &#123;</span><br><span class=\"line\">                if (timer) &#123;</span><br><span class=\"line\">                    clearTimeout(timer)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">                    lastTime &#x3D; null</span><br><span class=\"line\">                    fn.apply(context, args)</span><br><span class=\"line\">                &#125;, delay)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                lastTime &#x3D; null</span><br><span class=\"line\">                if (timer) &#123;</span><br><span class=\"line\">                    clearTimeout(timer)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"lodash的使用\"><a href=\"#lodash的使用\" class=\"headerlink\" title=\"lodash的使用\"></a>lodash的使用</h3><ol>\n<li>throttle</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.querySelector(&#39;#lodash_throttle&#39;).addEventListener(&#39;click&#39;, _.throttle(() &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(&#39;lodash throttle&#39;)</span><br><span class=\"line\">&#125;, 2000, &#123;</span><br><span class=\"line\">    leading: false,</span><br><span class=\"line\">    &#x2F;&#x2F; trailing: true</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>debounce</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.querySelector(&#39;#lodash_debounce&#39;).addEventListener(&#39;click&#39;, _.debounce(() &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(&#39;lodash debounce&#39;)</span><br><span class=\"line\">&#125;, 2000, &#123;</span><br><span class=\"line\">    maxWait: 3000,</span><br><span class=\"line\">    leading: false,</span><br><span class=\"line\">    &#x2F;&#x2F; trailing: true</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"节流-throttle\"><a href=\"#节流-throttle\" class=\"headerlink\" title=\"节流(throttle)\"></a>节流(throttle)</h3><ul>\n<li>在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。</li>\n</ul>\n<ol>\n<li>简单的一定时间内只执行一次</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(fn, interval &#x3D; 2000) &#123;</span><br><span class=\"line\">    let lastTime &#x3D; 0</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context &#x3D; this</span><br><span class=\"line\">        let args &#x3D; arguments</span><br><span class=\"line\">        let nowTime &#x3D; +new Date()</span><br><span class=\"line\"></span><br><span class=\"line\">        if (nowTime - lastTime &gt; interval) &#123;</span><br><span class=\"line\">            fn.apply(context, args)</span><br><span class=\"line\">            lastTime &#x3D; nowTime</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>添加leading参数，配置true在周期开始执行，false在周期结束执行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(fn, interval &#x3D; 2000, leading &#x3D; true) &#123;</span><br><span class=\"line\">    let lastTime &#x3D; 0</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context &#x3D; this</span><br><span class=\"line\">        let args &#x3D; arguments</span><br><span class=\"line\">        let nowTime &#x3D; +new Date()</span><br><span class=\"line\"></span><br><span class=\"line\">        if (nowTime - lastTime &gt; interval) &#123;</span><br><span class=\"line\">            if (leading) &#123;</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">                    fn.apply(context, args)</span><br><span class=\"line\">                &#125;, interval)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            lastTime &#x3D; nowTime</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><ul>\n<li>在某段时间内，如果有新的出发那么更新时间，不管你触发了多少次回调，我都只认最后一次。</li>\n</ul>\n<ol>\n<li>简单的</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;2秒内只要有事件，就重新计时</span><br><span class=\"line\">function debounce(fn, delay &#x3D; 2000) &#123;</span><br><span class=\"line\">    let timer &#x3D; null</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context &#x3D; this</span><br><span class=\"line\">        let args &#x3D; arguments</span><br><span class=\"line\"></span><br><span class=\"line\">        if (timer) &#123;</span><br><span class=\"line\">            clearTimeout(timer)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">            fn.apply(context, args)</span><br><span class=\"line\">        &#125;, delay)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>添加leading参数，配置true在周期开始执行，false在周期结束执行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(fn, delay &#x3D; 2000, leading &#x3D; true) &#123;</span><br><span class=\"line\">    let timer &#x3D; null</span><br><span class=\"line\">    let leadOpen &#x3D; null</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context &#x3D; this</span><br><span class=\"line\">        let args &#x3D; arguments</span><br><span class=\"line\"></span><br><span class=\"line\">        if (leading) &#123;</span><br><span class=\"line\">            if (!leadOpen) &#123;</span><br><span class=\"line\">                leadOpen &#x3D; true</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                clearTimeout(timer)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">                leadOpen &#x3D; false</span><br><span class=\"line\">            &#125;, delay)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (timer) &#123;</span><br><span class=\"line\">                clearTimeout(timer)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125;, delay)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>添加 maxWait 参数，maxWait 时间一定执行一次</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounceWithMaxWait(fn, delay &#x3D; 2000, maxWait &#x3D; 3000, leading &#x3D; true) &#123;</span><br><span class=\"line\">    let timer &#x3D; null</span><br><span class=\"line\">    let lastTime &#x3D; null</span><br><span class=\"line\">    let leadOpen &#x3D; null</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context &#x3D; this</span><br><span class=\"line\">        let args &#x3D; arguments</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!lastTime) &#123;</span><br><span class=\"line\">            lastTime &#x3D; +new Date()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        let newTime &#x3D; +new Date()</span><br><span class=\"line\"></span><br><span class=\"line\">        if(leading)&#123;</span><br><span class=\"line\">            if (newTime - lastTime &lt; maxWait) &#123;</span><br><span class=\"line\">                if (!leadOpen) &#123;</span><br><span class=\"line\">                    leadOpen &#x3D; true</span><br><span class=\"line\">                    fn.apply(context, args)</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    clearTimeout(timer)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">                    lastTime &#x3D; null</span><br><span class=\"line\">                    leadOpen &#x3D; false</span><br><span class=\"line\">                &#125;, delay)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                lastTime &#x3D; null</span><br><span class=\"line\">                leadOpen &#x3D; false</span><br><span class=\"line\">                clearTimeout(timer)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            if (newTime - lastTime &lt; maxWait) &#123;</span><br><span class=\"line\">                if (timer) &#123;</span><br><span class=\"line\">                    clearTimeout(timer)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                timer &#x3D; setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">                    lastTime &#x3D; null</span><br><span class=\"line\">                    fn.apply(context, args)</span><br><span class=\"line\">                &#125;, delay)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                lastTime &#x3D; null</span><br><span class=\"line\">                if (timer) &#123;</span><br><span class=\"line\">                    clearTimeout(timer)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"lodash的使用\"><a href=\"#lodash的使用\" class=\"headerlink\" title=\"lodash的使用\"></a>lodash的使用</h3><ol>\n<li>throttle</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.querySelector(&#39;#lodash_throttle&#39;).addEventListener(&#39;click&#39;, _.throttle(() &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(&#39;lodash throttle&#39;)</span><br><span class=\"line\">&#125;, 2000, &#123;</span><br><span class=\"line\">    leading: false,</span><br><span class=\"line\">    &#x2F;&#x2F; trailing: true</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>debounce</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.querySelector(&#39;#lodash_debounce&#39;).addEventListener(&#39;click&#39;, _.debounce(() &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(&#39;lodash debounce&#39;)</span><br><span class=\"line\">&#125;, 2000, &#123;</span><br><span class=\"line\">    maxWait: 3000,</span><br><span class=\"line\">    leading: false,</span><br><span class=\"line\">    &#x2F;&#x2F; trailing: true</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n"},{"title":"<linux>基础操作","date":"2020-08-23T16:00:00.000Z","_content":"\n### linux版本\n\n#### 内核版本\n\n- https://www.kernel.org/\n- 5.7.14 主版本呢号、次版本号、末版本号\n- 次版本号基数->开发板、偶数->稳定版\n\n#### 发行版本\n\n- 开源，厂商定制\n- redhat\n- fedora\n- centos\n- ubuntu\n- debian\n\n#### 发行版本\n\n### 帮助命令\n\n#### man\n\n- manual缩写\n- 参数：数字(1-9)：指定从哪本man手册中搜索帮助；关键字：指定要搜索帮助的关键字。\n- man 1 ls，man 7 ls\n- 按 q 退出\n\n#### help\n\n- bash内建命令，用于显示bash内建命令帮助信息\n- 内建命令使用 man buildin 获取\n- help [选项] [参数]\n- 选项：-d 显示描述，-m 按照man手册输出，-s 只输出内建命令的命令格式\n- 默认选项类似 -m\n\n#### info\n\n- info [选项] [参数]\n- 选项：-d：添加包含info格式帮助文档的目录；-f：指定要读取的info格式的帮助文档；-n：指定首先访问的info帮助文件的节点；-o：输出被选择的节点内容到指定文件。\n\n### 软件安装\n\n#### 软件包管理器\n\n1. centos、redhat使用yum包管理器，包格式rpm\n2. debian、ubantu使用apt包管理器，包格式deb\n\n#### rpm\n\n- 包格式：yarn-1.3.2-lp151.3.2.x86_64.rpm，uwsgi-devel-2.0.18-8.fc30.x86_64.rpm，软件名称(yarn)+软件版本+系统版本(el7)+平台(x86_64)\n\n- 需要将rpm包下载到本地安装\n- 命令:rpm -q 查询 -i 安装 -e 卸载\n- rpm -qa 查询所有安装的rpm包\n- rpm -q vim-common 查询单个包\n- 如果有依赖关系需要安装相关依赖包\n \n #### yum\n \n - yum源，修改配置文件，参考阿里源 [地址](https://developer.aliyun.com/mirror/)\n - 常用命令\n \n1. 列出所有可更新的软件清单命令：yum check-update\n2. 更新所有软件命令：yum update\n3. 仅安装指定的软件命令：yum install <package_name>\n4. 仅更新指定的软件命令：yum update <package_name>\n5. 列出所有可安裝的软件清单命令：yum list\n6. 删除软件包命令：yum remove <package_name>\n7. 查找软件包 命令：yum search <keyword>\n8. 清除缓存命令:\nyum clean packages: 清除缓存目录下的软件包\nyum clean headers: 清除缓存目录下的 headers\nyum clean oldheaders: 清除缓存目录下旧的 headers\nyum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers\n9. yum info <package_name>查看软件信息\n\n#### 源代码编译安装\n\n### 基本命令\n\n#### pwd\n\n- 显示当前路径\n\n#### ls\n\n- ls -l 显示详细内容\n- ls -a 显示隐藏文件\n- ls -r 逆向显示（默认文件名排序）ls -lrt 使用时间排序\n- ls -R 递归显示\n- ls -lh 按接近文件大小显示\n- ls -Sl 由大到小排序 ls -Slr 由小到大排序\n \n#### cd\n\n- cd - 回到上一个路径\n\n#### mkdir\n\n- 创建目录 mkdir ./a ./b ./c 创建多个目录\n- mkdir -p ./a/b/c 创建多级目录\n\n#### cp\n\n- cp -v 显示复制过程\n- cp -r 复制文件夹\n- cp -p 保留原有文件属性（时间等）\n- cp -a 保留文件属主等属性\n\n#### mv\n\n- 文件移动、重命名操作\n\n### 文本查看\n\n#### cat\n\n- 文本内容显示到终端\n- cat -n 添加行号\n\n#### head\n\n- 查看文件开头\n- head -5 ./a 开头5行\n\n#### tail\n\n- 查看文件结尾\n- tail -5 ./a 结尾5行\n- tail -f ./a 跟踪显示，有追加会更新显示\n\n#### wc\n\n- wc -l ./a 查看文件行数\n- 统计文件内容信息\n- -c 字节数、 -l 行数、 -m 字符数、 -w 字数、 -L 最长行的长度\n\n### 打包、压缩、解压\n\n#### tar打包压缩\n\n- tar -cf ./etc-back.tar /etc 打包tc文件夹\n- tar -czf ./etc-back.tar.gz /etc 打包tc文件夹，并通过gzip压缩\n- -j 通过bzip2 压缩，添加bz2后缀 tar -cjf ./etc-back.tar.bz2 /etc\n- bzip2安装：yum install -y bzip2\n\n#### tar解压\n\n- tar -xf ./etc-back.tar -C /root 解压并放到root目录\n- -zxf 解压gzip格式\n- -jxf解压bzip2格式\n\n### vi\n\n#### 正常模式\n\n- i 进入插入模式（光标位置），按 esc 返回正常模式\n- I 进入插入模式，光标在所在行开头\n- a 进入插入模式，光标在单词后位置\n- A 进入插入模式，光标在所在行结尾\n- o 进入插入模式，光标所在行下添加新行\n- O 进入插入模式，光标所在行上添加新行\n- : 进入命令模式，按 esc 返回正常模式\n- hjkl 移动光标\n- yy 复制一行，3yy 复制三行，y$ 复制光标位置到结尾\n- p 粘贴 \n- dd 剪切一行，d$ 剪切光标到结尾，3dd 剪切三行\n- u 插销操作\n- ctrl+r 重做操作\n- x 单个字符删除\n- r+输入新字符，单个字符替换\n- 输入行数，shift+g，跳转到指定行开头\n- g 文本第一行，G 文本最后一行\n- ^ 跳转行开头，$ 跳转行结尾\n\n#### 插入模式\n\n#### 命令模式\n\n- set nu 显示当前所在行\n- w 保存，w+文件名 保存到新文件\n- q 退出，wq 保存退出，q! 不保存退出\n- !+linux命令 执行linux命令，!ls\n- /+文本 搜索命令 ，n 向下移动，N 向上移动\n- s/旧字符/新字符，当前行查找替换，只替换第一个\n- %s/旧字符/新字符，全局查找替换，只替换第一个\n- %s/旧字符/新字符/g，全局替换\n- 3,5s/旧字符/新字符/g，3-5行之间替换\n- set+命令，修改 vi 配置\n\n#### 可视模式\n\n- v 字可视模式\n- V 行可视模式\n- ctrl+v 块可视模式，配合 d、l、I(大写i)可以进行块操作，d 删除、I 插入\n\n#### 全局配置\n\n- vim /etc/vimrc 在结尾添加配置，如：set nu\n\n### 用户、权限管理\n\n#### 用户管理\n\n- id 查找用户，id root 查看root用户信息，id 当前用户信息\n- useradd 新建用户，useradd yxc\n- userdel 删除用户，userdel -r yxc 删除用户以及相关配置文件\n- passwd 修改用户密码，passwd yxc 更改指定用户密码，passwd 更改当前用户密码\n- usermod 修改用户属性，usermod -d /home/yxc1 yxc 修改用户家目录\n- chage 修改帐号和密码的有效期限\n- 查看所有用户：cat /etc/passwd\n- /etc/shadow 用户密码信息\n\n#### 用户组\n\n- groupadd 新建用户组，groupadd g1\n- groupdel 删除用户组\n- usermod -g yxc g1 修改用户所属组\n- 查看所有用户组 cat /etc/passwd\n- vim /etc/password 编辑用户配置文件，yxc:x:1000:1001::/home/yxc:/bin/bash，x 是否需要密码登录\n- /etc/group 用户组信息\n\n#### su\n\n- su - yxc 切换用户，使用后 exit 退出\n- su -c ls root 切换用户执行命令，执行后退出\n\n#### sudo\n\n- 使用 visudo 配置用户权限\n\n### 文件权限\n\n- drwxr-xr-x. 2 root root       19 7月  20 22:23 test\n- -rw-r--r--. 1 root root    10240 7月  20 22:23 text.tar\n- 类型 d 文件夹， - 普通文件， b 块特殊文件，c 字特殊文件， l 符号链接，f 管道链接，s 套接字文件\n- rwx 文件类型，9个字符，分三组，所属用户、所属组、其他用户权限\n- r 读权限， w 写权限， x 执行权限。\n- 数字表示 r=4, w=2，x=1\n- 目录权限表示：x 进入目录， rx 显示目录文件名， wx 修改目录内的文件名\n- 权限冲突时以属主权限为主\n\n#### 修改权限\n\n- chmod u+x a.txt, chmod 755 a.txt，chmod u=rwx ./a 设置权限 u(用户)、g(组)、o(其他)、a(全部)，+(增加)、-(减少)、=(设置)\n- chown 更改属主、属组，chown yxc ./a，chown :g1 ./a\n- chgrp 单独更改属组，不常用\n\n### 网络管理\n\n1. 网络状态查看\n\n- net-tools\n安装：yum -y install net-tools\nifconfig、route、netstat\n普通用户需要输入 /sbin/ifconfig\nmii-tool eth0 查看网卡物理链接情况\nroute -n 查看网关（路由）-n 不解析域名\n- iproute2\nip、ss\n\n2. 网络配置\n3. 路由命令\n4. 网络故障排除\n5. 网络服务管理\n6. 常用网络配置文件\n\n### 进程\n\n#### ps、top查看进程\n\n- ps -f 显示UID、 -a 显示所有进程、 -l 更详细的显示（线程）\n- pstree\n- top 显示模式按 1 切换cpu统计模式 、显示模式按 s 修改更新时间 ，top -p 1888 按进程查询\n\n#### 进程控制命令\n\n- 优先级调整（NI）：\n\n1. nice 范围i -20到19，值越小优先级越高，占用资源越多，nice -n 10 ./a.sh\n2. renice 重新设置优先级，renice -n 15 1888\n\n- 进程的作业控制：\n\n1. jobs，jobs 显示后台进程，将后台运行的进程切换至前台，fg 1(后台进程代码) 召回制前台\n2. & 符号，后台运行进程， ./ a,sh &\n3. ctrl+z 挂起正在运行的程序，jobs 查看进程，fg 展示至前台，bg 后台运行\n\n#### 信号\n\n- 终端用户输入中断命令，通过信号机制停止程序运行\n- kill -l 查看kill支持的信号\n- kill -9 [进程号] 结束程序\n\n#### 守护进程\n\n- nohup 将程序以忽略挂起信号的方式运行起来\n- 守护进程：独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程的名称通常以d结尾，比如sshd、xinetd、crond等。守护进程的父进程是init进程。\n- screen  只要Screen本身没有终止，在其内部运行的会话都可以恢复。screen 进入screen环境，ctrl+a d 退出screen环境，screen -ls 查看screen的会话，screen -r sessionId 回复会话，安装：yum install screen，screent 中 使用 exit 命令退出。\n\n#### 系统日志\n\n- /var/log 文件夹\n- messages 系统常规日志，dmesg 内核运行信息，secure 安全日志，cron 周期计划任务日志\n\n#### service 控制系统服务\n\n#### systemctl 系统管理工具\n\n- 系统已安装的服务 /usr/lib/systemd/system/\n\n#### SELinux\n\n- 安全增强组件，会降低性能，大多数生产环境关闭\n- getenforce 查询当前SELinux状态\n- 配置文件 /etc/selinux/config SELINUX=，修改后需要重启生效\n- setenforce 0,临时修改配置，重启后失效\n\n### 内存与磁盘管理\n\n1. 内存与磁盘使用查看\n\n内存使用查看\n- free free -m, free -g，Swap交换分区（虚拟内存），在磁盘中，内存不够之后会分到虚拟内存中\n- top\n\n磁盘使用查看\n- fdisk fdisk -l 查看磁盘\n- parted -l 查看分区\n- df df -h 查看分区以及挂载目录\n- du 显示每个文件和目录的磁盘使用空间\n- du 与 ls 区别，ls 是实际大小，du 是所占磁盘空间，默认linux系统分区的 block size 是4k，使文件只有1个字节，也会占用4k，ls 显示的文件大小比du显示的磁盘占用空间小\n\n2. ext4 文件系统\n3. 磁盘配额使用\n4. 磁盘分区与挂载\n5. 交换分区（虚拟内存）查看创建\n6. 软件RAID使用\n7. 逻辑券管理\n8. 系统综合状态查看","source":"_posts/[linux]基础操作.md","raw":"---\ntitle: <linux>基础操作\ndate: 2020-08-24 00:00:00\ntags: [linux]\ncategories: linux\n---\n\n### linux版本\n\n#### 内核版本\n\n- https://www.kernel.org/\n- 5.7.14 主版本呢号、次版本号、末版本号\n- 次版本号基数->开发板、偶数->稳定版\n\n#### 发行版本\n\n- 开源，厂商定制\n- redhat\n- fedora\n- centos\n- ubuntu\n- debian\n\n#### 发行版本\n\n### 帮助命令\n\n#### man\n\n- manual缩写\n- 参数：数字(1-9)：指定从哪本man手册中搜索帮助；关键字：指定要搜索帮助的关键字。\n- man 1 ls，man 7 ls\n- 按 q 退出\n\n#### help\n\n- bash内建命令，用于显示bash内建命令帮助信息\n- 内建命令使用 man buildin 获取\n- help [选项] [参数]\n- 选项：-d 显示描述，-m 按照man手册输出，-s 只输出内建命令的命令格式\n- 默认选项类似 -m\n\n#### info\n\n- info [选项] [参数]\n- 选项：-d：添加包含info格式帮助文档的目录；-f：指定要读取的info格式的帮助文档；-n：指定首先访问的info帮助文件的节点；-o：输出被选择的节点内容到指定文件。\n\n### 软件安装\n\n#### 软件包管理器\n\n1. centos、redhat使用yum包管理器，包格式rpm\n2. debian、ubantu使用apt包管理器，包格式deb\n\n#### rpm\n\n- 包格式：yarn-1.3.2-lp151.3.2.x86_64.rpm，uwsgi-devel-2.0.18-8.fc30.x86_64.rpm，软件名称(yarn)+软件版本+系统版本(el7)+平台(x86_64)\n\n- 需要将rpm包下载到本地安装\n- 命令:rpm -q 查询 -i 安装 -e 卸载\n- rpm -qa 查询所有安装的rpm包\n- rpm -q vim-common 查询单个包\n- 如果有依赖关系需要安装相关依赖包\n \n #### yum\n \n - yum源，修改配置文件，参考阿里源 [地址](https://developer.aliyun.com/mirror/)\n - 常用命令\n \n1. 列出所有可更新的软件清单命令：yum check-update\n2. 更新所有软件命令：yum update\n3. 仅安装指定的软件命令：yum install <package_name>\n4. 仅更新指定的软件命令：yum update <package_name>\n5. 列出所有可安裝的软件清单命令：yum list\n6. 删除软件包命令：yum remove <package_name>\n7. 查找软件包 命令：yum search <keyword>\n8. 清除缓存命令:\nyum clean packages: 清除缓存目录下的软件包\nyum clean headers: 清除缓存目录下的 headers\nyum clean oldheaders: 清除缓存目录下旧的 headers\nyum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers\n9. yum info <package_name>查看软件信息\n\n#### 源代码编译安装\n\n### 基本命令\n\n#### pwd\n\n- 显示当前路径\n\n#### ls\n\n- ls -l 显示详细内容\n- ls -a 显示隐藏文件\n- ls -r 逆向显示（默认文件名排序）ls -lrt 使用时间排序\n- ls -R 递归显示\n- ls -lh 按接近文件大小显示\n- ls -Sl 由大到小排序 ls -Slr 由小到大排序\n \n#### cd\n\n- cd - 回到上一个路径\n\n#### mkdir\n\n- 创建目录 mkdir ./a ./b ./c 创建多个目录\n- mkdir -p ./a/b/c 创建多级目录\n\n#### cp\n\n- cp -v 显示复制过程\n- cp -r 复制文件夹\n- cp -p 保留原有文件属性（时间等）\n- cp -a 保留文件属主等属性\n\n#### mv\n\n- 文件移动、重命名操作\n\n### 文本查看\n\n#### cat\n\n- 文本内容显示到终端\n- cat -n 添加行号\n\n#### head\n\n- 查看文件开头\n- head -5 ./a 开头5行\n\n#### tail\n\n- 查看文件结尾\n- tail -5 ./a 结尾5行\n- tail -f ./a 跟踪显示，有追加会更新显示\n\n#### wc\n\n- wc -l ./a 查看文件行数\n- 统计文件内容信息\n- -c 字节数、 -l 行数、 -m 字符数、 -w 字数、 -L 最长行的长度\n\n### 打包、压缩、解压\n\n#### tar打包压缩\n\n- tar -cf ./etc-back.tar /etc 打包tc文件夹\n- tar -czf ./etc-back.tar.gz /etc 打包tc文件夹，并通过gzip压缩\n- -j 通过bzip2 压缩，添加bz2后缀 tar -cjf ./etc-back.tar.bz2 /etc\n- bzip2安装：yum install -y bzip2\n\n#### tar解压\n\n- tar -xf ./etc-back.tar -C /root 解压并放到root目录\n- -zxf 解压gzip格式\n- -jxf解压bzip2格式\n\n### vi\n\n#### 正常模式\n\n- i 进入插入模式（光标位置），按 esc 返回正常模式\n- I 进入插入模式，光标在所在行开头\n- a 进入插入模式，光标在单词后位置\n- A 进入插入模式，光标在所在行结尾\n- o 进入插入模式，光标所在行下添加新行\n- O 进入插入模式，光标所在行上添加新行\n- : 进入命令模式，按 esc 返回正常模式\n- hjkl 移动光标\n- yy 复制一行，3yy 复制三行，y$ 复制光标位置到结尾\n- p 粘贴 \n- dd 剪切一行，d$ 剪切光标到结尾，3dd 剪切三行\n- u 插销操作\n- ctrl+r 重做操作\n- x 单个字符删除\n- r+输入新字符，单个字符替换\n- 输入行数，shift+g，跳转到指定行开头\n- g 文本第一行，G 文本最后一行\n- ^ 跳转行开头，$ 跳转行结尾\n\n#### 插入模式\n\n#### 命令模式\n\n- set nu 显示当前所在行\n- w 保存，w+文件名 保存到新文件\n- q 退出，wq 保存退出，q! 不保存退出\n- !+linux命令 执行linux命令，!ls\n- /+文本 搜索命令 ，n 向下移动，N 向上移动\n- s/旧字符/新字符，当前行查找替换，只替换第一个\n- %s/旧字符/新字符，全局查找替换，只替换第一个\n- %s/旧字符/新字符/g，全局替换\n- 3,5s/旧字符/新字符/g，3-5行之间替换\n- set+命令，修改 vi 配置\n\n#### 可视模式\n\n- v 字可视模式\n- V 行可视模式\n- ctrl+v 块可视模式，配合 d、l、I(大写i)可以进行块操作，d 删除、I 插入\n\n#### 全局配置\n\n- vim /etc/vimrc 在结尾添加配置，如：set nu\n\n### 用户、权限管理\n\n#### 用户管理\n\n- id 查找用户，id root 查看root用户信息，id 当前用户信息\n- useradd 新建用户，useradd yxc\n- userdel 删除用户，userdel -r yxc 删除用户以及相关配置文件\n- passwd 修改用户密码，passwd yxc 更改指定用户密码，passwd 更改当前用户密码\n- usermod 修改用户属性，usermod -d /home/yxc1 yxc 修改用户家目录\n- chage 修改帐号和密码的有效期限\n- 查看所有用户：cat /etc/passwd\n- /etc/shadow 用户密码信息\n\n#### 用户组\n\n- groupadd 新建用户组，groupadd g1\n- groupdel 删除用户组\n- usermod -g yxc g1 修改用户所属组\n- 查看所有用户组 cat /etc/passwd\n- vim /etc/password 编辑用户配置文件，yxc:x:1000:1001::/home/yxc:/bin/bash，x 是否需要密码登录\n- /etc/group 用户组信息\n\n#### su\n\n- su - yxc 切换用户，使用后 exit 退出\n- su -c ls root 切换用户执行命令，执行后退出\n\n#### sudo\n\n- 使用 visudo 配置用户权限\n\n### 文件权限\n\n- drwxr-xr-x. 2 root root       19 7月  20 22:23 test\n- -rw-r--r--. 1 root root    10240 7月  20 22:23 text.tar\n- 类型 d 文件夹， - 普通文件， b 块特殊文件，c 字特殊文件， l 符号链接，f 管道链接，s 套接字文件\n- rwx 文件类型，9个字符，分三组，所属用户、所属组、其他用户权限\n- r 读权限， w 写权限， x 执行权限。\n- 数字表示 r=4, w=2，x=1\n- 目录权限表示：x 进入目录， rx 显示目录文件名， wx 修改目录内的文件名\n- 权限冲突时以属主权限为主\n\n#### 修改权限\n\n- chmod u+x a.txt, chmod 755 a.txt，chmod u=rwx ./a 设置权限 u(用户)、g(组)、o(其他)、a(全部)，+(增加)、-(减少)、=(设置)\n- chown 更改属主、属组，chown yxc ./a，chown :g1 ./a\n- chgrp 单独更改属组，不常用\n\n### 网络管理\n\n1. 网络状态查看\n\n- net-tools\n安装：yum -y install net-tools\nifconfig、route、netstat\n普通用户需要输入 /sbin/ifconfig\nmii-tool eth0 查看网卡物理链接情况\nroute -n 查看网关（路由）-n 不解析域名\n- iproute2\nip、ss\n\n2. 网络配置\n3. 路由命令\n4. 网络故障排除\n5. 网络服务管理\n6. 常用网络配置文件\n\n### 进程\n\n#### ps、top查看进程\n\n- ps -f 显示UID、 -a 显示所有进程、 -l 更详细的显示（线程）\n- pstree\n- top 显示模式按 1 切换cpu统计模式 、显示模式按 s 修改更新时间 ，top -p 1888 按进程查询\n\n#### 进程控制命令\n\n- 优先级调整（NI）：\n\n1. nice 范围i -20到19，值越小优先级越高，占用资源越多，nice -n 10 ./a.sh\n2. renice 重新设置优先级，renice -n 15 1888\n\n- 进程的作业控制：\n\n1. jobs，jobs 显示后台进程，将后台运行的进程切换至前台，fg 1(后台进程代码) 召回制前台\n2. & 符号，后台运行进程， ./ a,sh &\n3. ctrl+z 挂起正在运行的程序，jobs 查看进程，fg 展示至前台，bg 后台运行\n\n#### 信号\n\n- 终端用户输入中断命令，通过信号机制停止程序运行\n- kill -l 查看kill支持的信号\n- kill -9 [进程号] 结束程序\n\n#### 守护进程\n\n- nohup 将程序以忽略挂起信号的方式运行起来\n- 守护进程：独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程的名称通常以d结尾，比如sshd、xinetd、crond等。守护进程的父进程是init进程。\n- screen  只要Screen本身没有终止，在其内部运行的会话都可以恢复。screen 进入screen环境，ctrl+a d 退出screen环境，screen -ls 查看screen的会话，screen -r sessionId 回复会话，安装：yum install screen，screent 中 使用 exit 命令退出。\n\n#### 系统日志\n\n- /var/log 文件夹\n- messages 系统常规日志，dmesg 内核运行信息，secure 安全日志，cron 周期计划任务日志\n\n#### service 控制系统服务\n\n#### systemctl 系统管理工具\n\n- 系统已安装的服务 /usr/lib/systemd/system/\n\n#### SELinux\n\n- 安全增强组件，会降低性能，大多数生产环境关闭\n- getenforce 查询当前SELinux状态\n- 配置文件 /etc/selinux/config SELINUX=，修改后需要重启生效\n- setenforce 0,临时修改配置，重启后失效\n\n### 内存与磁盘管理\n\n1. 内存与磁盘使用查看\n\n内存使用查看\n- free free -m, free -g，Swap交换分区（虚拟内存），在磁盘中，内存不够之后会分到虚拟内存中\n- top\n\n磁盘使用查看\n- fdisk fdisk -l 查看磁盘\n- parted -l 查看分区\n- df df -h 查看分区以及挂载目录\n- du 显示每个文件和目录的磁盘使用空间\n- du 与 ls 区别，ls 是实际大小，du 是所占磁盘空间，默认linux系统分区的 block size 是4k，使文件只有1个字节，也会占用4k，ls 显示的文件大小比du显示的磁盘占用空间小\n\n2. ext4 文件系统\n3. 磁盘配额使用\n4. 磁盘分区与挂载\n5. 交换分区（虚拟内存）查看创建\n6. 软件RAID使用\n7. 逻辑券管理\n8. 系统综合状态查看","slug":"[linux]基础操作","published":1,"updated":"2021-03-15T14:40:13.302Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dkz002vwotj0b1qdg11","content":"<h3 id=\"linux版本\"><a href=\"#linux版本\" class=\"headerlink\" title=\"linux版本\"></a>linux版本</h3><h4 id=\"内核版本\"><a href=\"#内核版本\" class=\"headerlink\" title=\"内核版本\"></a>内核版本</h4><ul>\n<li><a href=\"https://www.kernel.org/\">https://www.kernel.org/</a></li>\n<li>5.7.14 主版本呢号、次版本号、末版本号</li>\n<li>次版本号基数-&gt;开发板、偶数-&gt;稳定版</li>\n</ul>\n<h4 id=\"发行版本\"><a href=\"#发行版本\" class=\"headerlink\" title=\"发行版本\"></a>发行版本</h4><ul>\n<li>开源，厂商定制</li>\n<li>redhat</li>\n<li>fedora</li>\n<li>centos</li>\n<li>ubuntu</li>\n<li>debian</li>\n</ul>\n<h4 id=\"发行版本-1\"><a href=\"#发行版本-1\" class=\"headerlink\" title=\"发行版本\"></a>发行版本</h4><h3 id=\"帮助命令\"><a href=\"#帮助命令\" class=\"headerlink\" title=\"帮助命令\"></a>帮助命令</h3><h4 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h4><ul>\n<li>manual缩写</li>\n<li>参数：数字(1-9)：指定从哪本man手册中搜索帮助；关键字：指定要搜索帮助的关键字。</li>\n<li>man 1 ls，man 7 ls</li>\n<li>按 q 退出</li>\n</ul>\n<h4 id=\"help\"><a href=\"#help\" class=\"headerlink\" title=\"help\"></a>help</h4><ul>\n<li>bash内建命令，用于显示bash内建命令帮助信息</li>\n<li>内建命令使用 man buildin 获取</li>\n<li>help [选项] [参数]</li>\n<li>选项：-d 显示描述，-m 按照man手册输出，-s 只输出内建命令的命令格式</li>\n<li>默认选项类似 -m</li>\n</ul>\n<h4 id=\"info\"><a href=\"#info\" class=\"headerlink\" title=\"info\"></a>info</h4><ul>\n<li>info [选项] [参数]</li>\n<li>选项：-d：添加包含info格式帮助文档的目录；-f：指定要读取的info格式的帮助文档；-n：指定首先访问的info帮助文件的节点；-o：输出被选择的节点内容到指定文件。</li>\n</ul>\n<h3 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h3><h4 id=\"软件包管理器\"><a href=\"#软件包管理器\" class=\"headerlink\" title=\"软件包管理器\"></a>软件包管理器</h4><ol>\n<li>centos、redhat使用yum包管理器，包格式rpm</li>\n<li>debian、ubantu使用apt包管理器，包格式deb</li>\n</ol>\n<h4 id=\"rpm\"><a href=\"#rpm\" class=\"headerlink\" title=\"rpm\"></a>rpm</h4><ul>\n<li><p>包格式：yarn-1.3.2-lp151.3.2.x86_64.rpm，uwsgi-devel-2.0.18-8.fc30.x86_64.rpm，软件名称(yarn)+软件版本+系统版本(el7)+平台(x86_64)</p>\n</li>\n<li><p>需要将rpm包下载到本地安装</p>\n</li>\n<li><p>命令:rpm -q 查询 -i 安装 -e 卸载</p>\n</li>\n<li><p>rpm -qa 查询所有安装的rpm包</p>\n</li>\n<li><p>rpm -q vim-common 查询单个包</p>\n</li>\n<li><p>如果有依赖关系需要安装相关依赖包</p>\n</li>\n</ul>\n<h4 id=\"yum\"><a href=\"#yum\" class=\"headerlink\" title=\"yum\"></a>yum</h4><ul>\n<li>yum源，修改配置文件，参考阿里源 <a href=\"https://developer.aliyun.com/mirror/\">地址</a></li>\n<li>常用命令</li>\n</ul>\n<ol>\n<li>列出所有可更新的软件清单命令：yum check-update</li>\n<li>更新所有软件命令：yum update</li>\n<li>仅安装指定的软件命令：yum install <package_name></li>\n<li>仅更新指定的软件命令：yum update <package_name></li>\n<li>列出所有可安裝的软件清单命令：yum list</li>\n<li>删除软件包命令：yum remove <package_name></li>\n<li>查找软件包 命令：yum search <keyword></li>\n<li>清除缓存命令:<br>yum clean packages: 清除缓存目录下的软件包<br>yum clean headers: 清除缓存目录下的 headers<br>yum clean oldheaders: 清除缓存目录下旧的 headers<br>yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</li>\n<li>yum info <package_name>查看软件信息</li>\n</ol>\n<h4 id=\"源代码编译安装\"><a href=\"#源代码编译安装\" class=\"headerlink\" title=\"源代码编译安装\"></a>源代码编译安装</h4><h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><h4 id=\"pwd\"><a href=\"#pwd\" class=\"headerlink\" title=\"pwd\"></a>pwd</h4><ul>\n<li>显示当前路径</li>\n</ul>\n<h4 id=\"ls\"><a href=\"#ls\" class=\"headerlink\" title=\"ls\"></a>ls</h4><ul>\n<li>ls -l 显示详细内容</li>\n<li>ls -a 显示隐藏文件</li>\n<li>ls -r 逆向显示（默认文件名排序）ls -lrt 使用时间排序</li>\n<li>ls -R 递归显示</li>\n<li>ls -lh 按接近文件大小显示</li>\n<li>ls -Sl 由大到小排序 ls -Slr 由小到大排序</li>\n</ul>\n<h4 id=\"cd\"><a href=\"#cd\" class=\"headerlink\" title=\"cd\"></a>cd</h4><ul>\n<li>cd - 回到上一个路径</li>\n</ul>\n<h4 id=\"mkdir\"><a href=\"#mkdir\" class=\"headerlink\" title=\"mkdir\"></a>mkdir</h4><ul>\n<li>创建目录 mkdir ./a ./b ./c 创建多个目录</li>\n<li>mkdir -p ./a/b/c 创建多级目录</li>\n</ul>\n<h4 id=\"cp\"><a href=\"#cp\" class=\"headerlink\" title=\"cp\"></a>cp</h4><ul>\n<li>cp -v 显示复制过程</li>\n<li>cp -r 复制文件夹</li>\n<li>cp -p 保留原有文件属性（时间等）</li>\n<li>cp -a 保留文件属主等属性</li>\n</ul>\n<h4 id=\"mv\"><a href=\"#mv\" class=\"headerlink\" title=\"mv\"></a>mv</h4><ul>\n<li>文件移动、重命名操作</li>\n</ul>\n<h3 id=\"文本查看\"><a href=\"#文本查看\" class=\"headerlink\" title=\"文本查看\"></a>文本查看</h3><h4 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a>cat</h4><ul>\n<li>文本内容显示到终端</li>\n<li>cat -n 添加行号</li>\n</ul>\n<h4 id=\"head\"><a href=\"#head\" class=\"headerlink\" title=\"head\"></a>head</h4><ul>\n<li>查看文件开头</li>\n<li>head -5 ./a 开头5行</li>\n</ul>\n<h4 id=\"tail\"><a href=\"#tail\" class=\"headerlink\" title=\"tail\"></a>tail</h4><ul>\n<li>查看文件结尾</li>\n<li>tail -5 ./a 结尾5行</li>\n<li>tail -f ./a 跟踪显示，有追加会更新显示</li>\n</ul>\n<h4 id=\"wc\"><a href=\"#wc\" class=\"headerlink\" title=\"wc\"></a>wc</h4><ul>\n<li>wc -l ./a 查看文件行数</li>\n<li>统计文件内容信息</li>\n<li>-c 字节数、 -l 行数、 -m 字符数、 -w 字数、 -L 最长行的长度</li>\n</ul>\n<h3 id=\"打包、压缩、解压\"><a href=\"#打包、压缩、解压\" class=\"headerlink\" title=\"打包、压缩、解压\"></a>打包、压缩、解压</h3><h4 id=\"tar打包压缩\"><a href=\"#tar打包压缩\" class=\"headerlink\" title=\"tar打包压缩\"></a>tar打包压缩</h4><ul>\n<li>tar -cf ./etc-back.tar /etc 打包tc文件夹</li>\n<li>tar -czf ./etc-back.tar.gz /etc 打包tc文件夹，并通过gzip压缩</li>\n<li>-j 通过bzip2 压缩，添加bz2后缀 tar -cjf ./etc-back.tar.bz2 /etc</li>\n<li>bzip2安装：yum install -y bzip2</li>\n</ul>\n<h4 id=\"tar解压\"><a href=\"#tar解压\" class=\"headerlink\" title=\"tar解压\"></a>tar解压</h4><ul>\n<li>tar -xf ./etc-back.tar -C /root 解压并放到root目录</li>\n<li>-zxf 解压gzip格式</li>\n<li>-jxf解压bzip2格式</li>\n</ul>\n<h3 id=\"vi\"><a href=\"#vi\" class=\"headerlink\" title=\"vi\"></a>vi</h3><h4 id=\"正常模式\"><a href=\"#正常模式\" class=\"headerlink\" title=\"正常模式\"></a>正常模式</h4><ul>\n<li>i 进入插入模式（光标位置），按 esc 返回正常模式</li>\n<li>I 进入插入模式，光标在所在行开头</li>\n<li>a 进入插入模式，光标在单词后位置</li>\n<li>A 进入插入模式，光标在所在行结尾</li>\n<li>o 进入插入模式，光标所在行下添加新行</li>\n<li>O 进入插入模式，光标所在行上添加新行</li>\n<li>: 进入命令模式，按 esc 返回正常模式</li>\n<li>hjkl 移动光标</li>\n<li>yy 复制一行，3yy 复制三行，y$ 复制光标位置到结尾</li>\n<li>p 粘贴 </li>\n<li>dd 剪切一行，d$ 剪切光标到结尾，3dd 剪切三行</li>\n<li>u 插销操作</li>\n<li>ctrl+r 重做操作</li>\n<li>x 单个字符删除</li>\n<li>r+输入新字符，单个字符替换</li>\n<li>输入行数，shift+g，跳转到指定行开头</li>\n<li>g 文本第一行，G 文本最后一行</li>\n<li>^ 跳转行开头，$ 跳转行结尾</li>\n</ul>\n<h4 id=\"插入模式\"><a href=\"#插入模式\" class=\"headerlink\" title=\"插入模式\"></a>插入模式</h4><h4 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h4><ul>\n<li>set nu 显示当前所在行</li>\n<li>w 保存，w+文件名 保存到新文件</li>\n<li>q 退出，wq 保存退出，q! 不保存退出</li>\n<li>!+linux命令 执行linux命令，!ls</li>\n<li>/+文本 搜索命令 ，n 向下移动，N 向上移动</li>\n<li>s/旧字符/新字符，当前行查找替换，只替换第一个</li>\n<li>%s/旧字符/新字符，全局查找替换，只替换第一个</li>\n<li>%s/旧字符/新字符/g，全局替换</li>\n<li>3,5s/旧字符/新字符/g，3-5行之间替换</li>\n<li>set+命令，修改 vi 配置</li>\n</ul>\n<h4 id=\"可视模式\"><a href=\"#可视模式\" class=\"headerlink\" title=\"可视模式\"></a>可视模式</h4><ul>\n<li>v 字可视模式</li>\n<li>V 行可视模式</li>\n<li>ctrl+v 块可视模式，配合 d、l、I(大写i)可以进行块操作，d 删除、I 插入</li>\n</ul>\n<h4 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h4><ul>\n<li>vim /etc/vimrc 在结尾添加配置，如：set nu</li>\n</ul>\n<h3 id=\"用户、权限管理\"><a href=\"#用户、权限管理\" class=\"headerlink\" title=\"用户、权限管理\"></a>用户、权限管理</h3><h4 id=\"用户管理\"><a href=\"#用户管理\" class=\"headerlink\" title=\"用户管理\"></a>用户管理</h4><ul>\n<li>id 查找用户，id root 查看root用户信息，id 当前用户信息</li>\n<li>useradd 新建用户，useradd yxc</li>\n<li>userdel 删除用户，userdel -r yxc 删除用户以及相关配置文件</li>\n<li>passwd 修改用户密码，passwd yxc 更改指定用户密码，passwd 更改当前用户密码</li>\n<li>usermod 修改用户属性，usermod -d /home/yxc1 yxc 修改用户家目录</li>\n<li>chage 修改帐号和密码的有效期限</li>\n<li>查看所有用户：cat /etc/passwd</li>\n<li>/etc/shadow 用户密码信息</li>\n</ul>\n<h4 id=\"用户组\"><a href=\"#用户组\" class=\"headerlink\" title=\"用户组\"></a>用户组</h4><ul>\n<li>groupadd 新建用户组，groupadd g1</li>\n<li>groupdel 删除用户组</li>\n<li>usermod -g yxc g1 修改用户所属组</li>\n<li>查看所有用户组 cat /etc/passwd</li>\n<li>vim /etc/password 编辑用户配置文件，yxc:x:1000:1001::/home/yxc:/bin/bash，x 是否需要密码登录</li>\n<li>/etc/group 用户组信息</li>\n</ul>\n<h4 id=\"su\"><a href=\"#su\" class=\"headerlink\" title=\"su\"></a>su</h4><ul>\n<li>su - yxc 切换用户，使用后 exit 退出</li>\n<li>su -c ls root 切换用户执行命令，执行后退出</li>\n</ul>\n<h4 id=\"sudo\"><a href=\"#sudo\" class=\"headerlink\" title=\"sudo\"></a>sudo</h4><ul>\n<li>使用 visudo 配置用户权限</li>\n</ul>\n<h3 id=\"文件权限\"><a href=\"#文件权限\" class=\"headerlink\" title=\"文件权限\"></a>文件权限</h3><ul>\n<li>drwxr-xr-x. 2 root root       19 7月  20 22:23 test</li>\n<li>-rw-r–r–. 1 root root    10240 7月  20 22:23 text.tar</li>\n<li>类型 d 文件夹， - 普通文件， b 块特殊文件，c 字特殊文件， l 符号链接，f 管道链接，s 套接字文件</li>\n<li>rwx 文件类型，9个字符，分三组，所属用户、所属组、其他用户权限</li>\n<li>r 读权限， w 写权限， x 执行权限。</li>\n<li>数字表示 r=4, w=2，x=1</li>\n<li>目录权限表示：x 进入目录， rx 显示目录文件名， wx 修改目录内的文件名</li>\n<li>权限冲突时以属主权限为主</li>\n</ul>\n<h4 id=\"修改权限\"><a href=\"#修改权限\" class=\"headerlink\" title=\"修改权限\"></a>修改权限</h4><ul>\n<li>chmod u+x a.txt, chmod 755 a.txt，chmod u=rwx ./a 设置权限 u(用户)、g(组)、o(其他)、a(全部)，+(增加)、-(减少)、=(设置)</li>\n<li>chown 更改属主、属组，chown yxc ./a，chown :g1 ./a</li>\n<li>chgrp 单独更改属组，不常用</li>\n</ul>\n<h3 id=\"网络管理\"><a href=\"#网络管理\" class=\"headerlink\" title=\"网络管理\"></a>网络管理</h3><ol>\n<li>网络状态查看</li>\n</ol>\n<ul>\n<li>net-tools<br>安装：yum -y install net-tools<br>ifconfig、route、netstat<br>普通用户需要输入 /sbin/ifconfig<br>mii-tool eth0 查看网卡物理链接情况<br>route -n 查看网关（路由）-n 不解析域名</li>\n<li>iproute2<br>ip、ss</li>\n</ul>\n<ol start=\"2\">\n<li>网络配置</li>\n<li>路由命令</li>\n<li>网络故障排除</li>\n<li>网络服务管理</li>\n<li>常用网络配置文件</li>\n</ol>\n<h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><h4 id=\"ps、top查看进程\"><a href=\"#ps、top查看进程\" class=\"headerlink\" title=\"ps、top查看进程\"></a>ps、top查看进程</h4><ul>\n<li>ps -f 显示UID、 -a 显示所有进程、 -l 更详细的显示（线程）</li>\n<li>pstree</li>\n<li>top 显示模式按 1 切换cpu统计模式 、显示模式按 s 修改更新时间 ，top -p 1888 按进程查询</li>\n</ul>\n<h4 id=\"进程控制命令\"><a href=\"#进程控制命令\" class=\"headerlink\" title=\"进程控制命令\"></a>进程控制命令</h4><ul>\n<li>优先级调整（NI）：</li>\n</ul>\n<ol>\n<li>nice 范围i -20到19，值越小优先级越高，占用资源越多，nice -n 10 ./a.sh</li>\n<li>renice 重新设置优先级，renice -n 15 1888</li>\n</ol>\n<ul>\n<li>进程的作业控制：</li>\n</ul>\n<ol>\n<li>jobs，jobs 显示后台进程，将后台运行的进程切换至前台，fg 1(后台进程代码) 召回制前台</li>\n<li>&amp; 符号，后台运行进程， ./ a,sh &amp;</li>\n<li>ctrl+z 挂起正在运行的程序，jobs 查看进程，fg 展示至前台，bg 后台运行</li>\n</ol>\n<h4 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h4><ul>\n<li>终端用户输入中断命令，通过信号机制停止程序运行</li>\n<li>kill -l 查看kill支持的信号</li>\n<li>kill -9 [进程号] 结束程序</li>\n</ul>\n<h4 id=\"守护进程\"><a href=\"#守护进程\" class=\"headerlink\" title=\"守护进程\"></a>守护进程</h4><ul>\n<li>nohup 将程序以忽略挂起信号的方式运行起来</li>\n<li>守护进程：独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程的名称通常以d结尾，比如sshd、xinetd、crond等。守护进程的父进程是init进程。</li>\n<li>screen  只要Screen本身没有终止，在其内部运行的会话都可以恢复。screen 进入screen环境，ctrl+a d 退出screen环境，screen -ls 查看screen的会话，screen -r sessionId 回复会话，安装：yum install screen，screent 中 使用 exit 命令退出。</li>\n</ul>\n<h4 id=\"系统日志\"><a href=\"#系统日志\" class=\"headerlink\" title=\"系统日志\"></a>系统日志</h4><ul>\n<li>/var/log 文件夹</li>\n<li>messages 系统常规日志，dmesg 内核运行信息，secure 安全日志，cron 周期计划任务日志</li>\n</ul>\n<h4 id=\"service-控制系统服务\"><a href=\"#service-控制系统服务\" class=\"headerlink\" title=\"service 控制系统服务\"></a>service 控制系统服务</h4><h4 id=\"systemctl-系统管理工具\"><a href=\"#systemctl-系统管理工具\" class=\"headerlink\" title=\"systemctl 系统管理工具\"></a>systemctl 系统管理工具</h4><ul>\n<li>系统已安装的服务 /usr/lib/systemd/system/</li>\n</ul>\n<h4 id=\"SELinux\"><a href=\"#SELinux\" class=\"headerlink\" title=\"SELinux\"></a>SELinux</h4><ul>\n<li>安全增强组件，会降低性能，大多数生产环境关闭</li>\n<li>getenforce 查询当前SELinux状态</li>\n<li>配置文件 /etc/selinux/config SELINUX=，修改后需要重启生效</li>\n<li>setenforce 0,临时修改配置，重启后失效</li>\n</ul>\n<h3 id=\"内存与磁盘管理\"><a href=\"#内存与磁盘管理\" class=\"headerlink\" title=\"内存与磁盘管理\"></a>内存与磁盘管理</h3><ol>\n<li>内存与磁盘使用查看</li>\n</ol>\n<p>内存使用查看</p>\n<ul>\n<li>free free -m, free -g，Swap交换分区（虚拟内存），在磁盘中，内存不够之后会分到虚拟内存中</li>\n<li>top</li>\n</ul>\n<p>磁盘使用查看</p>\n<ul>\n<li>fdisk fdisk -l 查看磁盘</li>\n<li>parted -l 查看分区</li>\n<li>df df -h 查看分区以及挂载目录</li>\n<li>du 显示每个文件和目录的磁盘使用空间</li>\n<li>du 与 ls 区别，ls 是实际大小，du 是所占磁盘空间，默认linux系统分区的 block size 是4k，使文件只有1个字节，也会占用4k，ls 显示的文件大小比du显示的磁盘占用空间小</li>\n</ul>\n<ol start=\"2\">\n<li>ext4 文件系统</li>\n<li>磁盘配额使用</li>\n<li>磁盘分区与挂载</li>\n<li>交换分区（虚拟内存）查看创建</li>\n<li>软件RAID使用</li>\n<li>逻辑券管理</li>\n<li>系统综合状态查看</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"linux版本\"><a href=\"#linux版本\" class=\"headerlink\" title=\"linux版本\"></a>linux版本</h3><h4 id=\"内核版本\"><a href=\"#内核版本\" class=\"headerlink\" title=\"内核版本\"></a>内核版本</h4><ul>\n<li><a href=\"https://www.kernel.org/\">https://www.kernel.org/</a></li>\n<li>5.7.14 主版本呢号、次版本号、末版本号</li>\n<li>次版本号基数-&gt;开发板、偶数-&gt;稳定版</li>\n</ul>\n<h4 id=\"发行版本\"><a href=\"#发行版本\" class=\"headerlink\" title=\"发行版本\"></a>发行版本</h4><ul>\n<li>开源，厂商定制</li>\n<li>redhat</li>\n<li>fedora</li>\n<li>centos</li>\n<li>ubuntu</li>\n<li>debian</li>\n</ul>\n<h4 id=\"发行版本-1\"><a href=\"#发行版本-1\" class=\"headerlink\" title=\"发行版本\"></a>发行版本</h4><h3 id=\"帮助命令\"><a href=\"#帮助命令\" class=\"headerlink\" title=\"帮助命令\"></a>帮助命令</h3><h4 id=\"man\"><a href=\"#man\" class=\"headerlink\" title=\"man\"></a>man</h4><ul>\n<li>manual缩写</li>\n<li>参数：数字(1-9)：指定从哪本man手册中搜索帮助；关键字：指定要搜索帮助的关键字。</li>\n<li>man 1 ls，man 7 ls</li>\n<li>按 q 退出</li>\n</ul>\n<h4 id=\"help\"><a href=\"#help\" class=\"headerlink\" title=\"help\"></a>help</h4><ul>\n<li>bash内建命令，用于显示bash内建命令帮助信息</li>\n<li>内建命令使用 man buildin 获取</li>\n<li>help [选项] [参数]</li>\n<li>选项：-d 显示描述，-m 按照man手册输出，-s 只输出内建命令的命令格式</li>\n<li>默认选项类似 -m</li>\n</ul>\n<h4 id=\"info\"><a href=\"#info\" class=\"headerlink\" title=\"info\"></a>info</h4><ul>\n<li>info [选项] [参数]</li>\n<li>选项：-d：添加包含info格式帮助文档的目录；-f：指定要读取的info格式的帮助文档；-n：指定首先访问的info帮助文件的节点；-o：输出被选择的节点内容到指定文件。</li>\n</ul>\n<h3 id=\"软件安装\"><a href=\"#软件安装\" class=\"headerlink\" title=\"软件安装\"></a>软件安装</h3><h4 id=\"软件包管理器\"><a href=\"#软件包管理器\" class=\"headerlink\" title=\"软件包管理器\"></a>软件包管理器</h4><ol>\n<li>centos、redhat使用yum包管理器，包格式rpm</li>\n<li>debian、ubantu使用apt包管理器，包格式deb</li>\n</ol>\n<h4 id=\"rpm\"><a href=\"#rpm\" class=\"headerlink\" title=\"rpm\"></a>rpm</h4><ul>\n<li><p>包格式：yarn-1.3.2-lp151.3.2.x86_64.rpm，uwsgi-devel-2.0.18-8.fc30.x86_64.rpm，软件名称(yarn)+软件版本+系统版本(el7)+平台(x86_64)</p>\n</li>\n<li><p>需要将rpm包下载到本地安装</p>\n</li>\n<li><p>命令:rpm -q 查询 -i 安装 -e 卸载</p>\n</li>\n<li><p>rpm -qa 查询所有安装的rpm包</p>\n</li>\n<li><p>rpm -q vim-common 查询单个包</p>\n</li>\n<li><p>如果有依赖关系需要安装相关依赖包</p>\n</li>\n</ul>\n<h4 id=\"yum\"><a href=\"#yum\" class=\"headerlink\" title=\"yum\"></a>yum</h4><ul>\n<li>yum源，修改配置文件，参考阿里源 <a href=\"https://developer.aliyun.com/mirror/\">地址</a></li>\n<li>常用命令</li>\n</ul>\n<ol>\n<li>列出所有可更新的软件清单命令：yum check-update</li>\n<li>更新所有软件命令：yum update</li>\n<li>仅安装指定的软件命令：yum install <package_name></li>\n<li>仅更新指定的软件命令：yum update <package_name></li>\n<li>列出所有可安裝的软件清单命令：yum list</li>\n<li>删除软件包命令：yum remove <package_name></li>\n<li>查找软件包 命令：yum search <keyword></li>\n<li>清除缓存命令:<br>yum clean packages: 清除缓存目录下的软件包<br>yum clean headers: 清除缓存目录下的 headers<br>yum clean oldheaders: 清除缓存目录下旧的 headers<br>yum clean, yum clean all (= yum clean packages; yum clean oldheaders) :清除缓存目录下的软件包及旧的headers</li>\n<li>yum info <package_name>查看软件信息</li>\n</ol>\n<h4 id=\"源代码编译安装\"><a href=\"#源代码编译安装\" class=\"headerlink\" title=\"源代码编译安装\"></a>源代码编译安装</h4><h3 id=\"基本命令\"><a href=\"#基本命令\" class=\"headerlink\" title=\"基本命令\"></a>基本命令</h3><h4 id=\"pwd\"><a href=\"#pwd\" class=\"headerlink\" title=\"pwd\"></a>pwd</h4><ul>\n<li>显示当前路径</li>\n</ul>\n<h4 id=\"ls\"><a href=\"#ls\" class=\"headerlink\" title=\"ls\"></a>ls</h4><ul>\n<li>ls -l 显示详细内容</li>\n<li>ls -a 显示隐藏文件</li>\n<li>ls -r 逆向显示（默认文件名排序）ls -lrt 使用时间排序</li>\n<li>ls -R 递归显示</li>\n<li>ls -lh 按接近文件大小显示</li>\n<li>ls -Sl 由大到小排序 ls -Slr 由小到大排序</li>\n</ul>\n<h4 id=\"cd\"><a href=\"#cd\" class=\"headerlink\" title=\"cd\"></a>cd</h4><ul>\n<li>cd - 回到上一个路径</li>\n</ul>\n<h4 id=\"mkdir\"><a href=\"#mkdir\" class=\"headerlink\" title=\"mkdir\"></a>mkdir</h4><ul>\n<li>创建目录 mkdir ./a ./b ./c 创建多个目录</li>\n<li>mkdir -p ./a/b/c 创建多级目录</li>\n</ul>\n<h4 id=\"cp\"><a href=\"#cp\" class=\"headerlink\" title=\"cp\"></a>cp</h4><ul>\n<li>cp -v 显示复制过程</li>\n<li>cp -r 复制文件夹</li>\n<li>cp -p 保留原有文件属性（时间等）</li>\n<li>cp -a 保留文件属主等属性</li>\n</ul>\n<h4 id=\"mv\"><a href=\"#mv\" class=\"headerlink\" title=\"mv\"></a>mv</h4><ul>\n<li>文件移动、重命名操作</li>\n</ul>\n<h3 id=\"文本查看\"><a href=\"#文本查看\" class=\"headerlink\" title=\"文本查看\"></a>文本查看</h3><h4 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a>cat</h4><ul>\n<li>文本内容显示到终端</li>\n<li>cat -n 添加行号</li>\n</ul>\n<h4 id=\"head\"><a href=\"#head\" class=\"headerlink\" title=\"head\"></a>head</h4><ul>\n<li>查看文件开头</li>\n<li>head -5 ./a 开头5行</li>\n</ul>\n<h4 id=\"tail\"><a href=\"#tail\" class=\"headerlink\" title=\"tail\"></a>tail</h4><ul>\n<li>查看文件结尾</li>\n<li>tail -5 ./a 结尾5行</li>\n<li>tail -f ./a 跟踪显示，有追加会更新显示</li>\n</ul>\n<h4 id=\"wc\"><a href=\"#wc\" class=\"headerlink\" title=\"wc\"></a>wc</h4><ul>\n<li>wc -l ./a 查看文件行数</li>\n<li>统计文件内容信息</li>\n<li>-c 字节数、 -l 行数、 -m 字符数、 -w 字数、 -L 最长行的长度</li>\n</ul>\n<h3 id=\"打包、压缩、解压\"><a href=\"#打包、压缩、解压\" class=\"headerlink\" title=\"打包、压缩、解压\"></a>打包、压缩、解压</h3><h4 id=\"tar打包压缩\"><a href=\"#tar打包压缩\" class=\"headerlink\" title=\"tar打包压缩\"></a>tar打包压缩</h4><ul>\n<li>tar -cf ./etc-back.tar /etc 打包tc文件夹</li>\n<li>tar -czf ./etc-back.tar.gz /etc 打包tc文件夹，并通过gzip压缩</li>\n<li>-j 通过bzip2 压缩，添加bz2后缀 tar -cjf ./etc-back.tar.bz2 /etc</li>\n<li>bzip2安装：yum install -y bzip2</li>\n</ul>\n<h4 id=\"tar解压\"><a href=\"#tar解压\" class=\"headerlink\" title=\"tar解压\"></a>tar解压</h4><ul>\n<li>tar -xf ./etc-back.tar -C /root 解压并放到root目录</li>\n<li>-zxf 解压gzip格式</li>\n<li>-jxf解压bzip2格式</li>\n</ul>\n<h3 id=\"vi\"><a href=\"#vi\" class=\"headerlink\" title=\"vi\"></a>vi</h3><h4 id=\"正常模式\"><a href=\"#正常模式\" class=\"headerlink\" title=\"正常模式\"></a>正常模式</h4><ul>\n<li>i 进入插入模式（光标位置），按 esc 返回正常模式</li>\n<li>I 进入插入模式，光标在所在行开头</li>\n<li>a 进入插入模式，光标在单词后位置</li>\n<li>A 进入插入模式，光标在所在行结尾</li>\n<li>o 进入插入模式，光标所在行下添加新行</li>\n<li>O 进入插入模式，光标所在行上添加新行</li>\n<li>: 进入命令模式，按 esc 返回正常模式</li>\n<li>hjkl 移动光标</li>\n<li>yy 复制一行，3yy 复制三行，y$ 复制光标位置到结尾</li>\n<li>p 粘贴 </li>\n<li>dd 剪切一行，d$ 剪切光标到结尾，3dd 剪切三行</li>\n<li>u 插销操作</li>\n<li>ctrl+r 重做操作</li>\n<li>x 单个字符删除</li>\n<li>r+输入新字符，单个字符替换</li>\n<li>输入行数，shift+g，跳转到指定行开头</li>\n<li>g 文本第一行，G 文本最后一行</li>\n<li>^ 跳转行开头，$ 跳转行结尾</li>\n</ul>\n<h4 id=\"插入模式\"><a href=\"#插入模式\" class=\"headerlink\" title=\"插入模式\"></a>插入模式</h4><h4 id=\"命令模式\"><a href=\"#命令模式\" class=\"headerlink\" title=\"命令模式\"></a>命令模式</h4><ul>\n<li>set nu 显示当前所在行</li>\n<li>w 保存，w+文件名 保存到新文件</li>\n<li>q 退出，wq 保存退出，q! 不保存退出</li>\n<li>!+linux命令 执行linux命令，!ls</li>\n<li>/+文本 搜索命令 ，n 向下移动，N 向上移动</li>\n<li>s/旧字符/新字符，当前行查找替换，只替换第一个</li>\n<li>%s/旧字符/新字符，全局查找替换，只替换第一个</li>\n<li>%s/旧字符/新字符/g，全局替换</li>\n<li>3,5s/旧字符/新字符/g，3-5行之间替换</li>\n<li>set+命令，修改 vi 配置</li>\n</ul>\n<h4 id=\"可视模式\"><a href=\"#可视模式\" class=\"headerlink\" title=\"可视模式\"></a>可视模式</h4><ul>\n<li>v 字可视模式</li>\n<li>V 行可视模式</li>\n<li>ctrl+v 块可视模式，配合 d、l、I(大写i)可以进行块操作，d 删除、I 插入</li>\n</ul>\n<h4 id=\"全局配置\"><a href=\"#全局配置\" class=\"headerlink\" title=\"全局配置\"></a>全局配置</h4><ul>\n<li>vim /etc/vimrc 在结尾添加配置，如：set nu</li>\n</ul>\n<h3 id=\"用户、权限管理\"><a href=\"#用户、权限管理\" class=\"headerlink\" title=\"用户、权限管理\"></a>用户、权限管理</h3><h4 id=\"用户管理\"><a href=\"#用户管理\" class=\"headerlink\" title=\"用户管理\"></a>用户管理</h4><ul>\n<li>id 查找用户，id root 查看root用户信息，id 当前用户信息</li>\n<li>useradd 新建用户，useradd yxc</li>\n<li>userdel 删除用户，userdel -r yxc 删除用户以及相关配置文件</li>\n<li>passwd 修改用户密码，passwd yxc 更改指定用户密码，passwd 更改当前用户密码</li>\n<li>usermod 修改用户属性，usermod -d /home/yxc1 yxc 修改用户家目录</li>\n<li>chage 修改帐号和密码的有效期限</li>\n<li>查看所有用户：cat /etc/passwd</li>\n<li>/etc/shadow 用户密码信息</li>\n</ul>\n<h4 id=\"用户组\"><a href=\"#用户组\" class=\"headerlink\" title=\"用户组\"></a>用户组</h4><ul>\n<li>groupadd 新建用户组，groupadd g1</li>\n<li>groupdel 删除用户组</li>\n<li>usermod -g yxc g1 修改用户所属组</li>\n<li>查看所有用户组 cat /etc/passwd</li>\n<li>vim /etc/password 编辑用户配置文件，yxc:x:1000:1001::/home/yxc:/bin/bash，x 是否需要密码登录</li>\n<li>/etc/group 用户组信息</li>\n</ul>\n<h4 id=\"su\"><a href=\"#su\" class=\"headerlink\" title=\"su\"></a>su</h4><ul>\n<li>su - yxc 切换用户，使用后 exit 退出</li>\n<li>su -c ls root 切换用户执行命令，执行后退出</li>\n</ul>\n<h4 id=\"sudo\"><a href=\"#sudo\" class=\"headerlink\" title=\"sudo\"></a>sudo</h4><ul>\n<li>使用 visudo 配置用户权限</li>\n</ul>\n<h3 id=\"文件权限\"><a href=\"#文件权限\" class=\"headerlink\" title=\"文件权限\"></a>文件权限</h3><ul>\n<li>drwxr-xr-x. 2 root root       19 7月  20 22:23 test</li>\n<li>-rw-r–r–. 1 root root    10240 7月  20 22:23 text.tar</li>\n<li>类型 d 文件夹， - 普通文件， b 块特殊文件，c 字特殊文件， l 符号链接，f 管道链接，s 套接字文件</li>\n<li>rwx 文件类型，9个字符，分三组，所属用户、所属组、其他用户权限</li>\n<li>r 读权限， w 写权限， x 执行权限。</li>\n<li>数字表示 r=4, w=2，x=1</li>\n<li>目录权限表示：x 进入目录， rx 显示目录文件名， wx 修改目录内的文件名</li>\n<li>权限冲突时以属主权限为主</li>\n</ul>\n<h4 id=\"修改权限\"><a href=\"#修改权限\" class=\"headerlink\" title=\"修改权限\"></a>修改权限</h4><ul>\n<li>chmod u+x a.txt, chmod 755 a.txt，chmod u=rwx ./a 设置权限 u(用户)、g(组)、o(其他)、a(全部)，+(增加)、-(减少)、=(设置)</li>\n<li>chown 更改属主、属组，chown yxc ./a，chown :g1 ./a</li>\n<li>chgrp 单独更改属组，不常用</li>\n</ul>\n<h3 id=\"网络管理\"><a href=\"#网络管理\" class=\"headerlink\" title=\"网络管理\"></a>网络管理</h3><ol>\n<li>网络状态查看</li>\n</ol>\n<ul>\n<li>net-tools<br>安装：yum -y install net-tools<br>ifconfig、route、netstat<br>普通用户需要输入 /sbin/ifconfig<br>mii-tool eth0 查看网卡物理链接情况<br>route -n 查看网关（路由）-n 不解析域名</li>\n<li>iproute2<br>ip、ss</li>\n</ul>\n<ol start=\"2\">\n<li>网络配置</li>\n<li>路由命令</li>\n<li>网络故障排除</li>\n<li>网络服务管理</li>\n<li>常用网络配置文件</li>\n</ol>\n<h3 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h3><h4 id=\"ps、top查看进程\"><a href=\"#ps、top查看进程\" class=\"headerlink\" title=\"ps、top查看进程\"></a>ps、top查看进程</h4><ul>\n<li>ps -f 显示UID、 -a 显示所有进程、 -l 更详细的显示（线程）</li>\n<li>pstree</li>\n<li>top 显示模式按 1 切换cpu统计模式 、显示模式按 s 修改更新时间 ，top -p 1888 按进程查询</li>\n</ul>\n<h4 id=\"进程控制命令\"><a href=\"#进程控制命令\" class=\"headerlink\" title=\"进程控制命令\"></a>进程控制命令</h4><ul>\n<li>优先级调整（NI）：</li>\n</ul>\n<ol>\n<li>nice 范围i -20到19，值越小优先级越高，占用资源越多，nice -n 10 ./a.sh</li>\n<li>renice 重新设置优先级，renice -n 15 1888</li>\n</ol>\n<ul>\n<li>进程的作业控制：</li>\n</ul>\n<ol>\n<li>jobs，jobs 显示后台进程，将后台运行的进程切换至前台，fg 1(后台进程代码) 召回制前台</li>\n<li>&amp; 符号，后台运行进程， ./ a,sh &amp;</li>\n<li>ctrl+z 挂起正在运行的程序，jobs 查看进程，fg 展示至前台，bg 后台运行</li>\n</ol>\n<h4 id=\"信号\"><a href=\"#信号\" class=\"headerlink\" title=\"信号\"></a>信号</h4><ul>\n<li>终端用户输入中断命令，通过信号机制停止程序运行</li>\n<li>kill -l 查看kill支持的信号</li>\n<li>kill -9 [进程号] 结束程序</li>\n</ul>\n<h4 id=\"守护进程\"><a href=\"#守护进程\" class=\"headerlink\" title=\"守护进程\"></a>守护进程</h4><ul>\n<li>nohup 将程序以忽略挂起信号的方式运行起来</li>\n<li>守护进程：独立于控制终端并且周期性地执行某种任务或等待处理某些发生的事件。它不需要用户输入就能运行而且提供某种服务，不是对整个系统就是对某个用户程序提供服务。守护进程一般在系统启动时开始运行，除非强行终止，否则直到系统关机都保持运行。守护进程的名称通常以d结尾，比如sshd、xinetd、crond等。守护进程的父进程是init进程。</li>\n<li>screen  只要Screen本身没有终止，在其内部运行的会话都可以恢复。screen 进入screen环境，ctrl+a d 退出screen环境，screen -ls 查看screen的会话，screen -r sessionId 回复会话，安装：yum install screen，screent 中 使用 exit 命令退出。</li>\n</ul>\n<h4 id=\"系统日志\"><a href=\"#系统日志\" class=\"headerlink\" title=\"系统日志\"></a>系统日志</h4><ul>\n<li>/var/log 文件夹</li>\n<li>messages 系统常规日志，dmesg 内核运行信息，secure 安全日志，cron 周期计划任务日志</li>\n</ul>\n<h4 id=\"service-控制系统服务\"><a href=\"#service-控制系统服务\" class=\"headerlink\" title=\"service 控制系统服务\"></a>service 控制系统服务</h4><h4 id=\"systemctl-系统管理工具\"><a href=\"#systemctl-系统管理工具\" class=\"headerlink\" title=\"systemctl 系统管理工具\"></a>systemctl 系统管理工具</h4><ul>\n<li>系统已安装的服务 /usr/lib/systemd/system/</li>\n</ul>\n<h4 id=\"SELinux\"><a href=\"#SELinux\" class=\"headerlink\" title=\"SELinux\"></a>SELinux</h4><ul>\n<li>安全增强组件，会降低性能，大多数生产环境关闭</li>\n<li>getenforce 查询当前SELinux状态</li>\n<li>配置文件 /etc/selinux/config SELINUX=，修改后需要重启生效</li>\n<li>setenforce 0,临时修改配置，重启后失效</li>\n</ul>\n<h3 id=\"内存与磁盘管理\"><a href=\"#内存与磁盘管理\" class=\"headerlink\" title=\"内存与磁盘管理\"></a>内存与磁盘管理</h3><ol>\n<li>内存与磁盘使用查看</li>\n</ol>\n<p>内存使用查看</p>\n<ul>\n<li>free free -m, free -g，Swap交换分区（虚拟内存），在磁盘中，内存不够之后会分到虚拟内存中</li>\n<li>top</li>\n</ul>\n<p>磁盘使用查看</p>\n<ul>\n<li>fdisk fdisk -l 查看磁盘</li>\n<li>parted -l 查看分区</li>\n<li>df df -h 查看分区以及挂载目录</li>\n<li>du 显示每个文件和目录的磁盘使用空间</li>\n<li>du 与 ls 区别，ls 是实际大小，du 是所占磁盘空间，默认linux系统分区的 block size 是4k，使文件只有1个字节，也会占用4k，ls 显示的文件大小比du显示的磁盘占用空间小</li>\n</ul>\n<ol start=\"2\">\n<li>ext4 文件系统</li>\n<li>磁盘配额使用</li>\n<li>磁盘分区与挂载</li>\n<li>交换分区（虚拟内存）查看创建</li>\n<li>软件RAID使用</li>\n<li>逻辑券管理</li>\n<li>系统综合状态查看</li>\n</ol>\n"},{"title":"<node>nodejs使用","date":"2021-02-19T16:00:00.000Z","_content":"\n### nodejs特点\n\n- js运行环境，基于chromeV8引擎解析代码，事件驱动，异步驱动，非阻塞I/O，高并发，单线程\n\n- nodejs前端工程化与后端服务应用：\n1. 运行环境：\n\t工程化：运行在本机开花环境\n\t服务：运行在远程服务器，涉及到发布工具（devops），进程管理工具（PM2）,监控告警机制，日志打印及跟踪染色\n2. 受众群体不同：\n\t工程化：服务开发者，提升开发效率，研发质量\n\t服务：真实用户群体，需要关注服务稳定性，并发性能，考虑扩容方案，优化服务性能\n3. 问题调试：\n\t工程化：本地运行，可以在脚本中打log\n\t服务：需要高性能日志工具，遇到内存泄漏、句柄泄漏或者进程异常退出等问题，需要工具分析\n4. 关注点不同：\n\t工程化：注重开发效率提升以及研发质量保证\n\t服务：真正发挥node异步驱动特性，在非CPU密集场景下，开发网络I/O较高服务\n\n### 事件循环\n\n- node 10+ 版本后在运行结果上与浏览器一致，但是基于 libev 库实现，浏览器的核心是宏任务和微任务，node 有阶段性任务执行阶段\n\n#### 循环阶段\n\n1. timers：执行 setTimeout、setInterval 回调函数\n2. pending callbacks：执行操作系统回调，如 TCP 错误回调\n3. idle、prepare：仅系统内部使用\n4. poll：检索新的 I/O 事件，执行与 I/O 相关的回调\n5. check：执行 setImmediate 回调，setImmediate 并不是立马执行，而是当事件循环 poll 中没有新的事件处理时就执行该部分\n6. close callbacks：执行关闭的回调，如 socket.on('close', ...)\n\n- 发起事件循环起点：\n\tnodejs 启动后\n\tsetTimeout、setInterval 回调\n\t某一次 I/O 回调\n\n#### poll过程\n\n- poll 过程中，主要处理的是异步 I/O 的回调函数，以及其他几乎所有的回调函数，异步 I/O 又分为网络 I/O 和文件 I/O\n\n#### 微任务宏任务\n\n- 微任务：process.nextTick 和 Promise，同一个事件循环中有其他任务存在时，优先执行微任务队列，优先级 process.nextTick 高于 Promise\n- 宏任务：setTimeout、setInterval、setImmediate 和 I/O，宏任务在微任务执行之后执行，因此在同一个事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么优先将微任务队列清空，再执行宏任务队列\n\n```javascript\n\"use strict\";\nconst process = require(\"process\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nconsole.log(\"start\");\n\nfunction promiseRun() {\n  Promise.resolve().then(() => {\n    console.log(\"promise\");\n  });\n}\n\nfs.readFile(path.resolve(__dirname, \"./file.txt\"), (err, data) => {\n  if (err) {\n    throw err;\n  }\n  promiseRun();\n  console.log(\"fs io callback\");\n});\n\nsetImmediate(() => {\n  promiseRun();\n  console.log(\"immediate\");\n});\n\nsetTimeout(() => {\n  promiseRun();\n  console.log(\"timeout\");\n  fs.readFile(path.resolve(__dirname, \"./file.txt\"), (err, data) => {\n    if (err) {\n      throw err;\n    }\n    console.log(\"async fs io callback\");\n  });\n}, 0);\n\npromiseRun();\n\nprocess.nextTick(() => {\n  console.log(\"nextTick\");\n});\n\nconsole.log(\"end\");\n\n// start\n// end\n// nextTick\n// promise\n// timeout\n// promise\n// immediate\n// promise\n// fs io callback\n// promise\n// async fs io callback\n```\n\n#### 单线程多线程\n\n- node 主线程是单线程执行的，但是 Node.js 存在多线程执行，多线程包括 setTimeout 和异步 I/O 事件。其实 Node.js 还存在其他的线程，包括垃圾回收、内存优化等\n\n### node适用服务场景\n\n- 适用场景：\n\t业务网关：鉴权处理服务，特性：网络 I/O 高，高并发，不涉及 CPU 密集逻辑\n\t中台服务：配置系统、反馈系统、推送系统、系统工具搭建，特点：网络 I/O高、并发高、通用性强及业务复杂度低\n\t运营系统：并发高，不涉及底层数据库读写\n\t爬虫系统：puppeteer，jsdom 等库支持动态静态爬虫抓取\n\n- 不适用场景：node 不适用阻塞主线程、CPU 密集型运算的服务，如：图片处理、大字符串数字处理、大文件读写\n\n### nodejs框架\n\n#### express与koa区别\n\n- expres内置很多中间件，比如connext、router，koa更加轻量化，可以根据需求定制框架\n- 中间件处理：express基于callback处理，koa基于await/async处理\n- 异步执行中间件：express并非严格按照洋葱模型执行中间件，koa严格遵循\n\n#### 中间件\n\n1. express\n\n- 流程\n  通过app.use方法注册中间件\n  一个中间件为一个layer对象，包含当前路由正则信息以及handle方法\n  所有中间件（Layer 对象）使用stack数组存储起来\n  每个 Router 对象都是通过一个stack数组，存储了相关中间件函数\n  router.handle函数通过next()方法遍历每一个 layer 进行比对，next()方法通过闭包维持了对于 Stack Index 游标的引用，当调用next()方法时，就会从下一个中间件开始查找\n\n- 处理结果\n\n```\n((req, res) => {\n  console.log('第一个中间件');\n  ((req, res) => {\n    console.log('第二个中间件');\n    (async(req, res) => {\n      console.log('第三个中间件 => 是一个 route 中间件，处理 /api/test1');\n      await sleep(2000)\n      res.status(200).send('hello')\n    })(req, res)\n    console.log('第二个中间件调用结束');\n  })(req, res)\n  console.log('第一个中间件调用结束')\n})(req, res)\n```\n\n- Express 的线形机制不容易实现拦截处理逻辑，会对业务代码有一定程度的侵扰，甚至造成不同中间件间的耦合，例如：记录请求响应的中间件，需要在初始中间件计时，在结束处理中计算时间\n\n2. koa中间件\n\n- 中间件使用\n\n```javascript\n// 最外层中间件，可以用于兜底 Koa 全局错误\napp.use(async (ctx, next) => {\n  try {\n    // console.log('中间件 1 开始执行')\n    // 执行下一个中间件\n    await next();\n    // console.log('中间件 1 执行结束')\n  } catch (error) {\n    console.log(`[koa error]: ${error.message}`)\n  }\n});\n// 第二层中间件，可以用于日志记录\napp.use(async (ctx, next) => {\n  // console.log('中间件 2 开始执行')\n  const { req } = ctx;\n  console.log(`req is ${JSON.stringify(req)}`);\n  await next();\n  console.log(`res is ${JSON.stringify(ctx.res)}`);\n  // console.log('中间件 2 执行结束')\n});\n```\n\n- koa组合中间件流程\n  通过compose方法组合中间件，返回一个中间件函数fnMiddleware\n  接收请求时，先调用handleRequest（调用createContext方法，封装ctx对象，调用this.handleRequest(ctx, fnMiddleware)处理该次请求）\n  通过fnMiddleware(ctx).then(handleResponse).catch(onerror)执行中间件\n\n- compose\n\n```javascript\nfunction compose(middleware) {\n  // 这里返回的函数，就是上文中的 fnMiddleware\n  return function (context, next) {\n    let index = -1;\n    return dispatch(0);\n\n    function dispatch(i) {\n      //\n      if (i <= index)\n        return Promise.reject(new Error(\"next() called multiple times\"));\n      index = i;\n      // 取出第 i 个中间件为 fn\n      let fn = middleware[i];\n\n      if (i === middleware.length) fn = next;\n\n      // 已经取到了最后一个中间件，直接返回一个 Promise 实例，进行串联\n      // 这一步的意义是保证最后一个中间件调用 next 方法时，也不会报错\n      if (!fn) return Promise.resolve();\n\n      try {\n        // 把 ctx 和 next 方法传入到中间件 fn 中，并将执行结果使用 Promise.resolve 包装\n        // 这里可以发现，我们在一个中间件中调用的 next 方法，其实就是dispatch.bind(null, i + 1)，即调用下一个中间件\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    }\n  };\n}\nconst fn1 = async (ctx, next) => {\n  console.log(\"1 start\");\n  await next();\n  console.log(\"1 end\");\n};\nconst fn2 = async (ctx, next) => {\n  console.log(\"2 start\");\n  await next();\n  console.log(\"2 end\");\n};\nconst fn3 = async (ctx, next) => {\n  console.log(\"3 start\");\n  await next();\n  console.log(\"3 end\");\n};\nconst fun = compose([fn1, fn2, fn3]);\nfun({}, () => {});\n// 1 start\n// 2 start\n// 3 start\n// 3 end\n// 2 end\n// 1 end\n```\n\n- dispatch(n)对应第 n 个中间件的执行，第 n 个中间件可以通过await next()来执行下一个中间件，同时在最后一个中间件执行完成后，依然有恢复执行的能力。\n- 通过洋葱模型，await next()控制调用 “下游”中间件，直到 “下游”没有中间件且堆栈执行完毕，最终流回“上游”中间件\n\n- 处理结果\n\n```\nasync function middleware1() {\n  ...\n  await (async function middleware2() {\n    ...\n    await (async function middleware3() {\n      ...\n    });\n    ...\n  });\n  ...\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/[node]nodejs使用.md","raw":"---\ntitle: <node>nodejs使用\ndate: 2021-02-20 00:00:00\ntags: [node]\ncategories: node\n---\n\n### nodejs特点\n\n- js运行环境，基于chromeV8引擎解析代码，事件驱动，异步驱动，非阻塞I/O，高并发，单线程\n\n- nodejs前端工程化与后端服务应用：\n1. 运行环境：\n\t工程化：运行在本机开花环境\n\t服务：运行在远程服务器，涉及到发布工具（devops），进程管理工具（PM2）,监控告警机制，日志打印及跟踪染色\n2. 受众群体不同：\n\t工程化：服务开发者，提升开发效率，研发质量\n\t服务：真实用户群体，需要关注服务稳定性，并发性能，考虑扩容方案，优化服务性能\n3. 问题调试：\n\t工程化：本地运行，可以在脚本中打log\n\t服务：需要高性能日志工具，遇到内存泄漏、句柄泄漏或者进程异常退出等问题，需要工具分析\n4. 关注点不同：\n\t工程化：注重开发效率提升以及研发质量保证\n\t服务：真正发挥node异步驱动特性，在非CPU密集场景下，开发网络I/O较高服务\n\n### 事件循环\n\n- node 10+ 版本后在运行结果上与浏览器一致，但是基于 libev 库实现，浏览器的核心是宏任务和微任务，node 有阶段性任务执行阶段\n\n#### 循环阶段\n\n1. timers：执行 setTimeout、setInterval 回调函数\n2. pending callbacks：执行操作系统回调，如 TCP 错误回调\n3. idle、prepare：仅系统内部使用\n4. poll：检索新的 I/O 事件，执行与 I/O 相关的回调\n5. check：执行 setImmediate 回调，setImmediate 并不是立马执行，而是当事件循环 poll 中没有新的事件处理时就执行该部分\n6. close callbacks：执行关闭的回调，如 socket.on('close', ...)\n\n- 发起事件循环起点：\n\tnodejs 启动后\n\tsetTimeout、setInterval 回调\n\t某一次 I/O 回调\n\n#### poll过程\n\n- poll 过程中，主要处理的是异步 I/O 的回调函数，以及其他几乎所有的回调函数，异步 I/O 又分为网络 I/O 和文件 I/O\n\n#### 微任务宏任务\n\n- 微任务：process.nextTick 和 Promise，同一个事件循环中有其他任务存在时，优先执行微任务队列，优先级 process.nextTick 高于 Promise\n- 宏任务：setTimeout、setInterval、setImmediate 和 I/O，宏任务在微任务执行之后执行，因此在同一个事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么优先将微任务队列清空，再执行宏任务队列\n\n```javascript\n\"use strict\";\nconst process = require(\"process\");\nconst fs = require(\"fs\");\nconst path = require(\"path\");\n\nconsole.log(\"start\");\n\nfunction promiseRun() {\n  Promise.resolve().then(() => {\n    console.log(\"promise\");\n  });\n}\n\nfs.readFile(path.resolve(__dirname, \"./file.txt\"), (err, data) => {\n  if (err) {\n    throw err;\n  }\n  promiseRun();\n  console.log(\"fs io callback\");\n});\n\nsetImmediate(() => {\n  promiseRun();\n  console.log(\"immediate\");\n});\n\nsetTimeout(() => {\n  promiseRun();\n  console.log(\"timeout\");\n  fs.readFile(path.resolve(__dirname, \"./file.txt\"), (err, data) => {\n    if (err) {\n      throw err;\n    }\n    console.log(\"async fs io callback\");\n  });\n}, 0);\n\npromiseRun();\n\nprocess.nextTick(() => {\n  console.log(\"nextTick\");\n});\n\nconsole.log(\"end\");\n\n// start\n// end\n// nextTick\n// promise\n// timeout\n// promise\n// immediate\n// promise\n// fs io callback\n// promise\n// async fs io callback\n```\n\n#### 单线程多线程\n\n- node 主线程是单线程执行的，但是 Node.js 存在多线程执行，多线程包括 setTimeout 和异步 I/O 事件。其实 Node.js 还存在其他的线程，包括垃圾回收、内存优化等\n\n### node适用服务场景\n\n- 适用场景：\n\t业务网关：鉴权处理服务，特性：网络 I/O 高，高并发，不涉及 CPU 密集逻辑\n\t中台服务：配置系统、反馈系统、推送系统、系统工具搭建，特点：网络 I/O高、并发高、通用性强及业务复杂度低\n\t运营系统：并发高，不涉及底层数据库读写\n\t爬虫系统：puppeteer，jsdom 等库支持动态静态爬虫抓取\n\n- 不适用场景：node 不适用阻塞主线程、CPU 密集型运算的服务，如：图片处理、大字符串数字处理、大文件读写\n\n### nodejs框架\n\n#### express与koa区别\n\n- expres内置很多中间件，比如connext、router，koa更加轻量化，可以根据需求定制框架\n- 中间件处理：express基于callback处理，koa基于await/async处理\n- 异步执行中间件：express并非严格按照洋葱模型执行中间件，koa严格遵循\n\n#### 中间件\n\n1. express\n\n- 流程\n  通过app.use方法注册中间件\n  一个中间件为一个layer对象，包含当前路由正则信息以及handle方法\n  所有中间件（Layer 对象）使用stack数组存储起来\n  每个 Router 对象都是通过一个stack数组，存储了相关中间件函数\n  router.handle函数通过next()方法遍历每一个 layer 进行比对，next()方法通过闭包维持了对于 Stack Index 游标的引用，当调用next()方法时，就会从下一个中间件开始查找\n\n- 处理结果\n\n```\n((req, res) => {\n  console.log('第一个中间件');\n  ((req, res) => {\n    console.log('第二个中间件');\n    (async(req, res) => {\n      console.log('第三个中间件 => 是一个 route 中间件，处理 /api/test1');\n      await sleep(2000)\n      res.status(200).send('hello')\n    })(req, res)\n    console.log('第二个中间件调用结束');\n  })(req, res)\n  console.log('第一个中间件调用结束')\n})(req, res)\n```\n\n- Express 的线形机制不容易实现拦截处理逻辑，会对业务代码有一定程度的侵扰，甚至造成不同中间件间的耦合，例如：记录请求响应的中间件，需要在初始中间件计时，在结束处理中计算时间\n\n2. koa中间件\n\n- 中间件使用\n\n```javascript\n// 最外层中间件，可以用于兜底 Koa 全局错误\napp.use(async (ctx, next) => {\n  try {\n    // console.log('中间件 1 开始执行')\n    // 执行下一个中间件\n    await next();\n    // console.log('中间件 1 执行结束')\n  } catch (error) {\n    console.log(`[koa error]: ${error.message}`)\n  }\n});\n// 第二层中间件，可以用于日志记录\napp.use(async (ctx, next) => {\n  // console.log('中间件 2 开始执行')\n  const { req } = ctx;\n  console.log(`req is ${JSON.stringify(req)}`);\n  await next();\n  console.log(`res is ${JSON.stringify(ctx.res)}`);\n  // console.log('中间件 2 执行结束')\n});\n```\n\n- koa组合中间件流程\n  通过compose方法组合中间件，返回一个中间件函数fnMiddleware\n  接收请求时，先调用handleRequest（调用createContext方法，封装ctx对象，调用this.handleRequest(ctx, fnMiddleware)处理该次请求）\n  通过fnMiddleware(ctx).then(handleResponse).catch(onerror)执行中间件\n\n- compose\n\n```javascript\nfunction compose(middleware) {\n  // 这里返回的函数，就是上文中的 fnMiddleware\n  return function (context, next) {\n    let index = -1;\n    return dispatch(0);\n\n    function dispatch(i) {\n      //\n      if (i <= index)\n        return Promise.reject(new Error(\"next() called multiple times\"));\n      index = i;\n      // 取出第 i 个中间件为 fn\n      let fn = middleware[i];\n\n      if (i === middleware.length) fn = next;\n\n      // 已经取到了最后一个中间件，直接返回一个 Promise 实例，进行串联\n      // 这一步的意义是保证最后一个中间件调用 next 方法时，也不会报错\n      if (!fn) return Promise.resolve();\n\n      try {\n        // 把 ctx 和 next 方法传入到中间件 fn 中，并将执行结果使用 Promise.resolve 包装\n        // 这里可以发现，我们在一个中间件中调用的 next 方法，其实就是dispatch.bind(null, i + 1)，即调用下一个中间件\n        return Promise.resolve(fn(context, dispatch.bind(null, i + 1)));\n      } catch (err) {\n        return Promise.reject(err);\n      }\n    }\n  };\n}\nconst fn1 = async (ctx, next) => {\n  console.log(\"1 start\");\n  await next();\n  console.log(\"1 end\");\n};\nconst fn2 = async (ctx, next) => {\n  console.log(\"2 start\");\n  await next();\n  console.log(\"2 end\");\n};\nconst fn3 = async (ctx, next) => {\n  console.log(\"3 start\");\n  await next();\n  console.log(\"3 end\");\n};\nconst fun = compose([fn1, fn2, fn3]);\nfun({}, () => {});\n// 1 start\n// 2 start\n// 3 start\n// 3 end\n// 2 end\n// 1 end\n```\n\n- dispatch(n)对应第 n 个中间件的执行，第 n 个中间件可以通过await next()来执行下一个中间件，同时在最后一个中间件执行完成后，依然有恢复执行的能力。\n- 通过洋葱模型，await next()控制调用 “下游”中间件，直到 “下游”没有中间件且堆栈执行完毕，最终流回“上游”中间件\n\n- 处理结果\n\n```\nasync function middleware1() {\n  ...\n  await (async function middleware2() {\n    ...\n    await (async function middleware3() {\n      ...\n    });\n    ...\n  });\n  ...\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"[node]nodejs使用","published":1,"updated":"2021-03-15T14:40:18.948Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dl0002ywotj3mumdug5","content":"<h3 id=\"nodejs特点\"><a href=\"#nodejs特点\" class=\"headerlink\" title=\"nodejs特点\"></a>nodejs特点</h3><ul>\n<li><p>js运行环境，基于chromeV8引擎解析代码，事件驱动，异步驱动，非阻塞I/O，高并发，单线程</p>\n</li>\n<li><p>nodejs前端工程化与后端服务应用：</p>\n</li>\n</ul>\n<ol>\n<li>运行环境：<br> 工程化：运行在本机开花环境<br> 服务：运行在远程服务器，涉及到发布工具（devops），进程管理工具（PM2）,监控告警机制，日志打印及跟踪染色</li>\n<li>受众群体不同：<br> 工程化：服务开发者，提升开发效率，研发质量<br> 服务：真实用户群体，需要关注服务稳定性，并发性能，考虑扩容方案，优化服务性能</li>\n<li>问题调试：<br> 工程化：本地运行，可以在脚本中打log<br> 服务：需要高性能日志工具，遇到内存泄漏、句柄泄漏或者进程异常退出等问题，需要工具分析</li>\n<li>关注点不同：<br> 工程化：注重开发效率提升以及研发质量保证<br> 服务：真正发挥node异步驱动特性，在非CPU密集场景下，开发网络I/O较高服务</li>\n</ol>\n<h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><ul>\n<li>node 10+ 版本后在运行结果上与浏览器一致，但是基于 libev 库实现，浏览器的核心是宏任务和微任务，node 有阶段性任务执行阶段</li>\n</ul>\n<h4 id=\"循环阶段\"><a href=\"#循环阶段\" class=\"headerlink\" title=\"循环阶段\"></a>循环阶段</h4><ol>\n<li>timers：执行 setTimeout、setInterval 回调函数</li>\n<li>pending callbacks：执行操作系统回调，如 TCP 错误回调</li>\n<li>idle、prepare：仅系统内部使用</li>\n<li>poll：检索新的 I/O 事件，执行与 I/O 相关的回调</li>\n<li>check：执行 setImmediate 回调，setImmediate 并不是立马执行，而是当事件循环 poll 中没有新的事件处理时就执行该部分</li>\n<li>close callbacks：执行关闭的回调，如 socket.on(‘close’, …)</li>\n</ol>\n<ul>\n<li>发起事件循环起点：<br>  nodejs 启动后<br>  setTimeout、setInterval 回调<br>  某一次 I/O 回调</li>\n</ul>\n<h4 id=\"poll过程\"><a href=\"#poll过程\" class=\"headerlink\" title=\"poll过程\"></a>poll过程</h4><ul>\n<li>poll 过程中，主要处理的是异步 I/O 的回调函数，以及其他几乎所有的回调函数，异步 I/O 又分为网络 I/O 和文件 I/O</li>\n</ul>\n<h4 id=\"微任务宏任务\"><a href=\"#微任务宏任务\" class=\"headerlink\" title=\"微任务宏任务\"></a>微任务宏任务</h4><ul>\n<li>微任务：process.nextTick 和 Promise，同一个事件循环中有其他任务存在时，优先执行微任务队列，优先级 process.nextTick 高于 Promise</li>\n<li>宏任务：setTimeout、setInterval、setImmediate 和 I/O，宏任务在微任务执行之后执行，因此在同一个事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么优先将微任务队列清空，再执行宏任务队列</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> process = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;process&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;path&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;start&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">promiseRun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;promise&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fs.readFile(path.resolve(__dirname, <span class=\"string\">&quot;./file.txt&quot;</span>), <span class=\"function\">(<span class=\"params\">err, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  promiseRun();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;fs io callback&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">setImmediate(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  promiseRun();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;immediate&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  promiseRun();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;timeout&quot;</span>);</span><br><span class=\"line\">  fs.readFile(path.resolve(__dirname, <span class=\"string\">&quot;./file.txt&quot;</span>), <span class=\"function\">(<span class=\"params\">err, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;async fs io callback&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">promiseRun();</span><br><span class=\"line\"></span><br><span class=\"line\">process.nextTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;nextTick&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// start</span></span><br><span class=\"line\"><span class=\"comment\">// end</span></span><br><span class=\"line\"><span class=\"comment\">// nextTick</span></span><br><span class=\"line\"><span class=\"comment\">// promise</span></span><br><span class=\"line\"><span class=\"comment\">// timeout</span></span><br><span class=\"line\"><span class=\"comment\">// promise</span></span><br><span class=\"line\"><span class=\"comment\">// immediate</span></span><br><span class=\"line\"><span class=\"comment\">// promise</span></span><br><span class=\"line\"><span class=\"comment\">// fs io callback</span></span><br><span class=\"line\"><span class=\"comment\">// promise</span></span><br><span class=\"line\"><span class=\"comment\">// async fs io callback</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"单线程多线程\"><a href=\"#单线程多线程\" class=\"headerlink\" title=\"单线程多线程\"></a>单线程多线程</h4><ul>\n<li>node 主线程是单线程执行的，但是 Node.js 存在多线程执行，多线程包括 setTimeout 和异步 I/O 事件。其实 Node.js 还存在其他的线程，包括垃圾回收、内存优化等</li>\n</ul>\n<h3 id=\"node适用服务场景\"><a href=\"#node适用服务场景\" class=\"headerlink\" title=\"node适用服务场景\"></a>node适用服务场景</h3><ul>\n<li><p>适用场景：<br>  业务网关：鉴权处理服务，特性：网络 I/O 高，高并发，不涉及 CPU 密集逻辑<br>  中台服务：配置系统、反馈系统、推送系统、系统工具搭建，特点：网络 I/O高、并发高、通用性强及业务复杂度低<br>  运营系统：并发高，不涉及底层数据库读写<br>  爬虫系统：puppeteer，jsdom 等库支持动态静态爬虫抓取</p>\n</li>\n<li><p>不适用场景：node 不适用阻塞主线程、CPU 密集型运算的服务，如：图片处理、大字符串数字处理、大文件读写</p>\n</li>\n</ul>\n<h3 id=\"nodejs框架\"><a href=\"#nodejs框架\" class=\"headerlink\" title=\"nodejs框架\"></a>nodejs框架</h3><h4 id=\"express与koa区别\"><a href=\"#express与koa区别\" class=\"headerlink\" title=\"express与koa区别\"></a>express与koa区别</h4><ul>\n<li>expres内置很多中间件，比如connext、router，koa更加轻量化，可以根据需求定制框架</li>\n<li>中间件处理：express基于callback处理，koa基于await/async处理</li>\n<li>异步执行中间件：express并非严格按照洋葱模型执行中间件，koa严格遵循</li>\n</ul>\n<h4 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h4><ol>\n<li>express</li>\n</ol>\n<ul>\n<li><p>流程<br>通过app.use方法注册中间件<br>一个中间件为一个layer对象，包含当前路由正则信息以及handle方法<br>所有中间件（Layer 对象）使用stack数组存储起来<br>每个 Router 对象都是通过一个stack数组，存储了相关中间件函数<br>router.handle函数通过next()方法遍历每一个 layer 进行比对，next()方法通过闭包维持了对于 Stack Index 游标的引用，当调用next()方法时，就会从下一个中间件开始查找</p>\n</li>\n<li><p>处理结果</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((req, res) &#x3D;&gt; &#123;</span><br><span class=\"line\">  console.log(&#39;第一个中间件&#39;);</span><br><span class=\"line\">  ((req, res) &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(&#39;第二个中间件&#39;);</span><br><span class=\"line\">    (async(req, res) &#x3D;&gt; &#123;</span><br><span class=\"line\">      console.log(&#39;第三个中间件 &#x3D;&gt; 是一个 route 中间件，处理 &#x2F;api&#x2F;test1&#39;);</span><br><span class=\"line\">      await sleep(2000)</span><br><span class=\"line\">      res.status(200).send(&#39;hello&#39;)</span><br><span class=\"line\">    &#125;)(req, res)</span><br><span class=\"line\">    console.log(&#39;第二个中间件调用结束&#39;);</span><br><span class=\"line\">  &#125;)(req, res)</span><br><span class=\"line\">  console.log(&#39;第一个中间件调用结束&#39;)</span><br><span class=\"line\">&#125;)(req, res)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Express 的线形机制不容易实现拦截处理逻辑，会对业务代码有一定程度的侵扰，甚至造成不同中间件间的耦合，例如：记录请求响应的中间件，需要在初始中间件计时，在结束处理中计算时间</li>\n</ul>\n<ol start=\"2\">\n<li>koa中间件</li>\n</ol>\n<ul>\n<li>中间件使用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最外层中间件，可以用于兜底 Koa 全局错误</span></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// console.log(&#x27;中间件 1 开始执行&#x27;)</span></span><br><span class=\"line\">    <span class=\"comment\">// 执行下一个中间件</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">    <span class=\"comment\">// console.log(&#x27;中间件 1 执行结束&#x27;)</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`[koa error]: <span class=\"subst\">$&#123;error.message&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 第二层中间件，可以用于日志记录</span></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(&#x27;中间件 2 开始执行&#x27;)</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; req &#125; = ctx;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`req is <span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(req)&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`res is <span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(ctx.res)&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"comment\">// console.log(&#x27;中间件 2 执行结束&#x27;)</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>koa组合中间件流程<br>通过compose方法组合中间件，返回一个中间件函数fnMiddleware<br>接收请求时，先调用handleRequest（调用createContext方法，封装ctx对象，调用this.handleRequest(ctx, fnMiddleware)处理该次请求）<br>通过fnMiddleware(ctx).then(handleResponse).catch(onerror)执行中间件</p>\n</li>\n<li><p>compose</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">middleware</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里返回的函数，就是上文中的 fnMiddleware</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context, next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dispatch(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i &lt;= index)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;next() called multiple times&quot;</span>));</span><br><span class=\"line\">      index = i;</span><br><span class=\"line\">      <span class=\"comment\">// 取出第 i 个中间件为 fn</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> fn = middleware[i];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === middleware.length) fn = next;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 已经取到了最后一个中间件，直接返回一个 Promise 实例，进行串联</span></span><br><span class=\"line\">      <span class=\"comment\">// 这一步的意义是保证最后一个中间件调用 next 方法时，也不会报错</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!fn) <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 把 ctx 和 next 方法传入到中间件 fn 中，并将执行结果使用 Promise.resolve 包装</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里可以发现，我们在一个中间件中调用的 next 方法，其实就是dispatch.bind(null, i + 1)，即调用下一个中间件</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(fn(context, dispatch.bind(<span class=\"literal\">null</span>, i + <span class=\"number\">1</span>)));</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> fn1 = <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;1 start&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;1 end&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> fn2 = <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;2 start&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;2 end&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> fn3 = <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;3 start&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;3 end&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> fun = compose([fn1, fn2, fn3]);</span><br><span class=\"line\">fun(&#123;&#125;, <span class=\"function\">() =&gt;</span> &#123;&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 1 start</span></span><br><span class=\"line\"><span class=\"comment\">// 2 start</span></span><br><span class=\"line\"><span class=\"comment\">// 3 start</span></span><br><span class=\"line\"><span class=\"comment\">// 3 end</span></span><br><span class=\"line\"><span class=\"comment\">// 2 end</span></span><br><span class=\"line\"><span class=\"comment\">// 1 end</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>dispatch(n)对应第 n 个中间件的执行，第 n 个中间件可以通过await next()来执行下一个中间件，同时在最后一个中间件执行完成后，依然有恢复执行的能力。</p>\n</li>\n<li><p>通过洋葱模型，await next()控制调用 “下游”中间件，直到 “下游”没有中间件且堆栈执行完毕，最终流回“上游”中间件</p>\n</li>\n<li><p>处理结果</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function middleware1() &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  await (async function middleware2() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    await (async function middleware3() &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"nodejs特点\"><a href=\"#nodejs特点\" class=\"headerlink\" title=\"nodejs特点\"></a>nodejs特点</h3><ul>\n<li><p>js运行环境，基于chromeV8引擎解析代码，事件驱动，异步驱动，非阻塞I/O，高并发，单线程</p>\n</li>\n<li><p>nodejs前端工程化与后端服务应用：</p>\n</li>\n</ul>\n<ol>\n<li>运行环境：<br> 工程化：运行在本机开花环境<br> 服务：运行在远程服务器，涉及到发布工具（devops），进程管理工具（PM2）,监控告警机制，日志打印及跟踪染色</li>\n<li>受众群体不同：<br> 工程化：服务开发者，提升开发效率，研发质量<br> 服务：真实用户群体，需要关注服务稳定性，并发性能，考虑扩容方案，优化服务性能</li>\n<li>问题调试：<br> 工程化：本地运行，可以在脚本中打log<br> 服务：需要高性能日志工具，遇到内存泄漏、句柄泄漏或者进程异常退出等问题，需要工具分析</li>\n<li>关注点不同：<br> 工程化：注重开发效率提升以及研发质量保证<br> 服务：真正发挥node异步驱动特性，在非CPU密集场景下，开发网络I/O较高服务</li>\n</ol>\n<h3 id=\"事件循环\"><a href=\"#事件循环\" class=\"headerlink\" title=\"事件循环\"></a>事件循环</h3><ul>\n<li>node 10+ 版本后在运行结果上与浏览器一致，但是基于 libev 库实现，浏览器的核心是宏任务和微任务，node 有阶段性任务执行阶段</li>\n</ul>\n<h4 id=\"循环阶段\"><a href=\"#循环阶段\" class=\"headerlink\" title=\"循环阶段\"></a>循环阶段</h4><ol>\n<li>timers：执行 setTimeout、setInterval 回调函数</li>\n<li>pending callbacks：执行操作系统回调，如 TCP 错误回调</li>\n<li>idle、prepare：仅系统内部使用</li>\n<li>poll：检索新的 I/O 事件，执行与 I/O 相关的回调</li>\n<li>check：执行 setImmediate 回调，setImmediate 并不是立马执行，而是当事件循环 poll 中没有新的事件处理时就执行该部分</li>\n<li>close callbacks：执行关闭的回调，如 socket.on(‘close’, …)</li>\n</ol>\n<ul>\n<li>发起事件循环起点：<br>  nodejs 启动后<br>  setTimeout、setInterval 回调<br>  某一次 I/O 回调</li>\n</ul>\n<h4 id=\"poll过程\"><a href=\"#poll过程\" class=\"headerlink\" title=\"poll过程\"></a>poll过程</h4><ul>\n<li>poll 过程中，主要处理的是异步 I/O 的回调函数，以及其他几乎所有的回调函数，异步 I/O 又分为网络 I/O 和文件 I/O</li>\n</ul>\n<h4 id=\"微任务宏任务\"><a href=\"#微任务宏任务\" class=\"headerlink\" title=\"微任务宏任务\"></a>微任务宏任务</h4><ul>\n<li>微任务：process.nextTick 和 Promise，同一个事件循环中有其他任务存在时，优先执行微任务队列，优先级 process.nextTick 高于 Promise</li>\n<li>宏任务：setTimeout、setInterval、setImmediate 和 I/O，宏任务在微任务执行之后执行，因此在同一个事件循环周期内，如果既存在微任务队列又存在宏任务队列，那么优先将微任务队列清空，再执行宏任务队列</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&quot;use strict&quot;</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> process = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;process&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> fs = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;fs&quot;</span>);</span><br><span class=\"line\"><span class=\"keyword\">const</span> path = <span class=\"built_in\">require</span>(<span class=\"string\">&quot;path&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;start&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">promiseRun</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">Promise</span>.resolve().then(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;promise&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">fs.readFile(path.resolve(__dirname, <span class=\"string\">&quot;./file.txt&quot;</span>), <span class=\"function\">(<span class=\"params\">err, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  promiseRun();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;fs io callback&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">setImmediate(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  promiseRun();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;immediate&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">setTimeout</span>(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  promiseRun();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;timeout&quot;</span>);</span><br><span class=\"line\">  fs.readFile(path.resolve(__dirname, <span class=\"string\">&quot;./file.txt&quot;</span>), <span class=\"function\">(<span class=\"params\">err, data</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (err) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> err;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;async fs io callback&quot;</span>);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">&#125;, <span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">promiseRun();</span><br><span class=\"line\"></span><br><span class=\"line\">process.nextTick(<span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;nextTick&quot;</span>);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;end&quot;</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// start</span></span><br><span class=\"line\"><span class=\"comment\">// end</span></span><br><span class=\"line\"><span class=\"comment\">// nextTick</span></span><br><span class=\"line\"><span class=\"comment\">// promise</span></span><br><span class=\"line\"><span class=\"comment\">// timeout</span></span><br><span class=\"line\"><span class=\"comment\">// promise</span></span><br><span class=\"line\"><span class=\"comment\">// immediate</span></span><br><span class=\"line\"><span class=\"comment\">// promise</span></span><br><span class=\"line\"><span class=\"comment\">// fs io callback</span></span><br><span class=\"line\"><span class=\"comment\">// promise</span></span><br><span class=\"line\"><span class=\"comment\">// async fs io callback</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"单线程多线程\"><a href=\"#单线程多线程\" class=\"headerlink\" title=\"单线程多线程\"></a>单线程多线程</h4><ul>\n<li>node 主线程是单线程执行的，但是 Node.js 存在多线程执行，多线程包括 setTimeout 和异步 I/O 事件。其实 Node.js 还存在其他的线程，包括垃圾回收、内存优化等</li>\n</ul>\n<h3 id=\"node适用服务场景\"><a href=\"#node适用服务场景\" class=\"headerlink\" title=\"node适用服务场景\"></a>node适用服务场景</h3><ul>\n<li><p>适用场景：<br>  业务网关：鉴权处理服务，特性：网络 I/O 高，高并发，不涉及 CPU 密集逻辑<br>  中台服务：配置系统、反馈系统、推送系统、系统工具搭建，特点：网络 I/O高、并发高、通用性强及业务复杂度低<br>  运营系统：并发高，不涉及底层数据库读写<br>  爬虫系统：puppeteer，jsdom 等库支持动态静态爬虫抓取</p>\n</li>\n<li><p>不适用场景：node 不适用阻塞主线程、CPU 密集型运算的服务，如：图片处理、大字符串数字处理、大文件读写</p>\n</li>\n</ul>\n<h3 id=\"nodejs框架\"><a href=\"#nodejs框架\" class=\"headerlink\" title=\"nodejs框架\"></a>nodejs框架</h3><h4 id=\"express与koa区别\"><a href=\"#express与koa区别\" class=\"headerlink\" title=\"express与koa区别\"></a>express与koa区别</h4><ul>\n<li>expres内置很多中间件，比如connext、router，koa更加轻量化，可以根据需求定制框架</li>\n<li>中间件处理：express基于callback处理，koa基于await/async处理</li>\n<li>异步执行中间件：express并非严格按照洋葱模型执行中间件，koa严格遵循</li>\n</ul>\n<h4 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h4><ol>\n<li>express</li>\n</ol>\n<ul>\n<li><p>流程<br>通过app.use方法注册中间件<br>一个中间件为一个layer对象，包含当前路由正则信息以及handle方法<br>所有中间件（Layer 对象）使用stack数组存储起来<br>每个 Router 对象都是通过一个stack数组，存储了相关中间件函数<br>router.handle函数通过next()方法遍历每一个 layer 进行比对，next()方法通过闭包维持了对于 Stack Index 游标的引用，当调用next()方法时，就会从下一个中间件开始查找</p>\n</li>\n<li><p>处理结果</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">((req, res) &#x3D;&gt; &#123;</span><br><span class=\"line\">  console.log(&#39;第一个中间件&#39;);</span><br><span class=\"line\">  ((req, res) &#x3D;&gt; &#123;</span><br><span class=\"line\">    console.log(&#39;第二个中间件&#39;);</span><br><span class=\"line\">    (async(req, res) &#x3D;&gt; &#123;</span><br><span class=\"line\">      console.log(&#39;第三个中间件 &#x3D;&gt; 是一个 route 中间件，处理 &#x2F;api&#x2F;test1&#39;);</span><br><span class=\"line\">      await sleep(2000)</span><br><span class=\"line\">      res.status(200).send(&#39;hello&#39;)</span><br><span class=\"line\">    &#125;)(req, res)</span><br><span class=\"line\">    console.log(&#39;第二个中间件调用结束&#39;);</span><br><span class=\"line\">  &#125;)(req, res)</span><br><span class=\"line\">  console.log(&#39;第一个中间件调用结束&#39;)</span><br><span class=\"line\">&#125;)(req, res)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Express 的线形机制不容易实现拦截处理逻辑，会对业务代码有一定程度的侵扰，甚至造成不同中间件间的耦合，例如：记录请求响应的中间件，需要在初始中间件计时，在结束处理中计算时间</li>\n</ul>\n<ol start=\"2\">\n<li>koa中间件</li>\n</ol>\n<ul>\n<li>中间件使用</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 最外层中间件，可以用于兜底 Koa 全局错误</span></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// console.log(&#x27;中间件 1 开始执行&#x27;)</span></span><br><span class=\"line\">    <span class=\"comment\">// 执行下一个中间件</span></span><br><span class=\"line\">    <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">    <span class=\"comment\">// console.log(&#x27;中间件 1 执行结束&#x27;)</span></span><br><span class=\"line\">  &#125; <span class=\"keyword\">catch</span> (error) &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"string\">`[koa error]: <span class=\"subst\">$&#123;error.message&#125;</span>`</span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 第二层中间件，可以用于日志记录</span></span><br><span class=\"line\">app.use(<span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"comment\">// console.log(&#x27;中间件 2 开始执行&#x27;)</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> &#123; req &#125; = ctx;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`req is <span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(req)&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">`res is <span class=\"subst\">$&#123;<span class=\"built_in\">JSON</span>.stringify(ctx.res)&#125;</span>`</span>);</span><br><span class=\"line\">  <span class=\"comment\">// console.log(&#x27;中间件 2 执行结束&#x27;)</span></span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>koa组合中间件流程<br>通过compose方法组合中间件，返回一个中间件函数fnMiddleware<br>接收请求时，先调用handleRequest（调用createContext方法，封装ctx对象，调用this.handleRequest(ctx, fnMiddleware)处理该次请求）<br>通过fnMiddleware(ctx).then(handleResponse).catch(onerror)执行中间件</p>\n</li>\n<li><p>compose</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">middleware</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 这里返回的函数，就是上文中的 fnMiddleware</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">context, next</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> index = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> dispatch(<span class=\"number\">0</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\">i</span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"comment\">//</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i &lt;= index)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(<span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;next() called multiple times&quot;</span>));</span><br><span class=\"line\">      index = i;</span><br><span class=\"line\">      <span class=\"comment\">// 取出第 i 个中间件为 fn</span></span><br><span class=\"line\">      <span class=\"keyword\">let</span> fn = middleware[i];</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (i === middleware.length) fn = next;</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"comment\">// 已经取到了最后一个中间件，直接返回一个 Promise 实例，进行串联</span></span><br><span class=\"line\">      <span class=\"comment\">// 这一步的意义是保证最后一个中间件调用 next 方法时，也不会报错</span></span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!fn) <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve();</span><br><span class=\"line\"></span><br><span class=\"line\">      <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 把 ctx 和 next 方法传入到中间件 fn 中，并将执行结果使用 Promise.resolve 包装</span></span><br><span class=\"line\">        <span class=\"comment\">// 这里可以发现，我们在一个中间件中调用的 next 方法，其实就是dispatch.bind(null, i + 1)，即调用下一个中间件</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.resolve(fn(context, dispatch.bind(<span class=\"literal\">null</span>, i + <span class=\"number\">1</span>)));</span><br><span class=\"line\">      &#125; <span class=\"keyword\">catch</span> (err) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"built_in\">Promise</span>.reject(err);</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> fn1 = <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;1 start&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;1 end&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> fn2 = <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;2 start&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;2 end&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> fn3 = <span class=\"keyword\">async</span> (ctx, next) =&gt; &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;3 start&quot;</span>);</span><br><span class=\"line\">  <span class=\"keyword\">await</span> next();</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">&quot;3 end&quot;</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> fun = compose([fn1, fn2, fn3]);</span><br><span class=\"line\">fun(&#123;&#125;, <span class=\"function\">() =&gt;</span> &#123;&#125;);</span><br><span class=\"line\"><span class=\"comment\">// 1 start</span></span><br><span class=\"line\"><span class=\"comment\">// 2 start</span></span><br><span class=\"line\"><span class=\"comment\">// 3 start</span></span><br><span class=\"line\"><span class=\"comment\">// 3 end</span></span><br><span class=\"line\"><span class=\"comment\">// 2 end</span></span><br><span class=\"line\"><span class=\"comment\">// 1 end</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>dispatch(n)对应第 n 个中间件的执行，第 n 个中间件可以通过await next()来执行下一个中间件，同时在最后一个中间件执行完成后，依然有恢复执行的能力。</p>\n</li>\n<li><p>通过洋葱模型，await next()控制调用 “下游”中间件，直到 “下游”没有中间件且堆栈执行完毕，最终流回“上游”中间件</p>\n</li>\n<li><p>处理结果</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function middleware1() &#123;</span><br><span class=\"line\">  ...</span><br><span class=\"line\">  await (async function middleware2() &#123;</span><br><span class=\"line\">    ...</span><br><span class=\"line\">    await (async function middleware3() &#123;</span><br><span class=\"line\">      ...</span><br><span class=\"line\">    &#125;);</span><br><span class=\"line\">    ...</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n"},{"title":"<react>react-router实现原理","date":"2020-06-10T16:00:00.000Z","_content":"\n#### 前端路由解决方案\n\n- 解决思路：1、拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容 2、感知 URL 的变化\n\n##### hash模式\n\n- hash 的改变\n\n```javascript\n// hash 的改变：我们可以通过 location 暴露出来的属性，直接去修改当前 URL 的 hash 值\nwindow.location.hash = 'home'\n```\n\n- hash变化监听：通过监听 “hashchange”事件，可以用 JS 来捕捉 hash 值的变化，进而决定我们页面内容是否需要更新\n\n```javascript\n// 监听hash变化，点击浏览器的前进后退会触发\nwindow.addEventListener('hashchange', function(event){ \n    // 根据 hash 的变化更新内容\n},false)\n```\n\n##### history\n\n- history api\n- 通过html5 新特性：pushState、replaceState实现\n\n```javascript\nwindow.history.forward()  // 前进到下一页\nwindow.history.back() // 后退到上一页\nwindow.history.go(2) // 前进两页\nwindow.history.go(-2) // 后退两页\n\n// html5新特性\nhistory.pushState(data[,title][,url]); // 向浏览历史中追加一条记录\nhistory.replaceState(data[,title][,url]); // 修改（替换）当前页在浏览历史中的信息\n```\n\n- 监听变化\n\n```\nwindow.addEventListener('popstate', function(e) {\n  console.log(e)\n});\n```\n\n- history模式需要在服务端完成 historyApiFallback 配置\n\n#### react-router设计模式\n\n##### Monorepo设计\n\n- 与 Monorepo 相对的概念是Multirepo。Multirepo 就是我们常用的开发模式，一个仓库对应一个工程，子团队自行维护\n- React Router 使用了 Monorepo 的工程架构，使工程代码对团队中的每一个人都具备透明度\n- 通常会使用 Lerna 作为开发管理 Monorepo 的开发工具，它的主要用户包括 Babel、React、umi、React Router 等\n\n##### Context数据共享\n\n- 使用 Context API 完成数据共享\n\n#### react-router相关库\n\n- 在 React Router 内部主要依靠 history 库完成，这是由 React Router 自己封装的库，为了实现跨平台运行的特性，内部提供两套基础 history，一套是直接使用浏览器的 History API，用于支持 react-router-dom；另一套是基于内存实现的版本，这是自己做的一个数组，用于支持 react-router-native\n- react-router 是没有 UI 层的，react-router-dom = react-router + Dom UI，而 react-router-native = react-router + native UI\n\n#### react-router关键模块\n\n1. Context 容器，分别是 Router 与 MemoryRouter，主要提供上下文消费容器；\n2. 直接消费者，提供路由匹配功能，分别是 Route、Redirect、Switch；\n3. 与平台关联的功能组件，分别是 react-router-dom 中的 Link、NavLink 以及 react-router-native 中的 DeepLinking\n\n\n\n\n\n\n\n\n\n","source":"_posts/[react]react-router实现原理.md","raw":"---\ntitle: <react>react-router实现原理\ndate: 2020-06-11 00:00:00\ntags: [react]\ncategories:  react\n---\n\n#### 前端路由解决方案\n\n- 解决思路：1、拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容 2、感知 URL 的变化\n\n##### hash模式\n\n- hash 的改变\n\n```javascript\n// hash 的改变：我们可以通过 location 暴露出来的属性，直接去修改当前 URL 的 hash 值\nwindow.location.hash = 'home'\n```\n\n- hash变化监听：通过监听 “hashchange”事件，可以用 JS 来捕捉 hash 值的变化，进而决定我们页面内容是否需要更新\n\n```javascript\n// 监听hash变化，点击浏览器的前进后退会触发\nwindow.addEventListener('hashchange', function(event){ \n    // 根据 hash 的变化更新内容\n},false)\n```\n\n##### history\n\n- history api\n- 通过html5 新特性：pushState、replaceState实现\n\n```javascript\nwindow.history.forward()  // 前进到下一页\nwindow.history.back() // 后退到上一页\nwindow.history.go(2) // 前进两页\nwindow.history.go(-2) // 后退两页\n\n// html5新特性\nhistory.pushState(data[,title][,url]); // 向浏览历史中追加一条记录\nhistory.replaceState(data[,title][,url]); // 修改（替换）当前页在浏览历史中的信息\n```\n\n- 监听变化\n\n```\nwindow.addEventListener('popstate', function(e) {\n  console.log(e)\n});\n```\n\n- history模式需要在服务端完成 historyApiFallback 配置\n\n#### react-router设计模式\n\n##### Monorepo设计\n\n- 与 Monorepo 相对的概念是Multirepo。Multirepo 就是我们常用的开发模式，一个仓库对应一个工程，子团队自行维护\n- React Router 使用了 Monorepo 的工程架构，使工程代码对团队中的每一个人都具备透明度\n- 通常会使用 Lerna 作为开发管理 Monorepo 的开发工具，它的主要用户包括 Babel、React、umi、React Router 等\n\n##### Context数据共享\n\n- 使用 Context API 完成数据共享\n\n#### react-router相关库\n\n- 在 React Router 内部主要依靠 history 库完成，这是由 React Router 自己封装的库，为了实现跨平台运行的特性，内部提供两套基础 history，一套是直接使用浏览器的 History API，用于支持 react-router-dom；另一套是基于内存实现的版本，这是自己做的一个数组，用于支持 react-router-native\n- react-router 是没有 UI 层的，react-router-dom = react-router + Dom UI，而 react-router-native = react-router + native UI\n\n#### react-router关键模块\n\n1. Context 容器，分别是 Router 与 MemoryRouter，主要提供上下文消费容器；\n2. 直接消费者，提供路由匹配功能，分别是 Route、Redirect、Switch；\n3. 与平台关联的功能组件，分别是 react-router-dom 中的 Link、NavLink 以及 react-router-native 中的 DeepLinking\n\n\n\n\n\n\n\n\n\n","slug":"[react]react-router实现原理","published":1,"updated":"2021-03-15T14:40:36.018Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dl00031wotj14xb7ueu","content":"<h4 id=\"前端路由解决方案\"><a href=\"#前端路由解决方案\" class=\"headerlink\" title=\"前端路由解决方案\"></a>前端路由解决方案</h4><ul>\n<li>解决思路：1、拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容 2、感知 URL 的变化</li>\n</ul>\n<h5 id=\"hash模式\"><a href=\"#hash模式\" class=\"headerlink\" title=\"hash模式\"></a>hash模式</h5><ul>\n<li>hash 的改变</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hash 的改变：我们可以通过 location 暴露出来的属性，直接去修改当前 URL 的 hash 值</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.location.hash = <span class=\"string\">&#x27;home&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>hash变化监听：通过监听 “hashchange”事件，可以用 JS 来捕捉 hash 值的变化，进而决定我们页面内容是否需要更新</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听hash变化，点击浏览器的前进后退会触发</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;hashchange&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 根据 hash 的变化更新内容</span></span><br><span class=\"line\">&#125;,<span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h5><ul>\n<li>history api</li>\n<li>通过html5 新特性：pushState、replaceState实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.history.forward()  <span class=\"comment\">// 前进到下一页</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.history.back() <span class=\"comment\">// 后退到上一页</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.history.go(<span class=\"number\">2</span>) <span class=\"comment\">// 前进两页</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.history.go(-<span class=\"number\">2</span>) <span class=\"comment\">// 后退两页</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// html5新特性</span></span><br><span class=\"line\">history.pushState(data[,title][,url]); <span class=\"comment\">// 向浏览历史中追加一条记录</span></span><br><span class=\"line\">history.replaceState(data[,title][,url]); <span class=\"comment\">// 修改（替换）当前页在浏览历史中的信息</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>监听变化</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&#39;popstate&#39;, function(e) &#123;</span><br><span class=\"line\">  console.log(e)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>history模式需要在服务端完成 historyApiFallback 配置</li>\n</ul>\n<h4 id=\"react-router设计模式\"><a href=\"#react-router设计模式\" class=\"headerlink\" title=\"react-router设计模式\"></a>react-router设计模式</h4><h5 id=\"Monorepo设计\"><a href=\"#Monorepo设计\" class=\"headerlink\" title=\"Monorepo设计\"></a>Monorepo设计</h5><ul>\n<li>与 Monorepo 相对的概念是Multirepo。Multirepo 就是我们常用的开发模式，一个仓库对应一个工程，子团队自行维护</li>\n<li>React Router 使用了 Monorepo 的工程架构，使工程代码对团队中的每一个人都具备透明度</li>\n<li>通常会使用 Lerna 作为开发管理 Monorepo 的开发工具，它的主要用户包括 Babel、React、umi、React Router 等</li>\n</ul>\n<h5 id=\"Context数据共享\"><a href=\"#Context数据共享\" class=\"headerlink\" title=\"Context数据共享\"></a>Context数据共享</h5><ul>\n<li>使用 Context API 完成数据共享</li>\n</ul>\n<h4 id=\"react-router相关库\"><a href=\"#react-router相关库\" class=\"headerlink\" title=\"react-router相关库\"></a>react-router相关库</h4><ul>\n<li>在 React Router 内部主要依靠 history 库完成，这是由 React Router 自己封装的库，为了实现跨平台运行的特性，内部提供两套基础 history，一套是直接使用浏览器的 History API，用于支持 react-router-dom；另一套是基于内存实现的版本，这是自己做的一个数组，用于支持 react-router-native</li>\n<li>react-router 是没有 UI 层的，react-router-dom = react-router + Dom UI，而 react-router-native = react-router + native UI</li>\n</ul>\n<h4 id=\"react-router关键模块\"><a href=\"#react-router关键模块\" class=\"headerlink\" title=\"react-router关键模块\"></a>react-router关键模块</h4><ol>\n<li>Context 容器，分别是 Router 与 MemoryRouter，主要提供上下文消费容器；</li>\n<li>直接消费者，提供路由匹配功能，分别是 Route、Redirect、Switch；</li>\n<li>与平台关联的功能组件，分别是 react-router-dom 中的 Link、NavLink 以及 react-router-native 中的 DeepLinking</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"前端路由解决方案\"><a href=\"#前端路由解决方案\" class=\"headerlink\" title=\"前端路由解决方案\"></a>前端路由解决方案</h4><ul>\n<li>解决思路：1、拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容 2、感知 URL 的变化</li>\n</ul>\n<h5 id=\"hash模式\"><a href=\"#hash模式\" class=\"headerlink\" title=\"hash模式\"></a>hash模式</h5><ul>\n<li>hash 的改变</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// hash 的改变：我们可以通过 location 暴露出来的属性，直接去修改当前 URL 的 hash 值</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.location.hash = <span class=\"string\">&#x27;home&#x27;</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>hash变化监听：通过监听 “hashchange”事件，可以用 JS 来捕捉 hash 值的变化，进而决定我们页面内容是否需要更新</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 监听hash变化，点击浏览器的前进后退会触发</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.addEventListener(<span class=\"string\">&#x27;hashchange&#x27;</span>, <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">event</span>)</span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">// 根据 hash 的变化更新内容</span></span><br><span class=\"line\">&#125;,<span class=\"literal\">false</span>)</span><br></pre></td></tr></table></figure>\n\n<h5 id=\"history\"><a href=\"#history\" class=\"headerlink\" title=\"history\"></a>history</h5><ul>\n<li>history api</li>\n<li>通过html5 新特性：pushState、replaceState实现</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">window</span>.history.forward()  <span class=\"comment\">// 前进到下一页</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.history.back() <span class=\"comment\">// 后退到上一页</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.history.go(<span class=\"number\">2</span>) <span class=\"comment\">// 前进两页</span></span><br><span class=\"line\"><span class=\"built_in\">window</span>.history.go(-<span class=\"number\">2</span>) <span class=\"comment\">// 后退两页</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// html5新特性</span></span><br><span class=\"line\">history.pushState(data[,title][,url]); <span class=\"comment\">// 向浏览历史中追加一条记录</span></span><br><span class=\"line\">history.replaceState(data[,title][,url]); <span class=\"comment\">// 修改（替换）当前页在浏览历史中的信息</span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>监听变化</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">window.addEventListener(&#39;popstate&#39;, function(e) &#123;</span><br><span class=\"line\">  console.log(e)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>history模式需要在服务端完成 historyApiFallback 配置</li>\n</ul>\n<h4 id=\"react-router设计模式\"><a href=\"#react-router设计模式\" class=\"headerlink\" title=\"react-router设计模式\"></a>react-router设计模式</h4><h5 id=\"Monorepo设计\"><a href=\"#Monorepo设计\" class=\"headerlink\" title=\"Monorepo设计\"></a>Monorepo设计</h5><ul>\n<li>与 Monorepo 相对的概念是Multirepo。Multirepo 就是我们常用的开发模式，一个仓库对应一个工程，子团队自行维护</li>\n<li>React Router 使用了 Monorepo 的工程架构，使工程代码对团队中的每一个人都具备透明度</li>\n<li>通常会使用 Lerna 作为开发管理 Monorepo 的开发工具，它的主要用户包括 Babel、React、umi、React Router 等</li>\n</ul>\n<h5 id=\"Context数据共享\"><a href=\"#Context数据共享\" class=\"headerlink\" title=\"Context数据共享\"></a>Context数据共享</h5><ul>\n<li>使用 Context API 完成数据共享</li>\n</ul>\n<h4 id=\"react-router相关库\"><a href=\"#react-router相关库\" class=\"headerlink\" title=\"react-router相关库\"></a>react-router相关库</h4><ul>\n<li>在 React Router 内部主要依靠 history 库完成，这是由 React Router 自己封装的库，为了实现跨平台运行的特性，内部提供两套基础 history，一套是直接使用浏览器的 History API，用于支持 react-router-dom；另一套是基于内存实现的版本，这是自己做的一个数组，用于支持 react-router-native</li>\n<li>react-router 是没有 UI 层的，react-router-dom = react-router + Dom UI，而 react-router-native = react-router + native UI</li>\n</ul>\n<h4 id=\"react-router关键模块\"><a href=\"#react-router关键模块\" class=\"headerlink\" title=\"react-router关键模块\"></a>react-router关键模块</h4><ol>\n<li>Context 容器，分别是 Router 与 MemoryRouter，主要提供上下文消费容器；</li>\n<li>直接消费者，提供路由匹配功能，分别是 Route、Redirect、Switch；</li>\n<li>与平台关联的功能组件，分别是 react-router-dom 中的 Link、NavLink 以及 react-router-native 中的 DeepLinking</li>\n</ol>\n"},{"title":"<react>react相关知识","date":"2020-09-11T16:00:00.000Z","_content":"\n#### 主要内容\n\n- 组件基础、状态管理、渲染流程、性能优化、Hooks、react生态\n\n### react是什么\n\n- 概念、用途、思路、优缺点\n\n1. react是网页UI框架，是组件化框架\n2. 通过组件化方式解决视图层开发的问题，提升开发效率\n3. 设计思路：声明式、组件化、通用性\n   声明式：使用jsx描述虚拟dom，更加直观\n   组件化：使用函数组件或者类组件，使试图模块可以复用\n   通用性：虚拟dom使react适用范围宾大，web、native都可以进行开发\n4. 缺点：react只是视图层框架、没有提工完整的工程化开发方案，需要借助社区方案，在技术选型和学习上有一定成本\n\n### react为什么使用jsx\n\n- jsx介绍、核心概念、对比方案\n\n1. jsx是javascript的扩展语法，语法类似xml，react团队不想引入js外的开发体系，希望通过合理的关注点分离保持组件开发的纯粹性。\n2. jsx用于声明react元素，在构建时，会被babel编译为React.createElement，jsx更像是React.createElement的语法糖\n3. 对比模板：模板会引入模板语法、模板指令等概念，增加学习成本\n   对比模板字符串：模板字符串结构会多次内嵌，结构复杂，优化困难\n\t对比json：代码提示困难\n\n### 类组件生命周期\n\n#### react15生命周期\n\n- 挂载阶段\n\nconstructor -> componentWillMount -> render -> componentDidMount\n\n- 更新阶段\n\n只修改state：shouldComponentUpdate -> componentWillUpdate -> render -> componentDidUpdate\n修改props内容：componentWillReceiveProps -> shouldComponentUpdate -> componentWillUpdate -> render -> componentDidUpdate\n\n- 卸载阶段\n\ncomponentWillUnmount\n\n#### react16生命周期\n\n- 挂载阶段\n\ngetDerivedStateFromProps -> render -> componentDidMount\n\n- 更新阶段\n\ngetDerivedStateFromProps -> shouldComponentUpdate -> render -> getSnapshotBeforeUpdate -> componentDidUpdate\n\n- 卸载阶段\n\ncomponentWillUnmount\n\n\n### 函数式组件与类组件区别\n\n- 共同点、不同点\n\n1. 函数式组件与类组件最终呈现效果一致\n2. 两者设计模式不同，类组件是面向对象编程，主打继承、生命周期概念。函数式组件是函数式编程，主打immutable、无副作用、引用透明等特点\n3. 由于推出Hooks，函数式组件可以替代类组件\n4. 性能优化方面，类组件使用shouldComponentUpdate阻断渲染提升性能，函数式组件依靠React.memo缓存渲染结果提升性能\n5. 类组件容易上手，函数式组件Hooks思想不容易理解，但函数组件是社区主推方案\n6. 类组件在未来时间切片与并发模式中，由于生命周期复杂性，不容易优化，函数组件轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展\n\n### react组件设计\n\n- 展示组件：专注展示组件本身特性\n1. 代理组件，封装常用属性，减少重复代码，例如：封装antd按钮组件\n2. 样式组件，封装常用样式\n3. 布局组件\n- 灵巧组件，专注组合组件\n1. 容器组件，例如：ListWrap接受list数据，展示ListItem元素\n2. 高阶组件，抽取公共逻辑，链式调用，渲染劫持\n\n- 高阶组件存在的问题以及处理方法\n1. 丢失静态函数：通过 hoist-non-react-statics 来处理\n2. refs属性不能穿透：使用 React.forwardRef 处理\n\n```javascript\n// 抽取公共逻辑\nfunction isLogin(WrappedComponent){\n  const isLogin = true\n  return (props)=>(\n    <Fragment>\n      <p>高阶组件检测是否登录</p>\n      {isLogin ? <WrappedComponent {...props} /> : (<span>未登录</span>)}\n    </Fragment>\n  )\n}\n\n// 埋点统计\nfunction pageLog(pagename){\n  return (WrappedComponent)=>{\n    return class Wrapper extends React.Component{\n      componentDidMount(){\n        console.log(pagename)\n      }\n      render (){\n        return <WrappedComponent {...this.props} />\n      }\n    }\n  }\n}\n\n// 高阶组件，链式调用\n@pageLog('个人中心')\n@isLogin\nclass UserInfo extends React.Component{\n  render (){\n    return (<span>已登录，个人中心</span>)\n  }\n}\n\n// 高阶组件，渲染劫持\nfunction withLoading(WrappedComponent) {\n  return class extends WrappedComponent {\n    render() {\n      if (this.props.isLoading) {\n        return <div>loading</div>;\n      }\n      return super.render();\n    }\n  };\n}\n@withLoading\nclass CardWrap extends React.Component {\n  render (){\n    return (<div>card</div>)\n  }\n}\n```\n\n### setState是同步还是异步\n\n- react合成事件：挂载在document（17之后挂载在渲染节点），dom事件出发后冒泡到document，react找到对应组件，创造合成事件\n- react中通过isBatchingUpdates 来判断setState是否异步，当值为true时异步，当值为false时直接更新\n- 异步场景：react可以控制的地方，如生命周期、合成事件中\n- 同步场景：react无法控制的地方，如ddEventListener 、setTimeout、setInterval 等事件中，就只能同步更新\n- 异步设计为了性能优化、减少渲染次数、保持内部一致性（如果setSatte是同步的，但是props更新还是异步的）、启用并发完成异步渲染\n\n```\nclass Test extends React.Component {\n  state  = {\n      count: 0\n  };\n\n    componentDidMount() {\n\t// 异步\n    this.setState({count: this.state.count + 1});\n    console.log(this.state.count);\n\n    this.setState({count: this.state.count + 1});\n    console.log(this.state.count);\n\t// 同步 \n    setTimeout(() => {\n      this.setState({count: this.state.count + 1});\n      console.log(this.state.count);\n\n      this.setState({count: this.state.count + 1});\n      console.log(this.state.count);\n    }, 0);\n  }\n \n  render() {\n    return null;\n  }\n};\n```\n\n### react组件间通信\n\n- 父->子：props\n- 子->夫：回调函数、实例函数(React.createRef)\n- 兄弟组件：父组件中转\n- 多层：Context，全局变量与事件、状态管理框架（flux、redux、Mobx）\n\n### react状态管理框架\n\n### Vitural Dom 原理\n\n- 概念、用途、思路、优缺点\n\n1. 原理：虚拟DOM原理是通过js对象模拟DOM节点，为了要提升代码抽象能力、避免人为DOM操作、降低代码整体风险等因素，react引入了虚拟DOM\n2. 实现：react在render函数中写的JSX会在babel编译下，转换为React.createElement执行JSX中的参数\n3. 过程：React.createElement执行后，会返回一个描述自己当前tag类型、props等属性以及children等情况的对象，通过树结构形成一颗虚拟DOM树，当状态发生变化时，对比更新前后虚拟DOM的差异，整个过程成为diff，生成的结果为patch，计算后，渲染patch完成真实dom更新\n4. 优点：改善大规模DOM操作的性能、避免XSS风险、以较低成本实现跨平台开发\n5. 缺点：内存占用高、高性能场景存在难以优化情况（如Google Earth等高性能应用）\n\n### react diff算法\n\n### react 渲染流程\n\n### react 渲染异常\n\n### react 性能优化\n\n### 避免重复渲染\n\n#### 重复渲染分析\n- 步骤：选择优化时机、定位重复渲染的问题、引入解决方案\n- 优化时机：需要确认当前性能问题与业务的关系，是否有必要优化\n- 定位问题：还原用户使用环境的方式进行复现，然后使用 Performance 与 React Profiler 工具进行分析，对照卡顿点与组件重复渲染次数及耗时排查性能问题\n\n#### 解决方案\n- 组件使用 React.memo、pureComponent、shouldComponentUpdate 缓存 API，减少重新渲染\n- 注意问题：\n1. 箭头函数props会触发更新，需要改为传递类方法\n\n```javascript\n<ListItem\n key={id}\n id={id}\n text={text}\n onMoveUp={(id) => { //... }} // 会触发更新\n onMoveDown={this.handleMoveDown} // 不会触发更新\n/>\n```\n\n2. props参数是对象时会触发更新，可以使用reselect库解决，增加缓存\n\n```javascript\nrender() {\n const data = this.props.list.map((item) => { /*... */ })\n return (\n    <FlatList\n      data={data}\n      renderItem={this.renderItem}\n    />\n )\n}\n\n// 解决方法\nimport { createSelector } fr om 'reselect'\nconst listSelector = props => props.list || []\nconst dataSelector = createSelector(\n  listSelector,\n  list => list.map((item) => { /*... */ })\n)\nrender() {\n return (\n    <FlatList\n      data={dataSelector(this.props)}\n      renderItem={this.renderItem}\n    />\n )\n}\n```\n\n3. 使用不可变数据处理：ImmutableJS、immerjs\n\n### 提升 react 代码可维护性\n\n1. 可分析性：从预防与兜底两个维度展开工作，预防依靠Lint工具与团队内部Code Review，兜底主要是在流水线中加入 sourcemap，能够通过线上报错快速定位源码\n2. 可改变性：使代码易于拓展，业务易于迭代，工作主要从设计模式与架构设计展开，设计模式指通过组件设计，使容器组件与展示组件划分边界，隔绝业务逻辑，整体架构设计，采用了 rematch 方案，rematch 中可以设计的 model 概念可以很好地收敛 action、reducer 及副作用，同时支持动态引入 model，保障业务横向拓展的能力\n3. 稳定性：通过提升核心业务代码的测试覆盖率来完成，\n4. 易测试性：采用 Rematch 的架构完成模块分离，整体业务逻辑挪到了 model 中，且 model 自身是一个 Pure Object，附加了多个纯函数。纯函数只要管理好输入与输出，在测试上就很容易\n5. 可维护性的依从性：建立团队规范，遵循代码约定，提升代码可读性。这方面的工作就是引入工具，减少人为犯错的概率，使用ESLint、stylelint、commitlint、配置编辑器的 editorconfig，配置样式的 prettier\n\n### react hooks 限制\n\n- 限制：\n1. 不能在循环，条件判断，嵌套函数中使用Hook\n2. 在 react 函数式组件中使用Hook\n- 存在限制的原因\n1. react旧开发模式存在的问题：（1）组件间难以复用状态逻辑（需要使用高阶组件、props、状态管框架），复杂组件难以理解（生命周期与业务耦合太深，关键功能难以拆分），人和机器容易混淆类（this问题，类难以优化）\n2. Hook是基于链表实现的，在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致取值错位，执行错误的 Hook\n3. 可以引入Eslint的Hook检查插件预防错误\n\n### useEffect 与 useLayoutEffect\n\n- 相同点：底层签名函数一直，都是调用的 mountEffectImpl，在使用上也没什么差异，基本可以直接替换，也都是用于处理副作用\n- 不同点：useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景，而 LayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 LayoutEffect 做计算量较大的耗时任务从而造成阻塞\n- 趋势：在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可\n\n### react hooks设计模式\n\n1. react hooks开发要抛弃生命周期的思考模式，以effects的角度思考，类组件的开发模式中，在componentDidMount 中放置一个监听事件，还需要考虑在 componentWillUnmount 中取消监听，甚至可能由于部分值变化，还需要在其他生命周期函数中对监听事件做特殊处理，可以将这一系列监听与取消监听放置在一个 useEffect 中，useEffect 可以不关心组件的生命周期，只需要关心外部依赖的变化即可，对于开发心智而言是极大的减负。这是 Hooks 的设计根本\n2. React.useMemo 取代 React.memo，因为 React.memo 并不能控制组件内部共享状态的变化，而 React.useMemo 更适合于 Hooks 的场景\n3. 常量处理，类组件中，经常将常量定义在类中，在组件函数中，由于每次渲染都会重新声明常量，组件内的函数每次会被重新创建，如果这个函数需要使用函数组件内部的变量，那么可以用 useCallback 包裹下这个函数\n4. useEffect第二个参数容易错误使用，使用值类型而不是引用类型，引用类型容易被篡改\n5. 将业务逻辑封装到各自的自定义 Hook 中，组件内部是抽空不放置业务逻辑，只是调用单个hooks暴漏的接口\n\n### react router原理\n\n- 实现原理\n1. HASH方式：依靠浏览器Hash变换\n2. 切换地址中的path：需要使用 HTML5 的 history API 中的 pushState、replaceState，使用时还需要服务端完成 historyApiFallback 配置\n- react router实现：内部靠自己封装的history库实现，提供两套基础history，一套直接使用浏览器history api，用于支持react-dom。另一套基于内存实现，自己做一个存储数组，用于支持react-router-native\n- 工作方式：\n1. 设计模式：在架构上通过Monorepo进行项目管理，具有团队间透明、迭代便利有点，整体的数据通信，通过react Content Api实现\n2. 关键模块：主要分为三类组件，（1）Context容器，比如 Router 与 MemoryRouter。（2）消费者组件，用于匹配路由，有Route、Redirect、Switch 等。（3）平台相关功能组件，如 Link、NavLink、DeepLinking 等","source":"_posts/[react]react相关知识.md","raw":"---\ntitle: <react>react相关知识\ndate: 2020-09-12 00:00:00\ntags: [js,react]\ncategories: react\n---\n\n#### 主要内容\n\n- 组件基础、状态管理、渲染流程、性能优化、Hooks、react生态\n\n### react是什么\n\n- 概念、用途、思路、优缺点\n\n1. react是网页UI框架，是组件化框架\n2. 通过组件化方式解决视图层开发的问题，提升开发效率\n3. 设计思路：声明式、组件化、通用性\n   声明式：使用jsx描述虚拟dom，更加直观\n   组件化：使用函数组件或者类组件，使试图模块可以复用\n   通用性：虚拟dom使react适用范围宾大，web、native都可以进行开发\n4. 缺点：react只是视图层框架、没有提工完整的工程化开发方案，需要借助社区方案，在技术选型和学习上有一定成本\n\n### react为什么使用jsx\n\n- jsx介绍、核心概念、对比方案\n\n1. jsx是javascript的扩展语法，语法类似xml，react团队不想引入js外的开发体系，希望通过合理的关注点分离保持组件开发的纯粹性。\n2. jsx用于声明react元素，在构建时，会被babel编译为React.createElement，jsx更像是React.createElement的语法糖\n3. 对比模板：模板会引入模板语法、模板指令等概念，增加学习成本\n   对比模板字符串：模板字符串结构会多次内嵌，结构复杂，优化困难\n\t对比json：代码提示困难\n\n### 类组件生命周期\n\n#### react15生命周期\n\n- 挂载阶段\n\nconstructor -> componentWillMount -> render -> componentDidMount\n\n- 更新阶段\n\n只修改state：shouldComponentUpdate -> componentWillUpdate -> render -> componentDidUpdate\n修改props内容：componentWillReceiveProps -> shouldComponentUpdate -> componentWillUpdate -> render -> componentDidUpdate\n\n- 卸载阶段\n\ncomponentWillUnmount\n\n#### react16生命周期\n\n- 挂载阶段\n\ngetDerivedStateFromProps -> render -> componentDidMount\n\n- 更新阶段\n\ngetDerivedStateFromProps -> shouldComponentUpdate -> render -> getSnapshotBeforeUpdate -> componentDidUpdate\n\n- 卸载阶段\n\ncomponentWillUnmount\n\n\n### 函数式组件与类组件区别\n\n- 共同点、不同点\n\n1. 函数式组件与类组件最终呈现效果一致\n2. 两者设计模式不同，类组件是面向对象编程，主打继承、生命周期概念。函数式组件是函数式编程，主打immutable、无副作用、引用透明等特点\n3. 由于推出Hooks，函数式组件可以替代类组件\n4. 性能优化方面，类组件使用shouldComponentUpdate阻断渲染提升性能，函数式组件依靠React.memo缓存渲染结果提升性能\n5. 类组件容易上手，函数式组件Hooks思想不容易理解，但函数组件是社区主推方案\n6. 类组件在未来时间切片与并发模式中，由于生命周期复杂性，不容易优化，函数组件轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展\n\n### react组件设计\n\n- 展示组件：专注展示组件本身特性\n1. 代理组件，封装常用属性，减少重复代码，例如：封装antd按钮组件\n2. 样式组件，封装常用样式\n3. 布局组件\n- 灵巧组件，专注组合组件\n1. 容器组件，例如：ListWrap接受list数据，展示ListItem元素\n2. 高阶组件，抽取公共逻辑，链式调用，渲染劫持\n\n- 高阶组件存在的问题以及处理方法\n1. 丢失静态函数：通过 hoist-non-react-statics 来处理\n2. refs属性不能穿透：使用 React.forwardRef 处理\n\n```javascript\n// 抽取公共逻辑\nfunction isLogin(WrappedComponent){\n  const isLogin = true\n  return (props)=>(\n    <Fragment>\n      <p>高阶组件检测是否登录</p>\n      {isLogin ? <WrappedComponent {...props} /> : (<span>未登录</span>)}\n    </Fragment>\n  )\n}\n\n// 埋点统计\nfunction pageLog(pagename){\n  return (WrappedComponent)=>{\n    return class Wrapper extends React.Component{\n      componentDidMount(){\n        console.log(pagename)\n      }\n      render (){\n        return <WrappedComponent {...this.props} />\n      }\n    }\n  }\n}\n\n// 高阶组件，链式调用\n@pageLog('个人中心')\n@isLogin\nclass UserInfo extends React.Component{\n  render (){\n    return (<span>已登录，个人中心</span>)\n  }\n}\n\n// 高阶组件，渲染劫持\nfunction withLoading(WrappedComponent) {\n  return class extends WrappedComponent {\n    render() {\n      if (this.props.isLoading) {\n        return <div>loading</div>;\n      }\n      return super.render();\n    }\n  };\n}\n@withLoading\nclass CardWrap extends React.Component {\n  render (){\n    return (<div>card</div>)\n  }\n}\n```\n\n### setState是同步还是异步\n\n- react合成事件：挂载在document（17之后挂载在渲染节点），dom事件出发后冒泡到document，react找到对应组件，创造合成事件\n- react中通过isBatchingUpdates 来判断setState是否异步，当值为true时异步，当值为false时直接更新\n- 异步场景：react可以控制的地方，如生命周期、合成事件中\n- 同步场景：react无法控制的地方，如ddEventListener 、setTimeout、setInterval 等事件中，就只能同步更新\n- 异步设计为了性能优化、减少渲染次数、保持内部一致性（如果setSatte是同步的，但是props更新还是异步的）、启用并发完成异步渲染\n\n```\nclass Test extends React.Component {\n  state  = {\n      count: 0\n  };\n\n    componentDidMount() {\n\t// 异步\n    this.setState({count: this.state.count + 1});\n    console.log(this.state.count);\n\n    this.setState({count: this.state.count + 1});\n    console.log(this.state.count);\n\t// 同步 \n    setTimeout(() => {\n      this.setState({count: this.state.count + 1});\n      console.log(this.state.count);\n\n      this.setState({count: this.state.count + 1});\n      console.log(this.state.count);\n    }, 0);\n  }\n \n  render() {\n    return null;\n  }\n};\n```\n\n### react组件间通信\n\n- 父->子：props\n- 子->夫：回调函数、实例函数(React.createRef)\n- 兄弟组件：父组件中转\n- 多层：Context，全局变量与事件、状态管理框架（flux、redux、Mobx）\n\n### react状态管理框架\n\n### Vitural Dom 原理\n\n- 概念、用途、思路、优缺点\n\n1. 原理：虚拟DOM原理是通过js对象模拟DOM节点，为了要提升代码抽象能力、避免人为DOM操作、降低代码整体风险等因素，react引入了虚拟DOM\n2. 实现：react在render函数中写的JSX会在babel编译下，转换为React.createElement执行JSX中的参数\n3. 过程：React.createElement执行后，会返回一个描述自己当前tag类型、props等属性以及children等情况的对象，通过树结构形成一颗虚拟DOM树，当状态发生变化时，对比更新前后虚拟DOM的差异，整个过程成为diff，生成的结果为patch，计算后，渲染patch完成真实dom更新\n4. 优点：改善大规模DOM操作的性能、避免XSS风险、以较低成本实现跨平台开发\n5. 缺点：内存占用高、高性能场景存在难以优化情况（如Google Earth等高性能应用）\n\n### react diff算法\n\n### react 渲染流程\n\n### react 渲染异常\n\n### react 性能优化\n\n### 避免重复渲染\n\n#### 重复渲染分析\n- 步骤：选择优化时机、定位重复渲染的问题、引入解决方案\n- 优化时机：需要确认当前性能问题与业务的关系，是否有必要优化\n- 定位问题：还原用户使用环境的方式进行复现，然后使用 Performance 与 React Profiler 工具进行分析，对照卡顿点与组件重复渲染次数及耗时排查性能问题\n\n#### 解决方案\n- 组件使用 React.memo、pureComponent、shouldComponentUpdate 缓存 API，减少重新渲染\n- 注意问题：\n1. 箭头函数props会触发更新，需要改为传递类方法\n\n```javascript\n<ListItem\n key={id}\n id={id}\n text={text}\n onMoveUp={(id) => { //... }} // 会触发更新\n onMoveDown={this.handleMoveDown} // 不会触发更新\n/>\n```\n\n2. props参数是对象时会触发更新，可以使用reselect库解决，增加缓存\n\n```javascript\nrender() {\n const data = this.props.list.map((item) => { /*... */ })\n return (\n    <FlatList\n      data={data}\n      renderItem={this.renderItem}\n    />\n )\n}\n\n// 解决方法\nimport { createSelector } fr om 'reselect'\nconst listSelector = props => props.list || []\nconst dataSelector = createSelector(\n  listSelector,\n  list => list.map((item) => { /*... */ })\n)\nrender() {\n return (\n    <FlatList\n      data={dataSelector(this.props)}\n      renderItem={this.renderItem}\n    />\n )\n}\n```\n\n3. 使用不可变数据处理：ImmutableJS、immerjs\n\n### 提升 react 代码可维护性\n\n1. 可分析性：从预防与兜底两个维度展开工作，预防依靠Lint工具与团队内部Code Review，兜底主要是在流水线中加入 sourcemap，能够通过线上报错快速定位源码\n2. 可改变性：使代码易于拓展，业务易于迭代，工作主要从设计模式与架构设计展开，设计模式指通过组件设计，使容器组件与展示组件划分边界，隔绝业务逻辑，整体架构设计，采用了 rematch 方案，rematch 中可以设计的 model 概念可以很好地收敛 action、reducer 及副作用，同时支持动态引入 model，保障业务横向拓展的能力\n3. 稳定性：通过提升核心业务代码的测试覆盖率来完成，\n4. 易测试性：采用 Rematch 的架构完成模块分离，整体业务逻辑挪到了 model 中，且 model 自身是一个 Pure Object，附加了多个纯函数。纯函数只要管理好输入与输出，在测试上就很容易\n5. 可维护性的依从性：建立团队规范，遵循代码约定，提升代码可读性。这方面的工作就是引入工具，减少人为犯错的概率，使用ESLint、stylelint、commitlint、配置编辑器的 editorconfig，配置样式的 prettier\n\n### react hooks 限制\n\n- 限制：\n1. 不能在循环，条件判断，嵌套函数中使用Hook\n2. 在 react 函数式组件中使用Hook\n- 存在限制的原因\n1. react旧开发模式存在的问题：（1）组件间难以复用状态逻辑（需要使用高阶组件、props、状态管框架），复杂组件难以理解（生命周期与业务耦合太深，关键功能难以拆分），人和机器容易混淆类（this问题，类难以优化）\n2. Hook是基于链表实现的，在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致取值错位，执行错误的 Hook\n3. 可以引入Eslint的Hook检查插件预防错误\n\n### useEffect 与 useLayoutEffect\n\n- 相同点：底层签名函数一直，都是调用的 mountEffectImpl，在使用上也没什么差异，基本可以直接替换，也都是用于处理副作用\n- 不同点：useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景，而 LayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 LayoutEffect 做计算量较大的耗时任务从而造成阻塞\n- 趋势：在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可\n\n### react hooks设计模式\n\n1. react hooks开发要抛弃生命周期的思考模式，以effects的角度思考，类组件的开发模式中，在componentDidMount 中放置一个监听事件，还需要考虑在 componentWillUnmount 中取消监听，甚至可能由于部分值变化，还需要在其他生命周期函数中对监听事件做特殊处理，可以将这一系列监听与取消监听放置在一个 useEffect 中，useEffect 可以不关心组件的生命周期，只需要关心外部依赖的变化即可，对于开发心智而言是极大的减负。这是 Hooks 的设计根本\n2. React.useMemo 取代 React.memo，因为 React.memo 并不能控制组件内部共享状态的变化，而 React.useMemo 更适合于 Hooks 的场景\n3. 常量处理，类组件中，经常将常量定义在类中，在组件函数中，由于每次渲染都会重新声明常量，组件内的函数每次会被重新创建，如果这个函数需要使用函数组件内部的变量，那么可以用 useCallback 包裹下这个函数\n4. useEffect第二个参数容易错误使用，使用值类型而不是引用类型，引用类型容易被篡改\n5. 将业务逻辑封装到各自的自定义 Hook 中，组件内部是抽空不放置业务逻辑，只是调用单个hooks暴漏的接口\n\n### react router原理\n\n- 实现原理\n1. HASH方式：依靠浏览器Hash变换\n2. 切换地址中的path：需要使用 HTML5 的 history API 中的 pushState、replaceState，使用时还需要服务端完成 historyApiFallback 配置\n- react router实现：内部靠自己封装的history库实现，提供两套基础history，一套直接使用浏览器history api，用于支持react-dom。另一套基于内存实现，自己做一个存储数组，用于支持react-router-native\n- 工作方式：\n1. 设计模式：在架构上通过Monorepo进行项目管理，具有团队间透明、迭代便利有点，整体的数据通信，通过react Content Api实现\n2. 关键模块：主要分为三类组件，（1）Context容器，比如 Router 与 MemoryRouter。（2）消费者组件，用于匹配路由，有Route、Redirect、Switch 等。（3）平台相关功能组件，如 Link、NavLink、DeepLinking 等","slug":"[react]react相关知识","published":1,"updated":"2021-03-15T14:40:41.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dl10034wotjhphm7963","content":"<h4 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h4><ul>\n<li>组件基础、状态管理、渲染流程、性能优化、Hooks、react生态</li>\n</ul>\n<h3 id=\"react是什么\"><a href=\"#react是什么\" class=\"headerlink\" title=\"react是什么\"></a>react是什么</h3><ul>\n<li>概念、用途、思路、优缺点</li>\n</ul>\n<ol>\n<li>react是网页UI框架，是组件化框架</li>\n<li>通过组件化方式解决视图层开发的问题，提升开发效率</li>\n<li>设计思路：声明式、组件化、通用性<br>声明式：使用jsx描述虚拟dom，更加直观<br>组件化：使用函数组件或者类组件，使试图模块可以复用<br>通用性：虚拟dom使react适用范围宾大，web、native都可以进行开发</li>\n<li>缺点：react只是视图层框架、没有提工完整的工程化开发方案，需要借助社区方案，在技术选型和学习上有一定成本</li>\n</ol>\n<h3 id=\"react为什么使用jsx\"><a href=\"#react为什么使用jsx\" class=\"headerlink\" title=\"react为什么使用jsx\"></a>react为什么使用jsx</h3><ul>\n<li>jsx介绍、核心概念、对比方案</li>\n</ul>\n<ol>\n<li>jsx是javascript的扩展语法，语法类似xml，react团队不想引入js外的开发体系，希望通过合理的关注点分离保持组件开发的纯粹性。</li>\n<li>jsx用于声明react元素，在构建时，会被babel编译为React.createElement，jsx更像是React.createElement的语法糖</li>\n<li>对比模板：模板会引入模板语法、模板指令等概念，增加学习成本<br>对比模板字符串：模板字符串结构会多次内嵌，结构复杂，优化困难<br> 对比json：代码提示困难</li>\n</ol>\n<h3 id=\"类组件生命周期\"><a href=\"#类组件生命周期\" class=\"headerlink\" title=\"类组件生命周期\"></a>类组件生命周期</h3><h4 id=\"react15生命周期\"><a href=\"#react15生命周期\" class=\"headerlink\" title=\"react15生命周期\"></a>react15生命周期</h4><ul>\n<li>挂载阶段</li>\n</ul>\n<p>constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount</p>\n<ul>\n<li>更新阶段</li>\n</ul>\n<p>只修改state：shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate<br>修改props内容：componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</p>\n<ul>\n<li>卸载阶段</li>\n</ul>\n<p>componentWillUnmount</p>\n<h4 id=\"react16生命周期\"><a href=\"#react16生命周期\" class=\"headerlink\" title=\"react16生命周期\"></a>react16生命周期</h4><ul>\n<li>挂载阶段</li>\n</ul>\n<p>getDerivedStateFromProps -&gt; render -&gt; componentDidMount</p>\n<ul>\n<li>更新阶段</li>\n</ul>\n<p>getDerivedStateFromProps -&gt; shouldComponentUpdate -&gt; render -&gt; getSnapshotBeforeUpdate -&gt; componentDidUpdate</p>\n<ul>\n<li>卸载阶段</li>\n</ul>\n<p>componentWillUnmount</p>\n<h3 id=\"函数式组件与类组件区别\"><a href=\"#函数式组件与类组件区别\" class=\"headerlink\" title=\"函数式组件与类组件区别\"></a>函数式组件与类组件区别</h3><ul>\n<li>共同点、不同点</li>\n</ul>\n<ol>\n<li>函数式组件与类组件最终呈现效果一致</li>\n<li>两者设计模式不同，类组件是面向对象编程，主打继承、生命周期概念。函数式组件是函数式编程，主打immutable、无副作用、引用透明等特点</li>\n<li>由于推出Hooks，函数式组件可以替代类组件</li>\n<li>性能优化方面，类组件使用shouldComponentUpdate阻断渲染提升性能，函数式组件依靠React.memo缓存渲染结果提升性能</li>\n<li>类组件容易上手，函数式组件Hooks思想不容易理解，但函数组件是社区主推方案</li>\n<li>类组件在未来时间切片与并发模式中，由于生命周期复杂性，不容易优化，函数组件轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展</li>\n</ol>\n<h3 id=\"react组件设计\"><a href=\"#react组件设计\" class=\"headerlink\" title=\"react组件设计\"></a>react组件设计</h3><ul>\n<li>展示组件：专注展示组件本身特性</li>\n</ul>\n<ol>\n<li>代理组件，封装常用属性，减少重复代码，例如：封装antd按钮组件</li>\n<li>样式组件，封装常用样式</li>\n<li>布局组件</li>\n</ol>\n<ul>\n<li>灵巧组件，专注组合组件</li>\n</ul>\n<ol>\n<li>容器组件，例如：ListWrap接受list数据，展示ListItem元素</li>\n<li>高阶组件，抽取公共逻辑，链式调用，渲染劫持</li>\n</ol>\n<ul>\n<li>高阶组件存在的问题以及处理方法</li>\n</ul>\n<ol>\n<li>丢失静态函数：通过 hoist-non-react-statics 来处理</li>\n<li>refs属性不能穿透：使用 React.forwardRef 处理</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 抽取公共逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isLogin</span>(<span class=\"params\">WrappedComponent</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isLogin = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">props</span>)=&gt;</span>(</span><br><span class=\"line\">    &lt;Fragment&gt;</span><br><span class=\"line\">      &lt;p&gt;高阶组件检测是否登录&lt;/p&gt;</span><br><span class=\"line\">      &#123;isLogin ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...props</span>&#125; /&gt;</span></span> : (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>未登录<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>)&#125;</span><br><span class=\"line\">    &lt;/Fragment&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 埋点统计</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pageLog</span>(<span class=\"params\">pagename</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">WrappedComponent</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wrapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"title\">componentDidMount</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(pagename)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      render ()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span></span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 高阶组件，链式调用</span></span><br><span class=\"line\">@pageLog(<span class=\"string\">&#x27;个人中心&#x27;</span>)</span><br><span class=\"line\">@isLogin</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserInfo</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  render ()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>已登录，个人中心<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 高阶组件，渲染劫持</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLoading</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.props.isLoading) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>loading<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.render();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@withLoading</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CardWrap</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render ()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>card<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"setState是同步还是异步\"><a href=\"#setState是同步还是异步\" class=\"headerlink\" title=\"setState是同步还是异步\"></a>setState是同步还是异步</h3><ul>\n<li>react合成事件：挂载在document（17之后挂载在渲染节点），dom事件出发后冒泡到document，react找到对应组件，创造合成事件</li>\n<li>react中通过isBatchingUpdates 来判断setState是否异步，当值为true时异步，当值为false时直接更新</li>\n<li>异步场景：react可以控制的地方，如生命周期、合成事件中</li>\n<li>同步场景：react无法控制的地方，如ddEventListener 、setTimeout、setInterval 等事件中，就只能同步更新</li>\n<li>异步设计为了性能优化、减少渲染次数、保持内部一致性（如果setSatte是同步的，但是props更新还是异步的）、启用并发完成异步渲染</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test extends React.Component &#123;</span><br><span class=\"line\">  state  &#x3D; &#123;</span><br><span class=\"line\">      count: 0</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 异步</span><br><span class=\"line\">    this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class=\"line\">    console.log(this.state.count);</span><br><span class=\"line\"></span><br><span class=\"line\">    this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class=\"line\">    console.log(this.state.count);</span><br><span class=\"line\">\t&#x2F;&#x2F; 同步 </span><br><span class=\"line\">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">      this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class=\"line\">      console.log(this.state.count);</span><br><span class=\"line\"></span><br><span class=\"line\">      this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class=\"line\">      console.log(this.state.count);</span><br><span class=\"line\">    &#125;, 0);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"react组件间通信\"><a href=\"#react组件间通信\" class=\"headerlink\" title=\"react组件间通信\"></a>react组件间通信</h3><ul>\n<li>父-&gt;子：props</li>\n<li>子-&gt;夫：回调函数、实例函数(React.createRef)</li>\n<li>兄弟组件：父组件中转</li>\n<li>多层：Context，全局变量与事件、状态管理框架（flux、redux、Mobx）</li>\n</ul>\n<h3 id=\"react状态管理框架\"><a href=\"#react状态管理框架\" class=\"headerlink\" title=\"react状态管理框架\"></a>react状态管理框架</h3><h3 id=\"Vitural-Dom-原理\"><a href=\"#Vitural-Dom-原理\" class=\"headerlink\" title=\"Vitural Dom 原理\"></a>Vitural Dom 原理</h3><ul>\n<li>概念、用途、思路、优缺点</li>\n</ul>\n<ol>\n<li>原理：虚拟DOM原理是通过js对象模拟DOM节点，为了要提升代码抽象能力、避免人为DOM操作、降低代码整体风险等因素，react引入了虚拟DOM</li>\n<li>实现：react在render函数中写的JSX会在babel编译下，转换为React.createElement执行JSX中的参数</li>\n<li>过程：React.createElement执行后，会返回一个描述自己当前tag类型、props等属性以及children等情况的对象，通过树结构形成一颗虚拟DOM树，当状态发生变化时，对比更新前后虚拟DOM的差异，整个过程成为diff，生成的结果为patch，计算后，渲染patch完成真实dom更新</li>\n<li>优点：改善大规模DOM操作的性能、避免XSS风险、以较低成本实现跨平台开发</li>\n<li>缺点：内存占用高、高性能场景存在难以优化情况（如Google Earth等高性能应用）</li>\n</ol>\n<h3 id=\"react-diff算法\"><a href=\"#react-diff算法\" class=\"headerlink\" title=\"react diff算法\"></a>react diff算法</h3><h3 id=\"react-渲染流程\"><a href=\"#react-渲染流程\" class=\"headerlink\" title=\"react 渲染流程\"></a>react 渲染流程</h3><h3 id=\"react-渲染异常\"><a href=\"#react-渲染异常\" class=\"headerlink\" title=\"react 渲染异常\"></a>react 渲染异常</h3><h3 id=\"react-性能优化\"><a href=\"#react-性能优化\" class=\"headerlink\" title=\"react 性能优化\"></a>react 性能优化</h3><h3 id=\"避免重复渲染\"><a href=\"#避免重复渲染\" class=\"headerlink\" title=\"避免重复渲染\"></a>避免重复渲染</h3><h4 id=\"重复渲染分析\"><a href=\"#重复渲染分析\" class=\"headerlink\" title=\"重复渲染分析\"></a>重复渲染分析</h4><ul>\n<li>步骤：选择优化时机、定位重复渲染的问题、引入解决方案</li>\n<li>优化时机：需要确认当前性能问题与业务的关系，是否有必要优化</li>\n<li>定位问题：还原用户使用环境的方式进行复现，然后使用 Performance 与 React Profiler 工具进行分析，对照卡顿点与组件重复渲染次数及耗时排查性能问题</li>\n</ul>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><ul>\n<li>组件使用 React.memo、pureComponent、shouldComponentUpdate 缓存 API，减少重新渲染</li>\n<li>注意问题：</li>\n</ul>\n<ol>\n<li>箭头函数props会触发更新，需要改为传递类方法</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ListItem</span><br><span class=\"line\"> key=&#123;id&#125;</span><br><span class=\"line\"> id=&#123;id&#125;</span><br><span class=\"line\"> text=&#123;text&#125;</span><br><span class=\"line\"> onMoveUp=&#123;<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> &#123; <span class=\"comment\">//... &#125;&#125; // 会触发更新</span></span><br><span class=\"line\"> onMoveDown=&#123;<span class=\"built_in\">this</span>.handleMoveDown&#125; <span class=\"comment\">// 不会触发更新</span></span><br><span class=\"line\">/&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>props参数是对象时会触发更新，可以使用reselect库解决，增加缓存</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> data = <span class=\"built_in\">this</span>.props.list.map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123; <span class=\"comment\">/*... */</span> &#125;)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;FlatList</span><br><span class=\"line\">      data=&#123;data&#125;</span><br><span class=\"line\">      renderItem=&#123;<span class=\"built_in\">this</span>.renderItem&#125;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\"> )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解决方法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createSelector &#125; fr om <span class=\"string\">&#x27;reselect&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> listSelector = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> props.list || []</span><br><span class=\"line\"><span class=\"keyword\">const</span> dataSelector = createSelector(</span><br><span class=\"line\">  listSelector,</span><br><span class=\"line\">  list =&gt; list.map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123; <span class=\"comment\">/*... */</span> &#125;)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;FlatList</span><br><span class=\"line\">      data=&#123;dataSelector(<span class=\"built_in\">this</span>.props)&#125;</span><br><span class=\"line\">      renderItem=&#123;<span class=\"built_in\">this</span>.renderItem&#125;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\"> )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>使用不可变数据处理：ImmutableJS、immerjs</li>\n</ol>\n<h3 id=\"提升-react-代码可维护性\"><a href=\"#提升-react-代码可维护性\" class=\"headerlink\" title=\"提升 react 代码可维护性\"></a>提升 react 代码可维护性</h3><ol>\n<li>可分析性：从预防与兜底两个维度展开工作，预防依靠Lint工具与团队内部Code Review，兜底主要是在流水线中加入 sourcemap，能够通过线上报错快速定位源码</li>\n<li>可改变性：使代码易于拓展，业务易于迭代，工作主要从设计模式与架构设计展开，设计模式指通过组件设计，使容器组件与展示组件划分边界，隔绝业务逻辑，整体架构设计，采用了 rematch 方案，rematch 中可以设计的 model 概念可以很好地收敛 action、reducer 及副作用，同时支持动态引入 model，保障业务横向拓展的能力</li>\n<li>稳定性：通过提升核心业务代码的测试覆盖率来完成，</li>\n<li>易测试性：采用 Rematch 的架构完成模块分离，整体业务逻辑挪到了 model 中，且 model 自身是一个 Pure Object，附加了多个纯函数。纯函数只要管理好输入与输出，在测试上就很容易</li>\n<li>可维护性的依从性：建立团队规范，遵循代码约定，提升代码可读性。这方面的工作就是引入工具，减少人为犯错的概率，使用ESLint、stylelint、commitlint、配置编辑器的 editorconfig，配置样式的 prettier</li>\n</ol>\n<h3 id=\"react-hooks-限制\"><a href=\"#react-hooks-限制\" class=\"headerlink\" title=\"react hooks 限制\"></a>react hooks 限制</h3><ul>\n<li>限制：</li>\n</ul>\n<ol>\n<li>不能在循环，条件判断，嵌套函数中使用Hook</li>\n<li>在 react 函数式组件中使用Hook</li>\n</ol>\n<ul>\n<li>存在限制的原因</li>\n</ul>\n<ol>\n<li>react旧开发模式存在的问题：（1）组件间难以复用状态逻辑（需要使用高阶组件、props、状态管框架），复杂组件难以理解（生命周期与业务耦合太深，关键功能难以拆分），人和机器容易混淆类（this问题，类难以优化）</li>\n<li>Hook是基于链表实现的，在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致取值错位，执行错误的 Hook</li>\n<li>可以引入Eslint的Hook检查插件预防错误</li>\n</ol>\n<h3 id=\"useEffect-与-useLayoutEffect\"><a href=\"#useEffect-与-useLayoutEffect\" class=\"headerlink\" title=\"useEffect 与 useLayoutEffect\"></a>useEffect 与 useLayoutEffect</h3><ul>\n<li>相同点：底层签名函数一直，都是调用的 mountEffectImpl，在使用上也没什么差异，基本可以直接替换，也都是用于处理副作用</li>\n<li>不同点：useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景，而 LayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 LayoutEffect 做计算量较大的耗时任务从而造成阻塞</li>\n<li>趋势：在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可</li>\n</ul>\n<h3 id=\"react-hooks设计模式\"><a href=\"#react-hooks设计模式\" class=\"headerlink\" title=\"react hooks设计模式\"></a>react hooks设计模式</h3><ol>\n<li>react hooks开发要抛弃生命周期的思考模式，以effects的角度思考，类组件的开发模式中，在componentDidMount 中放置一个监听事件，还需要考虑在 componentWillUnmount 中取消监听，甚至可能由于部分值变化，还需要在其他生命周期函数中对监听事件做特殊处理，可以将这一系列监听与取消监听放置在一个 useEffect 中，useEffect 可以不关心组件的生命周期，只需要关心外部依赖的变化即可，对于开发心智而言是极大的减负。这是 Hooks 的设计根本</li>\n<li>React.useMemo 取代 React.memo，因为 React.memo 并不能控制组件内部共享状态的变化，而 React.useMemo 更适合于 Hooks 的场景</li>\n<li>常量处理，类组件中，经常将常量定义在类中，在组件函数中，由于每次渲染都会重新声明常量，组件内的函数每次会被重新创建，如果这个函数需要使用函数组件内部的变量，那么可以用 useCallback 包裹下这个函数</li>\n<li>useEffect第二个参数容易错误使用，使用值类型而不是引用类型，引用类型容易被篡改</li>\n<li>将业务逻辑封装到各自的自定义 Hook 中，组件内部是抽空不放置业务逻辑，只是调用单个hooks暴漏的接口</li>\n</ol>\n<h3 id=\"react-router原理\"><a href=\"#react-router原理\" class=\"headerlink\" title=\"react router原理\"></a>react router原理</h3><ul>\n<li>实现原理</li>\n</ul>\n<ol>\n<li>HASH方式：依靠浏览器Hash变换</li>\n<li>切换地址中的path：需要使用 HTML5 的 history API 中的 pushState、replaceState，使用时还需要服务端完成 historyApiFallback 配置</li>\n</ol>\n<ul>\n<li>react router实现：内部靠自己封装的history库实现，提供两套基础history，一套直接使用浏览器history api，用于支持react-dom。另一套基于内存实现，自己做一个存储数组，用于支持react-router-native</li>\n<li>工作方式：</li>\n</ul>\n<ol>\n<li>设计模式：在架构上通过Monorepo进行项目管理，具有团队间透明、迭代便利有点，整体的数据通信，通过react Content Api实现</li>\n<li>关键模块：主要分为三类组件，（1）Context容器，比如 Router 与 MemoryRouter。（2）消费者组件，用于匹配路由，有Route、Redirect、Switch 等。（3）平台相关功能组件，如 Link、NavLink、DeepLinking 等</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"主要内容\"><a href=\"#主要内容\" class=\"headerlink\" title=\"主要内容\"></a>主要内容</h4><ul>\n<li>组件基础、状态管理、渲染流程、性能优化、Hooks、react生态</li>\n</ul>\n<h3 id=\"react是什么\"><a href=\"#react是什么\" class=\"headerlink\" title=\"react是什么\"></a>react是什么</h3><ul>\n<li>概念、用途、思路、优缺点</li>\n</ul>\n<ol>\n<li>react是网页UI框架，是组件化框架</li>\n<li>通过组件化方式解决视图层开发的问题，提升开发效率</li>\n<li>设计思路：声明式、组件化、通用性<br>声明式：使用jsx描述虚拟dom，更加直观<br>组件化：使用函数组件或者类组件，使试图模块可以复用<br>通用性：虚拟dom使react适用范围宾大，web、native都可以进行开发</li>\n<li>缺点：react只是视图层框架、没有提工完整的工程化开发方案，需要借助社区方案，在技术选型和学习上有一定成本</li>\n</ol>\n<h3 id=\"react为什么使用jsx\"><a href=\"#react为什么使用jsx\" class=\"headerlink\" title=\"react为什么使用jsx\"></a>react为什么使用jsx</h3><ul>\n<li>jsx介绍、核心概念、对比方案</li>\n</ul>\n<ol>\n<li>jsx是javascript的扩展语法，语法类似xml，react团队不想引入js外的开发体系，希望通过合理的关注点分离保持组件开发的纯粹性。</li>\n<li>jsx用于声明react元素，在构建时，会被babel编译为React.createElement，jsx更像是React.createElement的语法糖</li>\n<li>对比模板：模板会引入模板语法、模板指令等概念，增加学习成本<br>对比模板字符串：模板字符串结构会多次内嵌，结构复杂，优化困难<br> 对比json：代码提示困难</li>\n</ol>\n<h3 id=\"类组件生命周期\"><a href=\"#类组件生命周期\" class=\"headerlink\" title=\"类组件生命周期\"></a>类组件生命周期</h3><h4 id=\"react15生命周期\"><a href=\"#react15生命周期\" class=\"headerlink\" title=\"react15生命周期\"></a>react15生命周期</h4><ul>\n<li>挂载阶段</li>\n</ul>\n<p>constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount</p>\n<ul>\n<li>更新阶段</li>\n</ul>\n<p>只修改state：shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate<br>修改props内容：componentWillReceiveProps -&gt; shouldComponentUpdate -&gt; componentWillUpdate -&gt; render -&gt; componentDidUpdate</p>\n<ul>\n<li>卸载阶段</li>\n</ul>\n<p>componentWillUnmount</p>\n<h4 id=\"react16生命周期\"><a href=\"#react16生命周期\" class=\"headerlink\" title=\"react16生命周期\"></a>react16生命周期</h4><ul>\n<li>挂载阶段</li>\n</ul>\n<p>getDerivedStateFromProps -&gt; render -&gt; componentDidMount</p>\n<ul>\n<li>更新阶段</li>\n</ul>\n<p>getDerivedStateFromProps -&gt; shouldComponentUpdate -&gt; render -&gt; getSnapshotBeforeUpdate -&gt; componentDidUpdate</p>\n<ul>\n<li>卸载阶段</li>\n</ul>\n<p>componentWillUnmount</p>\n<h3 id=\"函数式组件与类组件区别\"><a href=\"#函数式组件与类组件区别\" class=\"headerlink\" title=\"函数式组件与类组件区别\"></a>函数式组件与类组件区别</h3><ul>\n<li>共同点、不同点</li>\n</ul>\n<ol>\n<li>函数式组件与类组件最终呈现效果一致</li>\n<li>两者设计模式不同，类组件是面向对象编程，主打继承、生命周期概念。函数式组件是函数式编程，主打immutable、无副作用、引用透明等特点</li>\n<li>由于推出Hooks，函数式组件可以替代类组件</li>\n<li>性能优化方面，类组件使用shouldComponentUpdate阻断渲染提升性能，函数式组件依靠React.memo缓存渲染结果提升性能</li>\n<li>类组件容易上手，函数式组件Hooks思想不容易理解，但函数组件是社区主推方案</li>\n<li>类组件在未来时间切片与并发模式中，由于生命周期复杂性，不容易优化，函数组件轻量简单，且在 Hooks 的基础上提供了比原先更细粒度的逻辑组织与复用，更能适应 React 的未来发展</li>\n</ol>\n<h3 id=\"react组件设计\"><a href=\"#react组件设计\" class=\"headerlink\" title=\"react组件设计\"></a>react组件设计</h3><ul>\n<li>展示组件：专注展示组件本身特性</li>\n</ul>\n<ol>\n<li>代理组件，封装常用属性，减少重复代码，例如：封装antd按钮组件</li>\n<li>样式组件，封装常用样式</li>\n<li>布局组件</li>\n</ol>\n<ul>\n<li>灵巧组件，专注组合组件</li>\n</ul>\n<ol>\n<li>容器组件，例如：ListWrap接受list数据，展示ListItem元素</li>\n<li>高阶组件，抽取公共逻辑，链式调用，渲染劫持</li>\n</ol>\n<ul>\n<li>高阶组件存在的问题以及处理方法</li>\n</ul>\n<ol>\n<li>丢失静态函数：通过 hoist-non-react-statics 来处理</li>\n<li>refs属性不能穿透：使用 React.forwardRef 处理</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 抽取公共逻辑</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">isLogin</span>(<span class=\"params\">WrappedComponent</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> isLogin = <span class=\"literal\">true</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">props</span>)=&gt;</span>(</span><br><span class=\"line\">    &lt;Fragment&gt;</span><br><span class=\"line\">      &lt;p&gt;高阶组件检测是否登录&lt;/p&gt;</span><br><span class=\"line\">      &#123;isLogin ? <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...props</span>&#125; /&gt;</span></span> : (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>未登录<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>)&#125;</span><br><span class=\"line\">    &lt;/Fragment&gt;</span><br><span class=\"line\">  )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 埋点统计</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">pageLog</span>(<span class=\"params\">pagename</span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">WrappedComponent</span>)=&gt;</span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Wrapper</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">      <span class=\"function\"><span class=\"title\">componentDidMount</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"built_in\">console</span>.log(pagename)</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      render ()&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">WrappedComponent</span> &#123;<span class=\"attr\">...this.props</span>&#125; /&gt;</span></span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 高阶组件，链式调用</span></span><br><span class=\"line\">@pageLog(<span class=\"string\">&#x27;个人中心&#x27;</span>)</span><br><span class=\"line\">@isLogin</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserInfo</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span></span>&#123;</span><br><span class=\"line\">  render ()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">span</span>&gt;</span>已登录，个人中心<span class=\"tag\">&lt;/<span class=\"name\">span</span>&gt;</span></span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 高阶组件，渲染劫持</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">withLoading</span>(<span class=\"params\">WrappedComponent</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"keyword\">extends</span> <span class=\"title\">WrappedComponent</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (<span class=\"built_in\">this</span>.props.isLoading) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>loading<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> <span class=\"built_in\">super</span>.render();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">@withLoading</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CardWrap</span> <span class=\"keyword\">extends</span> <span class=\"title\">React</span>.<span class=\"title\">Component</span> </span>&#123;</span><br><span class=\"line\">  render ()&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> (<span class=\"xml\"><span class=\"tag\">&lt;<span class=\"name\">div</span>&gt;</span>card<span class=\"tag\">&lt;/<span class=\"name\">div</span>&gt;</span></span>)</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"setState是同步还是异步\"><a href=\"#setState是同步还是异步\" class=\"headerlink\" title=\"setState是同步还是异步\"></a>setState是同步还是异步</h3><ul>\n<li>react合成事件：挂载在document（17之后挂载在渲染节点），dom事件出发后冒泡到document，react找到对应组件，创造合成事件</li>\n<li>react中通过isBatchingUpdates 来判断setState是否异步，当值为true时异步，当值为false时直接更新</li>\n<li>异步场景：react可以控制的地方，如生命周期、合成事件中</li>\n<li>同步场景：react无法控制的地方，如ddEventListener 、setTimeout、setInterval 等事件中，就只能同步更新</li>\n<li>异步设计为了性能优化、减少渲染次数、保持内部一致性（如果setSatte是同步的，但是props更新还是异步的）、启用并发完成异步渲染</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Test extends React.Component &#123;</span><br><span class=\"line\">  state  &#x3D; &#123;</span><br><span class=\"line\">      count: 0</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">\t&#x2F;&#x2F; 异步</span><br><span class=\"line\">    this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class=\"line\">    console.log(this.state.count);</span><br><span class=\"line\"></span><br><span class=\"line\">    this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class=\"line\">    console.log(this.state.count);</span><br><span class=\"line\">\t&#x2F;&#x2F; 同步 </span><br><span class=\"line\">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">      this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class=\"line\">      console.log(this.state.count);</span><br><span class=\"line\"></span><br><span class=\"line\">      this.setState(&#123;count: this.state.count + 1&#125;);</span><br><span class=\"line\">      console.log(this.state.count);</span><br><span class=\"line\">    &#125;, 0);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"> </span><br><span class=\"line\">  render() &#123;</span><br><span class=\"line\">    return null;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"react组件间通信\"><a href=\"#react组件间通信\" class=\"headerlink\" title=\"react组件间通信\"></a>react组件间通信</h3><ul>\n<li>父-&gt;子：props</li>\n<li>子-&gt;夫：回调函数、实例函数(React.createRef)</li>\n<li>兄弟组件：父组件中转</li>\n<li>多层：Context，全局变量与事件、状态管理框架（flux、redux、Mobx）</li>\n</ul>\n<h3 id=\"react状态管理框架\"><a href=\"#react状态管理框架\" class=\"headerlink\" title=\"react状态管理框架\"></a>react状态管理框架</h3><h3 id=\"Vitural-Dom-原理\"><a href=\"#Vitural-Dom-原理\" class=\"headerlink\" title=\"Vitural Dom 原理\"></a>Vitural Dom 原理</h3><ul>\n<li>概念、用途、思路、优缺点</li>\n</ul>\n<ol>\n<li>原理：虚拟DOM原理是通过js对象模拟DOM节点，为了要提升代码抽象能力、避免人为DOM操作、降低代码整体风险等因素，react引入了虚拟DOM</li>\n<li>实现：react在render函数中写的JSX会在babel编译下，转换为React.createElement执行JSX中的参数</li>\n<li>过程：React.createElement执行后，会返回一个描述自己当前tag类型、props等属性以及children等情况的对象，通过树结构形成一颗虚拟DOM树，当状态发生变化时，对比更新前后虚拟DOM的差异，整个过程成为diff，生成的结果为patch，计算后，渲染patch完成真实dom更新</li>\n<li>优点：改善大规模DOM操作的性能、避免XSS风险、以较低成本实现跨平台开发</li>\n<li>缺点：内存占用高、高性能场景存在难以优化情况（如Google Earth等高性能应用）</li>\n</ol>\n<h3 id=\"react-diff算法\"><a href=\"#react-diff算法\" class=\"headerlink\" title=\"react diff算法\"></a>react diff算法</h3><h3 id=\"react-渲染流程\"><a href=\"#react-渲染流程\" class=\"headerlink\" title=\"react 渲染流程\"></a>react 渲染流程</h3><h3 id=\"react-渲染异常\"><a href=\"#react-渲染异常\" class=\"headerlink\" title=\"react 渲染异常\"></a>react 渲染异常</h3><h3 id=\"react-性能优化\"><a href=\"#react-性能优化\" class=\"headerlink\" title=\"react 性能优化\"></a>react 性能优化</h3><h3 id=\"避免重复渲染\"><a href=\"#避免重复渲染\" class=\"headerlink\" title=\"避免重复渲染\"></a>避免重复渲染</h3><h4 id=\"重复渲染分析\"><a href=\"#重复渲染分析\" class=\"headerlink\" title=\"重复渲染分析\"></a>重复渲染分析</h4><ul>\n<li>步骤：选择优化时机、定位重复渲染的问题、引入解决方案</li>\n<li>优化时机：需要确认当前性能问题与业务的关系，是否有必要优化</li>\n<li>定位问题：还原用户使用环境的方式进行复现，然后使用 Performance 与 React Profiler 工具进行分析，对照卡顿点与组件重复渲染次数及耗时排查性能问题</li>\n</ul>\n<h4 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h4><ul>\n<li>组件使用 React.memo、pureComponent、shouldComponentUpdate 缓存 API，减少重新渲染</li>\n<li>注意问题：</li>\n</ul>\n<ol>\n<li>箭头函数props会触发更新，需要改为传递类方法</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;ListItem</span><br><span class=\"line\"> key=&#123;id&#125;</span><br><span class=\"line\"> id=&#123;id&#125;</span><br><span class=\"line\"> text=&#123;text&#125;</span><br><span class=\"line\"> onMoveUp=&#123;<span class=\"function\">(<span class=\"params\">id</span>) =&gt;</span> &#123; <span class=\"comment\">//... &#125;&#125; // 会触发更新</span></span><br><span class=\"line\"> onMoveDown=&#123;<span class=\"built_in\">this</span>.handleMoveDown&#125; <span class=\"comment\">// 不会触发更新</span></span><br><span class=\"line\">/&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>props参数是对象时会触发更新，可以使用reselect库解决，增加缓存</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">const</span> data = <span class=\"built_in\">this</span>.props.list.map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123; <span class=\"comment\">/*... */</span> &#125;)</span><br><span class=\"line\"> <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;FlatList</span><br><span class=\"line\">      data=&#123;data&#125;</span><br><span class=\"line\">      renderItem=&#123;<span class=\"built_in\">this</span>.renderItem&#125;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\"> )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 解决方法</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> &#123; createSelector &#125; fr om <span class=\"string\">&#x27;reselect&#x27;</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> listSelector = <span class=\"function\"><span class=\"params\">props</span> =&gt;</span> props.list || []</span><br><span class=\"line\"><span class=\"keyword\">const</span> dataSelector = createSelector(</span><br><span class=\"line\">  listSelector,</span><br><span class=\"line\">  list =&gt; list.map(<span class=\"function\">(<span class=\"params\">item</span>) =&gt;</span> &#123; <span class=\"comment\">/*... */</span> &#125;)</span><br><span class=\"line\">)</span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">render</span>(<span class=\"params\"></span>)</span> &#123;</span><br><span class=\"line\"> <span class=\"keyword\">return</span> (</span><br><span class=\"line\">    &lt;FlatList</span><br><span class=\"line\">      data=&#123;dataSelector(<span class=\"built_in\">this</span>.props)&#125;</span><br><span class=\"line\">      renderItem=&#123;<span class=\"built_in\">this</span>.renderItem&#125;</span><br><span class=\"line\">    /&gt;</span><br><span class=\"line\"> )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>使用不可变数据处理：ImmutableJS、immerjs</li>\n</ol>\n<h3 id=\"提升-react-代码可维护性\"><a href=\"#提升-react-代码可维护性\" class=\"headerlink\" title=\"提升 react 代码可维护性\"></a>提升 react 代码可维护性</h3><ol>\n<li>可分析性：从预防与兜底两个维度展开工作，预防依靠Lint工具与团队内部Code Review，兜底主要是在流水线中加入 sourcemap，能够通过线上报错快速定位源码</li>\n<li>可改变性：使代码易于拓展，业务易于迭代，工作主要从设计模式与架构设计展开，设计模式指通过组件设计，使容器组件与展示组件划分边界，隔绝业务逻辑，整体架构设计，采用了 rematch 方案，rematch 中可以设计的 model 概念可以很好地收敛 action、reducer 及副作用，同时支持动态引入 model，保障业务横向拓展的能力</li>\n<li>稳定性：通过提升核心业务代码的测试覆盖率来完成，</li>\n<li>易测试性：采用 Rematch 的架构完成模块分离，整体业务逻辑挪到了 model 中，且 model 自身是一个 Pure Object，附加了多个纯函数。纯函数只要管理好输入与输出，在测试上就很容易</li>\n<li>可维护性的依从性：建立团队规范，遵循代码约定，提升代码可读性。这方面的工作就是引入工具，减少人为犯错的概率，使用ESLint、stylelint、commitlint、配置编辑器的 editorconfig，配置样式的 prettier</li>\n</ol>\n<h3 id=\"react-hooks-限制\"><a href=\"#react-hooks-限制\" class=\"headerlink\" title=\"react hooks 限制\"></a>react hooks 限制</h3><ul>\n<li>限制：</li>\n</ul>\n<ol>\n<li>不能在循环，条件判断，嵌套函数中使用Hook</li>\n<li>在 react 函数式组件中使用Hook</li>\n</ol>\n<ul>\n<li>存在限制的原因</li>\n</ul>\n<ol>\n<li>react旧开发模式存在的问题：（1）组件间难以复用状态逻辑（需要使用高阶组件、props、状态管框架），复杂组件难以理解（生命周期与业务耦合太深，关键功能难以拆分），人和机器容易混淆类（this问题，类难以优化）</li>\n<li>Hook是基于链表实现的，在调用时按顺序加入数组中，如果使用循环、条件或嵌套函数很有可能导致取值错位，执行错误的 Hook</li>\n<li>可以引入Eslint的Hook检查插件预防错误</li>\n</ol>\n<h3 id=\"useEffect-与-useLayoutEffect\"><a href=\"#useEffect-与-useLayoutEffect\" class=\"headerlink\" title=\"useEffect 与 useLayoutEffect\"></a>useEffect 与 useLayoutEffect</h3><ul>\n<li>相同点：底层签名函数一直，都是调用的 mountEffectImpl，在使用上也没什么差异，基本可以直接替换，也都是用于处理副作用</li>\n<li>不同点：useEffect 在 React 的渲染过程中是被异步调用的，用于绝大多数场景，而 LayoutEffect 会在所有的 DOM 变更之后同步调用，主要用于处理 DOM 操作、调整样式、避免页面闪烁等问题。也正因为是同步处理，所以需要避免在 LayoutEffect 做计算量较大的耗时任务从而造成阻塞</li>\n<li>趋势：在未来的趋势上，两个 API 是会长期共存的，暂时没有删减合并的计划，需要开发者根据场景去自行选择。React 团队的建议非常实用，如果实在分不清，先用 useEffect，一般问题不大；如果页面有异常，再直接替换为 useLayoutEffect 即可</li>\n</ul>\n<h3 id=\"react-hooks设计模式\"><a href=\"#react-hooks设计模式\" class=\"headerlink\" title=\"react hooks设计模式\"></a>react hooks设计模式</h3><ol>\n<li>react hooks开发要抛弃生命周期的思考模式，以effects的角度思考，类组件的开发模式中，在componentDidMount 中放置一个监听事件，还需要考虑在 componentWillUnmount 中取消监听，甚至可能由于部分值变化，还需要在其他生命周期函数中对监听事件做特殊处理，可以将这一系列监听与取消监听放置在一个 useEffect 中，useEffect 可以不关心组件的生命周期，只需要关心外部依赖的变化即可，对于开发心智而言是极大的减负。这是 Hooks 的设计根本</li>\n<li>React.useMemo 取代 React.memo，因为 React.memo 并不能控制组件内部共享状态的变化，而 React.useMemo 更适合于 Hooks 的场景</li>\n<li>常量处理，类组件中，经常将常量定义在类中，在组件函数中，由于每次渲染都会重新声明常量，组件内的函数每次会被重新创建，如果这个函数需要使用函数组件内部的变量，那么可以用 useCallback 包裹下这个函数</li>\n<li>useEffect第二个参数容易错误使用，使用值类型而不是引用类型，引用类型容易被篡改</li>\n<li>将业务逻辑封装到各自的自定义 Hook 中，组件内部是抽空不放置业务逻辑，只是调用单个hooks暴漏的接口</li>\n</ol>\n<h3 id=\"react-router原理\"><a href=\"#react-router原理\" class=\"headerlink\" title=\"react router原理\"></a>react router原理</h3><ul>\n<li>实现原理</li>\n</ul>\n<ol>\n<li>HASH方式：依靠浏览器Hash变换</li>\n<li>切换地址中的path：需要使用 HTML5 的 history API 中的 pushState、replaceState，使用时还需要服务端完成 historyApiFallback 配置</li>\n</ol>\n<ul>\n<li>react router实现：内部靠自己封装的history库实现，提供两套基础history，一套直接使用浏览器history api，用于支持react-dom。另一套基于内存实现，自己做一个存储数组，用于支持react-router-native</li>\n<li>工作方式：</li>\n</ul>\n<ol>\n<li>设计模式：在架构上通过Monorepo进行项目管理，具有团队间透明、迭代便利有点，整体的数据通信，通过react Content Api实现</li>\n<li>关键模块：主要分为三类组件，（1）Context容器，比如 Router 与 MemoryRouter。（2）消费者组件，用于匹配路由，有Route、Redirect、Switch 等。（3）平台相关功能组件，如 Link、NavLink、DeepLinking 等</li>\n</ol>\n"},{"title":"<webpack>CommonsChunkPlugin与optimization-splitChunks","date":"2019-01-14T16:00:00.000Z","_content":"\n### CommonsChunkPlugin\n\n- 配置文档：https://www.webpackjs.com/plugins/commons-chunk-plugin/\n\n- 例子\n\n```\n//打包node_modules的公共代码\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'vendor',\n    chunks: commonChunks,//所有入口集合，如果不添加（文档里面说默认是所有入口），但是实际使用过程中不会打包所有入口公共代码，多以还是要添加为所有入口集合。\n    minChunks(module, count) {\n        return (\n            module.resource &&\n            /\\.js$/.test(module.resource) && module.resource.indexOf(\n                path.join(__dirname, '../node_modules')) === 0 && count >= 2\n        )\n    }\n}),\n//打包src下的公共代码\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'commonChunk',\n    chunks: commonChunks,\n    minChunks: function (module, count) {\n        // 保证commonChunk中的内容都是js且是scr下面调用的\n        return (\n            module.resource && /\\.js$/.test(module.resource) &&\n            module.resource.indexOf(\n                path.join(__dirname, '../src')\n            ) === 0 && count >= config.build.minChunks\n        )\n    }\n}),\n// webpackComonsChunk的执行环境，包含module的映射信息，会经常变化\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'manifest',\n    minChunks: Infinity\n}),\n```\n\n### optimization.splitChunks\n\n- 配置文档：https://webpack.js.org/plugins/split-chunks-plugin/\n\n```\noptimization: {\n    minimize: false,\n    splitChunks: {\n        minSize: 0,\n        // automaticNameDelimiter: '-',//文件名称分隔符默认'~'\n        chunks: \"all\",//选择哪些块进行优化，可选值：all、async和initial\n        cacheGroups: {\n            //拆分a入口文件node_modules引入的模块\n            vendorA: {\n                name: 'vendors-a',\n                test (module, chunks) {//匹配\n                    let res = (\n                        module.resource &&\n                        /\\.js$/.test(module.resource) &&\n                        module.resource.indexOf(path.join(__dirname, '../node_modules')) === 0 &&\n                        chunks.length == 1 &&\n                        chunks[0].name == 'a'\n                    )\n                    return res\n                },\n                // priority: 1,//打包首选优先级更高的缓存组，默认组的优先级为负，配置enforce会选择所有组\n                chunks: 'all',\n                minSize: 0,\n                enforce: true,//需要设置为true，否则会根据priority（优先级）等其他配置打包\n                minChunks: 1\n            },\n            //所有入口src下公共模块\n            commons: {\n                name: 'commons',\n                test (module, chunks) {\n                    let res = (\n                        module.resource &&\n                        /\\.js$/.test(module.resource) &&\n                        module.resource.indexOf(path.join(__dirname, '../src')) === 0 &&\n                        chunks.length >= 2\n                    )\n                    return res\n                },\n                chunks: 'all',\n                minSize: 0,\n                enforce: true,\n                minChunks: 1\n            },\n            //所有入口node_modules下公共模块\n            vendor: {\n                name: 'vendors',\n                test (module, chunks) {\n                    let res = (\n                        module.resource &&\n                        /\\.js$/.test(module.resource) &&\n                        module.resource.indexOf(path.join(__dirname, '../node_modules')) === 0 &&\n                        chunks.length >= 2\n                    )\n                    return res\n                },\n                chunks: 'all',\n                minSize: 0,\n                enforce: true,\n                minChunks: 1\n            }\n        },\n    },\n    //webpack运行文件\n    runtimeChunk: {\n        name: \"manifest\"\n    },\n},\n```\n","source":"_posts/[webpack]CommonsChunkPlugin与optimization-splitChunks.md","raw":"---\ntitle: <webpack>CommonsChunkPlugin与optimization-splitChunks\ndate: 2019-01-15 00:00:00\ntags: [webpack]\ncategories: webpack\n---\n\n### CommonsChunkPlugin\n\n- 配置文档：https://www.webpackjs.com/plugins/commons-chunk-plugin/\n\n- 例子\n\n```\n//打包node_modules的公共代码\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'vendor',\n    chunks: commonChunks,//所有入口集合，如果不添加（文档里面说默认是所有入口），但是实际使用过程中不会打包所有入口公共代码，多以还是要添加为所有入口集合。\n    minChunks(module, count) {\n        return (\n            module.resource &&\n            /\\.js$/.test(module.resource) && module.resource.indexOf(\n                path.join(__dirname, '../node_modules')) === 0 && count >= 2\n        )\n    }\n}),\n//打包src下的公共代码\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'commonChunk',\n    chunks: commonChunks,\n    minChunks: function (module, count) {\n        // 保证commonChunk中的内容都是js且是scr下面调用的\n        return (\n            module.resource && /\\.js$/.test(module.resource) &&\n            module.resource.indexOf(\n                path.join(__dirname, '../src')\n            ) === 0 && count >= config.build.minChunks\n        )\n    }\n}),\n// webpackComonsChunk的执行环境，包含module的映射信息，会经常变化\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'manifest',\n    minChunks: Infinity\n}),\n```\n\n### optimization.splitChunks\n\n- 配置文档：https://webpack.js.org/plugins/split-chunks-plugin/\n\n```\noptimization: {\n    minimize: false,\n    splitChunks: {\n        minSize: 0,\n        // automaticNameDelimiter: '-',//文件名称分隔符默认'~'\n        chunks: \"all\",//选择哪些块进行优化，可选值：all、async和initial\n        cacheGroups: {\n            //拆分a入口文件node_modules引入的模块\n            vendorA: {\n                name: 'vendors-a',\n                test (module, chunks) {//匹配\n                    let res = (\n                        module.resource &&\n                        /\\.js$/.test(module.resource) &&\n                        module.resource.indexOf(path.join(__dirname, '../node_modules')) === 0 &&\n                        chunks.length == 1 &&\n                        chunks[0].name == 'a'\n                    )\n                    return res\n                },\n                // priority: 1,//打包首选优先级更高的缓存组，默认组的优先级为负，配置enforce会选择所有组\n                chunks: 'all',\n                minSize: 0,\n                enforce: true,//需要设置为true，否则会根据priority（优先级）等其他配置打包\n                minChunks: 1\n            },\n            //所有入口src下公共模块\n            commons: {\n                name: 'commons',\n                test (module, chunks) {\n                    let res = (\n                        module.resource &&\n                        /\\.js$/.test(module.resource) &&\n                        module.resource.indexOf(path.join(__dirname, '../src')) === 0 &&\n                        chunks.length >= 2\n                    )\n                    return res\n                },\n                chunks: 'all',\n                minSize: 0,\n                enforce: true,\n                minChunks: 1\n            },\n            //所有入口node_modules下公共模块\n            vendor: {\n                name: 'vendors',\n                test (module, chunks) {\n                    let res = (\n                        module.resource &&\n                        /\\.js$/.test(module.resource) &&\n                        module.resource.indexOf(path.join(__dirname, '../node_modules')) === 0 &&\n                        chunks.length >= 2\n                    )\n                    return res\n                },\n                chunks: 'all',\n                minSize: 0,\n                enforce: true,\n                minChunks: 1\n            }\n        },\n    },\n    //webpack运行文件\n    runtimeChunk: {\n        name: \"manifest\"\n    },\n},\n```\n","slug":"[webpack]CommonsChunkPlugin与optimization-splitChunks","published":1,"updated":"2021-03-15T14:41:13.384Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dl20037wotj0kn5e5hc","content":"<h3 id=\"CommonsChunkPlugin\"><a href=\"#CommonsChunkPlugin\" class=\"headerlink\" title=\"CommonsChunkPlugin\"></a>CommonsChunkPlugin</h3><ul>\n<li><p>配置文档：<a href=\"https://www.webpackjs.com/plugins/commons-chunk-plugin/\">https://www.webpackjs.com/plugins/commons-chunk-plugin/</a></p>\n</li>\n<li><p>例子</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;打包node_modules的公共代码</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: &#39;vendor&#39;,</span><br><span class=\"line\">    chunks: commonChunks,&#x2F;&#x2F;所有入口集合，如果不添加（文档里面说默认是所有入口），但是实际使用过程中不会打包所有入口公共代码，多以还是要添加为所有入口集合。</span><br><span class=\"line\">    minChunks(module, count) &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            module.resource &amp;&amp;</span><br><span class=\"line\">            &#x2F;\\.js$&#x2F;.test(module.resource) &amp;&amp; module.resource.indexOf(</span><br><span class=\"line\">                path.join(__dirname, &#39;..&#x2F;node_modules&#39;)) &#x3D;&#x3D;&#x3D; 0 &amp;&amp; count &gt;&#x3D; 2</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\">&#x2F;&#x2F;打包src下的公共代码</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: &#39;commonChunk&#39;,</span><br><span class=\"line\">    chunks: commonChunks,</span><br><span class=\"line\">    minChunks: function (module, count) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 保证commonChunk中的内容都是js且是scr下面调用的</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            module.resource &amp;&amp; &#x2F;\\.js$&#x2F;.test(module.resource) &amp;&amp;</span><br><span class=\"line\">            module.resource.indexOf(</span><br><span class=\"line\">                path.join(__dirname, &#39;..&#x2F;src&#39;)</span><br><span class=\"line\">            ) &#x3D;&#x3D;&#x3D; 0 &amp;&amp; count &gt;&#x3D; config.build.minChunks</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\">&#x2F;&#x2F; webpackComonsChunk的执行环境，包含module的映射信息，会经常变化</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: &#39;manifest&#39;,</span><br><span class=\"line\">    minChunks: Infinity</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"optimization-splitChunks\"><a href=\"#optimization-splitChunks\" class=\"headerlink\" title=\"optimization.splitChunks\"></a>optimization.splitChunks</h3><ul>\n<li>配置文档：<a href=\"https://webpack.js.org/plugins/split-chunks-plugin/\">https://webpack.js.org/plugins/split-chunks-plugin/</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">optimization: &#123;</span><br><span class=\"line\">    minimize: false,</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">        minSize: 0,</span><br><span class=\"line\">        &#x2F;&#x2F; automaticNameDelimiter: &#39;-&#39;,&#x2F;&#x2F;文件名称分隔符默认&#39;~&#39;</span><br><span class=\"line\">        chunks: &quot;all&quot;,&#x2F;&#x2F;选择哪些块进行优化，可选值：all、async和initial</span><br><span class=\"line\">        cacheGroups: &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;拆分a入口文件node_modules引入的模块</span><br><span class=\"line\">            vendorA: &#123;</span><br><span class=\"line\">                name: &#39;vendors-a&#39;,</span><br><span class=\"line\">                test (module, chunks) &#123;&#x2F;&#x2F;匹配</span><br><span class=\"line\">                    let res &#x3D; (</span><br><span class=\"line\">                        module.resource &amp;&amp;</span><br><span class=\"line\">                        &#x2F;\\.js$&#x2F;.test(module.resource) &amp;&amp;</span><br><span class=\"line\">                        module.resource.indexOf(path.join(__dirname, &#39;..&#x2F;node_modules&#39;)) &#x3D;&#x3D;&#x3D; 0 &amp;&amp;</span><br><span class=\"line\">                        chunks.length &#x3D;&#x3D; 1 &amp;&amp;</span><br><span class=\"line\">                        chunks[0].name &#x3D;&#x3D; &#39;a&#39;</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                    return res</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#x2F;&#x2F; priority: 1,&#x2F;&#x2F;打包首选优先级更高的缓存组，默认组的优先级为负，配置enforce会选择所有组</span><br><span class=\"line\">                chunks: &#39;all&#39;,</span><br><span class=\"line\">                minSize: 0,</span><br><span class=\"line\">                enforce: true,&#x2F;&#x2F;需要设置为true，否则会根据priority（优先级）等其他配置打包</span><br><span class=\"line\">                minChunks: 1</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#x2F;&#x2F;所有入口src下公共模块</span><br><span class=\"line\">            commons: &#123;</span><br><span class=\"line\">                name: &#39;commons&#39;,</span><br><span class=\"line\">                test (module, chunks) &#123;</span><br><span class=\"line\">                    let res &#x3D; (</span><br><span class=\"line\">                        module.resource &amp;&amp;</span><br><span class=\"line\">                        &#x2F;\\.js$&#x2F;.test(module.resource) &amp;&amp;</span><br><span class=\"line\">                        module.resource.indexOf(path.join(__dirname, &#39;..&#x2F;src&#39;)) &#x3D;&#x3D;&#x3D; 0 &amp;&amp;</span><br><span class=\"line\">                        chunks.length &gt;&#x3D; 2</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                    return res</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                chunks: &#39;all&#39;,</span><br><span class=\"line\">                minSize: 0,</span><br><span class=\"line\">                enforce: true,</span><br><span class=\"line\">                minChunks: 1</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#x2F;&#x2F;所有入口node_modules下公共模块</span><br><span class=\"line\">            vendor: &#123;</span><br><span class=\"line\">                name: &#39;vendors&#39;,</span><br><span class=\"line\">                test (module, chunks) &#123;</span><br><span class=\"line\">                    let res &#x3D; (</span><br><span class=\"line\">                        module.resource &amp;&amp;</span><br><span class=\"line\">                        &#x2F;\\.js$&#x2F;.test(module.resource) &amp;&amp;</span><br><span class=\"line\">                        module.resource.indexOf(path.join(__dirname, &#39;..&#x2F;node_modules&#39;)) &#x3D;&#x3D;&#x3D; 0 &amp;&amp;</span><br><span class=\"line\">                        chunks.length &gt;&#x3D; 2</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                    return res</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                chunks: &#39;all&#39;,</span><br><span class=\"line\">                minSize: 0,</span><br><span class=\"line\">                enforce: true,</span><br><span class=\"line\">                minChunks: 1</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;webpack运行文件</span><br><span class=\"line\">    runtimeChunk: &#123;</span><br><span class=\"line\">        name: &quot;manifest&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"CommonsChunkPlugin\"><a href=\"#CommonsChunkPlugin\" class=\"headerlink\" title=\"CommonsChunkPlugin\"></a>CommonsChunkPlugin</h3><ul>\n<li><p>配置文档：<a href=\"https://www.webpackjs.com/plugins/commons-chunk-plugin/\">https://www.webpackjs.com/plugins/commons-chunk-plugin/</a></p>\n</li>\n<li><p>例子</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;打包node_modules的公共代码</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: &#39;vendor&#39;,</span><br><span class=\"line\">    chunks: commonChunks,&#x2F;&#x2F;所有入口集合，如果不添加（文档里面说默认是所有入口），但是实际使用过程中不会打包所有入口公共代码，多以还是要添加为所有入口集合。</span><br><span class=\"line\">    minChunks(module, count) &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            module.resource &amp;&amp;</span><br><span class=\"line\">            &#x2F;\\.js$&#x2F;.test(module.resource) &amp;&amp; module.resource.indexOf(</span><br><span class=\"line\">                path.join(__dirname, &#39;..&#x2F;node_modules&#39;)) &#x3D;&#x3D;&#x3D; 0 &amp;&amp; count &gt;&#x3D; 2</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\">&#x2F;&#x2F;打包src下的公共代码</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: &#39;commonChunk&#39;,</span><br><span class=\"line\">    chunks: commonChunks,</span><br><span class=\"line\">    minChunks: function (module, count) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; 保证commonChunk中的内容都是js且是scr下面调用的</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            module.resource &amp;&amp; &#x2F;\\.js$&#x2F;.test(module.resource) &amp;&amp;</span><br><span class=\"line\">            module.resource.indexOf(</span><br><span class=\"line\">                path.join(__dirname, &#39;..&#x2F;src&#39;)</span><br><span class=\"line\">            ) &#x3D;&#x3D;&#x3D; 0 &amp;&amp; count &gt;&#x3D; config.build.minChunks</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\">&#x2F;&#x2F; webpackComonsChunk的执行环境，包含module的映射信息，会经常变化</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: &#39;manifest&#39;,</span><br><span class=\"line\">    minChunks: Infinity</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"optimization-splitChunks\"><a href=\"#optimization-splitChunks\" class=\"headerlink\" title=\"optimization.splitChunks\"></a>optimization.splitChunks</h3><ul>\n<li>配置文档：<a href=\"https://webpack.js.org/plugins/split-chunks-plugin/\">https://webpack.js.org/plugins/split-chunks-plugin/</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">optimization: &#123;</span><br><span class=\"line\">    minimize: false,</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">        minSize: 0,</span><br><span class=\"line\">        &#x2F;&#x2F; automaticNameDelimiter: &#39;-&#39;,&#x2F;&#x2F;文件名称分隔符默认&#39;~&#39;</span><br><span class=\"line\">        chunks: &quot;all&quot;,&#x2F;&#x2F;选择哪些块进行优化，可选值：all、async和initial</span><br><span class=\"line\">        cacheGroups: &#123;</span><br><span class=\"line\">            &#x2F;&#x2F;拆分a入口文件node_modules引入的模块</span><br><span class=\"line\">            vendorA: &#123;</span><br><span class=\"line\">                name: &#39;vendors-a&#39;,</span><br><span class=\"line\">                test (module, chunks) &#123;&#x2F;&#x2F;匹配</span><br><span class=\"line\">                    let res &#x3D; (</span><br><span class=\"line\">                        module.resource &amp;&amp;</span><br><span class=\"line\">                        &#x2F;\\.js$&#x2F;.test(module.resource) &amp;&amp;</span><br><span class=\"line\">                        module.resource.indexOf(path.join(__dirname, &#39;..&#x2F;node_modules&#39;)) &#x3D;&#x3D;&#x3D; 0 &amp;&amp;</span><br><span class=\"line\">                        chunks.length &#x3D;&#x3D; 1 &amp;&amp;</span><br><span class=\"line\">                        chunks[0].name &#x3D;&#x3D; &#39;a&#39;</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                    return res</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &#x2F;&#x2F; priority: 1,&#x2F;&#x2F;打包首选优先级更高的缓存组，默认组的优先级为负，配置enforce会选择所有组</span><br><span class=\"line\">                chunks: &#39;all&#39;,</span><br><span class=\"line\">                minSize: 0,</span><br><span class=\"line\">                enforce: true,&#x2F;&#x2F;需要设置为true，否则会根据priority（优先级）等其他配置打包</span><br><span class=\"line\">                minChunks: 1</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#x2F;&#x2F;所有入口src下公共模块</span><br><span class=\"line\">            commons: &#123;</span><br><span class=\"line\">                name: &#39;commons&#39;,</span><br><span class=\"line\">                test (module, chunks) &#123;</span><br><span class=\"line\">                    let res &#x3D; (</span><br><span class=\"line\">                        module.resource &amp;&amp;</span><br><span class=\"line\">                        &#x2F;\\.js$&#x2F;.test(module.resource) &amp;&amp;</span><br><span class=\"line\">                        module.resource.indexOf(path.join(__dirname, &#39;..&#x2F;src&#39;)) &#x3D;&#x3D;&#x3D; 0 &amp;&amp;</span><br><span class=\"line\">                        chunks.length &gt;&#x3D; 2</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                    return res</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                chunks: &#39;all&#39;,</span><br><span class=\"line\">                minSize: 0,</span><br><span class=\"line\">                enforce: true,</span><br><span class=\"line\">                minChunks: 1</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            &#x2F;&#x2F;所有入口node_modules下公共模块</span><br><span class=\"line\">            vendor: &#123;</span><br><span class=\"line\">                name: &#39;vendors&#39;,</span><br><span class=\"line\">                test (module, chunks) &#123;</span><br><span class=\"line\">                    let res &#x3D; (</span><br><span class=\"line\">                        module.resource &amp;&amp;</span><br><span class=\"line\">                        &#x2F;\\.js$&#x2F;.test(module.resource) &amp;&amp;</span><br><span class=\"line\">                        module.resource.indexOf(path.join(__dirname, &#39;..&#x2F;node_modules&#39;)) &#x3D;&#x3D;&#x3D; 0 &amp;&amp;</span><br><span class=\"line\">                        chunks.length &gt;&#x3D; 2</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                    return res</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                chunks: &#39;all&#39;,</span><br><span class=\"line\">                minSize: 0,</span><br><span class=\"line\">                enforce: true,</span><br><span class=\"line\">                minChunks: 1</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#x2F;&#x2F;webpack运行文件</span><br><span class=\"line\">    runtimeChunk: &#123;</span><br><span class=\"line\">        name: &quot;manifest&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n"},{"title":"<react>redux实现原理","date":"2020-06-10T16:00:00.000Z","_content":"\n#### flux架构\n\n- Flux 架构中，一个应用将被拆分为以下 4 个部分：view(视图层)、action(动作)、dispatcher(派发器)、store(数据层)\n- Flux 工作流：用户与 View 之间产生交互，通过 View 发起一个 Action；Dispatcher 会把这个 Action 派发给 Store，通知 Store 进行相应的状态更新。Store 状态更新完成后，会进一步通知 View 去更新界面\n- 特点：单向数据流，Flux 最核心的地方在于严格的单向数据流，在单向数据流下，状态的变化是可预测的\n\n#### redux组成\n\n- Store：它是一个单一的数据源，而且是只读的\n- Action 是“动作”的意思，它是对变化的描述\n- Reducer 是一个函数，它负责对变化进行分发和处理，最终将新的数据返回给 Store\n\n#### redux实现的功能\n\n- 将状态统一放在一个state中，由store来管理\n- 这个store按照reducer的“shape”（形状）创建\n- reducer的作用：接收到action后，输出一个新的状态，对应地更新store上的状态\n- 外部改变state的最佳方式是通过调用store的dispatch方法，触发一个action，这个action被对应的reducer处理，完成state更新\n- 可以通过subscribe在store上添加一个监听函数。每当调用dispatch方法时，会执行所有的监听函数\n- 可以添加中间件处理副作用\n\n#### redux api\n\n- createStore：创建store，store 提供 subscribe，dispatch，getState 等方法\n- combineReducers：合并reducer\n- applyMiddleware：应用中间件\n\n#### createStore实现\n\n- creatorStore参数：reducer，initial_state（初始状态内容），applyMiddleware(middleware1, middleware2, ...)（指定中间件）\n\n- createStore处理流程\n1. 调用createStore\n2. 处理没有传入初始状态情况，两个参数都是function\n3. 如果enhancer不为空，调用enhancer包装creatorState\n4. 定义内部变量\n5. 定义ensureCanMutateNextListeners方法，保证currentListeners与nextListeners不指向统一引用\n6. 定义getState方法，用来返回当前状态\n7. 定义subscribe方法，用来注册监听函数\n8. 定义dispatch方法，用于派发action，调用reducer，触发订阅\n9. 定义replaceReducer方法，用于替换reducer\n10. 执行一次dispatch，初始化状态\n11. 定义observable方法\n12. 将getState\\subscribe\\dispatch等方法返回\n\n- dispatch处理流程\n\n- subscribe处理流程\n\n```javascript\n// createStore参数reducer，initial_state，applyMiddleware(middleware1, middleware2, ...)\nfunction createStore(reducer, preloadedState, enhancer) {\n  // 处理没有初始state，有中间件情况\n  if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n  // 处理中间件情况\n  if (enhancer) {\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  let currentReducer = reducer; // 当前store中的reducer，replaceReducer 会修改 reducer 的内容\n  let currentState = preloadedState; // 当前store中存储的状态\n  let currentListeners = []; // 当前store中放置的监听函数\n  let nextListeners = currentListeners; // 下一次dispatch时的监听函数\n  // 注意：当我们新添加一个监听函数时，只会在下一次dispatch的时候生效。\n  // 该变量用于记录当前是否正在进行 dispatch\n  let isDispatching = false;\n\n  // 该方法用于确认快照是 currentListeners 的副本，而不是 currentListeners 本身\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  // 获取state\n  function getState() {\n    return currentState;\n  }\n\n  // 添加一个监听函数，每当dispatch被调用的时候都会执行这个监听函数\n  function subscribe(listener) {\n    // 防止在reducer执行过程中调用\n    if (isDispatching) {\n      throw new Error();\n    }\n\n    let isSubscribe = true; //设置一个标志，标志该监听器已经订阅了\n    nextListeners.push(listener); // 注册监听函数\n    // 返回取消订阅的函数，即从数组中删除该监听函数\n    return function unsubscribe() {\n      if (!isSubscribe) {\n        return; // 如果已经取消订阅过了，直接返回\n      }\n\n      isSubscribe = false;\n      // 从下一轮的监听函数数组（用于下一次dispatch）中删除这个监听器。\n      const index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  // 触发了一个action，因此我们调用reducer，得到的新的state，并且执行所有添加到store中的监听函数。\n  function dispatch() {\n    // 若当前已经位于 dispatch 的流程中，则不允许再度发起 dispatch（禁止套娃）\n    if (isDispatching) {\n      throw new Error(\"Reducers may not dispatch actions.\");\n    }\n    try {\n      // 执行 reducer 前，先\"上锁\"，标记当前已经存在 dispatch 执行流程\n      isDispatching = true;\n      // 调用 reducer，计算新的 state\n      currentState = currentReducer(currentState, action);\n    } finally {\n      // 执行结束后，把\"锁\"打开，允许再次进行 dispatch\n      isDispatching = false;\n    }\n\n    // 触发订阅，更新监听函数\n    const listeners = (currentListeners = nextListeners);\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i];\n      listener();\n    }\n    return action;\n  }\n\n  // replaceReducer 可以更改当前的 reducer\n  function replaceReducer(nextReducer) {\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.REPLACE });\n    return store;\n  }\n\n  // 初始化state\n  dispatch({ type: ActionTypes.INIT });\n\n  // observable 方法可以忽略，它在 redux 内部使用，开发者一般不会直接接触\n  function observable() {\n    // observable 方法的实现\n  }\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable,\n  };\n}\n```\n\n#### combineReducers\n\n#### 中间件\n\n- 中间件相关的信息将作为 createStore 函数的一个 function 类型的入参被传入\n- 工作模式：action->middleware1->middleware2...->dispatch->reducer->nextState\n- applyMiddleware 将会对 dispatch 函数进行改写，使得 dispatch 在触发 reducer 之前，会首先执行对 Redux 中间件的链式调用\n\n#### redux-thunk\n\n- 若 action 是一个函数，那么 redux-thunk 就会执行它并且返回执行结果；若 action 不是一个函数，那么它就不是 redux-thunk 的处理目标，直接调用 next\n- 所有的 Redux 中间件都必须是高阶函数。在高阶函数中，我们习惯于将原函数称为“外层函数”，将 return 出来的函数称为“内层函数”\n\n```javascript\n// createThunkMiddleware 用于创建 thunk\nfunction createThunkMiddleware(extraArgument) {\n  // 返回值是一个 thunk，它是一个函数\n  return ({ dispatch, getState }) => (next) => (action) => {\n    // thunk 若感知到 action 是一个函数，就会执行 action\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n    // 若 action 不是一个函数，则不处理，直接放过\n    return next(action);\n  };\n}\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\nexport default thunk;\n```\n\n#### applyMiddleware\n\n- applyMiddleware 是 enhancer 的一种，而 enhancer 的意思是“增强器”，它增强的正是 createStore 的能力\n- 调用 enhancer 时，传入 createStore 及其相关的入参信息是非常必要的\n\n```javascript\n// applyMiddlerware 会使用“...”运算符将入参收敛为一个数组\nexport default function applyMiddleware(...middlewares) {\n  // 它返回的是一个接收 createStore 为入参的函数\n  return createStore => (...args) => {\n    // 首先调用 createStore，创建一个 store\n    const store = createStore(...args)\n    let dispatch = () => {\n      throw new Error(\n        `Dispatching while constructing your middleware is not allowed. ` +\n          `Other middleware would not be applied to this dispatch.`\n      )\n    }\n\n    // middlewareAPI 是中间件的入参\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch(...args)\n    }\n    // 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    // 改写原有的 dispatch：将 chain 中的函数按照顺序“组合”起来，调用最终组合出来的函数，传入 dispatch 作为入参\n    dispatch = compose(...chain)(store.dispatch)\n\n    // 返回一个新的 store 对象，这个 store 对象的 dispatch 已经被改写过了\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n\n1. 与creatorStore配合\n\n```javascript\nfunction createStore(reducer, preloadedState, enhancer) {\n    // 这里处理的是没有设定初始状态的情况，也就是第一个参数和第二个参数都传 function 的情况\n    if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n        // 此时第二个参数会被认为是 enhancer（中间件）\n        enhancer = preloadedState;\n        preloadedState = undefined;\n    }\n    // 当 enhancer 不为空时，便会将原来的 createStore 作为参数传入到 enhancer 中\n    if (typeof enhancer !== 'undefined') {\n        return enhancer(createStore)(reducer, preloadedState);\n    }\n    ......\n}\n```\n\n2. 改写dispatch函数\n\n```javascript\n// middlewareAPI 是中间件的入参\nconst middlewareAPI = {\n  getState: store.getState,\n  dispatch: (...args) => dispatch(...args)\n}\n// 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain\nconst chain = middlewares.map(middleware => middleware(middlewareAPI))\n// 改写原有的 dispatch：将 chain 中的函数按照顺序“组合”起来，调用最终组合出来的函数，传入 dispatch 作为入参\ndispatch = compose(...chain)(store.dispatch)\n```\n\n3. compose 源码，合成函数\n\n```javascript\n// compose 会首先利用“...”运算符将入参收敛为数组格式\nexport default function compose(...funcs) {\n  // 处理数组为空的边界情况\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  // 若只有一个函数，也就谈不上组合，直接返回\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n  // 若有多个函数，那么调用 reduce 方法来实现函数的组合\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n// compose(f1, f2, f3, f4)\n// (...args) =>  f1(f2(f3(f4(...args))))\n```\n\n```javascript\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return (arg) => arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n  const f = funcs.reduce((a, b) => (...args) => a(b(...args)));\n  return f;\n}\n\nconst f1 = (next) => {\n  return (action) => {\n    console.log(1);\n    next(action);\n  };\n};\nconst f2 = (next) => {\n  return (action) => {\n    console.log(2);\n    next(action);\n  };\n};\nconst f3 = (next) => {\n  return (action) => {\n    console.log(3);\n    next(action);\n  };\n};\n\n// compose(f1, f2, f3, f4)\n// (...args) =>  f1(f2(f3(f4(...args))))\nconst fun = compose(...[f1, f2, f3]);\nconst f = fun((action) => {\n  console.log(action);\n});\nf(\"action\");\n```\n\n#### 面向切面编程AOP\n\n- AOP 是一种典型的 “非侵入式”的逻辑扩充思路\n- 面向切面编程带来的利好是非常明显的。从 Redux 中间件机制中，不难看出，面向切面思想在很大程度上提升了我们组织逻辑的灵活度与干净度，帮助我们规避掉了逻辑冗余、逻辑耦合这类问题。通过将“切面”与业务逻辑剥离，开发者能够专注于业务逻辑的开发，并通过“即插即用”的方式自由地组织自己想要的扩展功能\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/[react]redux实现原理.md","raw":"---\ntitle: <react>redux实现原理\ndate: 2020-06-11 00:00:00\ntags: [react,redux]\ncategories:  react\n---\n\n#### flux架构\n\n- Flux 架构中，一个应用将被拆分为以下 4 个部分：view(视图层)、action(动作)、dispatcher(派发器)、store(数据层)\n- Flux 工作流：用户与 View 之间产生交互，通过 View 发起一个 Action；Dispatcher 会把这个 Action 派发给 Store，通知 Store 进行相应的状态更新。Store 状态更新完成后，会进一步通知 View 去更新界面\n- 特点：单向数据流，Flux 最核心的地方在于严格的单向数据流，在单向数据流下，状态的变化是可预测的\n\n#### redux组成\n\n- Store：它是一个单一的数据源，而且是只读的\n- Action 是“动作”的意思，它是对变化的描述\n- Reducer 是一个函数，它负责对变化进行分发和处理，最终将新的数据返回给 Store\n\n#### redux实现的功能\n\n- 将状态统一放在一个state中，由store来管理\n- 这个store按照reducer的“shape”（形状）创建\n- reducer的作用：接收到action后，输出一个新的状态，对应地更新store上的状态\n- 外部改变state的最佳方式是通过调用store的dispatch方法，触发一个action，这个action被对应的reducer处理，完成state更新\n- 可以通过subscribe在store上添加一个监听函数。每当调用dispatch方法时，会执行所有的监听函数\n- 可以添加中间件处理副作用\n\n#### redux api\n\n- createStore：创建store，store 提供 subscribe，dispatch，getState 等方法\n- combineReducers：合并reducer\n- applyMiddleware：应用中间件\n\n#### createStore实现\n\n- creatorStore参数：reducer，initial_state（初始状态内容），applyMiddleware(middleware1, middleware2, ...)（指定中间件）\n\n- createStore处理流程\n1. 调用createStore\n2. 处理没有传入初始状态情况，两个参数都是function\n3. 如果enhancer不为空，调用enhancer包装creatorState\n4. 定义内部变量\n5. 定义ensureCanMutateNextListeners方法，保证currentListeners与nextListeners不指向统一引用\n6. 定义getState方法，用来返回当前状态\n7. 定义subscribe方法，用来注册监听函数\n8. 定义dispatch方法，用于派发action，调用reducer，触发订阅\n9. 定义replaceReducer方法，用于替换reducer\n10. 执行一次dispatch，初始化状态\n11. 定义observable方法\n12. 将getState\\subscribe\\dispatch等方法返回\n\n- dispatch处理流程\n\n- subscribe处理流程\n\n```javascript\n// createStore参数reducer，initial_state，applyMiddleware(middleware1, middleware2, ...)\nfunction createStore(reducer, preloadedState, enhancer) {\n  // 处理没有初始state，有中间件情况\n  if (typeof preloadedState === \"function\" && typeof enhancer === \"undefined\") {\n    enhancer = preloadedState;\n    preloadedState = undefined;\n  }\n  // 处理中间件情况\n  if (enhancer) {\n    return enhancer(createStore)(reducer, preloadedState);\n  }\n\n  let currentReducer = reducer; // 当前store中的reducer，replaceReducer 会修改 reducer 的内容\n  let currentState = preloadedState; // 当前store中存储的状态\n  let currentListeners = []; // 当前store中放置的监听函数\n  let nextListeners = currentListeners; // 下一次dispatch时的监听函数\n  // 注意：当我们新添加一个监听函数时，只会在下一次dispatch的时候生效。\n  // 该变量用于记录当前是否正在进行 dispatch\n  let isDispatching = false;\n\n  // 该方法用于确认快照是 currentListeners 的副本，而不是 currentListeners 本身\n  function ensureCanMutateNextListeners() {\n    if (nextListeners === currentListeners) {\n      nextListeners = currentListeners.slice();\n    }\n  }\n\n  // 获取state\n  function getState() {\n    return currentState;\n  }\n\n  // 添加一个监听函数，每当dispatch被调用的时候都会执行这个监听函数\n  function subscribe(listener) {\n    // 防止在reducer执行过程中调用\n    if (isDispatching) {\n      throw new Error();\n    }\n\n    let isSubscribe = true; //设置一个标志，标志该监听器已经订阅了\n    nextListeners.push(listener); // 注册监听函数\n    // 返回取消订阅的函数，即从数组中删除该监听函数\n    return function unsubscribe() {\n      if (!isSubscribe) {\n        return; // 如果已经取消订阅过了，直接返回\n      }\n\n      isSubscribe = false;\n      // 从下一轮的监听函数数组（用于下一次dispatch）中删除这个监听器。\n      const index = nextListeners.indexOf(listener);\n      nextListeners.splice(index, 1);\n    };\n  }\n\n  // 触发了一个action，因此我们调用reducer，得到的新的state，并且执行所有添加到store中的监听函数。\n  function dispatch() {\n    // 若当前已经位于 dispatch 的流程中，则不允许再度发起 dispatch（禁止套娃）\n    if (isDispatching) {\n      throw new Error(\"Reducers may not dispatch actions.\");\n    }\n    try {\n      // 执行 reducer 前，先\"上锁\"，标记当前已经存在 dispatch 执行流程\n      isDispatching = true;\n      // 调用 reducer，计算新的 state\n      currentState = currentReducer(currentState, action);\n    } finally {\n      // 执行结束后，把\"锁\"打开，允许再次进行 dispatch\n      isDispatching = false;\n    }\n\n    // 触发订阅，更新监听函数\n    const listeners = (currentListeners = nextListeners);\n    for (let i = 0; i < listeners.length; i++) {\n      const listener = listeners[i];\n      listener();\n    }\n    return action;\n  }\n\n  // replaceReducer 可以更改当前的 reducer\n  function replaceReducer(nextReducer) {\n    currentReducer = nextReducer;\n    dispatch({ type: ActionTypes.REPLACE });\n    return store;\n  }\n\n  // 初始化state\n  dispatch({ type: ActionTypes.INIT });\n\n  // observable 方法可以忽略，它在 redux 内部使用，开发者一般不会直接接触\n  function observable() {\n    // observable 方法的实现\n  }\n\n  return {\n    dispatch,\n    subscribe,\n    getState,\n    replaceReducer,\n    [$$observable]: observable,\n  };\n}\n```\n\n#### combineReducers\n\n#### 中间件\n\n- 中间件相关的信息将作为 createStore 函数的一个 function 类型的入参被传入\n- 工作模式：action->middleware1->middleware2...->dispatch->reducer->nextState\n- applyMiddleware 将会对 dispatch 函数进行改写，使得 dispatch 在触发 reducer 之前，会首先执行对 Redux 中间件的链式调用\n\n#### redux-thunk\n\n- 若 action 是一个函数，那么 redux-thunk 就会执行它并且返回执行结果；若 action 不是一个函数，那么它就不是 redux-thunk 的处理目标，直接调用 next\n- 所有的 Redux 中间件都必须是高阶函数。在高阶函数中，我们习惯于将原函数称为“外层函数”，将 return 出来的函数称为“内层函数”\n\n```javascript\n// createThunkMiddleware 用于创建 thunk\nfunction createThunkMiddleware(extraArgument) {\n  // 返回值是一个 thunk，它是一个函数\n  return ({ dispatch, getState }) => (next) => (action) => {\n    // thunk 若感知到 action 是一个函数，就会执行 action\n    if (typeof action === 'function') {\n      return action(dispatch, getState, extraArgument);\n    }\n    // 若 action 不是一个函数，则不处理，直接放过\n    return next(action);\n  };\n}\nconst thunk = createThunkMiddleware();\nthunk.withExtraArgument = createThunkMiddleware;\nexport default thunk;\n```\n\n#### applyMiddleware\n\n- applyMiddleware 是 enhancer 的一种，而 enhancer 的意思是“增强器”，它增强的正是 createStore 的能力\n- 调用 enhancer 时，传入 createStore 及其相关的入参信息是非常必要的\n\n```javascript\n// applyMiddlerware 会使用“...”运算符将入参收敛为一个数组\nexport default function applyMiddleware(...middlewares) {\n  // 它返回的是一个接收 createStore 为入参的函数\n  return createStore => (...args) => {\n    // 首先调用 createStore，创建一个 store\n    const store = createStore(...args)\n    let dispatch = () => {\n      throw new Error(\n        `Dispatching while constructing your middleware is not allowed. ` +\n          `Other middleware would not be applied to this dispatch.`\n      )\n    }\n\n    // middlewareAPI 是中间件的入参\n    const middlewareAPI = {\n      getState: store.getState,\n      dispatch: (...args) => dispatch(...args)\n    }\n    // 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain\n    const chain = middlewares.map(middleware => middleware(middlewareAPI))\n    // 改写原有的 dispatch：将 chain 中的函数按照顺序“组合”起来，调用最终组合出来的函数，传入 dispatch 作为入参\n    dispatch = compose(...chain)(store.dispatch)\n\n    // 返回一个新的 store 对象，这个 store 对象的 dispatch 已经被改写过了\n    return {\n      ...store,\n      dispatch\n    }\n  }\n}\n```\n\n1. 与creatorStore配合\n\n```javascript\nfunction createStore(reducer, preloadedState, enhancer) {\n    // 这里处理的是没有设定初始状态的情况，也就是第一个参数和第二个参数都传 function 的情况\n    if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {\n        // 此时第二个参数会被认为是 enhancer（中间件）\n        enhancer = preloadedState;\n        preloadedState = undefined;\n    }\n    // 当 enhancer 不为空时，便会将原来的 createStore 作为参数传入到 enhancer 中\n    if (typeof enhancer !== 'undefined') {\n        return enhancer(createStore)(reducer, preloadedState);\n    }\n    ......\n}\n```\n\n2. 改写dispatch函数\n\n```javascript\n// middlewareAPI 是中间件的入参\nconst middlewareAPI = {\n  getState: store.getState,\n  dispatch: (...args) => dispatch(...args)\n}\n// 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain\nconst chain = middlewares.map(middleware => middleware(middlewareAPI))\n// 改写原有的 dispatch：将 chain 中的函数按照顺序“组合”起来，调用最终组合出来的函数，传入 dispatch 作为入参\ndispatch = compose(...chain)(store.dispatch)\n```\n\n3. compose 源码，合成函数\n\n```javascript\n// compose 会首先利用“...”运算符将入参收敛为数组格式\nexport default function compose(...funcs) {\n  // 处理数组为空的边界情况\n  if (funcs.length === 0) {\n    return arg => arg\n  }\n\n  // 若只有一个函数，也就谈不上组合，直接返回\n  if (funcs.length === 1) {\n    return funcs[0]\n  }\n  // 若有多个函数，那么调用 reduce 方法来实现函数的组合\n  return funcs.reduce((a, b) => (...args) => a(b(...args)))\n}\n// compose(f1, f2, f3, f4)\n// (...args) =>  f1(f2(f3(f4(...args))))\n```\n\n```javascript\nfunction compose(...funcs) {\n  if (funcs.length === 0) {\n    return (arg) => arg;\n  }\n\n  if (funcs.length === 1) {\n    return funcs[0];\n  }\n  const f = funcs.reduce((a, b) => (...args) => a(b(...args)));\n  return f;\n}\n\nconst f1 = (next) => {\n  return (action) => {\n    console.log(1);\n    next(action);\n  };\n};\nconst f2 = (next) => {\n  return (action) => {\n    console.log(2);\n    next(action);\n  };\n};\nconst f3 = (next) => {\n  return (action) => {\n    console.log(3);\n    next(action);\n  };\n};\n\n// compose(f1, f2, f3, f4)\n// (...args) =>  f1(f2(f3(f4(...args))))\nconst fun = compose(...[f1, f2, f3]);\nconst f = fun((action) => {\n  console.log(action);\n});\nf(\"action\");\n```\n\n#### 面向切面编程AOP\n\n- AOP 是一种典型的 “非侵入式”的逻辑扩充思路\n- 面向切面编程带来的利好是非常明显的。从 Redux 中间件机制中，不难看出，面向切面思想在很大程度上提升了我们组织逻辑的灵活度与干净度，帮助我们规避掉了逻辑冗余、逻辑耦合这类问题。通过将“切面”与业务逻辑剥离，开发者能够专注于业务逻辑的开发，并通过“即插即用”的方式自由地组织自己想要的扩展功能\n\n\n\n\n\n\n\n\n\n\n\n","slug":"[react]redux实现原理","published":1,"updated":"2021-03-15T14:40:47.204Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dl4003awotj021ggnnl","content":"<h4 id=\"flux架构\"><a href=\"#flux架构\" class=\"headerlink\" title=\"flux架构\"></a>flux架构</h4><ul>\n<li>Flux 架构中，一个应用将被拆分为以下 4 个部分：view(视图层)、action(动作)、dispatcher(派发器)、store(数据层)</li>\n<li>Flux 工作流：用户与 View 之间产生交互，通过 View 发起一个 Action；Dispatcher 会把这个 Action 派发给 Store，通知 Store 进行相应的状态更新。Store 状态更新完成后，会进一步通知 View 去更新界面</li>\n<li>特点：单向数据流，Flux 最核心的地方在于严格的单向数据流，在单向数据流下，状态的变化是可预测的</li>\n</ul>\n<h4 id=\"redux组成\"><a href=\"#redux组成\" class=\"headerlink\" title=\"redux组成\"></a>redux组成</h4><ul>\n<li>Store：它是一个单一的数据源，而且是只读的</li>\n<li>Action 是“动作”的意思，它是对变化的描述</li>\n<li>Reducer 是一个函数，它负责对变化进行分发和处理，最终将新的数据返回给 Store</li>\n</ul>\n<h4 id=\"redux实现的功能\"><a href=\"#redux实现的功能\" class=\"headerlink\" title=\"redux实现的功能\"></a>redux实现的功能</h4><ul>\n<li>将状态统一放在一个state中，由store来管理</li>\n<li>这个store按照reducer的“shape”（形状）创建</li>\n<li>reducer的作用：接收到action后，输出一个新的状态，对应地更新store上的状态</li>\n<li>外部改变state的最佳方式是通过调用store的dispatch方法，触发一个action，这个action被对应的reducer处理，完成state更新</li>\n<li>可以通过subscribe在store上添加一个监听函数。每当调用dispatch方法时，会执行所有的监听函数</li>\n<li>可以添加中间件处理副作用</li>\n</ul>\n<h4 id=\"redux-api\"><a href=\"#redux-api\" class=\"headerlink\" title=\"redux api\"></a>redux api</h4><ul>\n<li>createStore：创建store，store 提供 subscribe，dispatch，getState 等方法</li>\n<li>combineReducers：合并reducer</li>\n<li>applyMiddleware：应用中间件</li>\n</ul>\n<h4 id=\"createStore实现\"><a href=\"#createStore实现\" class=\"headerlink\" title=\"createStore实现\"></a>createStore实现</h4><ul>\n<li><p>creatorStore参数：reducer，initial_state（初始状态内容），applyMiddleware(middleware1, middleware2, …)（指定中间件）</p>\n</li>\n<li><p>createStore处理流程</p>\n</li>\n</ul>\n<ol>\n<li>调用createStore</li>\n<li>处理没有传入初始状态情况，两个参数都是function</li>\n<li>如果enhancer不为空，调用enhancer包装creatorState</li>\n<li>定义内部变量</li>\n<li>定义ensureCanMutateNextListeners方法，保证currentListeners与nextListeners不指向统一引用</li>\n<li>定义getState方法，用来返回当前状态</li>\n<li>定义subscribe方法，用来注册监听函数</li>\n<li>定义dispatch方法，用于派发action，调用reducer，触发订阅</li>\n<li>定义replaceReducer方法，用于替换reducer</li>\n<li>执行一次dispatch，初始化状态</li>\n<li>定义observable方法</li>\n<li>将getState\\subscribe\\dispatch等方法返回</li>\n</ol>\n<ul>\n<li><p>dispatch处理流程</p>\n</li>\n<li><p>subscribe处理流程</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// createStore参数reducer，initial_state，applyMiddleware(middleware1, middleware2, ...)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理没有初始state，有中间件情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> preloadedState === <span class=\"string\">&quot;function&quot;</span> &amp;&amp; <span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">    enhancer = preloadedState;</span><br><span class=\"line\">    preloadedState = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 处理中间件情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enhancer) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enhancer(createStore)(reducer, preloadedState);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentReducer = reducer; <span class=\"comment\">// 当前store中的reducer，replaceReducer 会修改 reducer 的内容</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentState = preloadedState; <span class=\"comment\">// 当前store中存储的状态</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentListeners = []; <span class=\"comment\">// 当前store中放置的监听函数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextListeners = currentListeners; <span class=\"comment\">// 下一次dispatch时的监听函数</span></span><br><span class=\"line\">  <span class=\"comment\">// 注意：当我们新添加一个监听函数时，只会在下一次dispatch的时候生效。</span></span><br><span class=\"line\">  <span class=\"comment\">// 该变量用于记录当前是否正在进行 dispatch</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> isDispatching = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 该方法用于确认快照是 currentListeners 的副本，而不是 currentListeners 本身</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ensureCanMutateNextListeners</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextListeners === currentListeners) &#123;</span><br><span class=\"line\">      nextListeners = currentListeners.slice();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 获取state</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getState</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 添加一个监听函数，每当dispatch被调用的时候都会执行这个监听函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">listener</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 防止在reducer执行过程中调用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isSubscribe = <span class=\"literal\">true</span>; <span class=\"comment\">//设置一个标志，标志该监听器已经订阅了</span></span><br><span class=\"line\">    nextListeners.push(listener); <span class=\"comment\">// 注册监听函数</span></span><br><span class=\"line\">    <span class=\"comment\">// 返回取消订阅的函数，即从数组中删除该监听函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unsubscribe</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isSubscribe) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>; <span class=\"comment\">// 如果已经取消订阅过了，直接返回</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      isSubscribe = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 从下一轮的监听函数数组（用于下一次dispatch）中删除这个监听器。</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> index = nextListeners.indexOf(listener);</span><br><span class=\"line\">      nextListeners.splice(index, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 触发了一个action，因此我们调用reducer，得到的新的state，并且执行所有添加到store中的监听函数。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若当前已经位于 dispatch 的流程中，则不允许再度发起 dispatch（禁止套娃）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;Reducers may not dispatch actions.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 执行 reducer 前，先&quot;上锁&quot;，标记当前已经存在 dispatch 执行流程</span></span><br><span class=\"line\">      isDispatching = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 调用 reducer，计算新的 state</span></span><br><span class=\"line\">      currentState = currentReducer(currentState, action);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 执行结束后，把&quot;锁&quot;打开，允许再次进行 dispatch</span></span><br><span class=\"line\">      isDispatching = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 触发订阅，更新监听函数</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> listeners = (currentListeners = nextListeners);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> listener = listeners[i];</span><br><span class=\"line\">      listener();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> action;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// replaceReducer 可以更改当前的 reducer</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replaceReducer</span>(<span class=\"params\">nextReducer</span>) </span>&#123;</span><br><span class=\"line\">    currentReducer = nextReducer;</span><br><span class=\"line\">    dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.REPLACE &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> store;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化state</span></span><br><span class=\"line\">  dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.INIT &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// observable 方法可以忽略，它在 redux 内部使用，开发者一般不会直接接触</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observable</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// observable 方法的实现</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    dispatch,</span><br><span class=\"line\">    subscribe,</span><br><span class=\"line\">    getState,</span><br><span class=\"line\">    replaceReducer,</span><br><span class=\"line\">    [$$observable]: observable,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h4><h4 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h4><ul>\n<li>中间件相关的信息将作为 createStore 函数的一个 function 类型的入参被传入</li>\n<li>工作模式：action-&gt;middleware1-&gt;middleware2…-&gt;dispatch-&gt;reducer-&gt;nextState</li>\n<li>applyMiddleware 将会对 dispatch 函数进行改写，使得 dispatch 在触发 reducer 之前，会首先执行对 Redux 中间件的链式调用</li>\n</ul>\n<h4 id=\"redux-thunk\"><a href=\"#redux-thunk\" class=\"headerlink\" title=\"redux-thunk\"></a>redux-thunk</h4><ul>\n<li>若 action 是一个函数，那么 redux-thunk 就会执行它并且返回执行结果；若 action 不是一个函数，那么它就不是 redux-thunk 的处理目标，直接调用 next</li>\n<li>所有的 Redux 中间件都必须是高阶函数。在高阶函数中，我们习惯于将原函数称为“外层函数”，将 return 出来的函数称为“内层函数”</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// createThunkMiddleware 用于创建 thunk</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createThunkMiddleware</span>(<span class=\"params\">extraArgument</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回值是一个 thunk，它是一个函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// thunk 若感知到 action 是一个函数，就会执行 action</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> action(dispatch, getState, extraArgument);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 若 action 不是一个函数，则不处理，直接放过</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> next(action);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> thunk = createThunkMiddleware();</span><br><span class=\"line\">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> thunk;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"applyMiddleware\"><a href=\"#applyMiddleware\" class=\"headerlink\" title=\"applyMiddleware\"></a>applyMiddleware</h4><ul>\n<li>applyMiddleware 是 enhancer 的一种，而 enhancer 的意思是“增强器”，它增强的正是 createStore 的能力</li>\n<li>调用 enhancer 时，传入 createStore 及其相关的入参信息是非常必要的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// applyMiddlerware 会使用“...”运算符将入参收敛为一个数组</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 它返回的是一个接收 createStore 为入参的函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">createStore</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先调用 createStore，创建一个 store</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = createStore(...args)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dispatch = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">`Dispatching while constructing your middleware is not allowed. `</span> +</span><br><span class=\"line\">          <span class=\"string\">`Other middleware would not be applied to this dispatch.`</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// middlewareAPI 是中间件的入参</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> middlewareAPI = &#123;</span><br><span class=\"line\">      getState: store.getState,</span><br><span class=\"line\">      dispatch: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class=\"line\">    <span class=\"comment\">// 改写原有的 dispatch：将 chain 中的函数按照顺序“组合”起来，调用最终组合出来的函数，传入 dispatch 作为入参</span></span><br><span class=\"line\">    dispatch = compose(...chain)(store.dispatch)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回一个新的 store 对象，这个 store 对象的 dispatch 已经被改写过了</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>与creatorStore配合</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里处理的是没有设定初始状态的情况，也就是第一个参数和第二个参数都传 function 的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> preloadedState === <span class=\"string\">&#x27;function&#x27;</span> &amp;&amp; <span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 此时第二个参数会被认为是 enhancer（中间件）</span></span><br><span class=\"line\">        enhancer = preloadedState;</span><br><span class=\"line\">        preloadedState = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当 enhancer 不为空时，便会将原来的 createStore 作为参数传入到 enhancer 中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> enhancer(createStore)(reducer, preloadedState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>改写dispatch函数</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// middlewareAPI 是中间件的入参</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> middlewareAPI = &#123;</span><br><span class=\"line\">  getState: store.getState,</span><br><span class=\"line\">  dispatch: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class=\"line\"><span class=\"comment\">// 改写原有的 dispatch：将 chain 中的函数按照顺序“组合”起来，调用最终组合出来的函数，传入 dispatch 作为入参</span></span><br><span class=\"line\">dispatch = compose(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>compose 源码，合成函数</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// compose 会首先利用“...”运算符将入参收敛为数组格式</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理数组为空的边界情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">arg</span> =&gt;</span> arg</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 若只有一个函数，也就谈不上组合，直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs[<span class=\"number\">0</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 若有多个函数，那么调用 reduce 方法来实现函数的组合</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// compose(f1, f2, f3, f4)</span></span><br><span class=\"line\"><span class=\"comment\">// (...args) =&gt;  f1(f2(f3(f4(...args))))</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">arg</span>) =&gt;</span> arg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = funcs.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> a(b(...args)));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> f1 = <span class=\"function\">(<span class=\"params\">next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">    next(action);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> f2 = <span class=\"function\">(<span class=\"params\">next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">    next(action);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> f3 = <span class=\"function\">(<span class=\"params\">next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">    next(action);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// compose(f1, f2, f3, f4)</span></span><br><span class=\"line\"><span class=\"comment\">// (...args) =&gt;  f1(f2(f3(f4(...args))))</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fun = compose(...[f1, f2, f3]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> f = fun(<span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(action);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">f(<span class=\"string\">&quot;action&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"面向切面编程AOP\"><a href=\"#面向切面编程AOP\" class=\"headerlink\" title=\"面向切面编程AOP\"></a>面向切面编程AOP</h4><ul>\n<li>AOP 是一种典型的 “非侵入式”的逻辑扩充思路</li>\n<li>面向切面编程带来的利好是非常明显的。从 Redux 中间件机制中，不难看出，面向切面思想在很大程度上提升了我们组织逻辑的灵活度与干净度，帮助我们规避掉了逻辑冗余、逻辑耦合这类问题。通过将“切面”与业务逻辑剥离，开发者能够专注于业务逻辑的开发，并通过“即插即用”的方式自由地组织自己想要的扩展功能</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"flux架构\"><a href=\"#flux架构\" class=\"headerlink\" title=\"flux架构\"></a>flux架构</h4><ul>\n<li>Flux 架构中，一个应用将被拆分为以下 4 个部分：view(视图层)、action(动作)、dispatcher(派发器)、store(数据层)</li>\n<li>Flux 工作流：用户与 View 之间产生交互，通过 View 发起一个 Action；Dispatcher 会把这个 Action 派发给 Store，通知 Store 进行相应的状态更新。Store 状态更新完成后，会进一步通知 View 去更新界面</li>\n<li>特点：单向数据流，Flux 最核心的地方在于严格的单向数据流，在单向数据流下，状态的变化是可预测的</li>\n</ul>\n<h4 id=\"redux组成\"><a href=\"#redux组成\" class=\"headerlink\" title=\"redux组成\"></a>redux组成</h4><ul>\n<li>Store：它是一个单一的数据源，而且是只读的</li>\n<li>Action 是“动作”的意思，它是对变化的描述</li>\n<li>Reducer 是一个函数，它负责对变化进行分发和处理，最终将新的数据返回给 Store</li>\n</ul>\n<h4 id=\"redux实现的功能\"><a href=\"#redux实现的功能\" class=\"headerlink\" title=\"redux实现的功能\"></a>redux实现的功能</h4><ul>\n<li>将状态统一放在一个state中，由store来管理</li>\n<li>这个store按照reducer的“shape”（形状）创建</li>\n<li>reducer的作用：接收到action后，输出一个新的状态，对应地更新store上的状态</li>\n<li>外部改变state的最佳方式是通过调用store的dispatch方法，触发一个action，这个action被对应的reducer处理，完成state更新</li>\n<li>可以通过subscribe在store上添加一个监听函数。每当调用dispatch方法时，会执行所有的监听函数</li>\n<li>可以添加中间件处理副作用</li>\n</ul>\n<h4 id=\"redux-api\"><a href=\"#redux-api\" class=\"headerlink\" title=\"redux api\"></a>redux api</h4><ul>\n<li>createStore：创建store，store 提供 subscribe，dispatch，getState 等方法</li>\n<li>combineReducers：合并reducer</li>\n<li>applyMiddleware：应用中间件</li>\n</ul>\n<h4 id=\"createStore实现\"><a href=\"#createStore实现\" class=\"headerlink\" title=\"createStore实现\"></a>createStore实现</h4><ul>\n<li><p>creatorStore参数：reducer，initial_state（初始状态内容），applyMiddleware(middleware1, middleware2, …)（指定中间件）</p>\n</li>\n<li><p>createStore处理流程</p>\n</li>\n</ul>\n<ol>\n<li>调用createStore</li>\n<li>处理没有传入初始状态情况，两个参数都是function</li>\n<li>如果enhancer不为空，调用enhancer包装creatorState</li>\n<li>定义内部变量</li>\n<li>定义ensureCanMutateNextListeners方法，保证currentListeners与nextListeners不指向统一引用</li>\n<li>定义getState方法，用来返回当前状态</li>\n<li>定义subscribe方法，用来注册监听函数</li>\n<li>定义dispatch方法，用于派发action，调用reducer，触发订阅</li>\n<li>定义replaceReducer方法，用于替换reducer</li>\n<li>执行一次dispatch，初始化状态</li>\n<li>定义observable方法</li>\n<li>将getState\\subscribe\\dispatch等方法返回</li>\n</ol>\n<ul>\n<li><p>dispatch处理流程</p>\n</li>\n<li><p>subscribe处理流程</p>\n</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// createStore参数reducer，initial_state，applyMiddleware(middleware1, middleware2, ...)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理没有初始state，有中间件情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> preloadedState === <span class=\"string\">&quot;function&quot;</span> &amp;&amp; <span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">&quot;undefined&quot;</span>) &#123;</span><br><span class=\"line\">    enhancer = preloadedState;</span><br><span class=\"line\">    preloadedState = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 处理中间件情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (enhancer) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> enhancer(createStore)(reducer, preloadedState);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentReducer = reducer; <span class=\"comment\">// 当前store中的reducer，replaceReducer 会修改 reducer 的内容</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentState = preloadedState; <span class=\"comment\">// 当前store中存储的状态</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> currentListeners = []; <span class=\"comment\">// 当前store中放置的监听函数</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> nextListeners = currentListeners; <span class=\"comment\">// 下一次dispatch时的监听函数</span></span><br><span class=\"line\">  <span class=\"comment\">// 注意：当我们新添加一个监听函数时，只会在下一次dispatch的时候生效。</span></span><br><span class=\"line\">  <span class=\"comment\">// 该变量用于记录当前是否正在进行 dispatch</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> isDispatching = <span class=\"literal\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 该方法用于确认快照是 currentListeners 的副本，而不是 currentListeners 本身</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">ensureCanMutateNextListeners</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (nextListeners === currentListeners) &#123;</span><br><span class=\"line\">      nextListeners = currentListeners.slice();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 获取state</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">getState</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> currentState;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 添加一个监听函数，每当dispatch被调用的时候都会执行这个监听函数</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">subscribe</span>(<span class=\"params\">listener</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 防止在reducer执行过程中调用</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">let</span> isSubscribe = <span class=\"literal\">true</span>; <span class=\"comment\">//设置一个标志，标志该监听器已经订阅了</span></span><br><span class=\"line\">    nextListeners.push(listener); <span class=\"comment\">// 注册监听函数</span></span><br><span class=\"line\">    <span class=\"comment\">// 返回取消订阅的函数，即从数组中删除该监听函数</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">unsubscribe</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (!isSubscribe) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span>; <span class=\"comment\">// 如果已经取消订阅过了，直接返回</span></span><br><span class=\"line\">      &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">      isSubscribe = <span class=\"literal\">false</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 从下一轮的监听函数数组（用于下一次dispatch）中删除这个监听器。</span></span><br><span class=\"line\">      <span class=\"keyword\">const</span> index = nextListeners.indexOf(listener);</span><br><span class=\"line\">      nextListeners.splice(index, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 触发了一个action，因此我们调用reducer，得到的新的state，并且执行所有添加到store中的监听函数。</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">dispatch</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 若当前已经位于 dispatch 的流程中，则不允许再度发起 dispatch（禁止套娃）</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isDispatching) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(<span class=\"string\">&quot;Reducers may not dispatch actions.&quot;</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 执行 reducer 前，先&quot;上锁&quot;，标记当前已经存在 dispatch 执行流程</span></span><br><span class=\"line\">      isDispatching = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      <span class=\"comment\">// 调用 reducer，计算新的 state</span></span><br><span class=\"line\">      currentState = currentReducer(currentState, action);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">      <span class=\"comment\">// 执行结束后，把&quot;锁&quot;打开，允许再次进行 dispatch</span></span><br><span class=\"line\">      isDispatching = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 触发订阅，更新监听函数</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> listeners = (currentListeners = nextListeners);</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; listeners.length; i++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">const</span> listener = listeners[i];</span><br><span class=\"line\">      listener();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> action;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// replaceReducer 可以更改当前的 reducer</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">replaceReducer</span>(<span class=\"params\">nextReducer</span>) </span>&#123;</span><br><span class=\"line\">    currentReducer = nextReducer;</span><br><span class=\"line\">    dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.REPLACE &#125;);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> store;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 初始化state</span></span><br><span class=\"line\">  dispatch(&#123; <span class=\"attr\">type</span>: ActionTypes.INIT &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// observable 方法可以忽略，它在 redux 内部使用，开发者一般不会直接接触</span></span><br><span class=\"line\">  <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">observable</span>(<span class=\"params\"></span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// observable 方法的实现</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">    dispatch,</span><br><span class=\"line\">    subscribe,</span><br><span class=\"line\">    getState,</span><br><span class=\"line\">    replaceReducer,</span><br><span class=\"line\">    [$$observable]: observable,</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"combineReducers\"><a href=\"#combineReducers\" class=\"headerlink\" title=\"combineReducers\"></a>combineReducers</h4><h4 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h4><ul>\n<li>中间件相关的信息将作为 createStore 函数的一个 function 类型的入参被传入</li>\n<li>工作模式：action-&gt;middleware1-&gt;middleware2…-&gt;dispatch-&gt;reducer-&gt;nextState</li>\n<li>applyMiddleware 将会对 dispatch 函数进行改写，使得 dispatch 在触发 reducer 之前，会首先执行对 Redux 中间件的链式调用</li>\n</ul>\n<h4 id=\"redux-thunk\"><a href=\"#redux-thunk\" class=\"headerlink\" title=\"redux-thunk\"></a>redux-thunk</h4><ul>\n<li>若 action 是一个函数，那么 redux-thunk 就会执行它并且返回执行结果；若 action 不是一个函数，那么它就不是 redux-thunk 的处理目标，直接调用 next</li>\n<li>所有的 Redux 中间件都必须是高阶函数。在高阶函数中，我们习惯于将原函数称为“外层函数”，将 return 出来的函数称为“内层函数”</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// createThunkMiddleware 用于创建 thunk</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createThunkMiddleware</span>(<span class=\"params\">extraArgument</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 返回值是一个 thunk，它是一个函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">&#123; dispatch, getState &#125;</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">next</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// thunk 若感知到 action 是一个函数，就会执行 action</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> action === <span class=\"string\">&#x27;function&#x27;</span>) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">return</span> action(dispatch, getState, extraArgument);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 若 action 不是一个函数，则不处理，直接放过</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> next(action);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">const</span> thunk = createThunkMiddleware();</span><br><span class=\"line\">thunk.withExtraArgument = createThunkMiddleware;</span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> thunk;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"applyMiddleware\"><a href=\"#applyMiddleware\" class=\"headerlink\" title=\"applyMiddleware\"></a>applyMiddleware</h4><ul>\n<li>applyMiddleware 是 enhancer 的一种，而 enhancer 的意思是“增强器”，它增强的正是 createStore 的能力</li>\n<li>调用 enhancer 时，传入 createStore 及其相关的入参信息是非常必要的</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// applyMiddlerware 会使用“...”运算符将入参收敛为一个数组</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">applyMiddleware</span>(<span class=\"params\">...middlewares</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 它返回的是一个接收 createStore 为入参的函数</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">createStore</span> =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"comment\">// 首先调用 createStore，创建一个 store</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> store = createStore(...args)</span><br><span class=\"line\">    <span class=\"keyword\">let</span> dispatch = <span class=\"function\">() =&gt;</span> &#123;</span><br><span class=\"line\">      <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> <span class=\"built_in\">Error</span>(</span><br><span class=\"line\">        <span class=\"string\">`Dispatching while constructing your middleware is not allowed. `</span> +</span><br><span class=\"line\">          <span class=\"string\">`Other middleware would not be applied to this dispatch.`</span></span><br><span class=\"line\">      )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// middlewareAPI 是中间件的入参</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> middlewareAPI = &#123;</span><br><span class=\"line\">      getState: store.getState,</span><br><span class=\"line\">      dispatch: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class=\"line\">    <span class=\"comment\">// 改写原有的 dispatch：将 chain 中的函数按照顺序“组合”起来，调用最终组合出来的函数，传入 dispatch 作为入参</span></span><br><span class=\"line\">    dispatch = compose(...chain)(store.dispatch)</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 返回一个新的 store 对象，这个 store 对象的 dispatch 已经被改写过了</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> &#123;</span><br><span class=\"line\">      ...store,</span><br><span class=\"line\">      dispatch</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>与creatorStore配合</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">createStore</span>(<span class=\"params\">reducer, preloadedState, enhancer</span>) </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 这里处理的是没有设定初始状态的情况，也就是第一个参数和第二个参数都传 function 的情况</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> preloadedState === <span class=\"string\">&#x27;function&#x27;</span> &amp;&amp; <span class=\"keyword\">typeof</span> enhancer === <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"comment\">// 此时第二个参数会被认为是 enhancer（中间件）</span></span><br><span class=\"line\">        enhancer = preloadedState;</span><br><span class=\"line\">        preloadedState = <span class=\"literal\">undefined</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 当 enhancer 不为空时，便会将原来的 createStore 作为参数传入到 enhancer 中</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (<span class=\"keyword\">typeof</span> enhancer !== <span class=\"string\">&#x27;undefined&#x27;</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> enhancer(createStore)(reducer, preloadedState);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ......</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>改写dispatch函数</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// middlewareAPI 是中间件的入参</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> middlewareAPI = &#123;</span><br><span class=\"line\">  getState: store.getState,</span><br><span class=\"line\">  dispatch: <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> dispatch(...args)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 遍历中间件数组，调用每个中间件，并且传入 middlewareAPI 作为入参，得到目标函数数组 chain</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> chain = middlewares.map(<span class=\"function\"><span class=\"params\">middleware</span> =&gt;</span> middleware(middlewareAPI))</span><br><span class=\"line\"><span class=\"comment\">// 改写原有的 dispatch：将 chain 中的函数按照顺序“组合”起来，调用最终组合出来的函数，传入 dispatch 作为入参</span></span><br><span class=\"line\">dispatch = compose(...chain)(store.dispatch)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>compose 源码，合成函数</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// compose 会首先利用“...”运算符将入参收敛为数组格式</span></span><br><span class=\"line\"><span class=\"keyword\">export</span> <span class=\"keyword\">default</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">// 处理数组为空的边界情况</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\"><span class=\"params\">arg</span> =&gt;</span> arg</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">// 若只有一个函数，也就谈不上组合，直接返回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs[<span class=\"number\">0</span>]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 若有多个函数，那么调用 reduce 方法来实现函数的组合</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> funcs.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> a(b(...args)))</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// compose(f1, f2, f3, f4)</span></span><br><span class=\"line\"><span class=\"comment\">// (...args) =&gt;  f1(f2(f3(f4(...args))))</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">compose</span>(<span class=\"params\">...funcs</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">arg</span>) =&gt;</span> arg;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (funcs.length === <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> funcs[<span class=\"number\">0</span>];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> f = funcs.reduce(<span class=\"function\">(<span class=\"params\">a, b</span>) =&gt;</span> <span class=\"function\">(<span class=\"params\">...args</span>) =&gt;</span> a(b(...args)));</span><br><span class=\"line\">  <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">const</span> f1 = <span class=\"function\">(<span class=\"params\">next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">1</span>);</span><br><span class=\"line\">    next(action);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> f2 = <span class=\"function\">(<span class=\"params\">next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">2</span>);</span><br><span class=\"line\">    next(action);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> f3 = <span class=\"function\">(<span class=\"params\">next</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">    <span class=\"built_in\">console</span>.log(<span class=\"number\">3</span>);</span><br><span class=\"line\">    next(action);</span><br><span class=\"line\">  &#125;;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// compose(f1, f2, f3, f4)</span></span><br><span class=\"line\"><span class=\"comment\">// (...args) =&gt;  f1(f2(f3(f4(...args))))</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> fun = compose(...[f1, f2, f3]);</span><br><span class=\"line\"><span class=\"keyword\">const</span> f = fun(<span class=\"function\">(<span class=\"params\">action</span>) =&gt;</span> &#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(action);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">f(<span class=\"string\">&quot;action&quot;</span>);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"面向切面编程AOP\"><a href=\"#面向切面编程AOP\" class=\"headerlink\" title=\"面向切面编程AOP\"></a>面向切面编程AOP</h4><ul>\n<li>AOP 是一种典型的 “非侵入式”的逻辑扩充思路</li>\n<li>面向切面编程带来的利好是非常明显的。从 Redux 中间件机制中，不难看出，面向切面思想在很大程度上提升了我们组织逻辑的灵活度与干净度，帮助我们规避掉了逻辑冗余、逻辑耦合这类问题。通过将“切面”与业务逻辑剥离，开发者能够专注于业务逻辑的开发，并通过“即插即用”的方式自由地组织自己想要的扩展功能</li>\n</ul>\n"},{"title":"<react>学习笔记","date":"2019-03-26T16:00:00.000Z","_content":"\n### JSX\n\n1. 最外层只允许被一个标签包裹\n2. 标签一定要闭合\n3. DOM元素和组件元素（组件元素要大写开头）,也可以使用命名空间方式使用组件(<MUI.Button />)\n4. 注释：\n\n```\n{/* 注释 */}\n/*\n多行注释\n*/\n```\n\n5. 元素属性：特殊：class->calssName  for->htmlfor，自定义属性需要小驼峰写法\n6. Boolean 属性：省略的话默认为true 比如 disabled\n7. 展开属性：<Component {...data} />，使用ES6展开运算符\n8. DOM元素自定义HTML属性： data- 无障碍属性 aria-\n9. JavaScript属性表达式：\n\n```\nconst person = <Person name={window.isLoggedIn ? window.name : ''} />\n```\n\n10. HTML转义：react会将所有显示到DOM的字符串转义，防止xss\n\n### react数据流\n\n#### state\n\n- 使用setState更新state\n\n#### props\n\n- 是properties的简写\n- props默认值\n\n```\nimport React,{Component} from 'react'\n\nexport default class DefaultProps extends Component{\n    static defaultProps = {\n        name: '123'\n    }\n    render(){\n        return(\n            <div>{this.props.name}</div>\n        )\n    }\n}\n```\n\n- 子组件prop--children：代表组件的子组件集合\n- 组件props：props可以传入DOM节点，组件节点\n- 子组件修改props，通过父组件传递的prop函数修改\n\n### react生命周期\n\n```\ncomponentWillMount(){\n}\ncomponentDidMount(){\n}\ncomponentWillUnmount(){\n}\ncomponentWillReceiveProps(nextProps){\n}\nshouldComponentUpdate(nextProps, nextState) {\n    return true\n}\ncomponentWillUpdate(nextProps, nextState){\n}\ncomponentDidUpdate(prevProps, prevState) {\n}\n```\n\n#### 组件挂载时\n\n- componentWillMount与componentDidMount会在初始化时运行一次\n- 如果在componentDidMount中运行setState那么组件会再次更新，在初始化过程中会渲染两次组件\n\n#### 组件卸载时\n\n- componentWillUnmount执行，可以执行一些清理方法，比如时间回收、定时器清除\n\n#### 组件自身state更新\n\n- 会依次执行shouldComponentUpdate、componentWillUpdate、componentDidUpdate\n- shouldComponentUpdate接收需要更新的props和state，可以通过返回true/false判断是否更新组件\n- 注意：不能在componentWillUpdate中执行setState\n\n#### 父组件更新props的更新\n\n- 依次执行componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、componentDidUpdate\n\n### ReactDom\n\n### 事件系统\n\n#### 合成事件\n\n- React基于Virtual DOM实现了合成事件\n- 合成事件支持事件冒泡机制，可以使用stoPropagation()和preventDefault()中断\n- JSX中必须使用小驼峰书写事件属性名：onClick\n- 合成事件实现机制\n\n1. 事件委托：react不会把事件处理直接绑定到真实节点上，而是把所有事件绑定到结构的最外层，使用统一的事件监听器，简化了事件处理和回收机制，提升效率。\n2. 自动绑定：使用ES6 class和纯函数时，事件方法上下文不会指向该组件，需要手动绑定this\n\n```\n//bing绑定\nrender(){\n    return(\n        <div onClick={this.clickFun.bind(this)}>son</div>\n    )\n}\n//只绑定、不传参可以使用双冒号方法\nrender(){\n    return(\n        <div onClick={::this.clickFun}>son</div>\n    )\n}\n//构造器内声明\nconstructor(props){\n    super(props)\n    this.clickFun = this.clickFun.bind(this)\n}\n//箭头函数\nrender(){\n    return(\n        <div onClick=()=>{this.clickFun()}>son</div>\n    )\n}\n```\n\n#### 原生事件\n\n- componentDidMount中可以绑定原生事件\n- 注意一定要手动移除原生事件绑定，否则会造成内存泄漏\n\n```\ncomponentWillUnmount(){\n    this.refs.button.removeEventListener('click')\n}\n```\n\n#### 合成与原生混用\n\n- 绑定相同元素原生事件先调用\n- 合成事件阻止冒泡只对合成事件起作用\n- 原生事件阻止冒泡会影响合成事件\n\n### 组件建通信\n\n#### 父向子通信\n\n- 通过props传递\n\n#### 子向父\n\n- 利用回调函数：\n- 利用自定义事件机制：\n\n#### 跨级通信\n\n- 使用context实现：\n\n#### 没有嵌套关系的组件通信\n\n- 使用EventEmitter\n\n```\n//event.js\nimport {EventEmitter} from 'events'\nexport default new EventEmitter()\n```\n```\n//组件中使用\nimport React,{Component} from 'react'\nimport emitter from '../common/event'\nexport default class EventEmitter extends Component{\n    componentDidMount() {\n        this.myEvent = function(res){\n            console.log(res)\n        }\n        emitter.on('my-event',this.myEvent)\n    }\n    componentWillUnmount() {\n        if(this.myEvent){\n            emitter.removeListener('my-event',this.myEvent)\n        }\n    }\n    emitData(){\n        emitter.emit('my-event',123)\n    }\n    render(){\n        return(\n            <div>\n                <button type=\"button\" onClick={()=>{this.emitData()}}>emit</button>\n            </div>\n        )\n    }\n}\n```\n\n### 组件间抽象\n\n#### mixin\n\n1. 使用createClass构建组件时提供了mixin属性\n\n- 官方pureRenderMixin\n- 如果是React的生命周期方法，会叠加在一起顺序执行\n- React中不允许出现普通方法的mixin，会包ReactClassInterface错误\n- createClass使用mixin做了两件事：1.共享工具方法 2.生命周期继承（props与state合并，生命周期方法合并）\n\n2. ES6 Classes与decorator\n\n- ES6可以使用[decorator](http://caibaojian.com/es6/decorator.html)实现mixin\n\n#### mixin存在的问题\n\n- 破坏原有组件封装性，需要维护‘不可见’状态\n- 命名冲突，尤其对于第三方引用\n- 增加复杂性，生命周期过多\n\n### 高阶组件\n\n- 高阶函数：函数接收函数作为输入，或者输出一个函数\n- 高阶组件会返回一个增强的React组件\n\n#### 属性代理\n\n```\nimport React,{Component} from 'react'\nclass HigherOrder extends Component{\n    render(){\n        return(\n            <div>\n                <p>456</p>\n            </div>\n        )\n    }\n}\nconst MyContainer = (WrappedComponent)=>{\n    return class ContainerComponent extends Component {\n        //获取子组件引用\n        proc(comObj){\n            console.log(comObj)\n        }\n        render(){\n            const props = Object.assign({},this.props,{\n                ref: this.proc.bind(this)\n            })\n            return (\n                <div>\n                    <span>123</span>\n                    <WrappedComponent {...props}></WrappedComponent>\n                </div>\n            )\n        }\n    }\n}\nexport default MyContainer(HigherOrder)\n```\n\n- 可以通过高阶组件传递props，这种方式成为属性代理\n- 原始组件具备高阶组件对他的修饰，保持单个组件的封装同时还保持了易用性\n- 功能\n\n1. 控制props\n2. 通过refs使用引用\n3. 抽象state\n4. 使用其他元素包裹WrappedComponent\n\n#### 反向继承\n\n```\nimport React,{Component} from 'react'\nclass Super extends Component{\n    constructor(props){\n        super(props)\n        this.state = {\n            show: true\n        }\n    }\n    render(){\n        return(\n            <div>123</div>\n        )\n    }\n}\nclass Sub extends Super{\n    changeState(){\n        this.setState({\n            show: !this.state.show\n        })\n    }\n    render(){\n        return(\n            <div>\n                <button type=\"button\" onClick={()=>{this.changeState()}}>toggle</button>\n                {this.state.show ? super.render() : ''}\n            </div>\n        )\n    }\n}\nexport default Sub\n```\n\n- 渲染劫持\n- 控制state\n\n#### 高阶组件命名\n\n- 高阶组件会失去原始WrappedComponent的displayName\n- 可以参照react-redux中getDiaplayName实现\n- 可以使用[recompose](https://github.com/acdlite/recompose)库，已经停止更新。。。可以使用Hooks解决这些问题\n\n#### 高阶组件参数\n\n- 使用闭包传参\n\n### PureRender\n\n#### 纯函数\n\n- 三大原则：1.给定相同的输入，总是返回相同的输出 2.过程没有副作用（不改变外部状态） 3.没有额外的状态依赖（不与第三方共享变量）\n\n- 组件满足纯函数条件：被相同的props和state渲染得到相同的结果\n\n### Hooks\n\n#### useState\n\n```\nimport React, { useState,useEffect } from \"react\";\nfunction MyStateHook(props) {\n    const [num,setNum] = useState(1)\n    return(\n        <div>\n            <p>{num}</p>\n            <button type=\"button\" onClick={()=>{setNum(num+1)}}>num+1</button>\n        </div>\n    )\n}\n```\n\n#### useEffect\n\n```\nimport React, { useState,useEffect } from \"react\";\nfunction MyEffetHook(props) {\n    const [num,setNum] = useState(1)\n    useEffect(()=>{\n        if(num == 1){\n            setTimeout(()=>{\n                setNum(2)\n            },1000)\n        }\n        //componentWillUnmount时调用\n        return ()=>{\n        }\n    },[])//第二个参数传递一个数组，在这些值没有更改时不会触发，如果传空数组，相当于只在componentDidMount触发\n\n    return(\n        <div>\n            <p>{num}</p>\n            <button type=\"button\" onClick={()=>{setNum(1)}}>num+1</button>\n        </div>\n    )\n}\n```\n\n","source":"_posts/[react]学习笔记.md","raw":"---\ntitle: <react>学习笔记\ndate: 2019-03-27 00:00:00\ntags: [js,react]\ncategories: react\n---\n\n### JSX\n\n1. 最外层只允许被一个标签包裹\n2. 标签一定要闭合\n3. DOM元素和组件元素（组件元素要大写开头）,也可以使用命名空间方式使用组件(<MUI.Button />)\n4. 注释：\n\n```\n{/* 注释 */}\n/*\n多行注释\n*/\n```\n\n5. 元素属性：特殊：class->calssName  for->htmlfor，自定义属性需要小驼峰写法\n6. Boolean 属性：省略的话默认为true 比如 disabled\n7. 展开属性：<Component {...data} />，使用ES6展开运算符\n8. DOM元素自定义HTML属性： data- 无障碍属性 aria-\n9. JavaScript属性表达式：\n\n```\nconst person = <Person name={window.isLoggedIn ? window.name : ''} />\n```\n\n10. HTML转义：react会将所有显示到DOM的字符串转义，防止xss\n\n### react数据流\n\n#### state\n\n- 使用setState更新state\n\n#### props\n\n- 是properties的简写\n- props默认值\n\n```\nimport React,{Component} from 'react'\n\nexport default class DefaultProps extends Component{\n    static defaultProps = {\n        name: '123'\n    }\n    render(){\n        return(\n            <div>{this.props.name}</div>\n        )\n    }\n}\n```\n\n- 子组件prop--children：代表组件的子组件集合\n- 组件props：props可以传入DOM节点，组件节点\n- 子组件修改props，通过父组件传递的prop函数修改\n\n### react生命周期\n\n```\ncomponentWillMount(){\n}\ncomponentDidMount(){\n}\ncomponentWillUnmount(){\n}\ncomponentWillReceiveProps(nextProps){\n}\nshouldComponentUpdate(nextProps, nextState) {\n    return true\n}\ncomponentWillUpdate(nextProps, nextState){\n}\ncomponentDidUpdate(prevProps, prevState) {\n}\n```\n\n#### 组件挂载时\n\n- componentWillMount与componentDidMount会在初始化时运行一次\n- 如果在componentDidMount中运行setState那么组件会再次更新，在初始化过程中会渲染两次组件\n\n#### 组件卸载时\n\n- componentWillUnmount执行，可以执行一些清理方法，比如时间回收、定时器清除\n\n#### 组件自身state更新\n\n- 会依次执行shouldComponentUpdate、componentWillUpdate、componentDidUpdate\n- shouldComponentUpdate接收需要更新的props和state，可以通过返回true/false判断是否更新组件\n- 注意：不能在componentWillUpdate中执行setState\n\n#### 父组件更新props的更新\n\n- 依次执行componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、componentDidUpdate\n\n### ReactDom\n\n### 事件系统\n\n#### 合成事件\n\n- React基于Virtual DOM实现了合成事件\n- 合成事件支持事件冒泡机制，可以使用stoPropagation()和preventDefault()中断\n- JSX中必须使用小驼峰书写事件属性名：onClick\n- 合成事件实现机制\n\n1. 事件委托：react不会把事件处理直接绑定到真实节点上，而是把所有事件绑定到结构的最外层，使用统一的事件监听器，简化了事件处理和回收机制，提升效率。\n2. 自动绑定：使用ES6 class和纯函数时，事件方法上下文不会指向该组件，需要手动绑定this\n\n```\n//bing绑定\nrender(){\n    return(\n        <div onClick={this.clickFun.bind(this)}>son</div>\n    )\n}\n//只绑定、不传参可以使用双冒号方法\nrender(){\n    return(\n        <div onClick={::this.clickFun}>son</div>\n    )\n}\n//构造器内声明\nconstructor(props){\n    super(props)\n    this.clickFun = this.clickFun.bind(this)\n}\n//箭头函数\nrender(){\n    return(\n        <div onClick=()=>{this.clickFun()}>son</div>\n    )\n}\n```\n\n#### 原生事件\n\n- componentDidMount中可以绑定原生事件\n- 注意一定要手动移除原生事件绑定，否则会造成内存泄漏\n\n```\ncomponentWillUnmount(){\n    this.refs.button.removeEventListener('click')\n}\n```\n\n#### 合成与原生混用\n\n- 绑定相同元素原生事件先调用\n- 合成事件阻止冒泡只对合成事件起作用\n- 原生事件阻止冒泡会影响合成事件\n\n### 组件建通信\n\n#### 父向子通信\n\n- 通过props传递\n\n#### 子向父\n\n- 利用回调函数：\n- 利用自定义事件机制：\n\n#### 跨级通信\n\n- 使用context实现：\n\n#### 没有嵌套关系的组件通信\n\n- 使用EventEmitter\n\n```\n//event.js\nimport {EventEmitter} from 'events'\nexport default new EventEmitter()\n```\n```\n//组件中使用\nimport React,{Component} from 'react'\nimport emitter from '../common/event'\nexport default class EventEmitter extends Component{\n    componentDidMount() {\n        this.myEvent = function(res){\n            console.log(res)\n        }\n        emitter.on('my-event',this.myEvent)\n    }\n    componentWillUnmount() {\n        if(this.myEvent){\n            emitter.removeListener('my-event',this.myEvent)\n        }\n    }\n    emitData(){\n        emitter.emit('my-event',123)\n    }\n    render(){\n        return(\n            <div>\n                <button type=\"button\" onClick={()=>{this.emitData()}}>emit</button>\n            </div>\n        )\n    }\n}\n```\n\n### 组件间抽象\n\n#### mixin\n\n1. 使用createClass构建组件时提供了mixin属性\n\n- 官方pureRenderMixin\n- 如果是React的生命周期方法，会叠加在一起顺序执行\n- React中不允许出现普通方法的mixin，会包ReactClassInterface错误\n- createClass使用mixin做了两件事：1.共享工具方法 2.生命周期继承（props与state合并，生命周期方法合并）\n\n2. ES6 Classes与decorator\n\n- ES6可以使用[decorator](http://caibaojian.com/es6/decorator.html)实现mixin\n\n#### mixin存在的问题\n\n- 破坏原有组件封装性，需要维护‘不可见’状态\n- 命名冲突，尤其对于第三方引用\n- 增加复杂性，生命周期过多\n\n### 高阶组件\n\n- 高阶函数：函数接收函数作为输入，或者输出一个函数\n- 高阶组件会返回一个增强的React组件\n\n#### 属性代理\n\n```\nimport React,{Component} from 'react'\nclass HigherOrder extends Component{\n    render(){\n        return(\n            <div>\n                <p>456</p>\n            </div>\n        )\n    }\n}\nconst MyContainer = (WrappedComponent)=>{\n    return class ContainerComponent extends Component {\n        //获取子组件引用\n        proc(comObj){\n            console.log(comObj)\n        }\n        render(){\n            const props = Object.assign({},this.props,{\n                ref: this.proc.bind(this)\n            })\n            return (\n                <div>\n                    <span>123</span>\n                    <WrappedComponent {...props}></WrappedComponent>\n                </div>\n            )\n        }\n    }\n}\nexport default MyContainer(HigherOrder)\n```\n\n- 可以通过高阶组件传递props，这种方式成为属性代理\n- 原始组件具备高阶组件对他的修饰，保持单个组件的封装同时还保持了易用性\n- 功能\n\n1. 控制props\n2. 通过refs使用引用\n3. 抽象state\n4. 使用其他元素包裹WrappedComponent\n\n#### 反向继承\n\n```\nimport React,{Component} from 'react'\nclass Super extends Component{\n    constructor(props){\n        super(props)\n        this.state = {\n            show: true\n        }\n    }\n    render(){\n        return(\n            <div>123</div>\n        )\n    }\n}\nclass Sub extends Super{\n    changeState(){\n        this.setState({\n            show: !this.state.show\n        })\n    }\n    render(){\n        return(\n            <div>\n                <button type=\"button\" onClick={()=>{this.changeState()}}>toggle</button>\n                {this.state.show ? super.render() : ''}\n            </div>\n        )\n    }\n}\nexport default Sub\n```\n\n- 渲染劫持\n- 控制state\n\n#### 高阶组件命名\n\n- 高阶组件会失去原始WrappedComponent的displayName\n- 可以参照react-redux中getDiaplayName实现\n- 可以使用[recompose](https://github.com/acdlite/recompose)库，已经停止更新。。。可以使用Hooks解决这些问题\n\n#### 高阶组件参数\n\n- 使用闭包传参\n\n### PureRender\n\n#### 纯函数\n\n- 三大原则：1.给定相同的输入，总是返回相同的输出 2.过程没有副作用（不改变外部状态） 3.没有额外的状态依赖（不与第三方共享变量）\n\n- 组件满足纯函数条件：被相同的props和state渲染得到相同的结果\n\n### Hooks\n\n#### useState\n\n```\nimport React, { useState,useEffect } from \"react\";\nfunction MyStateHook(props) {\n    const [num,setNum] = useState(1)\n    return(\n        <div>\n            <p>{num}</p>\n            <button type=\"button\" onClick={()=>{setNum(num+1)}}>num+1</button>\n        </div>\n    )\n}\n```\n\n#### useEffect\n\n```\nimport React, { useState,useEffect } from \"react\";\nfunction MyEffetHook(props) {\n    const [num,setNum] = useState(1)\n    useEffect(()=>{\n        if(num == 1){\n            setTimeout(()=>{\n                setNum(2)\n            },1000)\n        }\n        //componentWillUnmount时调用\n        return ()=>{\n        }\n    },[])//第二个参数传递一个数组，在这些值没有更改时不会触发，如果传空数组，相当于只在componentDidMount触发\n\n    return(\n        <div>\n            <p>{num}</p>\n            <button type=\"button\" onClick={()=>{setNum(1)}}>num+1</button>\n        </div>\n    )\n}\n```\n\n","slug":"[react]学习笔记","published":1,"updated":"2021-03-15T14:40:30.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dl5003dwotj1u76b69n","content":"<h3 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h3><ol>\n<li>最外层只允许被一个标签包裹</li>\n<li>标签一定要闭合</li>\n<li>DOM元素和组件元素（组件元素要大写开头）,也可以使用命名空间方式使用组件(&lt;MUI.Button /&gt;)</li>\n<li>注释：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#x2F;* 注释 *&#x2F;&#125;</span><br><span class=\"line\">&#x2F;*</span><br><span class=\"line\">多行注释</span><br><span class=\"line\">*&#x2F;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>元素属性：特殊：class-&gt;calssName  for-&gt;htmlfor，自定义属性需要小驼峰写法</li>\n<li>Boolean 属性：省略的话默认为true 比如 disabled</li>\n<li>展开属性：&lt;Component {…data} /&gt;，使用ES6展开运算符</li>\n<li>DOM元素自定义HTML属性： data- 无障碍属性 aria-</li>\n<li>JavaScript属性表达式：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const person &#x3D; &lt;Person name&#x3D;&#123;window.isLoggedIn ? window.name : &#39;&#39;&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li>HTML转义：react会将所有显示到DOM的字符串转义，防止xss</li>\n</ol>\n<h3 id=\"react数据流\"><a href=\"#react数据流\" class=\"headerlink\" title=\"react数据流\"></a>react数据流</h3><h4 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h4><ul>\n<li>使用setState更新state</li>\n</ul>\n<h4 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h4><ul>\n<li>是properties的简写</li>\n<li>props默认值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React,&#123;Component&#125; from &#39;react&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">export default class DefaultProps extends Component&#123;</span><br><span class=\"line\">    static defaultProps &#x3D; &#123;</span><br><span class=\"line\">        name: &#39;123&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return(</span><br><span class=\"line\">            &lt;div&gt;&#123;this.props.name&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>子组件prop–children：代表组件的子组件集合</li>\n<li>组件props：props可以传入DOM节点，组件节点</li>\n<li>子组件修改props，通过父组件传递的prop函数修改</li>\n</ul>\n<h3 id=\"react生命周期\"><a href=\"#react生命周期\" class=\"headerlink\" title=\"react生命周期\"></a>react生命周期</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentWillMount()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">componentDidMount()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">componentWillUnmount()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">componentWillReceiveProps(nextProps)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class=\"line\">    return true</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">componentWillUpdate(nextProps, nextState)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"组件挂载时\"><a href=\"#组件挂载时\" class=\"headerlink\" title=\"组件挂载时\"></a>组件挂载时</h4><ul>\n<li>componentWillMount与componentDidMount会在初始化时运行一次</li>\n<li>如果在componentDidMount中运行setState那么组件会再次更新，在初始化过程中会渲染两次组件</li>\n</ul>\n<h4 id=\"组件卸载时\"><a href=\"#组件卸载时\" class=\"headerlink\" title=\"组件卸载时\"></a>组件卸载时</h4><ul>\n<li>componentWillUnmount执行，可以执行一些清理方法，比如时间回收、定时器清除</li>\n</ul>\n<h4 id=\"组件自身state更新\"><a href=\"#组件自身state更新\" class=\"headerlink\" title=\"组件自身state更新\"></a>组件自身state更新</h4><ul>\n<li>会依次执行shouldComponentUpdate、componentWillUpdate、componentDidUpdate</li>\n<li>shouldComponentUpdate接收需要更新的props和state，可以通过返回true/false判断是否更新组件</li>\n<li>注意：不能在componentWillUpdate中执行setState</li>\n</ul>\n<h4 id=\"父组件更新props的更新\"><a href=\"#父组件更新props的更新\" class=\"headerlink\" title=\"父组件更新props的更新\"></a>父组件更新props的更新</h4><ul>\n<li>依次执行componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、componentDidUpdate</li>\n</ul>\n<h3 id=\"ReactDom\"><a href=\"#ReactDom\" class=\"headerlink\" title=\"ReactDom\"></a>ReactDom</h3><h3 id=\"事件系统\"><a href=\"#事件系统\" class=\"headerlink\" title=\"事件系统\"></a>事件系统</h3><h4 id=\"合成事件\"><a href=\"#合成事件\" class=\"headerlink\" title=\"合成事件\"></a>合成事件</h4><ul>\n<li>React基于Virtual DOM实现了合成事件</li>\n<li>合成事件支持事件冒泡机制，可以使用stoPropagation()和preventDefault()中断</li>\n<li>JSX中必须使用小驼峰书写事件属性名：onClick</li>\n<li>合成事件实现机制</li>\n</ul>\n<ol>\n<li>事件委托：react不会把事件处理直接绑定到真实节点上，而是把所有事件绑定到结构的最外层，使用统一的事件监听器，简化了事件处理和回收机制，提升效率。</li>\n<li>自动绑定：使用ES6 class和纯函数时，事件方法上下文不会指向该组件，需要手动绑定this</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;bing绑定</span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    return(</span><br><span class=\"line\">        &lt;div onClick&#x3D;&#123;this.clickFun.bind(this)&#125;&gt;son&lt;&#x2F;div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;只绑定、不传参可以使用双冒号方法</span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    return(</span><br><span class=\"line\">        &lt;div onClick&#x3D;&#123;::this.clickFun&#125;&gt;son&lt;&#x2F;div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;构造器内声明</span><br><span class=\"line\">constructor(props)&#123;</span><br><span class=\"line\">    super(props)</span><br><span class=\"line\">    this.clickFun &#x3D; this.clickFun.bind(this)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;箭头函数</span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    return(</span><br><span class=\"line\">        &lt;div onClick&#x3D;()&#x3D;&gt;&#123;this.clickFun()&#125;&gt;son&lt;&#x2F;div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原生事件\"><a href=\"#原生事件\" class=\"headerlink\" title=\"原生事件\"></a>原生事件</h4><ul>\n<li>componentDidMount中可以绑定原生事件</li>\n<li>注意一定要手动移除原生事件绑定，否则会造成内存泄漏</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentWillUnmount()&#123;</span><br><span class=\"line\">    this.refs.button.removeEventListener(&#39;click&#39;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"合成与原生混用\"><a href=\"#合成与原生混用\" class=\"headerlink\" title=\"合成与原生混用\"></a>合成与原生混用</h4><ul>\n<li>绑定相同元素原生事件先调用</li>\n<li>合成事件阻止冒泡只对合成事件起作用</li>\n<li>原生事件阻止冒泡会影响合成事件</li>\n</ul>\n<h3 id=\"组件建通信\"><a href=\"#组件建通信\" class=\"headerlink\" title=\"组件建通信\"></a>组件建通信</h3><h4 id=\"父向子通信\"><a href=\"#父向子通信\" class=\"headerlink\" title=\"父向子通信\"></a>父向子通信</h4><ul>\n<li>通过props传递</li>\n</ul>\n<h4 id=\"子向父\"><a href=\"#子向父\" class=\"headerlink\" title=\"子向父\"></a>子向父</h4><ul>\n<li>利用回调函数：</li>\n<li>利用自定义事件机制：</li>\n</ul>\n<h4 id=\"跨级通信\"><a href=\"#跨级通信\" class=\"headerlink\" title=\"跨级通信\"></a>跨级通信</h4><ul>\n<li>使用context实现：</li>\n</ul>\n<h4 id=\"没有嵌套关系的组件通信\"><a href=\"#没有嵌套关系的组件通信\" class=\"headerlink\" title=\"没有嵌套关系的组件通信\"></a>没有嵌套关系的组件通信</h4><ul>\n<li>使用EventEmitter</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;event.js</span><br><span class=\"line\">import &#123;EventEmitter&#125; from &#39;events&#39;</span><br><span class=\"line\">export default new EventEmitter()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;组件中使用</span><br><span class=\"line\">import React,&#123;Component&#125; from &#39;react&#39;</span><br><span class=\"line\">import emitter from &#39;..&#x2F;common&#x2F;event&#39;</span><br><span class=\"line\">export default class EventEmitter extends Component&#123;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        this.myEvent &#x3D; function(res)&#123;</span><br><span class=\"line\">            console.log(res)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        emitter.on(&#39;my-event&#39;,this.myEvent)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">        if(this.myEvent)&#123;</span><br><span class=\"line\">            emitter.removeListener(&#39;my-event&#39;,this.myEvent)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    emitData()&#123;</span><br><span class=\"line\">        emitter.emit(&#39;my-event&#39;,123)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return(</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;()&#x3D;&gt;&#123;this.emitData()&#125;&#125;&gt;emit&lt;&#x2F;button&gt;</span><br><span class=\"line\">            &lt;&#x2F;div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"组件间抽象\"><a href=\"#组件间抽象\" class=\"headerlink\" title=\"组件间抽象\"></a>组件间抽象</h3><h4 id=\"mixin\"><a href=\"#mixin\" class=\"headerlink\" title=\"mixin\"></a>mixin</h4><ol>\n<li>使用createClass构建组件时提供了mixin属性</li>\n</ol>\n<ul>\n<li>官方pureRenderMixin</li>\n<li>如果是React的生命周期方法，会叠加在一起顺序执行</li>\n<li>React中不允许出现普通方法的mixin，会包ReactClassInterface错误</li>\n<li>createClass使用mixin做了两件事：1.共享工具方法 2.生命周期继承（props与state合并，生命周期方法合并）</li>\n</ul>\n<ol start=\"2\">\n<li>ES6 Classes与decorator</li>\n</ol>\n<ul>\n<li>ES6可以使用<a href=\"http://caibaojian.com/es6/decorator.html\">decorator</a>实现mixin</li>\n</ul>\n<h4 id=\"mixin存在的问题\"><a href=\"#mixin存在的问题\" class=\"headerlink\" title=\"mixin存在的问题\"></a>mixin存在的问题</h4><ul>\n<li>破坏原有组件封装性，需要维护‘不可见’状态</li>\n<li>命名冲突，尤其对于第三方引用</li>\n<li>增加复杂性，生命周期过多</li>\n</ul>\n<h3 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h3><ul>\n<li>高阶函数：函数接收函数作为输入，或者输出一个函数</li>\n<li>高阶组件会返回一个增强的React组件</li>\n</ul>\n<h4 id=\"属性代理\"><a href=\"#属性代理\" class=\"headerlink\" title=\"属性代理\"></a>属性代理</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React,&#123;Component&#125; from &#39;react&#39;</span><br><span class=\"line\">class HigherOrder extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return(</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;p&gt;456&lt;&#x2F;p&gt;</span><br><span class=\"line\">            &lt;&#x2F;div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const MyContainer &#x3D; (WrappedComponent)&#x3D;&gt;&#123;</span><br><span class=\"line\">    return class ContainerComponent extends Component &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;获取子组件引用</span><br><span class=\"line\">        proc(comObj)&#123;</span><br><span class=\"line\">            console.log(comObj)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        render()&#123;</span><br><span class=\"line\">            const props &#x3D; Object.assign(&#123;&#125;,this.props,&#123;</span><br><span class=\"line\">                ref: this.proc.bind(this)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            return (</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;span&gt;123&lt;&#x2F;span&gt;</span><br><span class=\"line\">                    &lt;WrappedComponent &#123;...props&#125;&gt;&lt;&#x2F;WrappedComponent&gt;</span><br><span class=\"line\">                &lt;&#x2F;div&gt;</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default MyContainer(HigherOrder)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以通过高阶组件传递props，这种方式成为属性代理</li>\n<li>原始组件具备高阶组件对他的修饰，保持单个组件的封装同时还保持了易用性</li>\n<li>功能</li>\n</ul>\n<ol>\n<li>控制props</li>\n<li>通过refs使用引用</li>\n<li>抽象state</li>\n<li>使用其他元素包裹WrappedComponent</li>\n</ol>\n<h4 id=\"反向继承\"><a href=\"#反向继承\" class=\"headerlink\" title=\"反向继承\"></a>反向继承</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React,&#123;Component&#125; from &#39;react&#39;</span><br><span class=\"line\">class Super extends Component&#123;</span><br><span class=\"line\">    constructor(props)&#123;</span><br><span class=\"line\">        super(props)</span><br><span class=\"line\">        this.state &#x3D; &#123;</span><br><span class=\"line\">            show: true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return(</span><br><span class=\"line\">            &lt;div&gt;123&lt;&#x2F;div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Sub extends Super&#123;</span><br><span class=\"line\">    changeState()&#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            show: !this.state.show</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return(</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;()&#x3D;&gt;&#123;this.changeState()&#125;&#125;&gt;toggle&lt;&#x2F;button&gt;</span><br><span class=\"line\">                &#123;this.state.show ? super.render() : &#39;&#39;&#125;</span><br><span class=\"line\">            &lt;&#x2F;div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default Sub</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>渲染劫持</li>\n<li>控制state</li>\n</ul>\n<h4 id=\"高阶组件命名\"><a href=\"#高阶组件命名\" class=\"headerlink\" title=\"高阶组件命名\"></a>高阶组件命名</h4><ul>\n<li>高阶组件会失去原始WrappedComponent的displayName</li>\n<li>可以参照react-redux中getDiaplayName实现</li>\n<li>可以使用<a href=\"https://github.com/acdlite/recompose\">recompose</a>库，已经停止更新。。。可以使用Hooks解决这些问题</li>\n</ul>\n<h4 id=\"高阶组件参数\"><a href=\"#高阶组件参数\" class=\"headerlink\" title=\"高阶组件参数\"></a>高阶组件参数</h4><ul>\n<li>使用闭包传参</li>\n</ul>\n<h3 id=\"PureRender\"><a href=\"#PureRender\" class=\"headerlink\" title=\"PureRender\"></a>PureRender</h3><h4 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h4><ul>\n<li><p>三大原则：1.给定相同的输入，总是返回相同的输出 2.过程没有副作用（不改变外部状态） 3.没有额外的状态依赖（不与第三方共享变量）</p>\n</li>\n<li><p>组件满足纯函数条件：被相同的props和state渲染得到相同的结果</p>\n</li>\n</ul>\n<h3 id=\"Hooks\"><a href=\"#Hooks\" class=\"headerlink\" title=\"Hooks\"></a>Hooks</h3><h4 id=\"useState\"><a href=\"#useState\" class=\"headerlink\" title=\"useState\"></a>useState</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; useState,useEffect &#125; from &quot;react&quot;;</span><br><span class=\"line\">function MyStateHook(props) &#123;</span><br><span class=\"line\">    const [num,setNum] &#x3D; useState(1)</span><br><span class=\"line\">    return(</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;&#123;num&#125;&lt;&#x2F;p&gt;</span><br><span class=\"line\">            &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;()&#x3D;&gt;&#123;setNum(num+1)&#125;&#125;&gt;num+1&lt;&#x2F;button&gt;</span><br><span class=\"line\">        &lt;&#x2F;div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"useEffect\"><a href=\"#useEffect\" class=\"headerlink\" title=\"useEffect\"></a>useEffect</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; useState,useEffect &#125; from &quot;react&quot;;</span><br><span class=\"line\">function MyEffetHook(props) &#123;</span><br><span class=\"line\">    const [num,setNum] &#x3D; useState(1)</span><br><span class=\"line\">    useEffect(()&#x3D;&gt;&#123;</span><br><span class=\"line\">        if(num &#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">            setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">                setNum(2)</span><br><span class=\"line\">            &#125;,1000)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;componentWillUnmount时调用</span><br><span class=\"line\">        return ()&#x3D;&gt;&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,[])&#x2F;&#x2F;第二个参数传递一个数组，在这些值没有更改时不会触发，如果传空数组，相当于只在componentDidMount触发</span><br><span class=\"line\"></span><br><span class=\"line\">    return(</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;&#123;num&#125;&lt;&#x2F;p&gt;</span><br><span class=\"line\">            &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;()&#x3D;&gt;&#123;setNum(1)&#125;&#125;&gt;num+1&lt;&#x2F;button&gt;</span><br><span class=\"line\">        &lt;&#x2F;div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"JSX\"><a href=\"#JSX\" class=\"headerlink\" title=\"JSX\"></a>JSX</h3><ol>\n<li>最外层只允许被一个标签包裹</li>\n<li>标签一定要闭合</li>\n<li>DOM元素和组件元素（组件元素要大写开头）,也可以使用命名空间方式使用组件(&lt;MUI.Button /&gt;)</li>\n<li>注释：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;&#x2F;* 注释 *&#x2F;&#125;</span><br><span class=\"line\">&#x2F;*</span><br><span class=\"line\">多行注释</span><br><span class=\"line\">*&#x2F;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>元素属性：特殊：class-&gt;calssName  for-&gt;htmlfor，自定义属性需要小驼峰写法</li>\n<li>Boolean 属性：省略的话默认为true 比如 disabled</li>\n<li>展开属性：&lt;Component {…data} /&gt;，使用ES6展开运算符</li>\n<li>DOM元素自定义HTML属性： data- 无障碍属性 aria-</li>\n<li>JavaScript属性表达式：</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const person &#x3D; &lt;Person name&#x3D;&#123;window.isLoggedIn ? window.name : &#39;&#39;&#125; &#x2F;&gt;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"10\">\n<li>HTML转义：react会将所有显示到DOM的字符串转义，防止xss</li>\n</ol>\n<h3 id=\"react数据流\"><a href=\"#react数据流\" class=\"headerlink\" title=\"react数据流\"></a>react数据流</h3><h4 id=\"state\"><a href=\"#state\" class=\"headerlink\" title=\"state\"></a>state</h4><ul>\n<li>使用setState更新state</li>\n</ul>\n<h4 id=\"props\"><a href=\"#props\" class=\"headerlink\" title=\"props\"></a>props</h4><ul>\n<li>是properties的简写</li>\n<li>props默认值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React,&#123;Component&#125; from &#39;react&#39;</span><br><span class=\"line\"></span><br><span class=\"line\">export default class DefaultProps extends Component&#123;</span><br><span class=\"line\">    static defaultProps &#x3D; &#123;</span><br><span class=\"line\">        name: &#39;123&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return(</span><br><span class=\"line\">            &lt;div&gt;&#123;this.props.name&#125;&lt;&#x2F;div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>子组件prop–children：代表组件的子组件集合</li>\n<li>组件props：props可以传入DOM节点，组件节点</li>\n<li>子组件修改props，通过父组件传递的prop函数修改</li>\n</ul>\n<h3 id=\"react生命周期\"><a href=\"#react生命周期\" class=\"headerlink\" title=\"react生命周期\"></a>react生命周期</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentWillMount()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">componentDidMount()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">componentWillUnmount()&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">componentWillReceiveProps(nextProps)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">shouldComponentUpdate(nextProps, nextState) &#123;</span><br><span class=\"line\">    return true</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">componentWillUpdate(nextProps, nextState)&#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">componentDidUpdate(prevProps, prevState) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"组件挂载时\"><a href=\"#组件挂载时\" class=\"headerlink\" title=\"组件挂载时\"></a>组件挂载时</h4><ul>\n<li>componentWillMount与componentDidMount会在初始化时运行一次</li>\n<li>如果在componentDidMount中运行setState那么组件会再次更新，在初始化过程中会渲染两次组件</li>\n</ul>\n<h4 id=\"组件卸载时\"><a href=\"#组件卸载时\" class=\"headerlink\" title=\"组件卸载时\"></a>组件卸载时</h4><ul>\n<li>componentWillUnmount执行，可以执行一些清理方法，比如时间回收、定时器清除</li>\n</ul>\n<h4 id=\"组件自身state更新\"><a href=\"#组件自身state更新\" class=\"headerlink\" title=\"组件自身state更新\"></a>组件自身state更新</h4><ul>\n<li>会依次执行shouldComponentUpdate、componentWillUpdate、componentDidUpdate</li>\n<li>shouldComponentUpdate接收需要更新的props和state，可以通过返回true/false判断是否更新组件</li>\n<li>注意：不能在componentWillUpdate中执行setState</li>\n</ul>\n<h4 id=\"父组件更新props的更新\"><a href=\"#父组件更新props的更新\" class=\"headerlink\" title=\"父组件更新props的更新\"></a>父组件更新props的更新</h4><ul>\n<li>依次执行componentWillReceiveProps、shouldComponentUpdate、componentWillUpdate、componentDidUpdate</li>\n</ul>\n<h3 id=\"ReactDom\"><a href=\"#ReactDom\" class=\"headerlink\" title=\"ReactDom\"></a>ReactDom</h3><h3 id=\"事件系统\"><a href=\"#事件系统\" class=\"headerlink\" title=\"事件系统\"></a>事件系统</h3><h4 id=\"合成事件\"><a href=\"#合成事件\" class=\"headerlink\" title=\"合成事件\"></a>合成事件</h4><ul>\n<li>React基于Virtual DOM实现了合成事件</li>\n<li>合成事件支持事件冒泡机制，可以使用stoPropagation()和preventDefault()中断</li>\n<li>JSX中必须使用小驼峰书写事件属性名：onClick</li>\n<li>合成事件实现机制</li>\n</ul>\n<ol>\n<li>事件委托：react不会把事件处理直接绑定到真实节点上，而是把所有事件绑定到结构的最外层，使用统一的事件监听器，简化了事件处理和回收机制，提升效率。</li>\n<li>自动绑定：使用ES6 class和纯函数时，事件方法上下文不会指向该组件，需要手动绑定this</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;bing绑定</span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    return(</span><br><span class=\"line\">        &lt;div onClick&#x3D;&#123;this.clickFun.bind(this)&#125;&gt;son&lt;&#x2F;div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;只绑定、不传参可以使用双冒号方法</span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    return(</span><br><span class=\"line\">        &lt;div onClick&#x3D;&#123;::this.clickFun&#125;&gt;son&lt;&#x2F;div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;构造器内声明</span><br><span class=\"line\">constructor(props)&#123;</span><br><span class=\"line\">    super(props)</span><br><span class=\"line\">    this.clickFun &#x3D; this.clickFun.bind(this)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;箭头函数</span><br><span class=\"line\">render()&#123;</span><br><span class=\"line\">    return(</span><br><span class=\"line\">        &lt;div onClick&#x3D;()&#x3D;&gt;&#123;this.clickFun()&#125;&gt;son&lt;&#x2F;div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原生事件\"><a href=\"#原生事件\" class=\"headerlink\" title=\"原生事件\"></a>原生事件</h4><ul>\n<li>componentDidMount中可以绑定原生事件</li>\n<li>注意一定要手动移除原生事件绑定，否则会造成内存泄漏</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">componentWillUnmount()&#123;</span><br><span class=\"line\">    this.refs.button.removeEventListener(&#39;click&#39;)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"合成与原生混用\"><a href=\"#合成与原生混用\" class=\"headerlink\" title=\"合成与原生混用\"></a>合成与原生混用</h4><ul>\n<li>绑定相同元素原生事件先调用</li>\n<li>合成事件阻止冒泡只对合成事件起作用</li>\n<li>原生事件阻止冒泡会影响合成事件</li>\n</ul>\n<h3 id=\"组件建通信\"><a href=\"#组件建通信\" class=\"headerlink\" title=\"组件建通信\"></a>组件建通信</h3><h4 id=\"父向子通信\"><a href=\"#父向子通信\" class=\"headerlink\" title=\"父向子通信\"></a>父向子通信</h4><ul>\n<li>通过props传递</li>\n</ul>\n<h4 id=\"子向父\"><a href=\"#子向父\" class=\"headerlink\" title=\"子向父\"></a>子向父</h4><ul>\n<li>利用回调函数：</li>\n<li>利用自定义事件机制：</li>\n</ul>\n<h4 id=\"跨级通信\"><a href=\"#跨级通信\" class=\"headerlink\" title=\"跨级通信\"></a>跨级通信</h4><ul>\n<li>使用context实现：</li>\n</ul>\n<h4 id=\"没有嵌套关系的组件通信\"><a href=\"#没有嵌套关系的组件通信\" class=\"headerlink\" title=\"没有嵌套关系的组件通信\"></a>没有嵌套关系的组件通信</h4><ul>\n<li>使用EventEmitter</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;event.js</span><br><span class=\"line\">import &#123;EventEmitter&#125; from &#39;events&#39;</span><br><span class=\"line\">export default new EventEmitter()</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;组件中使用</span><br><span class=\"line\">import React,&#123;Component&#125; from &#39;react&#39;</span><br><span class=\"line\">import emitter from &#39;..&#x2F;common&#x2F;event&#39;</span><br><span class=\"line\">export default class EventEmitter extends Component&#123;</span><br><span class=\"line\">    componentDidMount() &#123;</span><br><span class=\"line\">        this.myEvent &#x3D; function(res)&#123;</span><br><span class=\"line\">            console.log(res)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        emitter.on(&#39;my-event&#39;,this.myEvent)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    componentWillUnmount() &#123;</span><br><span class=\"line\">        if(this.myEvent)&#123;</span><br><span class=\"line\">            emitter.removeListener(&#39;my-event&#39;,this.myEvent)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    emitData()&#123;</span><br><span class=\"line\">        emitter.emit(&#39;my-event&#39;,123)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return(</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;()&#x3D;&gt;&#123;this.emitData()&#125;&#125;&gt;emit&lt;&#x2F;button&gt;</span><br><span class=\"line\">            &lt;&#x2F;div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"组件间抽象\"><a href=\"#组件间抽象\" class=\"headerlink\" title=\"组件间抽象\"></a>组件间抽象</h3><h4 id=\"mixin\"><a href=\"#mixin\" class=\"headerlink\" title=\"mixin\"></a>mixin</h4><ol>\n<li>使用createClass构建组件时提供了mixin属性</li>\n</ol>\n<ul>\n<li>官方pureRenderMixin</li>\n<li>如果是React的生命周期方法，会叠加在一起顺序执行</li>\n<li>React中不允许出现普通方法的mixin，会包ReactClassInterface错误</li>\n<li>createClass使用mixin做了两件事：1.共享工具方法 2.生命周期继承（props与state合并，生命周期方法合并）</li>\n</ul>\n<ol start=\"2\">\n<li>ES6 Classes与decorator</li>\n</ol>\n<ul>\n<li>ES6可以使用<a href=\"http://caibaojian.com/es6/decorator.html\">decorator</a>实现mixin</li>\n</ul>\n<h4 id=\"mixin存在的问题\"><a href=\"#mixin存在的问题\" class=\"headerlink\" title=\"mixin存在的问题\"></a>mixin存在的问题</h4><ul>\n<li>破坏原有组件封装性，需要维护‘不可见’状态</li>\n<li>命名冲突，尤其对于第三方引用</li>\n<li>增加复杂性，生命周期过多</li>\n</ul>\n<h3 id=\"高阶组件\"><a href=\"#高阶组件\" class=\"headerlink\" title=\"高阶组件\"></a>高阶组件</h3><ul>\n<li>高阶函数：函数接收函数作为输入，或者输出一个函数</li>\n<li>高阶组件会返回一个增强的React组件</li>\n</ul>\n<h4 id=\"属性代理\"><a href=\"#属性代理\" class=\"headerlink\" title=\"属性代理\"></a>属性代理</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React,&#123;Component&#125; from &#39;react&#39;</span><br><span class=\"line\">class HigherOrder extends Component&#123;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return(</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;p&gt;456&lt;&#x2F;p&gt;</span><br><span class=\"line\">            &lt;&#x2F;div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">const MyContainer &#x3D; (WrappedComponent)&#x3D;&gt;&#123;</span><br><span class=\"line\">    return class ContainerComponent extends Component &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;获取子组件引用</span><br><span class=\"line\">        proc(comObj)&#123;</span><br><span class=\"line\">            console.log(comObj)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        render()&#123;</span><br><span class=\"line\">            const props &#x3D; Object.assign(&#123;&#125;,this.props,&#123;</span><br><span class=\"line\">                ref: this.proc.bind(this)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">            return (</span><br><span class=\"line\">                &lt;div&gt;</span><br><span class=\"line\">                    &lt;span&gt;123&lt;&#x2F;span&gt;</span><br><span class=\"line\">                    &lt;WrappedComponent &#123;...props&#125;&gt;&lt;&#x2F;WrappedComponent&gt;</span><br><span class=\"line\">                &lt;&#x2F;div&gt;</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default MyContainer(HigherOrder)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>可以通过高阶组件传递props，这种方式成为属性代理</li>\n<li>原始组件具备高阶组件对他的修饰，保持单个组件的封装同时还保持了易用性</li>\n<li>功能</li>\n</ul>\n<ol>\n<li>控制props</li>\n<li>通过refs使用引用</li>\n<li>抽象state</li>\n<li>使用其他元素包裹WrappedComponent</li>\n</ol>\n<h4 id=\"反向继承\"><a href=\"#反向继承\" class=\"headerlink\" title=\"反向继承\"></a>反向继承</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React,&#123;Component&#125; from &#39;react&#39;</span><br><span class=\"line\">class Super extends Component&#123;</span><br><span class=\"line\">    constructor(props)&#123;</span><br><span class=\"line\">        super(props)</span><br><span class=\"line\">        this.state &#x3D; &#123;</span><br><span class=\"line\">            show: true</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return(</span><br><span class=\"line\">            &lt;div&gt;123&lt;&#x2F;div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class Sub extends Super&#123;</span><br><span class=\"line\">    changeState()&#123;</span><br><span class=\"line\">        this.setState(&#123;</span><br><span class=\"line\">            show: !this.state.show</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    render()&#123;</span><br><span class=\"line\">        return(</span><br><span class=\"line\">            &lt;div&gt;</span><br><span class=\"line\">                &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;()&#x3D;&gt;&#123;this.changeState()&#125;&#125;&gt;toggle&lt;&#x2F;button&gt;</span><br><span class=\"line\">                &#123;this.state.show ? super.render() : &#39;&#39;&#125;</span><br><span class=\"line\">            &lt;&#x2F;div&gt;</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">export default Sub</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>渲染劫持</li>\n<li>控制state</li>\n</ul>\n<h4 id=\"高阶组件命名\"><a href=\"#高阶组件命名\" class=\"headerlink\" title=\"高阶组件命名\"></a>高阶组件命名</h4><ul>\n<li>高阶组件会失去原始WrappedComponent的displayName</li>\n<li>可以参照react-redux中getDiaplayName实现</li>\n<li>可以使用<a href=\"https://github.com/acdlite/recompose\">recompose</a>库，已经停止更新。。。可以使用Hooks解决这些问题</li>\n</ul>\n<h4 id=\"高阶组件参数\"><a href=\"#高阶组件参数\" class=\"headerlink\" title=\"高阶组件参数\"></a>高阶组件参数</h4><ul>\n<li>使用闭包传参</li>\n</ul>\n<h3 id=\"PureRender\"><a href=\"#PureRender\" class=\"headerlink\" title=\"PureRender\"></a>PureRender</h3><h4 id=\"纯函数\"><a href=\"#纯函数\" class=\"headerlink\" title=\"纯函数\"></a>纯函数</h4><ul>\n<li><p>三大原则：1.给定相同的输入，总是返回相同的输出 2.过程没有副作用（不改变外部状态） 3.没有额外的状态依赖（不与第三方共享变量）</p>\n</li>\n<li><p>组件满足纯函数条件：被相同的props和state渲染得到相同的结果</p>\n</li>\n</ul>\n<h3 id=\"Hooks\"><a href=\"#Hooks\" class=\"headerlink\" title=\"Hooks\"></a>Hooks</h3><h4 id=\"useState\"><a href=\"#useState\" class=\"headerlink\" title=\"useState\"></a>useState</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; useState,useEffect &#125; from &quot;react&quot;;</span><br><span class=\"line\">function MyStateHook(props) &#123;</span><br><span class=\"line\">    const [num,setNum] &#x3D; useState(1)</span><br><span class=\"line\">    return(</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;&#123;num&#125;&lt;&#x2F;p&gt;</span><br><span class=\"line\">            &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;()&#x3D;&gt;&#123;setNum(num+1)&#125;&#125;&gt;num+1&lt;&#x2F;button&gt;</span><br><span class=\"line\">        &lt;&#x2F;div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"useEffect\"><a href=\"#useEffect\" class=\"headerlink\" title=\"useEffect\"></a>useEffect</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import React, &#123; useState,useEffect &#125; from &quot;react&quot;;</span><br><span class=\"line\">function MyEffetHook(props) &#123;</span><br><span class=\"line\">    const [num,setNum] &#x3D; useState(1)</span><br><span class=\"line\">    useEffect(()&#x3D;&gt;&#123;</span><br><span class=\"line\">        if(num &#x3D;&#x3D; 1)&#123;</span><br><span class=\"line\">            setTimeout(()&#x3D;&gt;&#123;</span><br><span class=\"line\">                setNum(2)</span><br><span class=\"line\">            &#125;,1000)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        &#x2F;&#x2F;componentWillUnmount时调用</span><br><span class=\"line\">        return ()&#x3D;&gt;&#123;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,[])&#x2F;&#x2F;第二个参数传递一个数组，在这些值没有更改时不会触发，如果传空数组，相当于只在componentDidMount触发</span><br><span class=\"line\"></span><br><span class=\"line\">    return(</span><br><span class=\"line\">        &lt;div&gt;</span><br><span class=\"line\">            &lt;p&gt;&#123;num&#125;&lt;&#x2F;p&gt;</span><br><span class=\"line\">            &lt;button type&#x3D;&quot;button&quot; onClick&#x3D;&#123;()&#x3D;&gt;&#123;setNum(1)&#125;&#125;&gt;num+1&lt;&#x2F;button&gt;</span><br><span class=\"line\">        &lt;&#x2F;div&gt;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n"},{"title":"<webpack>打包文件相关","date":"2018-12-20T16:00:00.000Z","_content":"\n### 打包js\n\n- 命令行：webpack entry<entry> output\n\n```\nwebpack index.js bundle.js\n```\n- webpack配置文件\n\n### 打包ES6\n\n- babel-loader：https://www.webpackjs.com/loaders/babel-loader/\n- babel配置：https://crazyaguai.github.io/2018/11/14/Babel%E9%85%8D%E7%BD%AE/\n\n```\n{\n    test: /\\.js$/,\n    exclude: /(node_modules|bower_components)/,\n    use: {\n        loader: 'babel-loader'\n    }\n}\n```\n\n#### 打包ts\n\n### 处理css\n\n- 处理css并提取公共代码\n- style-loader 创建style标签写入html中\n- css-loader js可以引入css\n\n1. loader\n\n```\n{\n    test: /\\.css$/,\n    use: ExtractTextPlugin.extract(\n        {\n            fallback: [{\n                loader: 'style-loader'\n            }],\n            use: [\n                {\n                    loader: 'css-loader',\n                    options: {\n                        minimize: true,//是否压缩\n                        module: false,//是否使用css Module\n                    }\n                },{\n                    loader: 'postcss-loader',\n                    options: {\n                        ident: 'postcss',\n                        plugins: [\n                            require('autoprefixer')()\n                        ]\n                    }\n                }\n            ]\n        }\n    )\n}\n```\n\n2. plugin\n\n```\nnew ExtractTextPlugin({\n    filename: 'css/[name][hash].min.css',\n    allChunks: false,//默认false，指定提取范围，设置为true时异步加载的也会被提取出来\n})\n```\n\n### 处理sass\n\n- 安装依赖\n\n```\nnpm install sass-loader node-sass --save-dev\n```\n\n1. loader\n\n```\n{\n    test: /\\.scss$/,\n    use: [\n        {\n            loader: 'style-loader',\n            options: {\n                // singletion: true,//放在一个style中，开启后sourceMap会失效\n                sourceMap: true\n            }\n        },\n        {\n            loader: 'css-loader',\n            options: {\n                // minimize: true,\n                sourceMap: true\n            }\n        }, {\n            loader: 'postcss-loader',\n            options: {\n                ident: 'postcss',\n                sourceMap: true,\n                plugins: [\n                    require('postcss-sprites')({\n                        spritePath: 'dist/img/',\n                        retina: true,//处理视网膜屏两倍大图,图片需要以@2x结尾\n                    }),\n                    require('autoprefixer')(),\n                ]\n            }\n        },{\n            loader: 'sass-loader'\n        }\n    ]\n}\n```\n\n2. 压缩提取的css并且删除重复内容\n\n```\n new OptimizeCSSPlugin({\n    cssProcessorOptions: {\n        safe: true\n    }\n}),\n```\n\n3. css tree-shaking(对于变量css无法使用)\n\n```\nnew PurifyCss({\n    paths: glob.sync([\n        path.resolve(__dirname,'../src/a.js'),\n        path.resolve(__dirname,'../index.html')\n    ])\n}),\n```\n\n### PostCss\n\n- 安装\n\n```\nnpm install postcss postcss-loader autoprefixer --save-dev\n```\n\n- Autoprefixer 添加浏览器前缀\n- css-nano 压缩css\n- css-next 使用css新语法（css Variables\\custom selectors\\calc）\n- postcss-sprites 转换雪碧图\n- 在sass-loader和css-loader之间使用\n\n```\n{\n    loader: 'postcss-loader',\n    options: {\n        ident: 'postcss',\n        sourceMap: true,\n        plugins: [\n            require('postcss-sprites')({\n                spritePath: 'dist/img/',\n                retina: true,//处理视网膜屏两倍大图,图片需要以@2x结尾\n            }),\n            require('autoprefixer')(),\n        ]\n    }\n}\n```\n\n### Tree Shaking\n\n#### js Tree Shaking\n- 使用场景：常规优化、使用第三方库的某一个功能\n- https://www.webpackjs.com/guides/tree-shaking/\n- lodash 需要配置babel babel-plugin-lodash插件\n```\nnew webpack.optimize.UglifyJsPlugin()\n```\n\n#### css Tree Shaking\n\n- 安装 purifycss-webpack\n- glob-all 支持多路径\n\n```\nnew PurifyCss({\n    paths: glob.sync([\n        path.resolve(__dirname,'../src/a.js'),\n        path.resolve(__dirname,'../index.html')\n    ])\n})\n```\n\n### 图片处理\n\n- file-loader\n- url-loader\n- img-loader\n- postcss-sprites\n\n```\n{\n    test: /\\.(png|jpg|jpeg|gif)$/,\n    use: [\n        // {\n        //     loader: 'file-loader',\n        //     options: {\n        //         publicPath: '',\n        //         name: 'img/[name][hash].[ext]',\n        //         // useRelativePath: true,\n        //         outputPath: ''\n        //     }\n        // },\n        {\n            loader: 'url-loader',//转换base64\n            options: {\n                limit: 100,\n                // publicPath: '',\n                name: 'img/[name][hash].[ext]',\n                outputPath: ''\n            }\n        },{\n            loader: 'img-loader',//压缩图片(3.x版本参数不同)\n            options: {\n                pngquant: {\n                    quality: 80\n                }\n            }\n        }\n    ]\n}\n```\n\n### 字体文件处理\n\n```\n{\n    test: /\\.(eot|woff2?|ttf|svg|otf)$/,\n    use: [\n        {\n            loader: 'url-loader',\n            options: {\n                limit: 100,//配置是否生成单独文件\n                // publicPath: '../',\n                name: 'fonts/[name][hash].[ext]',\n                outputPath: ''\n            }\n        }\n    ]\n}\n```\n\n### 第三方js库\n\n- webpack.providePlugin 不用在文件中import，webpack会注入\n\n```\nwebpack.providePlugin({\n    $: 'jquery',\n})\n```\n\n- 使用别名引入非node_modules文件 https://www.webpackjs.com/configuration/resolve/， 然后再配置providePlugin\n\n```\nresolve: {\n    alias: {\n        jquery$: path.resolve(__dirname,'src/jquery.js')\n    }\n}\n```\n\n- imports-loader\n\n```\n{\n    test: path.resolve(__dirname,src/index.js),\n    use:[{\n        loader: 'imports-loader',\n        options: {\n            $: 'jqury'\n        }\n    }]\n}\n```\n\n### 提前加载webpack代码\n\n- 将webpack代码插入html中\n- inline-manifest-webpack-plugin 提取manifest文件到html中，减少浏览器请求，与htmlwebpackplugin搭配可能会有BUG，推荐使用下边的\n- html-webpack-inline-chunk-plugin\n\n```\nnew HtmlInlineChunkPlugin({\n    name: 'manifest'\n})\n```\n","source":"_posts/[webpack]打包文件相关.md","raw":"---\ntitle: <webpack>打包文件相关\ndate: 2018-12-21 00:00:00\ntags: [webpack]\ncategories: webpack\n---\n\n### 打包js\n\n- 命令行：webpack entry<entry> output\n\n```\nwebpack index.js bundle.js\n```\n- webpack配置文件\n\n### 打包ES6\n\n- babel-loader：https://www.webpackjs.com/loaders/babel-loader/\n- babel配置：https://crazyaguai.github.io/2018/11/14/Babel%E9%85%8D%E7%BD%AE/\n\n```\n{\n    test: /\\.js$/,\n    exclude: /(node_modules|bower_components)/,\n    use: {\n        loader: 'babel-loader'\n    }\n}\n```\n\n#### 打包ts\n\n### 处理css\n\n- 处理css并提取公共代码\n- style-loader 创建style标签写入html中\n- css-loader js可以引入css\n\n1. loader\n\n```\n{\n    test: /\\.css$/,\n    use: ExtractTextPlugin.extract(\n        {\n            fallback: [{\n                loader: 'style-loader'\n            }],\n            use: [\n                {\n                    loader: 'css-loader',\n                    options: {\n                        minimize: true,//是否压缩\n                        module: false,//是否使用css Module\n                    }\n                },{\n                    loader: 'postcss-loader',\n                    options: {\n                        ident: 'postcss',\n                        plugins: [\n                            require('autoprefixer')()\n                        ]\n                    }\n                }\n            ]\n        }\n    )\n}\n```\n\n2. plugin\n\n```\nnew ExtractTextPlugin({\n    filename: 'css/[name][hash].min.css',\n    allChunks: false,//默认false，指定提取范围，设置为true时异步加载的也会被提取出来\n})\n```\n\n### 处理sass\n\n- 安装依赖\n\n```\nnpm install sass-loader node-sass --save-dev\n```\n\n1. loader\n\n```\n{\n    test: /\\.scss$/,\n    use: [\n        {\n            loader: 'style-loader',\n            options: {\n                // singletion: true,//放在一个style中，开启后sourceMap会失效\n                sourceMap: true\n            }\n        },\n        {\n            loader: 'css-loader',\n            options: {\n                // minimize: true,\n                sourceMap: true\n            }\n        }, {\n            loader: 'postcss-loader',\n            options: {\n                ident: 'postcss',\n                sourceMap: true,\n                plugins: [\n                    require('postcss-sprites')({\n                        spritePath: 'dist/img/',\n                        retina: true,//处理视网膜屏两倍大图,图片需要以@2x结尾\n                    }),\n                    require('autoprefixer')(),\n                ]\n            }\n        },{\n            loader: 'sass-loader'\n        }\n    ]\n}\n```\n\n2. 压缩提取的css并且删除重复内容\n\n```\n new OptimizeCSSPlugin({\n    cssProcessorOptions: {\n        safe: true\n    }\n}),\n```\n\n3. css tree-shaking(对于变量css无法使用)\n\n```\nnew PurifyCss({\n    paths: glob.sync([\n        path.resolve(__dirname,'../src/a.js'),\n        path.resolve(__dirname,'../index.html')\n    ])\n}),\n```\n\n### PostCss\n\n- 安装\n\n```\nnpm install postcss postcss-loader autoprefixer --save-dev\n```\n\n- Autoprefixer 添加浏览器前缀\n- css-nano 压缩css\n- css-next 使用css新语法（css Variables\\custom selectors\\calc）\n- postcss-sprites 转换雪碧图\n- 在sass-loader和css-loader之间使用\n\n```\n{\n    loader: 'postcss-loader',\n    options: {\n        ident: 'postcss',\n        sourceMap: true,\n        plugins: [\n            require('postcss-sprites')({\n                spritePath: 'dist/img/',\n                retina: true,//处理视网膜屏两倍大图,图片需要以@2x结尾\n            }),\n            require('autoprefixer')(),\n        ]\n    }\n}\n```\n\n### Tree Shaking\n\n#### js Tree Shaking\n- 使用场景：常规优化、使用第三方库的某一个功能\n- https://www.webpackjs.com/guides/tree-shaking/\n- lodash 需要配置babel babel-plugin-lodash插件\n```\nnew webpack.optimize.UglifyJsPlugin()\n```\n\n#### css Tree Shaking\n\n- 安装 purifycss-webpack\n- glob-all 支持多路径\n\n```\nnew PurifyCss({\n    paths: glob.sync([\n        path.resolve(__dirname,'../src/a.js'),\n        path.resolve(__dirname,'../index.html')\n    ])\n})\n```\n\n### 图片处理\n\n- file-loader\n- url-loader\n- img-loader\n- postcss-sprites\n\n```\n{\n    test: /\\.(png|jpg|jpeg|gif)$/,\n    use: [\n        // {\n        //     loader: 'file-loader',\n        //     options: {\n        //         publicPath: '',\n        //         name: 'img/[name][hash].[ext]',\n        //         // useRelativePath: true,\n        //         outputPath: ''\n        //     }\n        // },\n        {\n            loader: 'url-loader',//转换base64\n            options: {\n                limit: 100,\n                // publicPath: '',\n                name: 'img/[name][hash].[ext]',\n                outputPath: ''\n            }\n        },{\n            loader: 'img-loader',//压缩图片(3.x版本参数不同)\n            options: {\n                pngquant: {\n                    quality: 80\n                }\n            }\n        }\n    ]\n}\n```\n\n### 字体文件处理\n\n```\n{\n    test: /\\.(eot|woff2?|ttf|svg|otf)$/,\n    use: [\n        {\n            loader: 'url-loader',\n            options: {\n                limit: 100,//配置是否生成单独文件\n                // publicPath: '../',\n                name: 'fonts/[name][hash].[ext]',\n                outputPath: ''\n            }\n        }\n    ]\n}\n```\n\n### 第三方js库\n\n- webpack.providePlugin 不用在文件中import，webpack会注入\n\n```\nwebpack.providePlugin({\n    $: 'jquery',\n})\n```\n\n- 使用别名引入非node_modules文件 https://www.webpackjs.com/configuration/resolve/， 然后再配置providePlugin\n\n```\nresolve: {\n    alias: {\n        jquery$: path.resolve(__dirname,'src/jquery.js')\n    }\n}\n```\n\n- imports-loader\n\n```\n{\n    test: path.resolve(__dirname,src/index.js),\n    use:[{\n        loader: 'imports-loader',\n        options: {\n            $: 'jqury'\n        }\n    }]\n}\n```\n\n### 提前加载webpack代码\n\n- 将webpack代码插入html中\n- inline-manifest-webpack-plugin 提取manifest文件到html中，减少浏览器请求，与htmlwebpackplugin搭配可能会有BUG，推荐使用下边的\n- html-webpack-inline-chunk-plugin\n\n```\nnew HtmlInlineChunkPlugin({\n    name: 'manifest'\n})\n```\n","slug":"[webpack]打包文件相关","published":1,"updated":"2021-03-15T14:40:57.629Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dl6003gwotj0ynf863k","content":"<h3 id=\"打包js\"><a href=\"#打包js\" class=\"headerlink\" title=\"打包js\"></a>打包js</h3><ul>\n<li>命令行：webpack entry<entry> output</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack index.js bundle.js</span><br></pre></td></tr></table></figure>\n<ul>\n<li>webpack配置文件</li>\n</ul>\n<h3 id=\"打包ES6\"><a href=\"#打包ES6\" class=\"headerlink\" title=\"打包ES6\"></a>打包ES6</h3><ul>\n<li>babel-loader：<a href=\"https://www.webpackjs.com/loaders/babel-loader/\">https://www.webpackjs.com/loaders/babel-loader/</a></li>\n<li>babel配置：<a href=\"https://crazyaguai.github.io/2018/11/14/Babel%E9%85%8D%E7%BD%AE/\">https://crazyaguai.github.io/2018/11/14/Babel%E9%85%8D%E7%BD%AE/</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: &#x2F;\\.js$&#x2F;,</span><br><span class=\"line\">    exclude: &#x2F;(node_modules|bower_components)&#x2F;,</span><br><span class=\"line\">    use: &#123;</span><br><span class=\"line\">        loader: &#39;babel-loader&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"打包ts\"><a href=\"#打包ts\" class=\"headerlink\" title=\"打包ts\"></a>打包ts</h4><h3 id=\"处理css\"><a href=\"#处理css\" class=\"headerlink\" title=\"处理css\"></a>处理css</h3><ul>\n<li>处理css并提取公共代码</li>\n<li>style-loader 创建style标签写入html中</li>\n<li>css-loader js可以引入css</li>\n</ul>\n<ol>\n<li>loader</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: &#x2F;\\.css$&#x2F;,</span><br><span class=\"line\">    use: ExtractTextPlugin.extract(</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fallback: [&#123;</span><br><span class=\"line\">                loader: &#39;style-loader&#39;</span><br><span class=\"line\">            &#125;],</span><br><span class=\"line\">            use: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    loader: &#39;css-loader&#39;,</span><br><span class=\"line\">                    options: &#123;</span><br><span class=\"line\">                        minimize: true,&#x2F;&#x2F;是否压缩</span><br><span class=\"line\">                        module: false,&#x2F;&#x2F;是否使用css Module</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,&#123;</span><br><span class=\"line\">                    loader: &#39;postcss-loader&#39;,</span><br><span class=\"line\">                    options: &#123;</span><br><span class=\"line\">                        ident: &#39;postcss&#39;,</span><br><span class=\"line\">                        plugins: [</span><br><span class=\"line\">                            require(&#39;autoprefixer&#39;)()</span><br><span class=\"line\">                        ]</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>plugin</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new ExtractTextPlugin(&#123;</span><br><span class=\"line\">    filename: &#39;css&#x2F;[name][hash].min.css&#39;,</span><br><span class=\"line\">    allChunks: false,&#x2F;&#x2F;默认false，指定提取范围，设置为true时异步加载的也会被提取出来</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"处理sass\"><a href=\"#处理sass\" class=\"headerlink\" title=\"处理sass\"></a>处理sass</h3><ul>\n<li>安装依赖</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install sass-loader node-sass --save-dev</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>loader</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: &#x2F;\\.scss$&#x2F;,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &#39;style-loader&#39;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; singletion: true,&#x2F;&#x2F;放在一个style中，开启后sourceMap会失效</span><br><span class=\"line\">                sourceMap: true</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &#39;css-loader&#39;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; minimize: true,</span><br><span class=\"line\">                sourceMap: true</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, &#123;</span><br><span class=\"line\">            loader: &#39;postcss-loader&#39;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                ident: &#39;postcss&#39;,</span><br><span class=\"line\">                sourceMap: true,</span><br><span class=\"line\">                plugins: [</span><br><span class=\"line\">                    require(&#39;postcss-sprites&#39;)(&#123;</span><br><span class=\"line\">                        spritePath: &#39;dist&#x2F;img&#x2F;&#39;,</span><br><span class=\"line\">                        retina: true,&#x2F;&#x2F;处理视网膜屏两倍大图,图片需要以@2x结尾</span><br><span class=\"line\">                    &#125;),</span><br><span class=\"line\">                    require(&#39;autoprefixer&#39;)(),</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,&#123;</span><br><span class=\"line\">            loader: &#39;sass-loader&#39;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>压缩提取的css并且删除重复内容</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> new OptimizeCSSPlugin(&#123;</span><br><span class=\"line\">    cssProcessorOptions: &#123;</span><br><span class=\"line\">        safe: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>css tree-shaking(对于变量css无法使用)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new PurifyCss(&#123;</span><br><span class=\"line\">    paths: glob.sync([</span><br><span class=\"line\">        path.resolve(__dirname,&#39;..&#x2F;src&#x2F;a.js&#39;),</span><br><span class=\"line\">        path.resolve(__dirname,&#39;..&#x2F;index.html&#39;)</span><br><span class=\"line\">    ])</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"PostCss\"><a href=\"#PostCss\" class=\"headerlink\" title=\"PostCss\"></a>PostCss</h3><ul>\n<li>安装</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install postcss postcss-loader autoprefixer --save-dev</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Autoprefixer 添加浏览器前缀</li>\n<li>css-nano 压缩css</li>\n<li>css-next 使用css新语法（css Variables\\custom selectors\\calc）</li>\n<li>postcss-sprites 转换雪碧图</li>\n<li>在sass-loader和css-loader之间使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    loader: &#39;postcss-loader&#39;,</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">        ident: &#39;postcss&#39;,</span><br><span class=\"line\">        sourceMap: true,</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">            require(&#39;postcss-sprites&#39;)(&#123;</span><br><span class=\"line\">                spritePath: &#39;dist&#x2F;img&#x2F;&#39;,</span><br><span class=\"line\">                retina: true,&#x2F;&#x2F;处理视网膜屏两倍大图,图片需要以@2x结尾</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">            require(&#39;autoprefixer&#39;)(),</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Tree-Shaking\"><a href=\"#Tree-Shaking\" class=\"headerlink\" title=\"Tree Shaking\"></a>Tree Shaking</h3><h4 id=\"js-Tree-Shaking\"><a href=\"#js-Tree-Shaking\" class=\"headerlink\" title=\"js Tree Shaking\"></a>js Tree Shaking</h4><ul>\n<li>使用场景：常规优化、使用第三方库的某一个功能</li>\n<li><a href=\"https://www.webpackjs.com/guides/tree-shaking/\">https://www.webpackjs.com/guides/tree-shaking/</a></li>\n<li>lodash 需要配置babel babel-plugin-lodash插件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new webpack.optimize.UglifyJsPlugin()</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"css-Tree-Shaking\"><a href=\"#css-Tree-Shaking\" class=\"headerlink\" title=\"css Tree Shaking\"></a>css Tree Shaking</h4><ul>\n<li>安装 purifycss-webpack</li>\n<li>glob-all 支持多路径</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new PurifyCss(&#123;</span><br><span class=\"line\">    paths: glob.sync([</span><br><span class=\"line\">        path.resolve(__dirname,&#39;..&#x2F;src&#x2F;a.js&#39;),</span><br><span class=\"line\">        path.resolve(__dirname,&#39;..&#x2F;index.html&#39;)</span><br><span class=\"line\">    ])</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"图片处理\"><a href=\"#图片处理\" class=\"headerlink\" title=\"图片处理\"></a>图片处理</h3><ul>\n<li>file-loader</li>\n<li>url-loader</li>\n<li>img-loader</li>\n<li>postcss-sprites</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: &#x2F;\\.(png|jpg|jpeg|gif)$&#x2F;,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">        &#x2F;&#x2F; &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;     loader: &#39;file-loader&#39;,</span><br><span class=\"line\">        &#x2F;&#x2F;     options: &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;         publicPath: &#39;&#39;,</span><br><span class=\"line\">        &#x2F;&#x2F;         name: &#39;img&#x2F;[name][hash].[ext]&#39;,</span><br><span class=\"line\">        &#x2F;&#x2F;         &#x2F;&#x2F; useRelativePath: true,</span><br><span class=\"line\">        &#x2F;&#x2F;         outputPath: &#39;&#39;</span><br><span class=\"line\">        &#x2F;&#x2F;     &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &#39;url-loader&#39;,&#x2F;&#x2F;转换base64</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                limit: 100,</span><br><span class=\"line\">                &#x2F;&#x2F; publicPath: &#39;&#39;,</span><br><span class=\"line\">                name: &#39;img&#x2F;[name][hash].[ext]&#39;,</span><br><span class=\"line\">                outputPath: &#39;&#39;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,&#123;</span><br><span class=\"line\">            loader: &#39;img-loader&#39;,&#x2F;&#x2F;压缩图片(3.x版本参数不同)</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                pngquant: &#123;</span><br><span class=\"line\">                    quality: 80</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字体文件处理\"><a href=\"#字体文件处理\" class=\"headerlink\" title=\"字体文件处理\"></a>字体文件处理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: &#x2F;\\.(eot|woff2?|ttf|svg|otf)$&#x2F;,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &#39;url-loader&#39;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                limit: 100,&#x2F;&#x2F;配置是否生成单独文件</span><br><span class=\"line\">                &#x2F;&#x2F; publicPath: &#39;..&#x2F;&#39;,</span><br><span class=\"line\">                name: &#39;fonts&#x2F;[name][hash].[ext]&#39;,</span><br><span class=\"line\">                outputPath: &#39;&#39;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第三方js库\"><a href=\"#第三方js库\" class=\"headerlink\" title=\"第三方js库\"></a>第三方js库</h3><ul>\n<li>webpack.providePlugin 不用在文件中import，webpack会注入</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack.providePlugin(&#123;</span><br><span class=\"line\">    $: &#39;jquery&#39;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用别名引入非node_modules文件 <a href=\"https://www.webpackjs.com/configuration/resolve/%EF%BC%8C\">https://www.webpackjs.com/configuration/resolve/，</a> 然后再配置providePlugin</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: &#123;</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">        jquery$: path.resolve(__dirname,&#39;src&#x2F;jquery.js&#39;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>imports-loader</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: path.resolve(__dirname,src&#x2F;index.js),</span><br><span class=\"line\">    use:[&#123;</span><br><span class=\"line\">        loader: &#39;imports-loader&#39;,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">            $: &#39;jqury&#39;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"提前加载webpack代码\"><a href=\"#提前加载webpack代码\" class=\"headerlink\" title=\"提前加载webpack代码\"></a>提前加载webpack代码</h3><ul>\n<li>将webpack代码插入html中</li>\n<li>inline-manifest-webpack-plugin 提取manifest文件到html中，减少浏览器请求，与htmlwebpackplugin搭配可能会有BUG，推荐使用下边的</li>\n<li>html-webpack-inline-chunk-plugin</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new HtmlInlineChunkPlugin(&#123;</span><br><span class=\"line\">    name: &#39;manifest&#39;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"打包js\"><a href=\"#打包js\" class=\"headerlink\" title=\"打包js\"></a>打包js</h3><ul>\n<li>命令行：webpack entry<entry> output</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack index.js bundle.js</span><br></pre></td></tr></table></figure>\n<ul>\n<li>webpack配置文件</li>\n</ul>\n<h3 id=\"打包ES6\"><a href=\"#打包ES6\" class=\"headerlink\" title=\"打包ES6\"></a>打包ES6</h3><ul>\n<li>babel-loader：<a href=\"https://www.webpackjs.com/loaders/babel-loader/\">https://www.webpackjs.com/loaders/babel-loader/</a></li>\n<li>babel配置：<a href=\"https://crazyaguai.github.io/2018/11/14/Babel%E9%85%8D%E7%BD%AE/\">https://crazyaguai.github.io/2018/11/14/Babel%E9%85%8D%E7%BD%AE/</a></li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: &#x2F;\\.js$&#x2F;,</span><br><span class=\"line\">    exclude: &#x2F;(node_modules|bower_components)&#x2F;,</span><br><span class=\"line\">    use: &#123;</span><br><span class=\"line\">        loader: &#39;babel-loader&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"打包ts\"><a href=\"#打包ts\" class=\"headerlink\" title=\"打包ts\"></a>打包ts</h4><h3 id=\"处理css\"><a href=\"#处理css\" class=\"headerlink\" title=\"处理css\"></a>处理css</h3><ul>\n<li>处理css并提取公共代码</li>\n<li>style-loader 创建style标签写入html中</li>\n<li>css-loader js可以引入css</li>\n</ul>\n<ol>\n<li>loader</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: &#x2F;\\.css$&#x2F;,</span><br><span class=\"line\">    use: ExtractTextPlugin.extract(</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fallback: [&#123;</span><br><span class=\"line\">                loader: &#39;style-loader&#39;</span><br><span class=\"line\">            &#125;],</span><br><span class=\"line\">            use: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    loader: &#39;css-loader&#39;,</span><br><span class=\"line\">                    options: &#123;</span><br><span class=\"line\">                        minimize: true,&#x2F;&#x2F;是否压缩</span><br><span class=\"line\">                        module: false,&#x2F;&#x2F;是否使用css Module</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,&#123;</span><br><span class=\"line\">                    loader: &#39;postcss-loader&#39;,</span><br><span class=\"line\">                    options: &#123;</span><br><span class=\"line\">                        ident: &#39;postcss&#39;,</span><br><span class=\"line\">                        plugins: [</span><br><span class=\"line\">                            require(&#39;autoprefixer&#39;)()</span><br><span class=\"line\">                        ]</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>plugin</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new ExtractTextPlugin(&#123;</span><br><span class=\"line\">    filename: &#39;css&#x2F;[name][hash].min.css&#39;,</span><br><span class=\"line\">    allChunks: false,&#x2F;&#x2F;默认false，指定提取范围，设置为true时异步加载的也会被提取出来</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"处理sass\"><a href=\"#处理sass\" class=\"headerlink\" title=\"处理sass\"></a>处理sass</h3><ul>\n<li>安装依赖</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install sass-loader node-sass --save-dev</span><br></pre></td></tr></table></figure>\n\n<ol>\n<li>loader</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: &#x2F;\\.scss$&#x2F;,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &#39;style-loader&#39;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; singletion: true,&#x2F;&#x2F;放在一个style中，开启后sourceMap会失效</span><br><span class=\"line\">                sourceMap: true</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &#39;css-loader&#39;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                &#x2F;&#x2F; minimize: true,</span><br><span class=\"line\">                sourceMap: true</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, &#123;</span><br><span class=\"line\">            loader: &#39;postcss-loader&#39;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                ident: &#39;postcss&#39;,</span><br><span class=\"line\">                sourceMap: true,</span><br><span class=\"line\">                plugins: [</span><br><span class=\"line\">                    require(&#39;postcss-sprites&#39;)(&#123;</span><br><span class=\"line\">                        spritePath: &#39;dist&#x2F;img&#x2F;&#39;,</span><br><span class=\"line\">                        retina: true,&#x2F;&#x2F;处理视网膜屏两倍大图,图片需要以@2x结尾</span><br><span class=\"line\">                    &#125;),</span><br><span class=\"line\">                    require(&#39;autoprefixer&#39;)(),</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,&#123;</span><br><span class=\"line\">            loader: &#39;sass-loader&#39;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>压缩提取的css并且删除重复内容</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> new OptimizeCSSPlugin(&#123;</span><br><span class=\"line\">    cssProcessorOptions: &#123;</span><br><span class=\"line\">        safe: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>css tree-shaking(对于变量css无法使用)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new PurifyCss(&#123;</span><br><span class=\"line\">    paths: glob.sync([</span><br><span class=\"line\">        path.resolve(__dirname,&#39;..&#x2F;src&#x2F;a.js&#39;),</span><br><span class=\"line\">        path.resolve(__dirname,&#39;..&#x2F;index.html&#39;)</span><br><span class=\"line\">    ])</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"PostCss\"><a href=\"#PostCss\" class=\"headerlink\" title=\"PostCss\"></a>PostCss</h3><ul>\n<li>安装</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install postcss postcss-loader autoprefixer --save-dev</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Autoprefixer 添加浏览器前缀</li>\n<li>css-nano 压缩css</li>\n<li>css-next 使用css新语法（css Variables\\custom selectors\\calc）</li>\n<li>postcss-sprites 转换雪碧图</li>\n<li>在sass-loader和css-loader之间使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    loader: &#39;postcss-loader&#39;,</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">        ident: &#39;postcss&#39;,</span><br><span class=\"line\">        sourceMap: true,</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">            require(&#39;postcss-sprites&#39;)(&#123;</span><br><span class=\"line\">                spritePath: &#39;dist&#x2F;img&#x2F;&#39;,</span><br><span class=\"line\">                retina: true,&#x2F;&#x2F;处理视网膜屏两倍大图,图片需要以@2x结尾</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">            require(&#39;autoprefixer&#39;)(),</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Tree-Shaking\"><a href=\"#Tree-Shaking\" class=\"headerlink\" title=\"Tree Shaking\"></a>Tree Shaking</h3><h4 id=\"js-Tree-Shaking\"><a href=\"#js-Tree-Shaking\" class=\"headerlink\" title=\"js Tree Shaking\"></a>js Tree Shaking</h4><ul>\n<li>使用场景：常规优化、使用第三方库的某一个功能</li>\n<li><a href=\"https://www.webpackjs.com/guides/tree-shaking/\">https://www.webpackjs.com/guides/tree-shaking/</a></li>\n<li>lodash 需要配置babel babel-plugin-lodash插件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new webpack.optimize.UglifyJsPlugin()</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"css-Tree-Shaking\"><a href=\"#css-Tree-Shaking\" class=\"headerlink\" title=\"css Tree Shaking\"></a>css Tree Shaking</h4><ul>\n<li>安装 purifycss-webpack</li>\n<li>glob-all 支持多路径</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new PurifyCss(&#123;</span><br><span class=\"line\">    paths: glob.sync([</span><br><span class=\"line\">        path.resolve(__dirname,&#39;..&#x2F;src&#x2F;a.js&#39;),</span><br><span class=\"line\">        path.resolve(__dirname,&#39;..&#x2F;index.html&#39;)</span><br><span class=\"line\">    ])</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"图片处理\"><a href=\"#图片处理\" class=\"headerlink\" title=\"图片处理\"></a>图片处理</h3><ul>\n<li>file-loader</li>\n<li>url-loader</li>\n<li>img-loader</li>\n<li>postcss-sprites</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: &#x2F;\\.(png|jpg|jpeg|gif)$&#x2F;,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">        &#x2F;&#x2F; &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;     loader: &#39;file-loader&#39;,</span><br><span class=\"line\">        &#x2F;&#x2F;     options: &#123;</span><br><span class=\"line\">        &#x2F;&#x2F;         publicPath: &#39;&#39;,</span><br><span class=\"line\">        &#x2F;&#x2F;         name: &#39;img&#x2F;[name][hash].[ext]&#39;,</span><br><span class=\"line\">        &#x2F;&#x2F;         &#x2F;&#x2F; useRelativePath: true,</span><br><span class=\"line\">        &#x2F;&#x2F;         outputPath: &#39;&#39;</span><br><span class=\"line\">        &#x2F;&#x2F;     &#125;</span><br><span class=\"line\">        &#x2F;&#x2F; &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &#39;url-loader&#39;,&#x2F;&#x2F;转换base64</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                limit: 100,</span><br><span class=\"line\">                &#x2F;&#x2F; publicPath: &#39;&#39;,</span><br><span class=\"line\">                name: &#39;img&#x2F;[name][hash].[ext]&#39;,</span><br><span class=\"line\">                outputPath: &#39;&#39;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,&#123;</span><br><span class=\"line\">            loader: &#39;img-loader&#39;,&#x2F;&#x2F;压缩图片(3.x版本参数不同)</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                pngquant: &#123;</span><br><span class=\"line\">                    quality: 80</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"字体文件处理\"><a href=\"#字体文件处理\" class=\"headerlink\" title=\"字体文件处理\"></a>字体文件处理</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: &#x2F;\\.(eot|woff2?|ttf|svg|otf)$&#x2F;,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &#39;url-loader&#39;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                limit: 100,&#x2F;&#x2F;配置是否生成单独文件</span><br><span class=\"line\">                &#x2F;&#x2F; publicPath: &#39;..&#x2F;&#39;,</span><br><span class=\"line\">                name: &#39;fonts&#x2F;[name][hash].[ext]&#39;,</span><br><span class=\"line\">                outputPath: &#39;&#39;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"第三方js库\"><a href=\"#第三方js库\" class=\"headerlink\" title=\"第三方js库\"></a>第三方js库</h3><ul>\n<li>webpack.providePlugin 不用在文件中import，webpack会注入</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack.providePlugin(&#123;</span><br><span class=\"line\">    $: &#39;jquery&#39;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>使用别名引入非node_modules文件 <a href=\"https://www.webpackjs.com/configuration/resolve/%EF%BC%8C\">https://www.webpackjs.com/configuration/resolve/，</a> 然后再配置providePlugin</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: &#123;</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">        jquery$: path.resolve(__dirname,&#39;src&#x2F;jquery.js&#39;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>imports-loader</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: path.resolve(__dirname,src&#x2F;index.js),</span><br><span class=\"line\">    use:[&#123;</span><br><span class=\"line\">        loader: &#39;imports-loader&#39;,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">            $: &#39;jqury&#39;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"提前加载webpack代码\"><a href=\"#提前加载webpack代码\" class=\"headerlink\" title=\"提前加载webpack代码\"></a>提前加载webpack代码</h3><ul>\n<li>将webpack代码插入html中</li>\n<li>inline-manifest-webpack-plugin 提取manifest文件到html中，减少浏览器请求，与htmlwebpackplugin搭配可能会有BUG，推荐使用下边的</li>\n<li>html-webpack-inline-chunk-plugin</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new HtmlInlineChunkPlugin(&#123;</span><br><span class=\"line\">    name: &#39;manifest&#39;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n"},{"title":"<webpack>搭建环境以及相关优化","date":"2018-12-20T16:00:00.000Z","_content":"\n### webpack watch mode\n\n- 使用方式\n\n```\nwebpack -watch\nwebpack -w\n```\n\n- 不会建立web服务器\n\n### webpack-dev-server\n\n- live reloading (重新刷新浏览器)\n- 路径重定向\n- https\n- 在浏览器显示编译错误\n- 接口代理\n- 模块热更新（不刷新浏览器更新代码）https://www.webpackjs.com/guides/hot-module-replacement/\n- 基本配置 https://www.webpackjs.com/configuration/dev-server/\n\n### express + webpack-dev-middleware\n\n### 开启source-map\n\n#### js开启source-map\n\n- Devtool\n\n1. 开发环境使用 cheap-module-source-map\\source-map\n2. 生产环境使用 一般不用，如果修改问题可以配置为source-map\n\n- 生产环境uglify压缩时需要开启配置\n- webpack.SourceMapDevToolPlugin\n- webpack.EvalSourceMapDevToolPlugin\n\n#### css开启source-map\n\n- 开启相关loader的sourcemap配置\n\n### 开发环境和生产环境的区别\n\n#### 开发环境\n\n1. 模块热更新\n2. sourceMap\n3. 接口代理\n4. 代码规范检查\n\n#### 生产环境\n\n1. 提取公共代码\n2. 压缩混淆\n3. 文件压缩或base64编码\n4. 去除无用代码 tree-shaking\n5. 分离css\n6. 打包代码配置\n\n### 打包结果分析\n\n- 官方 Offical Analyse Tool\n\n1. 命令\n\n```\nwebpack --profile --json >stats.json\nwebpack --profile --json | Out-file 'stats.json' - Encoding //windows下命令\n```\n\n2. 官方分析地址 http://webpack.github.io/analyse/\n\n- webpack-bundle-analyzer\n\n1. 抵用插件BundleAnalyzerPlugin https://www.npmjs.com/package/webpack-bundle-analyzer\n\n2. 命令行\n\n```\nwebpack-bundle-analyzer stats.json\n```\n\n### 优化打包速度\n\n1. 分开vendor与app（第三方与开发文件）使用Dllplugin与DllReferencePlugin\n2. UglifyJsPlugin 配置参数 parallel:true（并行处理压缩）\n3. UglifyJsPlugin cache缓存\n4. HappyPach 并行处理 loader\n5. babel-loader 配置 cacheDirectory开启缓存、配置include exlude规定范围\n6. 其他\n\n- 减少 resolve\n- 去除 source-map\n- cache-loader\n- 升级 node\\webpack\n\n### 长缓存优化\n\n#### 场景1：app改变vendor也改变了\n\n1. 提取vendor\n2. 解决hash变化问题：hash->chunkhash(将打包的hash变为代码快的hash)，将output[hash]改为[chunkhash]\n3. 提取 manifest 文件（提取webpack runtime 代码）\n\n#### 场景2：引入新的模块，模块顺序发生变化，vendor hash变化了（因为chunkId变了）\n\n1. NameChunksPlugin 改变chunk名\n2. 保持moduleId稳定 NameModulesPlugin （如果想看打包module name命令行添加 --display-modules）\n3. 或者使用HashedModuleIdsPlugin 保持moduleId稳定\n\n- vue配置\n\n```\n// 保持chunkId不变\nnew webpack.NamedChunksPlugin(),\n// 保持moduleID稳定\nnew webpack.HashedModuleIdsPlugin(),\n```\n\n#### 场景3：动态引入时vendor hash发生变化（异步加载的包改变）\n\n1. 在动态引入的代码中添加 异步module名称\n\n```\nimport(/* webpackChunkName: \"print\" */ './print')\n```\n\n#### 总结优化打包\n\n1. 独立打包vendor\n2. 抽出manifest\n3. NameChunksPlugin\\NameModulesPlugin\\HashedModuleIdsPlugin\n4. 动态加载模块设置名称\n","source":"_posts/[webpack]搭建环境以及相关优化.md","raw":"---\ntitle: <webpack>搭建环境以及相关优化\ndate: 2018-12-21 00:00:00\ntags: [webpack]\ncategories: webpack\n---\n\n### webpack watch mode\n\n- 使用方式\n\n```\nwebpack -watch\nwebpack -w\n```\n\n- 不会建立web服务器\n\n### webpack-dev-server\n\n- live reloading (重新刷新浏览器)\n- 路径重定向\n- https\n- 在浏览器显示编译错误\n- 接口代理\n- 模块热更新（不刷新浏览器更新代码）https://www.webpackjs.com/guides/hot-module-replacement/\n- 基本配置 https://www.webpackjs.com/configuration/dev-server/\n\n### express + webpack-dev-middleware\n\n### 开启source-map\n\n#### js开启source-map\n\n- Devtool\n\n1. 开发环境使用 cheap-module-source-map\\source-map\n2. 生产环境使用 一般不用，如果修改问题可以配置为source-map\n\n- 生产环境uglify压缩时需要开启配置\n- webpack.SourceMapDevToolPlugin\n- webpack.EvalSourceMapDevToolPlugin\n\n#### css开启source-map\n\n- 开启相关loader的sourcemap配置\n\n### 开发环境和生产环境的区别\n\n#### 开发环境\n\n1. 模块热更新\n2. sourceMap\n3. 接口代理\n4. 代码规范检查\n\n#### 生产环境\n\n1. 提取公共代码\n2. 压缩混淆\n3. 文件压缩或base64编码\n4. 去除无用代码 tree-shaking\n5. 分离css\n6. 打包代码配置\n\n### 打包结果分析\n\n- 官方 Offical Analyse Tool\n\n1. 命令\n\n```\nwebpack --profile --json >stats.json\nwebpack --profile --json | Out-file 'stats.json' - Encoding //windows下命令\n```\n\n2. 官方分析地址 http://webpack.github.io/analyse/\n\n- webpack-bundle-analyzer\n\n1. 抵用插件BundleAnalyzerPlugin https://www.npmjs.com/package/webpack-bundle-analyzer\n\n2. 命令行\n\n```\nwebpack-bundle-analyzer stats.json\n```\n\n### 优化打包速度\n\n1. 分开vendor与app（第三方与开发文件）使用Dllplugin与DllReferencePlugin\n2. UglifyJsPlugin 配置参数 parallel:true（并行处理压缩）\n3. UglifyJsPlugin cache缓存\n4. HappyPach 并行处理 loader\n5. babel-loader 配置 cacheDirectory开启缓存、配置include exlude规定范围\n6. 其他\n\n- 减少 resolve\n- 去除 source-map\n- cache-loader\n- 升级 node\\webpack\n\n### 长缓存优化\n\n#### 场景1：app改变vendor也改变了\n\n1. 提取vendor\n2. 解决hash变化问题：hash->chunkhash(将打包的hash变为代码快的hash)，将output[hash]改为[chunkhash]\n3. 提取 manifest 文件（提取webpack runtime 代码）\n\n#### 场景2：引入新的模块，模块顺序发生变化，vendor hash变化了（因为chunkId变了）\n\n1. NameChunksPlugin 改变chunk名\n2. 保持moduleId稳定 NameModulesPlugin （如果想看打包module name命令行添加 --display-modules）\n3. 或者使用HashedModuleIdsPlugin 保持moduleId稳定\n\n- vue配置\n\n```\n// 保持chunkId不变\nnew webpack.NamedChunksPlugin(),\n// 保持moduleID稳定\nnew webpack.HashedModuleIdsPlugin(),\n```\n\n#### 场景3：动态引入时vendor hash发生变化（异步加载的包改变）\n\n1. 在动态引入的代码中添加 异步module名称\n\n```\nimport(/* webpackChunkName: \"print\" */ './print')\n```\n\n#### 总结优化打包\n\n1. 独立打包vendor\n2. 抽出manifest\n3. NameChunksPlugin\\NameModulesPlugin\\HashedModuleIdsPlugin\n4. 动态加载模块设置名称\n","slug":"[webpack]搭建环境以及相关优化","published":1,"updated":"2021-03-15T14:40:52.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dl6003jwotj89vafisn","content":"<h3 id=\"webpack-watch-mode\"><a href=\"#webpack-watch-mode\" class=\"headerlink\" title=\"webpack watch mode\"></a>webpack watch mode</h3><ul>\n<li>使用方式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack -watch</span><br><span class=\"line\">webpack -w</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>不会建立web服务器</li>\n</ul>\n<h3 id=\"webpack-dev-server\"><a href=\"#webpack-dev-server\" class=\"headerlink\" title=\"webpack-dev-server\"></a>webpack-dev-server</h3><ul>\n<li>live reloading (重新刷新浏览器)</li>\n<li>路径重定向</li>\n<li>https</li>\n<li>在浏览器显示编译错误</li>\n<li>接口代理</li>\n<li>模块热更新（不刷新浏览器更新代码）<a href=\"https://www.webpackjs.com/guides/hot-module-replacement/\">https://www.webpackjs.com/guides/hot-module-replacement/</a></li>\n<li>基本配置 <a href=\"https://www.webpackjs.com/configuration/dev-server/\">https://www.webpackjs.com/configuration/dev-server/</a></li>\n</ul>\n<h3 id=\"express-webpack-dev-middleware\"><a href=\"#express-webpack-dev-middleware\" class=\"headerlink\" title=\"express + webpack-dev-middleware\"></a>express + webpack-dev-middleware</h3><h3 id=\"开启source-map\"><a href=\"#开启source-map\" class=\"headerlink\" title=\"开启source-map\"></a>开启source-map</h3><h4 id=\"js开启source-map\"><a href=\"#js开启source-map\" class=\"headerlink\" title=\"js开启source-map\"></a>js开启source-map</h4><ul>\n<li>Devtool</li>\n</ul>\n<ol>\n<li>开发环境使用 cheap-module-source-map\\source-map</li>\n<li>生产环境使用 一般不用，如果修改问题可以配置为source-map</li>\n</ol>\n<ul>\n<li>生产环境uglify压缩时需要开启配置</li>\n<li>webpack.SourceMapDevToolPlugin</li>\n<li>webpack.EvalSourceMapDevToolPlugin</li>\n</ul>\n<h4 id=\"css开启source-map\"><a href=\"#css开启source-map\" class=\"headerlink\" title=\"css开启source-map\"></a>css开启source-map</h4><ul>\n<li>开启相关loader的sourcemap配置</li>\n</ul>\n<h3 id=\"开发环境和生产环境的区别\"><a href=\"#开发环境和生产环境的区别\" class=\"headerlink\" title=\"开发环境和生产环境的区别\"></a>开发环境和生产环境的区别</h3><h4 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h4><ol>\n<li>模块热更新</li>\n<li>sourceMap</li>\n<li>接口代理</li>\n<li>代码规范检查</li>\n</ol>\n<h4 id=\"生产环境\"><a href=\"#生产环境\" class=\"headerlink\" title=\"生产环境\"></a>生产环境</h4><ol>\n<li>提取公共代码</li>\n<li>压缩混淆</li>\n<li>文件压缩或base64编码</li>\n<li>去除无用代码 tree-shaking</li>\n<li>分离css</li>\n<li>打包代码配置</li>\n</ol>\n<h3 id=\"打包结果分析\"><a href=\"#打包结果分析\" class=\"headerlink\" title=\"打包结果分析\"></a>打包结果分析</h3><ul>\n<li>官方 Offical Analyse Tool</li>\n</ul>\n<ol>\n<li>命令</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack --profile --json &gt;stats.json</span><br><span class=\"line\">webpack --profile --json | Out-file &#39;stats.json&#39; - Encoding &#x2F;&#x2F;windows下命令</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>官方分析地址 <a href=\"http://webpack.github.io/analyse/\">http://webpack.github.io/analyse/</a></li>\n</ol>\n<ul>\n<li>webpack-bundle-analyzer</li>\n</ul>\n<ol>\n<li><p>抵用插件BundleAnalyzerPlugin <a href=\"https://www.npmjs.com/package/webpack-bundle-analyzer\">https://www.npmjs.com/package/webpack-bundle-analyzer</a></p>\n</li>\n<li><p>命令行</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack-bundle-analyzer stats.json</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"优化打包速度\"><a href=\"#优化打包速度\" class=\"headerlink\" title=\"优化打包速度\"></a>优化打包速度</h3><ol>\n<li>分开vendor与app（第三方与开发文件）使用Dllplugin与DllReferencePlugin</li>\n<li>UglifyJsPlugin 配置参数 parallel:true（并行处理压缩）</li>\n<li>UglifyJsPlugin cache缓存</li>\n<li>HappyPach 并行处理 loader</li>\n<li>babel-loader 配置 cacheDirectory开启缓存、配置include exlude规定范围</li>\n<li>其他</li>\n</ol>\n<ul>\n<li>减少 resolve</li>\n<li>去除 source-map</li>\n<li>cache-loader</li>\n<li>升级 node\\webpack</li>\n</ul>\n<h3 id=\"长缓存优化\"><a href=\"#长缓存优化\" class=\"headerlink\" title=\"长缓存优化\"></a>长缓存优化</h3><h4 id=\"场景1：app改变vendor也改变了\"><a href=\"#场景1：app改变vendor也改变了\" class=\"headerlink\" title=\"场景1：app改变vendor也改变了\"></a>场景1：app改变vendor也改变了</h4><ol>\n<li>提取vendor</li>\n<li>解决hash变化问题：hash-&gt;chunkhash(将打包的hash变为代码快的hash)，将output[hash]改为[chunkhash]</li>\n<li>提取 manifest 文件（提取webpack runtime 代码）</li>\n</ol>\n<h4 id=\"场景2：引入新的模块，模块顺序发生变化，vendor-hash变化了（因为chunkId变了）\"><a href=\"#场景2：引入新的模块，模块顺序发生变化，vendor-hash变化了（因为chunkId变了）\" class=\"headerlink\" title=\"场景2：引入新的模块，模块顺序发生变化，vendor hash变化了（因为chunkId变了）\"></a>场景2：引入新的模块，模块顺序发生变化，vendor hash变化了（因为chunkId变了）</h4><ol>\n<li>NameChunksPlugin 改变chunk名</li>\n<li>保持moduleId稳定 NameModulesPlugin （如果想看打包module name命令行添加 –display-modules）</li>\n<li>或者使用HashedModuleIdsPlugin 保持moduleId稳定</li>\n</ol>\n<ul>\n<li>vue配置</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 保持chunkId不变</span><br><span class=\"line\">new webpack.NamedChunksPlugin(),</span><br><span class=\"line\">&#x2F;&#x2F; 保持moduleID稳定</span><br><span class=\"line\">new webpack.HashedModuleIdsPlugin(),</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"场景3：动态引入时vendor-hash发生变化（异步加载的包改变）\"><a href=\"#场景3：动态引入时vendor-hash发生变化（异步加载的包改变）\" class=\"headerlink\" title=\"场景3：动态引入时vendor hash发生变化（异步加载的包改变）\"></a>场景3：动态引入时vendor hash发生变化（异步加载的包改变）</h4><ol>\n<li>在动态引入的代码中添加 异步module名称</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import(&#x2F;* webpackChunkName: &quot;print&quot; *&#x2F; &#39;.&#x2F;print&#39;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结优化打包\"><a href=\"#总结优化打包\" class=\"headerlink\" title=\"总结优化打包\"></a>总结优化打包</h4><ol>\n<li>独立打包vendor</li>\n<li>抽出manifest</li>\n<li>NameChunksPlugin\\NameModulesPlugin\\HashedModuleIdsPlugin</li>\n<li>动态加载模块设置名称</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"webpack-watch-mode\"><a href=\"#webpack-watch-mode\" class=\"headerlink\" title=\"webpack watch mode\"></a>webpack watch mode</h3><ul>\n<li>使用方式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack -watch</span><br><span class=\"line\">webpack -w</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>不会建立web服务器</li>\n</ul>\n<h3 id=\"webpack-dev-server\"><a href=\"#webpack-dev-server\" class=\"headerlink\" title=\"webpack-dev-server\"></a>webpack-dev-server</h3><ul>\n<li>live reloading (重新刷新浏览器)</li>\n<li>路径重定向</li>\n<li>https</li>\n<li>在浏览器显示编译错误</li>\n<li>接口代理</li>\n<li>模块热更新（不刷新浏览器更新代码）<a href=\"https://www.webpackjs.com/guides/hot-module-replacement/\">https://www.webpackjs.com/guides/hot-module-replacement/</a></li>\n<li>基本配置 <a href=\"https://www.webpackjs.com/configuration/dev-server/\">https://www.webpackjs.com/configuration/dev-server/</a></li>\n</ul>\n<h3 id=\"express-webpack-dev-middleware\"><a href=\"#express-webpack-dev-middleware\" class=\"headerlink\" title=\"express + webpack-dev-middleware\"></a>express + webpack-dev-middleware</h3><h3 id=\"开启source-map\"><a href=\"#开启source-map\" class=\"headerlink\" title=\"开启source-map\"></a>开启source-map</h3><h4 id=\"js开启source-map\"><a href=\"#js开启source-map\" class=\"headerlink\" title=\"js开启source-map\"></a>js开启source-map</h4><ul>\n<li>Devtool</li>\n</ul>\n<ol>\n<li>开发环境使用 cheap-module-source-map\\source-map</li>\n<li>生产环境使用 一般不用，如果修改问题可以配置为source-map</li>\n</ol>\n<ul>\n<li>生产环境uglify压缩时需要开启配置</li>\n<li>webpack.SourceMapDevToolPlugin</li>\n<li>webpack.EvalSourceMapDevToolPlugin</li>\n</ul>\n<h4 id=\"css开启source-map\"><a href=\"#css开启source-map\" class=\"headerlink\" title=\"css开启source-map\"></a>css开启source-map</h4><ul>\n<li>开启相关loader的sourcemap配置</li>\n</ul>\n<h3 id=\"开发环境和生产环境的区别\"><a href=\"#开发环境和生产环境的区别\" class=\"headerlink\" title=\"开发环境和生产环境的区别\"></a>开发环境和生产环境的区别</h3><h4 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h4><ol>\n<li>模块热更新</li>\n<li>sourceMap</li>\n<li>接口代理</li>\n<li>代码规范检查</li>\n</ol>\n<h4 id=\"生产环境\"><a href=\"#生产环境\" class=\"headerlink\" title=\"生产环境\"></a>生产环境</h4><ol>\n<li>提取公共代码</li>\n<li>压缩混淆</li>\n<li>文件压缩或base64编码</li>\n<li>去除无用代码 tree-shaking</li>\n<li>分离css</li>\n<li>打包代码配置</li>\n</ol>\n<h3 id=\"打包结果分析\"><a href=\"#打包结果分析\" class=\"headerlink\" title=\"打包结果分析\"></a>打包结果分析</h3><ul>\n<li>官方 Offical Analyse Tool</li>\n</ul>\n<ol>\n<li>命令</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack --profile --json &gt;stats.json</span><br><span class=\"line\">webpack --profile --json | Out-file &#39;stats.json&#39; - Encoding &#x2F;&#x2F;windows下命令</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>官方分析地址 <a href=\"http://webpack.github.io/analyse/\">http://webpack.github.io/analyse/</a></li>\n</ol>\n<ul>\n<li>webpack-bundle-analyzer</li>\n</ul>\n<ol>\n<li><p>抵用插件BundleAnalyzerPlugin <a href=\"https://www.npmjs.com/package/webpack-bundle-analyzer\">https://www.npmjs.com/package/webpack-bundle-analyzer</a></p>\n</li>\n<li><p>命令行</p>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack-bundle-analyzer stats.json</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"优化打包速度\"><a href=\"#优化打包速度\" class=\"headerlink\" title=\"优化打包速度\"></a>优化打包速度</h3><ol>\n<li>分开vendor与app（第三方与开发文件）使用Dllplugin与DllReferencePlugin</li>\n<li>UglifyJsPlugin 配置参数 parallel:true（并行处理压缩）</li>\n<li>UglifyJsPlugin cache缓存</li>\n<li>HappyPach 并行处理 loader</li>\n<li>babel-loader 配置 cacheDirectory开启缓存、配置include exlude规定范围</li>\n<li>其他</li>\n</ol>\n<ul>\n<li>减少 resolve</li>\n<li>去除 source-map</li>\n<li>cache-loader</li>\n<li>升级 node\\webpack</li>\n</ul>\n<h3 id=\"长缓存优化\"><a href=\"#长缓存优化\" class=\"headerlink\" title=\"长缓存优化\"></a>长缓存优化</h3><h4 id=\"场景1：app改变vendor也改变了\"><a href=\"#场景1：app改变vendor也改变了\" class=\"headerlink\" title=\"场景1：app改变vendor也改变了\"></a>场景1：app改变vendor也改变了</h4><ol>\n<li>提取vendor</li>\n<li>解决hash变化问题：hash-&gt;chunkhash(将打包的hash变为代码快的hash)，将output[hash]改为[chunkhash]</li>\n<li>提取 manifest 文件（提取webpack runtime 代码）</li>\n</ol>\n<h4 id=\"场景2：引入新的模块，模块顺序发生变化，vendor-hash变化了（因为chunkId变了）\"><a href=\"#场景2：引入新的模块，模块顺序发生变化，vendor-hash变化了（因为chunkId变了）\" class=\"headerlink\" title=\"场景2：引入新的模块，模块顺序发生变化，vendor hash变化了（因为chunkId变了）\"></a>场景2：引入新的模块，模块顺序发生变化，vendor hash变化了（因为chunkId变了）</h4><ol>\n<li>NameChunksPlugin 改变chunk名</li>\n<li>保持moduleId稳定 NameModulesPlugin （如果想看打包module name命令行添加 –display-modules）</li>\n<li>或者使用HashedModuleIdsPlugin 保持moduleId稳定</li>\n</ol>\n<ul>\n<li>vue配置</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 保持chunkId不变</span><br><span class=\"line\">new webpack.NamedChunksPlugin(),</span><br><span class=\"line\">&#x2F;&#x2F; 保持moduleID稳定</span><br><span class=\"line\">new webpack.HashedModuleIdsPlugin(),</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"场景3：动态引入时vendor-hash发生变化（异步加载的包改变）\"><a href=\"#场景3：动态引入时vendor-hash发生变化（异步加载的包改变）\" class=\"headerlink\" title=\"场景3：动态引入时vendor hash发生变化（异步加载的包改变）\"></a>场景3：动态引入时vendor hash发生变化（异步加载的包改变）</h4><ol>\n<li>在动态引入的代码中添加 异步module名称</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import(&#x2F;* webpackChunkName: &quot;print&quot; *&#x2F; &#39;.&#x2F;print&#39;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"总结优化打包\"><a href=\"#总结优化打包\" class=\"headerlink\" title=\"总结优化打包\"></a>总结优化打包</h4><ol>\n<li>独立打包vendor</li>\n<li>抽出manifest</li>\n<li>NameChunksPlugin\\NameModulesPlugin\\HashedModuleIdsPlugin</li>\n<li>动态加载模块设置名称</li>\n</ol>\n"},{"title":"<webpack>简介以及相关概念","date":"2018-12-18T16:00:00.000Z","_content":"\n### 作者为什么要开发webpack\n\n- 为了实现代码分割功能\n\n### 为什么要构建\n\n- 开发分工变化：单页面应用、越来越复杂、文件越来越多\n- 框架演变：由js库变为前端框架、模块化开发、新的语法特性、逻辑分层、MVVM框架\n- 语言的发展：HTML(W3C)、css->less\\sass\\stylus预处理工具、js->ts\\模块化\\ES6\n- 环境的变化：前端代码可以使用node环境服务\n- 社区变化：github、npm 包管理需要构建\n- 工具的变化：grunt\\gulp\\webpack\\rollup\n- #### 为什么要webpack\n- Vue-cli\\React-starter\\Angular-cli 都是webpack构建的\n- 支持Code-Spliting(代码分割)\n- 支持模块化\n\n### 模块化开发\n\n- 命名空间->commonjs(只能在nodejs服务端使用)->AMD|CMD|UMD->ES6 module\n- 命名空间\n\n```\nvar NameSpace = {}\nNameSpace.type = NameSpace.type || {}\nNameSpace.type.method = function(){}\n```\n\n#### commonjs\n\n1. 一个文件是一个模块\n2. 通过 module.exports 暴露模块接口\n\n#### AMD\n\n1. 使用 define 定义模块、使用 require 加载模块\n2. RequireJS\n3. 依赖前置，提前执行\n\n```\ndefine(['jquery'], function ($) {\n    //    methods\n    function myFunc(){};\n\n    //    exposed public methods\n    return myFunc;\n});\n```\n\n#### CMD\n\n1. SeaJS\n2. 尽可能懒执行\n\n```\ndefine(function (require, exports, module) {\n    // load dependence\n    var $ = require('jquery');\n\n    //    methods\n    function myFunc(){};\n\n    //    exposed public methods\n    return myFunc;\n})\n```\n\n#### UMD(Universal Module Definition)通用模块解决方案\n\n1. 判断是否支持AMD\n2. 判断是否支持commonJS\n3. 如果都没有，使用全局变量\n\n```\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['jquery'], factory);\n    } else if (typeof exports === 'object') {\n        // Node, CommonJS-like\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.jQuery);\n    }\n}(this, function ($) {\n    //    methods\n    function myFunc(){};\n\n    //    exposed public method\n    return myFunc;\n}));\n```\n\n#### ESM\n\n1. 一个文件一个模块 export/import\n\n#### webpack支持的模块化\n\n- AMD\\ES Module(推荐)\\CommonJS\n\n#### css模块化\n\n- CSS设计模式：OOCSS\\SMACSS\\Atomic css\\MCSS\\AMCSS\\BEM\n- CSS Module：\n\n### webpack简介\n\n#### 功能进化\n\n- v2版本\n\n1. Tree Shaking\n2. ES Module\n3. 动态 import\n4. 新的文档\n\n- v3版本\n\n1. Scope Hoisting（作用于提升）打包后代码性能提升\n2. Magic Comments (配合动态import使用) 指定打包后的文件名\n\n- v4版本\n\n#### 核心概念\n\n- entry\n\n1. 代码入口、打包入口、单个或者多个\n\n```\nmodule.exports = {\n    entry: {\n        index: 'index.js',\n        vendor: ['jquery']\n    }\n}\n```\n\n- output\n\n1. 对打包生成文件的描述、一个或者多个\n2. https://www.webpackjs.com/configuration/output/\n\n- Loaders\n\n1. 处理文件、转化为模块\n2. https://www.webpackjs.com/loaders/\n\n- Plugins\n\n1. 参与整个打包过程\n2. https://www.webpackjs.com/plugins/\n\n#### 名词\n\n- chunk 代码块\n- Bundle 打包后的文件\n- Module 模块\n","source":"_posts/[webpack]简介以及相关概念.md","raw":"---\ntitle: <webpack>简介以及相关概念\ndate: 2018-12-19 00:00:00\ntags: [webpack]\ncategories: webpack\n---\n\n### 作者为什么要开发webpack\n\n- 为了实现代码分割功能\n\n### 为什么要构建\n\n- 开发分工变化：单页面应用、越来越复杂、文件越来越多\n- 框架演变：由js库变为前端框架、模块化开发、新的语法特性、逻辑分层、MVVM框架\n- 语言的发展：HTML(W3C)、css->less\\sass\\stylus预处理工具、js->ts\\模块化\\ES6\n- 环境的变化：前端代码可以使用node环境服务\n- 社区变化：github、npm 包管理需要构建\n- 工具的变化：grunt\\gulp\\webpack\\rollup\n- #### 为什么要webpack\n- Vue-cli\\React-starter\\Angular-cli 都是webpack构建的\n- 支持Code-Spliting(代码分割)\n- 支持模块化\n\n### 模块化开发\n\n- 命名空间->commonjs(只能在nodejs服务端使用)->AMD|CMD|UMD->ES6 module\n- 命名空间\n\n```\nvar NameSpace = {}\nNameSpace.type = NameSpace.type || {}\nNameSpace.type.method = function(){}\n```\n\n#### commonjs\n\n1. 一个文件是一个模块\n2. 通过 module.exports 暴露模块接口\n\n#### AMD\n\n1. 使用 define 定义模块、使用 require 加载模块\n2. RequireJS\n3. 依赖前置，提前执行\n\n```\ndefine(['jquery'], function ($) {\n    //    methods\n    function myFunc(){};\n\n    //    exposed public methods\n    return myFunc;\n});\n```\n\n#### CMD\n\n1. SeaJS\n2. 尽可能懒执行\n\n```\ndefine(function (require, exports, module) {\n    // load dependence\n    var $ = require('jquery');\n\n    //    methods\n    function myFunc(){};\n\n    //    exposed public methods\n    return myFunc;\n})\n```\n\n#### UMD(Universal Module Definition)通用模块解决方案\n\n1. 判断是否支持AMD\n2. 判断是否支持commonJS\n3. 如果都没有，使用全局变量\n\n```\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['jquery'], factory);\n    } else if (typeof exports === 'object') {\n        // Node, CommonJS-like\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.jQuery);\n    }\n}(this, function ($) {\n    //    methods\n    function myFunc(){};\n\n    //    exposed public method\n    return myFunc;\n}));\n```\n\n#### ESM\n\n1. 一个文件一个模块 export/import\n\n#### webpack支持的模块化\n\n- AMD\\ES Module(推荐)\\CommonJS\n\n#### css模块化\n\n- CSS设计模式：OOCSS\\SMACSS\\Atomic css\\MCSS\\AMCSS\\BEM\n- CSS Module：\n\n### webpack简介\n\n#### 功能进化\n\n- v2版本\n\n1. Tree Shaking\n2. ES Module\n3. 动态 import\n4. 新的文档\n\n- v3版本\n\n1. Scope Hoisting（作用于提升）打包后代码性能提升\n2. Magic Comments (配合动态import使用) 指定打包后的文件名\n\n- v4版本\n\n#### 核心概念\n\n- entry\n\n1. 代码入口、打包入口、单个或者多个\n\n```\nmodule.exports = {\n    entry: {\n        index: 'index.js',\n        vendor: ['jquery']\n    }\n}\n```\n\n- output\n\n1. 对打包生成文件的描述、一个或者多个\n2. https://www.webpackjs.com/configuration/output/\n\n- Loaders\n\n1. 处理文件、转化为模块\n2. https://www.webpackjs.com/loaders/\n\n- Plugins\n\n1. 参与整个打包过程\n2. https://www.webpackjs.com/plugins/\n\n#### 名词\n\n- chunk 代码块\n- Bundle 打包后的文件\n- Module 模块\n","slug":"[webpack]简介以及相关概念","published":1,"updated":"2021-03-15T14:41:02.946Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dl7003mwotjdu4k4o20","content":"<h3 id=\"作者为什么要开发webpack\"><a href=\"#作者为什么要开发webpack\" class=\"headerlink\" title=\"作者为什么要开发webpack\"></a>作者为什么要开发webpack</h3><ul>\n<li>为了实现代码分割功能</li>\n</ul>\n<h3 id=\"为什么要构建\"><a href=\"#为什么要构建\" class=\"headerlink\" title=\"为什么要构建\"></a>为什么要构建</h3><ul>\n<li>开发分工变化：单页面应用、越来越复杂、文件越来越多</li>\n<li>框架演变：由js库变为前端框架、模块化开发、新的语法特性、逻辑分层、MVVM框架</li>\n<li>语言的发展：HTML(W3C)、css-&gt;less\\sass\\stylus预处理工具、js-&gt;ts\\模块化\\ES6</li>\n<li>环境的变化：前端代码可以使用node环境服务</li>\n<li>社区变化：github、npm 包管理需要构建</li>\n<li>工具的变化：grunt\\gulp\\webpack\\rollup</li>\n<li><h4 id=\"为什么要webpack\"><a href=\"#为什么要webpack\" class=\"headerlink\" title=\"为什么要webpack\"></a>为什么要webpack</h4></li>\n<li>Vue-cli\\React-starter\\Angular-cli 都是webpack构建的</li>\n<li>支持Code-Spliting(代码分割)</li>\n<li>支持模块化</li>\n</ul>\n<h3 id=\"模块化开发\"><a href=\"#模块化开发\" class=\"headerlink\" title=\"模块化开发\"></a>模块化开发</h3><ul>\n<li>命名空间-&gt;commonjs(只能在nodejs服务端使用)-&gt;AMD|CMD|UMD-&gt;ES6 module</li>\n<li>命名空间</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var NameSpace &#x3D; &#123;&#125;</span><br><span class=\"line\">NameSpace.type &#x3D; NameSpace.type || &#123;&#125;</span><br><span class=\"line\">NameSpace.type.method &#x3D; function()&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"commonjs\"><a href=\"#commonjs\" class=\"headerlink\" title=\"commonjs\"></a>commonjs</h4><ol>\n<li>一个文件是一个模块</li>\n<li>通过 module.exports 暴露模块接口</li>\n</ol>\n<h4 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h4><ol>\n<li>使用 define 定义模块、使用 require 加载模块</li>\n<li>RequireJS</li>\n<li>依赖前置，提前执行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([&#39;jquery&#39;], function ($) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;    methods</span><br><span class=\"line\">    function myFunc()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;    exposed public methods</span><br><span class=\"line\">    return myFunc;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h4><ol>\n<li>SeaJS</li>\n<li>尽可能懒执行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(function (require, exports, module) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; load dependence</span><br><span class=\"line\">    var $ &#x3D; require(&#39;jquery&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;    methods</span><br><span class=\"line\">    function myFunc()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;    exposed public methods</span><br><span class=\"line\">    return myFunc;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"UMD-Universal-Module-Definition-通用模块解决方案\"><a href=\"#UMD-Universal-Module-Definition-通用模块解决方案\" class=\"headerlink\" title=\"UMD(Universal Module Definition)通用模块解决方案\"></a>UMD(Universal Module Definition)通用模块解决方案</h4><ol>\n<li>判断是否支持AMD</li>\n<li>判断是否支持commonJS</li>\n<li>如果都没有，使用全局变量</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function (root, factory) &#123;</span><br><span class=\"line\">    if (typeof define &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; AMD</span><br><span class=\"line\">        define([&#39;jquery&#39;], factory);</span><br><span class=\"line\">    &#125; else if (typeof exports &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Node, CommonJS-like</span><br><span class=\"line\">        module.exports &#x3D; factory(require(&#39;jquery&#39;));</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Browser globals (root is window)</span><br><span class=\"line\">        root.returnExports &#x3D; factory(root.jQuery);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(this, function ($) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;    methods</span><br><span class=\"line\">    function myFunc()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;    exposed public method</span><br><span class=\"line\">    return myFunc;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ESM\"><a href=\"#ESM\" class=\"headerlink\" title=\"ESM\"></a>ESM</h4><ol>\n<li>一个文件一个模块 export/import</li>\n</ol>\n<h4 id=\"webpack支持的模块化\"><a href=\"#webpack支持的模块化\" class=\"headerlink\" title=\"webpack支持的模块化\"></a>webpack支持的模块化</h4><ul>\n<li>AMD\\ES Module(推荐)\\CommonJS</li>\n</ul>\n<h4 id=\"css模块化\"><a href=\"#css模块化\" class=\"headerlink\" title=\"css模块化\"></a>css模块化</h4><ul>\n<li>CSS设计模式：OOCSS\\SMACSS\\Atomic css\\MCSS\\AMCSS\\BEM</li>\n<li>CSS Module：</li>\n</ul>\n<h3 id=\"webpack简介\"><a href=\"#webpack简介\" class=\"headerlink\" title=\"webpack简介\"></a>webpack简介</h3><h4 id=\"功能进化\"><a href=\"#功能进化\" class=\"headerlink\" title=\"功能进化\"></a>功能进化</h4><ul>\n<li>v2版本</li>\n</ul>\n<ol>\n<li>Tree Shaking</li>\n<li>ES Module</li>\n<li>动态 import</li>\n<li>新的文档</li>\n</ol>\n<ul>\n<li>v3版本</li>\n</ul>\n<ol>\n<li>Scope Hoisting（作用于提升）打包后代码性能提升</li>\n<li>Magic Comments (配合动态import使用) 指定打包后的文件名</li>\n</ol>\n<ul>\n<li>v4版本</li>\n</ul>\n<h4 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h4><ul>\n<li>entry</li>\n</ul>\n<ol>\n<li>代码入口、打包入口、单个或者多个</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        index: &#39;index.js&#39;,</span><br><span class=\"line\">        vendor: [&#39;jquery&#39;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>output</li>\n</ul>\n<ol>\n<li>对打包生成文件的描述、一个或者多个</li>\n<li><a href=\"https://www.webpackjs.com/configuration/output/\">https://www.webpackjs.com/configuration/output/</a></li>\n</ol>\n<ul>\n<li>Loaders</li>\n</ul>\n<ol>\n<li>处理文件、转化为模块</li>\n<li><a href=\"https://www.webpackjs.com/loaders/\">https://www.webpackjs.com/loaders/</a></li>\n</ol>\n<ul>\n<li>Plugins</li>\n</ul>\n<ol>\n<li>参与整个打包过程</li>\n<li><a href=\"https://www.webpackjs.com/plugins/\">https://www.webpackjs.com/plugins/</a></li>\n</ol>\n<h4 id=\"名词\"><a href=\"#名词\" class=\"headerlink\" title=\"名词\"></a>名词</h4><ul>\n<li>chunk 代码块</li>\n<li>Bundle 打包后的文件</li>\n<li>Module 模块</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"作者为什么要开发webpack\"><a href=\"#作者为什么要开发webpack\" class=\"headerlink\" title=\"作者为什么要开发webpack\"></a>作者为什么要开发webpack</h3><ul>\n<li>为了实现代码分割功能</li>\n</ul>\n<h3 id=\"为什么要构建\"><a href=\"#为什么要构建\" class=\"headerlink\" title=\"为什么要构建\"></a>为什么要构建</h3><ul>\n<li>开发分工变化：单页面应用、越来越复杂、文件越来越多</li>\n<li>框架演变：由js库变为前端框架、模块化开发、新的语法特性、逻辑分层、MVVM框架</li>\n<li>语言的发展：HTML(W3C)、css-&gt;less\\sass\\stylus预处理工具、js-&gt;ts\\模块化\\ES6</li>\n<li>环境的变化：前端代码可以使用node环境服务</li>\n<li>社区变化：github、npm 包管理需要构建</li>\n<li>工具的变化：grunt\\gulp\\webpack\\rollup</li>\n<li><h4 id=\"为什么要webpack\"><a href=\"#为什么要webpack\" class=\"headerlink\" title=\"为什么要webpack\"></a>为什么要webpack</h4></li>\n<li>Vue-cli\\React-starter\\Angular-cli 都是webpack构建的</li>\n<li>支持Code-Spliting(代码分割)</li>\n<li>支持模块化</li>\n</ul>\n<h3 id=\"模块化开发\"><a href=\"#模块化开发\" class=\"headerlink\" title=\"模块化开发\"></a>模块化开发</h3><ul>\n<li>命名空间-&gt;commonjs(只能在nodejs服务端使用)-&gt;AMD|CMD|UMD-&gt;ES6 module</li>\n<li>命名空间</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var NameSpace &#x3D; &#123;&#125;</span><br><span class=\"line\">NameSpace.type &#x3D; NameSpace.type || &#123;&#125;</span><br><span class=\"line\">NameSpace.type.method &#x3D; function()&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"commonjs\"><a href=\"#commonjs\" class=\"headerlink\" title=\"commonjs\"></a>commonjs</h4><ol>\n<li>一个文件是一个模块</li>\n<li>通过 module.exports 暴露模块接口</li>\n</ol>\n<h4 id=\"AMD\"><a href=\"#AMD\" class=\"headerlink\" title=\"AMD\"></a>AMD</h4><ol>\n<li>使用 define 定义模块、使用 require 加载模块</li>\n<li>RequireJS</li>\n<li>依赖前置，提前执行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([&#39;jquery&#39;], function ($) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;    methods</span><br><span class=\"line\">    function myFunc()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;    exposed public methods</span><br><span class=\"line\">    return myFunc;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"CMD\"><a href=\"#CMD\" class=\"headerlink\" title=\"CMD\"></a>CMD</h4><ol>\n<li>SeaJS</li>\n<li>尽可能懒执行</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(function (require, exports, module) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F; load dependence</span><br><span class=\"line\">    var $ &#x3D; require(&#39;jquery&#39;);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;    methods</span><br><span class=\"line\">    function myFunc()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;    exposed public methods</span><br><span class=\"line\">    return myFunc;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"UMD-Universal-Module-Definition-通用模块解决方案\"><a href=\"#UMD-Universal-Module-Definition-通用模块解决方案\" class=\"headerlink\" title=\"UMD(Universal Module Definition)通用模块解决方案\"></a>UMD(Universal Module Definition)通用模块解决方案</h4><ol>\n<li>判断是否支持AMD</li>\n<li>判断是否支持commonJS</li>\n<li>如果都没有，使用全局变量</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function (root, factory) &#123;</span><br><span class=\"line\">    if (typeof define &#x3D;&#x3D;&#x3D; &#39;function&#39; &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; AMD</span><br><span class=\"line\">        define([&#39;jquery&#39;], factory);</span><br><span class=\"line\">    &#125; else if (typeof exports &#x3D;&#x3D;&#x3D; &#39;object&#39;) &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Node, CommonJS-like</span><br><span class=\"line\">        module.exports &#x3D; factory(require(&#39;jquery&#39;));</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        &#x2F;&#x2F; Browser globals (root is window)</span><br><span class=\"line\">        root.returnExports &#x3D; factory(root.jQuery);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(this, function ($) &#123;</span><br><span class=\"line\">    &#x2F;&#x2F;    methods</span><br><span class=\"line\">    function myFunc()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;&#x2F;    exposed public method</span><br><span class=\"line\">    return myFunc;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"ESM\"><a href=\"#ESM\" class=\"headerlink\" title=\"ESM\"></a>ESM</h4><ol>\n<li>一个文件一个模块 export/import</li>\n</ol>\n<h4 id=\"webpack支持的模块化\"><a href=\"#webpack支持的模块化\" class=\"headerlink\" title=\"webpack支持的模块化\"></a>webpack支持的模块化</h4><ul>\n<li>AMD\\ES Module(推荐)\\CommonJS</li>\n</ul>\n<h4 id=\"css模块化\"><a href=\"#css模块化\" class=\"headerlink\" title=\"css模块化\"></a>css模块化</h4><ul>\n<li>CSS设计模式：OOCSS\\SMACSS\\Atomic css\\MCSS\\AMCSS\\BEM</li>\n<li>CSS Module：</li>\n</ul>\n<h3 id=\"webpack简介\"><a href=\"#webpack简介\" class=\"headerlink\" title=\"webpack简介\"></a>webpack简介</h3><h4 id=\"功能进化\"><a href=\"#功能进化\" class=\"headerlink\" title=\"功能进化\"></a>功能进化</h4><ul>\n<li>v2版本</li>\n</ul>\n<ol>\n<li>Tree Shaking</li>\n<li>ES Module</li>\n<li>动态 import</li>\n<li>新的文档</li>\n</ol>\n<ul>\n<li>v3版本</li>\n</ul>\n<ol>\n<li>Scope Hoisting（作用于提升）打包后代码性能提升</li>\n<li>Magic Comments (配合动态import使用) 指定打包后的文件名</li>\n</ol>\n<ul>\n<li>v4版本</li>\n</ul>\n<h4 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h4><ul>\n<li>entry</li>\n</ul>\n<ol>\n<li>代码入口、打包入口、单个或者多个</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports &#x3D; &#123;</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        index: &#39;index.js&#39;,</span><br><span class=\"line\">        vendor: [&#39;jquery&#39;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>output</li>\n</ul>\n<ol>\n<li>对打包生成文件的描述、一个或者多个</li>\n<li><a href=\"https://www.webpackjs.com/configuration/output/\">https://www.webpackjs.com/configuration/output/</a></li>\n</ol>\n<ul>\n<li>Loaders</li>\n</ul>\n<ol>\n<li>处理文件、转化为模块</li>\n<li><a href=\"https://www.webpackjs.com/loaders/\">https://www.webpackjs.com/loaders/</a></li>\n</ol>\n<ul>\n<li>Plugins</li>\n</ul>\n<ol>\n<li>参与整个打包过程</li>\n<li><a href=\"https://www.webpackjs.com/plugins/\">https://www.webpackjs.com/plugins/</a></li>\n</ol>\n<h4 id=\"名词\"><a href=\"#名词\" class=\"headerlink\" title=\"名词\"></a>名词</h4><ul>\n<li>chunk 代码块</li>\n<li>Bundle 打包后的文件</li>\n<li>Module 模块</li>\n</ul>\n"},{"title":"<webpack>配置全局常量","date":"2018-09-25T16:00:00.000Z","_content":"\n### 简介\n\n- 需求：进行项目打包时需要配置不同的服务url，手动去更改容易出错，因此将不同url打包写入程序，根据webpack配置不同打包命令。需要用到全局常量的配置。\n\n### webpack配置文件中的全局常量\n\n- 使用 [cross-env](https://www.npmjs.com/package/cross-env) 库可以配置webpack配置文件中的全局常量。\n首先安装这个库：\n\n```\nnpm install --save-dev cross-env\n```\n\n- 修改package.json中的命令：\n\n```\n\"scripts\": {\n    \"build-qa\": \"cross-env OUTPUT_DATA=qa node webpack/build.js\"\n}\n```\n\n- 此时，执行npm run build-qa命令时可以在webpack配置文件中获取相关常量：\n\n```\n//webpack.prod.conf.js文件中\nconsole.log(process.env.OUTPUT_DATA)//qa\n```\n\n### 配置打包代码中的全局常量\n\n- 使用 [DefinePlugin](https://www.webpackjs.com/plugins/define-plugin/) 可以配置打包代码中的常量：\n具体配置：\n\n```\nnew webpack.DefinePlugin({\n    'process.env': {\n        NODE_ENV: '\"production\"',\n        OUTPUT_DATA: process.env.OUTPUT_DATA == 'qa' ? '\"qa\"' : '\"\"'\n    }\n})\n```\n\n- 注意，因为这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 '\"production\"', 或者使用 JSON.stringify('production')。\n- 配置之后，webpack会将项目代码中的process.env.OUTPUT_DATA、process.env.NODE_ENV 变量替换为对应的常量。\n- 结合以上两种方式，就可以控制webpack打包的常量了。\n\n\n\n","source":"_posts/[webpack]配置全局常量.md","raw":"---\ntitle: <webpack>配置全局常量\ndate: 2018-09-26 00:00:00\ntags: [webpack]\ncategories: webpack\n---\n\n### 简介\n\n- 需求：进行项目打包时需要配置不同的服务url，手动去更改容易出错，因此将不同url打包写入程序，根据webpack配置不同打包命令。需要用到全局常量的配置。\n\n### webpack配置文件中的全局常量\n\n- 使用 [cross-env](https://www.npmjs.com/package/cross-env) 库可以配置webpack配置文件中的全局常量。\n首先安装这个库：\n\n```\nnpm install --save-dev cross-env\n```\n\n- 修改package.json中的命令：\n\n```\n\"scripts\": {\n    \"build-qa\": \"cross-env OUTPUT_DATA=qa node webpack/build.js\"\n}\n```\n\n- 此时，执行npm run build-qa命令时可以在webpack配置文件中获取相关常量：\n\n```\n//webpack.prod.conf.js文件中\nconsole.log(process.env.OUTPUT_DATA)//qa\n```\n\n### 配置打包代码中的全局常量\n\n- 使用 [DefinePlugin](https://www.webpackjs.com/plugins/define-plugin/) 可以配置打包代码中的常量：\n具体配置：\n\n```\nnew webpack.DefinePlugin({\n    'process.env': {\n        NODE_ENV: '\"production\"',\n        OUTPUT_DATA: process.env.OUTPUT_DATA == 'qa' ? '\"qa\"' : '\"\"'\n    }\n})\n```\n\n- 注意，因为这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 '\"production\"', 或者使用 JSON.stringify('production')。\n- 配置之后，webpack会将项目代码中的process.env.OUTPUT_DATA、process.env.NODE_ENV 变量替换为对应的常量。\n- 结合以上两种方式，就可以控制webpack打包的常量了。\n\n\n\n","slug":"[webpack]配置全局常量","published":1,"updated":"2021-03-15T14:41:08.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dl8003pwotjcvk34dee","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>需求：进行项目打包时需要配置不同的服务url，手动去更改容易出错，因此将不同url打包写入程序，根据webpack配置不同打包命令。需要用到全局常量的配置。</li>\n</ul>\n<h3 id=\"webpack配置文件中的全局常量\"><a href=\"#webpack配置文件中的全局常量\" class=\"headerlink\" title=\"webpack配置文件中的全局常量\"></a>webpack配置文件中的全局常量</h3><ul>\n<li>使用 <a href=\"https://www.npmjs.com/package/cross-env\">cross-env</a> 库可以配置webpack配置文件中的全局常量。<br>首先安装这个库：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev cross-env</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改package.json中的命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;build-qa&quot;: &quot;cross-env OUTPUT_DATA&#x3D;qa node webpack&#x2F;build.js&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>此时，执行npm run build-qa命令时可以在webpack配置文件中获取相关常量：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;webpack.prod.conf.js文件中</span><br><span class=\"line\">console.log(process.env.OUTPUT_DATA)&#x2F;&#x2F;qa</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置打包代码中的全局常量\"><a href=\"#配置打包代码中的全局常量\" class=\"headerlink\" title=\"配置打包代码中的全局常量\"></a>配置打包代码中的全局常量</h3><ul>\n<li>使用 <a href=\"https://www.webpackjs.com/plugins/define-plugin/\">DefinePlugin</a> 可以配置打包代码中的常量：<br>具体配置：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new webpack.DefinePlugin(&#123;</span><br><span class=\"line\">    &#39;process.env&#39;: &#123;</span><br><span class=\"line\">        NODE_ENV: &#39;&quot;production&quot;&#39;,</span><br><span class=\"line\">        OUTPUT_DATA: process.env.OUTPUT_DATA &#x3D;&#x3D; &#39;qa&#39; ? &#39;&quot;qa&quot;&#39; : &#39;&quot;&quot;&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意，因为这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 ‘“production”‘, 或者使用 JSON.stringify(‘production’)。</li>\n<li>配置之后，webpack会将项目代码中的process.env.OUTPUT_DATA、process.env.NODE_ENV 变量替换为对应的常量。</li>\n<li>结合以上两种方式，就可以控制webpack打包的常量了。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>需求：进行项目打包时需要配置不同的服务url，手动去更改容易出错，因此将不同url打包写入程序，根据webpack配置不同打包命令。需要用到全局常量的配置。</li>\n</ul>\n<h3 id=\"webpack配置文件中的全局常量\"><a href=\"#webpack配置文件中的全局常量\" class=\"headerlink\" title=\"webpack配置文件中的全局常量\"></a>webpack配置文件中的全局常量</h3><ul>\n<li>使用 <a href=\"https://www.npmjs.com/package/cross-env\">cross-env</a> 库可以配置webpack配置文件中的全局常量。<br>首先安装这个库：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev cross-env</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>修改package.json中的命令：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;build-qa&quot;: &quot;cross-env OUTPUT_DATA&#x3D;qa node webpack&#x2F;build.js&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>此时，执行npm run build-qa命令时可以在webpack配置文件中获取相关常量：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;webpack.prod.conf.js文件中</span><br><span class=\"line\">console.log(process.env.OUTPUT_DATA)&#x2F;&#x2F;qa</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"配置打包代码中的全局常量\"><a href=\"#配置打包代码中的全局常量\" class=\"headerlink\" title=\"配置打包代码中的全局常量\"></a>配置打包代码中的全局常量</h3><ul>\n<li>使用 <a href=\"https://www.webpackjs.com/plugins/define-plugin/\">DefinePlugin</a> 可以配置打包代码中的常量：<br>具体配置：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new webpack.DefinePlugin(&#123;</span><br><span class=\"line\">    &#39;process.env&#39;: &#123;</span><br><span class=\"line\">        NODE_ENV: &#39;&quot;production&quot;&#39;,</span><br><span class=\"line\">        OUTPUT_DATA: process.env.OUTPUT_DATA &#x3D;&#x3D; &#39;qa&#39; ? &#39;&quot;qa&quot;&#39; : &#39;&quot;&quot;&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>注意，因为这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 ‘“production”‘, 或者使用 JSON.stringify(‘production’)。</li>\n<li>配置之后，webpack会将项目代码中的process.env.OUTPUT_DATA、process.env.NODE_ENV 变量替换为对应的常量。</li>\n<li>结合以上两种方式，就可以控制webpack打包的常量了。</li>\n</ul>\n"},{"title":"<前端>性能优化","date":"2019-02-13T03:06:38.000Z","_content":"\n#### http优化\n\n1. 减少单次请求时间\n2. 减少请求次数\n\n#### webpack优化\n\n1. 提高构建速度\n\n- bable-loader中使用 include 或 exclude 来帮我们避免不必要的转译，比如排除node_modules文件夹\n\n2. 使用DLLPlugin打包第三方库\n3. Happypack将 loader 由单进程转为多进程\n4. 使用tree-shaking删除冗余代码，UglifyJsPlugin\n5. webpack按需加载\n6. 使用CommonsChunkPlugin拆分公共代码，webpack4使用optimization.splitChunks\n\n- https://crazyaguai.github.io/2019/01/15/webpack-CommonsChunkPlugin%E4%B8%8Eoptimization-splitChunks/\n\n7. 生产环境关闭source-map\n8. 压缩混淆代码，UglifyJsPlugin\n9. 长缓存优化\n\n- https://crazyaguai.github.io/2018/12/21/webpack-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/#%E9%95%BF%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96\n\n10. html-webpack-inline-chunk-plugin提前加载manifest.js\n\n#### 服务器开启gzip\n\n#### 图片优化\n- 一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。\n\n1. JPEG/JPG：有损压缩、体积小、加载快、不支持透明\n\n- 优点：有损压缩，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。\n- 使用场景：JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG图片经常作为大的背景图、轮播图或 Banner 图出现。\n- 缺点：处理矢量图形和 Logo等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。JPEG 图像不支持透明度处理。\n\n2. PNG-8 与 PNG-24：无损压缩、质量高、体积大、支持透明\n\n- 使用场景：呈现小的 Logo、颜色简单且对比强烈的图片或背景等。\n\n3. SVG：文本文件、体积小、不失真、兼容性好\n\n- 特性：SVG 与 PNG 和 JPG 相比，文件体积更小，可压缩性更强。图片可无限放大而不失真。SVG 是文本文件，可以直接写在html dom中。\n- 局限：渲染成本比较高，有学习成本（是可编程的）。\n- 使用场景：\n\n4. base64：文本文件、依赖编码、小图标解决方案\n\n- Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。\n- 应用场景：小图标，更新频率非常低\n- url-loader可配置转换为base64图\n\n5. WebP\n\n- Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。\n- WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。\n- 局限性：浏览器支持情况不好，增加服务器的负担（编码同样质量的WebP文件会占用更多的计算资源。）\n\n#### 浏览器缓存\n\n1. Memory Cache\n\n- 指内存中的缓存，从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。\n- Base64 格式的图片，几乎永远可以被塞进 memory cache，体积不大的 JS、CSS文件，也有较大地被写入内存的几率。\n\n2. Service Worker Cache\n\n- Service Worker 是一种独立于主线程之外的 Javascript 线程。\n- https://www.jianshu.com/p/62338c038c42\n\n3. HTTP Cache\n\n- https://crazyaguai.github.io/2018/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/\n\n4. Push Cache\n\n- Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。\n\n#### 本地存储\n\n1. cookie\n- 劣势：有体积上限（4KB）,紧跟域名，会带来资源浪费，同一个域名下的所有请求，都会携带 Cookie。\n2. web storage\n\n- 特性：存储容量大，仅位于浏览器端，不与服务端发生通信。\n- Local Storage 与 Session Storage 的区别：**生命周期**，Local Storage 是持久化的本地存储，Session Storage 是临时性的本地存储。**作用域**，Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享(不同tab页面不能共享)。\n\n#### 使用CDN缓存\n\n- CDN 的核心点有两个，一个是缓存，一个是回源（缓存过期向上层服务器请求资源）。\n- CDN 往往被用来存放静态资源。“静态资源”，就是像JS、CSS、图片等不需要业务服务器进行计算即得的资源。\n#### 服务端渲染\n#### 浏览器运行机制\n- 渲染过程：首先基于 HTML 构建一个 DOM 树，这棵 DOM 树与 CSS 解释器解析出的 CSSOM 相结合，就有了布局渲染树。最后浏览器以布局渲染树为蓝本，去计算布局并绘制图像，我们页面的初次渲染就大功告成了。\n\n1. CSS 优化\n\n- CSS 选择符是从右到左进行匹配的。\n- 避免使用通配符，只对需要用到的元素进行选择。\n- 关注可以通过继承实现的属性，避免重复匹配重复定义。\n- 少用标签选择器。如果可以，用类选择器替代。\n- 减少选择器嵌套。\n\n2. CSS与JS加载顺序优化\n\n- CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。\n- JS 引擎是独立于渲染引擎存在的。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。\n- 通过对JS使用 defer 和 async 来避免不必要的阻塞。\n- async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行。\n- defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。\n- 脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。\n\n#### DOM优化\n\n1. DOM操作为什么慢：（1）JS 引擎和渲染引擎（浏览器内核）是独立实现的。用 JS 去操作 DOM 时依赖了桥接接口作为“桥梁”。（2）DOM 的修改引发样式的更迭，会触发回流或重绘。\n2. 回流（重排）：当我们对 DOM 的修改引发了DOM几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）。时\n3. 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时。\n4. 重绘不一定导致回流，回流一定会导致重绘。回流比重绘做的事情更多，带来的开销也更大。\n5. 减少DOM操作\n（1）使用js变量 （2）使用DocumentFragment（表示一个没有父级文件的最小文档对象，不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。）https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment\n\n```\nlet container = document.getElementById('container')\n// 创建一个DOM Fragment对象作为容器\nlet content = document.createDocumentFragment()\nfor(let count=0;count<10000;count++){\n  let oSpan = document.createElement(\"span\")\n  oSpan.innerHTML = '我是一个小测试'\n  content.appendChild(oSpan)\n}\ncontainer.appendChild(content)\n```\n\n#### Event Loop 与异步更新\n\n- https://crazyaguai.github.io/2018/10/20/js-eventLoop/\n\n#### 回流与重绘\n\n1. 触发回流：（1）几何属性有 width、height、padding、margin、left、top、border （2）节点的增减、移动等操作。（3）获取一些也定属性的值（需要即时计算），offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight\n2. （1）避免回流与重绘（用js变量将缓存属性值）（2）避免逐条改变样式（通过修改class修改style）(3)将DOM离线，设置display: none，之后再操作\n3. Flush对列\n\n- 浏览器会缓存flush对列，优化Layout和Paint。\n\n#### Lazy-Load优化首屏体验\n\n- 监听屏幕加载页面\n\n#### 节流（throttle）与防抖（debounce）\n\n- https://crazyaguai.github.io/2018/11/15/js-%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/\n\n#### 性能监控\n\n- chrome Performance面板\n- LightHouse\n","source":"_posts/[前端]性能优化.md","raw":"---\ntitle: <前端>性能优化\ndate: 2019-02-13 11:06:38\ntags: [性能优化,浏览器,js]\ncategories: 性能优化\n---\n\n#### http优化\n\n1. 减少单次请求时间\n2. 减少请求次数\n\n#### webpack优化\n\n1. 提高构建速度\n\n- bable-loader中使用 include 或 exclude 来帮我们避免不必要的转译，比如排除node_modules文件夹\n\n2. 使用DLLPlugin打包第三方库\n3. Happypack将 loader 由单进程转为多进程\n4. 使用tree-shaking删除冗余代码，UglifyJsPlugin\n5. webpack按需加载\n6. 使用CommonsChunkPlugin拆分公共代码，webpack4使用optimization.splitChunks\n\n- https://crazyaguai.github.io/2019/01/15/webpack-CommonsChunkPlugin%E4%B8%8Eoptimization-splitChunks/\n\n7. 生产环境关闭source-map\n8. 压缩混淆代码，UglifyJsPlugin\n9. 长缓存优化\n\n- https://crazyaguai.github.io/2018/12/21/webpack-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/#%E9%95%BF%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96\n\n10. html-webpack-inline-chunk-plugin提前加载manifest.js\n\n#### 服务器开启gzip\n\n#### 图片优化\n- 一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。\n\n1. JPEG/JPG：有损压缩、体积小、加载快、不支持透明\n\n- 优点：有损压缩，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。\n- 使用场景：JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG图片经常作为大的背景图、轮播图或 Banner 图出现。\n- 缺点：处理矢量图形和 Logo等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。JPEG 图像不支持透明度处理。\n\n2. PNG-8 与 PNG-24：无损压缩、质量高、体积大、支持透明\n\n- 使用场景：呈现小的 Logo、颜色简单且对比强烈的图片或背景等。\n\n3. SVG：文本文件、体积小、不失真、兼容性好\n\n- 特性：SVG 与 PNG 和 JPG 相比，文件体积更小，可压缩性更强。图片可无限放大而不失真。SVG 是文本文件，可以直接写在html dom中。\n- 局限：渲染成本比较高，有学习成本（是可编程的）。\n- 使用场景：\n\n4. base64：文本文件、依赖编码、小图标解决方案\n\n- Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。\n- 应用场景：小图标，更新频率非常低\n- url-loader可配置转换为base64图\n\n5. WebP\n\n- Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。\n- WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。\n- 局限性：浏览器支持情况不好，增加服务器的负担（编码同样质量的WebP文件会占用更多的计算资源。）\n\n#### 浏览器缓存\n\n1. Memory Cache\n\n- 指内存中的缓存，从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。\n- Base64 格式的图片，几乎永远可以被塞进 memory cache，体积不大的 JS、CSS文件，也有较大地被写入内存的几率。\n\n2. Service Worker Cache\n\n- Service Worker 是一种独立于主线程之外的 Javascript 线程。\n- https://www.jianshu.com/p/62338c038c42\n\n3. HTTP Cache\n\n- https://crazyaguai.github.io/2018/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/\n\n4. Push Cache\n\n- Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。\n\n#### 本地存储\n\n1. cookie\n- 劣势：有体积上限（4KB）,紧跟域名，会带来资源浪费，同一个域名下的所有请求，都会携带 Cookie。\n2. web storage\n\n- 特性：存储容量大，仅位于浏览器端，不与服务端发生通信。\n- Local Storage 与 Session Storage 的区别：**生命周期**，Local Storage 是持久化的本地存储，Session Storage 是临时性的本地存储。**作用域**，Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享(不同tab页面不能共享)。\n\n#### 使用CDN缓存\n\n- CDN 的核心点有两个，一个是缓存，一个是回源（缓存过期向上层服务器请求资源）。\n- CDN 往往被用来存放静态资源。“静态资源”，就是像JS、CSS、图片等不需要业务服务器进行计算即得的资源。\n#### 服务端渲染\n#### 浏览器运行机制\n- 渲染过程：首先基于 HTML 构建一个 DOM 树，这棵 DOM 树与 CSS 解释器解析出的 CSSOM 相结合，就有了布局渲染树。最后浏览器以布局渲染树为蓝本，去计算布局并绘制图像，我们页面的初次渲染就大功告成了。\n\n1. CSS 优化\n\n- CSS 选择符是从右到左进行匹配的。\n- 避免使用通配符，只对需要用到的元素进行选择。\n- 关注可以通过继承实现的属性，避免重复匹配重复定义。\n- 少用标签选择器。如果可以，用类选择器替代。\n- 减少选择器嵌套。\n\n2. CSS与JS加载顺序优化\n\n- CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。\n- JS 引擎是独立于渲染引擎存在的。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。\n- 通过对JS使用 defer 和 async 来避免不必要的阻塞。\n- async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行。\n- defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。\n- 脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。\n\n#### DOM优化\n\n1. DOM操作为什么慢：（1）JS 引擎和渲染引擎（浏览器内核）是独立实现的。用 JS 去操作 DOM 时依赖了桥接接口作为“桥梁”。（2）DOM 的修改引发样式的更迭，会触发回流或重绘。\n2. 回流（重排）：当我们对 DOM 的修改引发了DOM几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）。时\n3. 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时。\n4. 重绘不一定导致回流，回流一定会导致重绘。回流比重绘做的事情更多，带来的开销也更大。\n5. 减少DOM操作\n（1）使用js变量 （2）使用DocumentFragment（表示一个没有父级文件的最小文档对象，不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。）https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment\n\n```\nlet container = document.getElementById('container')\n// 创建一个DOM Fragment对象作为容器\nlet content = document.createDocumentFragment()\nfor(let count=0;count<10000;count++){\n  let oSpan = document.createElement(\"span\")\n  oSpan.innerHTML = '我是一个小测试'\n  content.appendChild(oSpan)\n}\ncontainer.appendChild(content)\n```\n\n#### Event Loop 与异步更新\n\n- https://crazyaguai.github.io/2018/10/20/js-eventLoop/\n\n#### 回流与重绘\n\n1. 触发回流：（1）几何属性有 width、height、padding、margin、left、top、border （2）节点的增减、移动等操作。（3）获取一些也定属性的值（需要即时计算），offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight\n2. （1）避免回流与重绘（用js变量将缓存属性值）（2）避免逐条改变样式（通过修改class修改style）(3)将DOM离线，设置display: none，之后再操作\n3. Flush对列\n\n- 浏览器会缓存flush对列，优化Layout和Paint。\n\n#### Lazy-Load优化首屏体验\n\n- 监听屏幕加载页面\n\n#### 节流（throttle）与防抖（debounce）\n\n- https://crazyaguai.github.io/2018/11/15/js-%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/\n\n#### 性能监控\n\n- chrome Performance面板\n- LightHouse\n","slug":"[前端]性能优化","published":1,"updated":"2021-03-15T14:35:21.752Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dl8003swotj1xs7ev1q","content":"<h4 id=\"http优化\"><a href=\"#http优化\" class=\"headerlink\" title=\"http优化\"></a>http优化</h4><ol>\n<li>减少单次请求时间</li>\n<li>减少请求次数</li>\n</ol>\n<h4 id=\"webpack优化\"><a href=\"#webpack优化\" class=\"headerlink\" title=\"webpack优化\"></a>webpack优化</h4><ol>\n<li>提高构建速度</li>\n</ol>\n<ul>\n<li>bable-loader中使用 include 或 exclude 来帮我们避免不必要的转译，比如排除node_modules文件夹</li>\n</ul>\n<ol start=\"2\">\n<li>使用DLLPlugin打包第三方库</li>\n<li>Happypack将 loader 由单进程转为多进程</li>\n<li>使用tree-shaking删除冗余代码，UglifyJsPlugin</li>\n<li>webpack按需加载</li>\n<li>使用CommonsChunkPlugin拆分公共代码，webpack4使用optimization.splitChunks</li>\n</ol>\n<ul>\n<li><a href=\"https://crazyaguai.github.io/2019/01/15/webpack-CommonsChunkPlugin%E4%B8%8Eoptimization-splitChunks/\">https://crazyaguai.github.io/2019/01/15/webpack-CommonsChunkPlugin%E4%B8%8Eoptimization-splitChunks/</a></li>\n</ul>\n<ol start=\"7\">\n<li>生产环境关闭source-map</li>\n<li>压缩混淆代码，UglifyJsPlugin</li>\n<li>长缓存优化</li>\n</ol>\n<ul>\n<li><a href=\"https://crazyaguai.github.io/2018/12/21/webpack-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/#%E9%95%BF%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96\">https://crazyaguai.github.io/2018/12/21/webpack-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/#%E9%95%BF%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96</a></li>\n</ul>\n<ol start=\"10\">\n<li>html-webpack-inline-chunk-plugin提前加载manifest.js</li>\n</ol>\n<h4 id=\"服务器开启gzip\"><a href=\"#服务器开启gzip\" class=\"headerlink\" title=\"服务器开启gzip\"></a>服务器开启gzip</h4><h4 id=\"图片优化\"><a href=\"#图片优化\" class=\"headerlink\" title=\"图片优化\"></a>图片优化</h4><ul>\n<li>一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。</li>\n</ul>\n<ol>\n<li>JPEG/JPG：有损压缩、体积小、加载快、不支持透明</li>\n</ol>\n<ul>\n<li>优点：有损压缩，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。</li>\n<li>使用场景：JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG图片经常作为大的背景图、轮播图或 Banner 图出现。</li>\n<li>缺点：处理矢量图形和 Logo等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。JPEG 图像不支持透明度处理。</li>\n</ul>\n<ol start=\"2\">\n<li>PNG-8 与 PNG-24：无损压缩、质量高、体积大、支持透明</li>\n</ol>\n<ul>\n<li>使用场景：呈现小的 Logo、颜色简单且对比强烈的图片或背景等。</li>\n</ul>\n<ol start=\"3\">\n<li>SVG：文本文件、体积小、不失真、兼容性好</li>\n</ol>\n<ul>\n<li>特性：SVG 与 PNG 和 JPG 相比，文件体积更小，可压缩性更强。图片可无限放大而不失真。SVG 是文本文件，可以直接写在html dom中。</li>\n<li>局限：渲染成本比较高，有学习成本（是可编程的）。</li>\n<li>使用场景：</li>\n</ul>\n<ol start=\"4\">\n<li>base64：文本文件、依赖编码、小图标解决方案</li>\n</ol>\n<ul>\n<li>Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。</li>\n<li>应用场景：小图标，更新频率非常低</li>\n<li>url-loader可配置转换为base64图</li>\n</ul>\n<ol start=\"5\">\n<li>WebP</li>\n</ol>\n<ul>\n<li>Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。</li>\n<li>WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。</li>\n<li>局限性：浏览器支持情况不好，增加服务器的负担（编码同样质量的WebP文件会占用更多的计算资源。）</li>\n</ul>\n<h4 id=\"浏览器缓存\"><a href=\"#浏览器缓存\" class=\"headerlink\" title=\"浏览器缓存\"></a>浏览器缓存</h4><ol>\n<li>Memory Cache</li>\n</ol>\n<ul>\n<li>指内存中的缓存，从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。</li>\n<li>Base64 格式的图片，几乎永远可以被塞进 memory cache，体积不大的 JS、CSS文件，也有较大地被写入内存的几率。</li>\n</ul>\n<ol start=\"2\">\n<li>Service Worker Cache</li>\n</ol>\n<ul>\n<li>Service Worker 是一种独立于主线程之外的 Javascript 线程。</li>\n<li><a href=\"https://www.jianshu.com/p/62338c038c42\">https://www.jianshu.com/p/62338c038c42</a></li>\n</ul>\n<ol start=\"3\">\n<li>HTTP Cache</li>\n</ol>\n<ul>\n<li><a href=\"https://crazyaguai.github.io/2018/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/\">https://crazyaguai.github.io/2018/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</a></li>\n</ul>\n<ol start=\"4\">\n<li>Push Cache</li>\n</ol>\n<ul>\n<li>Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。</li>\n</ul>\n<h4 id=\"本地存储\"><a href=\"#本地存储\" class=\"headerlink\" title=\"本地存储\"></a>本地存储</h4><ol>\n<li>cookie</li>\n</ol>\n<ul>\n<li>劣势：有体积上限（4KB）,紧跟域名，会带来资源浪费，同一个域名下的所有请求，都会携带 Cookie。</li>\n</ul>\n<ol start=\"2\">\n<li>web storage</li>\n</ol>\n<ul>\n<li>特性：存储容量大，仅位于浏览器端，不与服务端发生通信。</li>\n<li>Local Storage 与 Session Storage 的区别：<strong>生命周期</strong>，Local Storage 是持久化的本地存储，Session Storage 是临时性的本地存储。<strong>作用域</strong>，Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享(不同tab页面不能共享)。</li>\n</ul>\n<h4 id=\"使用CDN缓存\"><a href=\"#使用CDN缓存\" class=\"headerlink\" title=\"使用CDN缓存\"></a>使用CDN缓存</h4><ul>\n<li>CDN 的核心点有两个，一个是缓存，一个是回源（缓存过期向上层服务器请求资源）。</li>\n<li>CDN 往往被用来存放静态资源。“静态资源”，就是像JS、CSS、图片等不需要业务服务器进行计算即得的资源。<h4 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h4><h4 id=\"浏览器运行机制\"><a href=\"#浏览器运行机制\" class=\"headerlink\" title=\"浏览器运行机制\"></a>浏览器运行机制</h4></li>\n<li>渲染过程：首先基于 HTML 构建一个 DOM 树，这棵 DOM 树与 CSS 解释器解析出的 CSSOM 相结合，就有了布局渲染树。最后浏览器以布局渲染树为蓝本，去计算布局并绘制图像，我们页面的初次渲染就大功告成了。</li>\n</ul>\n<ol>\n<li>CSS 优化</li>\n</ol>\n<ul>\n<li>CSS 选择符是从右到左进行匹配的。</li>\n<li>避免使用通配符，只对需要用到的元素进行选择。</li>\n<li>关注可以通过继承实现的属性，避免重复匹配重复定义。</li>\n<li>少用标签选择器。如果可以，用类选择器替代。</li>\n<li>减少选择器嵌套。</li>\n</ul>\n<ol start=\"2\">\n<li>CSS与JS加载顺序优化</li>\n</ol>\n<ul>\n<li>CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</li>\n<li>JS 引擎是独立于渲染引擎存在的。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。</li>\n<li>通过对JS使用 defer 和 async 来避免不必要的阻塞。</li>\n<li>async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行。</li>\n<li>defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。</li>\n<li>脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。</li>\n</ul>\n<h4 id=\"DOM优化\"><a href=\"#DOM优化\" class=\"headerlink\" title=\"DOM优化\"></a>DOM优化</h4><ol>\n<li>DOM操作为什么慢：（1）JS 引擎和渲染引擎（浏览器内核）是独立实现的。用 JS 去操作 DOM 时依赖了桥接接口作为“桥梁”。（2）DOM 的修改引发样式的更迭，会触发回流或重绘。</li>\n<li>回流（重排）：当我们对 DOM 的修改引发了DOM几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）。时</li>\n<li>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时。</li>\n<li>重绘不一定导致回流，回流一定会导致重绘。回流比重绘做的事情更多，带来的开销也更大。</li>\n<li>减少DOM操作<br>（1）使用js变量 （2）使用DocumentFragment（表示一个没有父级文件的最小文档对象，不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。）<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment\">https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment</a></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let container &#x3D; document.getElementById(&#39;container&#39;)</span><br><span class=\"line\">&#x2F;&#x2F; 创建一个DOM Fragment对象作为容器</span><br><span class=\"line\">let content &#x3D; document.createDocumentFragment()</span><br><span class=\"line\">for(let count&#x3D;0;count&lt;10000;count++)&#123;</span><br><span class=\"line\">  let oSpan &#x3D; document.createElement(&quot;span&quot;)</span><br><span class=\"line\">  oSpan.innerHTML &#x3D; &#39;我是一个小测试&#39;</span><br><span class=\"line\">  content.appendChild(oSpan)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">container.appendChild(content)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Event-Loop-与异步更新\"><a href=\"#Event-Loop-与异步更新\" class=\"headerlink\" title=\"Event Loop 与异步更新\"></a>Event Loop 与异步更新</h4><ul>\n<li><a href=\"https://crazyaguai.github.io/2018/10/20/js-eventLoop/\">https://crazyaguai.github.io/2018/10/20/js-eventLoop/</a></li>\n</ul>\n<h4 id=\"回流与重绘\"><a href=\"#回流与重绘\" class=\"headerlink\" title=\"回流与重绘\"></a>回流与重绘</h4><ol>\n<li>触发回流：（1）几何属性有 width、height、padding、margin、left、top、border （2）节点的增减、移动等操作。（3）获取一些也定属性的值（需要即时计算），offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</li>\n<li>（1）避免回流与重绘（用js变量将缓存属性值）（2）避免逐条改变样式（通过修改class修改style）(3)将DOM离线，设置display: none，之后再操作</li>\n<li>Flush对列</li>\n</ol>\n<ul>\n<li>浏览器会缓存flush对列，优化Layout和Paint。</li>\n</ul>\n<h4 id=\"Lazy-Load优化首屏体验\"><a href=\"#Lazy-Load优化首屏体验\" class=\"headerlink\" title=\"Lazy-Load优化首屏体验\"></a>Lazy-Load优化首屏体验</h4><ul>\n<li>监听屏幕加载页面</li>\n</ul>\n<h4 id=\"节流（throttle）与防抖（debounce）\"><a href=\"#节流（throttle）与防抖（debounce）\" class=\"headerlink\" title=\"节流（throttle）与防抖（debounce）\"></a>节流（throttle）与防抖（debounce）</h4><ul>\n<li><a href=\"https://crazyaguai.github.io/2018/11/15/js-%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/\">https://crazyaguai.github.io/2018/11/15/js-%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</a></li>\n</ul>\n<h4 id=\"性能监控\"><a href=\"#性能监控\" class=\"headerlink\" title=\"性能监控\"></a>性能监控</h4><ul>\n<li>chrome Performance面板</li>\n<li>LightHouse</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"http优化\"><a href=\"#http优化\" class=\"headerlink\" title=\"http优化\"></a>http优化</h4><ol>\n<li>减少单次请求时间</li>\n<li>减少请求次数</li>\n</ol>\n<h4 id=\"webpack优化\"><a href=\"#webpack优化\" class=\"headerlink\" title=\"webpack优化\"></a>webpack优化</h4><ol>\n<li>提高构建速度</li>\n</ol>\n<ul>\n<li>bable-loader中使用 include 或 exclude 来帮我们避免不必要的转译，比如排除node_modules文件夹</li>\n</ul>\n<ol start=\"2\">\n<li>使用DLLPlugin打包第三方库</li>\n<li>Happypack将 loader 由单进程转为多进程</li>\n<li>使用tree-shaking删除冗余代码，UglifyJsPlugin</li>\n<li>webpack按需加载</li>\n<li>使用CommonsChunkPlugin拆分公共代码，webpack4使用optimization.splitChunks</li>\n</ol>\n<ul>\n<li><a href=\"https://crazyaguai.github.io/2019/01/15/webpack-CommonsChunkPlugin%E4%B8%8Eoptimization-splitChunks/\">https://crazyaguai.github.io/2019/01/15/webpack-CommonsChunkPlugin%E4%B8%8Eoptimization-splitChunks/</a></li>\n</ul>\n<ol start=\"7\">\n<li>生产环境关闭source-map</li>\n<li>压缩混淆代码，UglifyJsPlugin</li>\n<li>长缓存优化</li>\n</ol>\n<ul>\n<li><a href=\"https://crazyaguai.github.io/2018/12/21/webpack-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/#%E9%95%BF%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96\">https://crazyaguai.github.io/2018/12/21/webpack-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/#%E9%95%BF%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96</a></li>\n</ul>\n<ol start=\"10\">\n<li>html-webpack-inline-chunk-plugin提前加载manifest.js</li>\n</ol>\n<h4 id=\"服务器开启gzip\"><a href=\"#服务器开启gzip\" class=\"headerlink\" title=\"服务器开启gzip\"></a>服务器开启gzip</h4><h4 id=\"图片优化\"><a href=\"#图片优化\" class=\"headerlink\" title=\"图片优化\"></a>图片优化</h4><ul>\n<li>一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。</li>\n</ul>\n<ol>\n<li>JPEG/JPG：有损压缩、体积小、加载快、不支持透明</li>\n</ol>\n<ul>\n<li>优点：有损压缩，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。</li>\n<li>使用场景：JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG图片经常作为大的背景图、轮播图或 Banner 图出现。</li>\n<li>缺点：处理矢量图形和 Logo等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。JPEG 图像不支持透明度处理。</li>\n</ul>\n<ol start=\"2\">\n<li>PNG-8 与 PNG-24：无损压缩、质量高、体积大、支持透明</li>\n</ol>\n<ul>\n<li>使用场景：呈现小的 Logo、颜色简单且对比强烈的图片或背景等。</li>\n</ul>\n<ol start=\"3\">\n<li>SVG：文本文件、体积小、不失真、兼容性好</li>\n</ol>\n<ul>\n<li>特性：SVG 与 PNG 和 JPG 相比，文件体积更小，可压缩性更强。图片可无限放大而不失真。SVG 是文本文件，可以直接写在html dom中。</li>\n<li>局限：渲染成本比较高，有学习成本（是可编程的）。</li>\n<li>使用场景：</li>\n</ul>\n<ol start=\"4\">\n<li>base64：文本文件、依赖编码、小图标解决方案</li>\n</ol>\n<ul>\n<li>Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。</li>\n<li>应用场景：小图标，更新频率非常低</li>\n<li>url-loader可配置转换为base64图</li>\n</ul>\n<ol start=\"5\">\n<li>WebP</li>\n</ol>\n<ul>\n<li>Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。</li>\n<li>WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。</li>\n<li>局限性：浏览器支持情况不好，增加服务器的负担（编码同样质量的WebP文件会占用更多的计算资源。）</li>\n</ul>\n<h4 id=\"浏览器缓存\"><a href=\"#浏览器缓存\" class=\"headerlink\" title=\"浏览器缓存\"></a>浏览器缓存</h4><ol>\n<li>Memory Cache</li>\n</ol>\n<ul>\n<li>指内存中的缓存，从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。</li>\n<li>Base64 格式的图片，几乎永远可以被塞进 memory cache，体积不大的 JS、CSS文件，也有较大地被写入内存的几率。</li>\n</ul>\n<ol start=\"2\">\n<li>Service Worker Cache</li>\n</ol>\n<ul>\n<li>Service Worker 是一种独立于主线程之外的 Javascript 线程。</li>\n<li><a href=\"https://www.jianshu.com/p/62338c038c42\">https://www.jianshu.com/p/62338c038c42</a></li>\n</ul>\n<ol start=\"3\">\n<li>HTTP Cache</li>\n</ol>\n<ul>\n<li><a href=\"https://crazyaguai.github.io/2018/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/\">https://crazyaguai.github.io/2018/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</a></li>\n</ul>\n<ol start=\"4\">\n<li>Push Cache</li>\n</ol>\n<ul>\n<li>Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。</li>\n</ul>\n<h4 id=\"本地存储\"><a href=\"#本地存储\" class=\"headerlink\" title=\"本地存储\"></a>本地存储</h4><ol>\n<li>cookie</li>\n</ol>\n<ul>\n<li>劣势：有体积上限（4KB）,紧跟域名，会带来资源浪费，同一个域名下的所有请求，都会携带 Cookie。</li>\n</ul>\n<ol start=\"2\">\n<li>web storage</li>\n</ol>\n<ul>\n<li>特性：存储容量大，仅位于浏览器端，不与服务端发生通信。</li>\n<li>Local Storage 与 Session Storage 的区别：<strong>生命周期</strong>，Local Storage 是持久化的本地存储，Session Storage 是临时性的本地存储。<strong>作用域</strong>，Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享(不同tab页面不能共享)。</li>\n</ul>\n<h4 id=\"使用CDN缓存\"><a href=\"#使用CDN缓存\" class=\"headerlink\" title=\"使用CDN缓存\"></a>使用CDN缓存</h4><ul>\n<li>CDN 的核心点有两个，一个是缓存，一个是回源（缓存过期向上层服务器请求资源）。</li>\n<li>CDN 往往被用来存放静态资源。“静态资源”，就是像JS、CSS、图片等不需要业务服务器进行计算即得的资源。<h4 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h4><h4 id=\"浏览器运行机制\"><a href=\"#浏览器运行机制\" class=\"headerlink\" title=\"浏览器运行机制\"></a>浏览器运行机制</h4></li>\n<li>渲染过程：首先基于 HTML 构建一个 DOM 树，这棵 DOM 树与 CSS 解释器解析出的 CSSOM 相结合，就有了布局渲染树。最后浏览器以布局渲染树为蓝本，去计算布局并绘制图像，我们页面的初次渲染就大功告成了。</li>\n</ul>\n<ol>\n<li>CSS 优化</li>\n</ol>\n<ul>\n<li>CSS 选择符是从右到左进行匹配的。</li>\n<li>避免使用通配符，只对需要用到的元素进行选择。</li>\n<li>关注可以通过继承实现的属性，避免重复匹配重复定义。</li>\n<li>少用标签选择器。如果可以，用类选择器替代。</li>\n<li>减少选择器嵌套。</li>\n</ul>\n<ol start=\"2\">\n<li>CSS与JS加载顺序优化</li>\n</ol>\n<ul>\n<li>CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</li>\n<li>JS 引擎是独立于渲染引擎存在的。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。</li>\n<li>通过对JS使用 defer 和 async 来避免不必要的阻塞。</li>\n<li>async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行。</li>\n<li>defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。</li>\n<li>脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。</li>\n</ul>\n<h4 id=\"DOM优化\"><a href=\"#DOM优化\" class=\"headerlink\" title=\"DOM优化\"></a>DOM优化</h4><ol>\n<li>DOM操作为什么慢：（1）JS 引擎和渲染引擎（浏览器内核）是独立实现的。用 JS 去操作 DOM 时依赖了桥接接口作为“桥梁”。（2）DOM 的修改引发样式的更迭，会触发回流或重绘。</li>\n<li>回流（重排）：当我们对 DOM 的修改引发了DOM几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）。时</li>\n<li>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时。</li>\n<li>重绘不一定导致回流，回流一定会导致重绘。回流比重绘做的事情更多，带来的开销也更大。</li>\n<li>减少DOM操作<br>（1）使用js变量 （2）使用DocumentFragment（表示一个没有父级文件的最小文档对象，不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。）<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment\">https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment</a></li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let container &#x3D; document.getElementById(&#39;container&#39;)</span><br><span class=\"line\">&#x2F;&#x2F; 创建一个DOM Fragment对象作为容器</span><br><span class=\"line\">let content &#x3D; document.createDocumentFragment()</span><br><span class=\"line\">for(let count&#x3D;0;count&lt;10000;count++)&#123;</span><br><span class=\"line\">  let oSpan &#x3D; document.createElement(&quot;span&quot;)</span><br><span class=\"line\">  oSpan.innerHTML &#x3D; &#39;我是一个小测试&#39;</span><br><span class=\"line\">  content.appendChild(oSpan)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">container.appendChild(content)</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"Event-Loop-与异步更新\"><a href=\"#Event-Loop-与异步更新\" class=\"headerlink\" title=\"Event Loop 与异步更新\"></a>Event Loop 与异步更新</h4><ul>\n<li><a href=\"https://crazyaguai.github.io/2018/10/20/js-eventLoop/\">https://crazyaguai.github.io/2018/10/20/js-eventLoop/</a></li>\n</ul>\n<h4 id=\"回流与重绘\"><a href=\"#回流与重绘\" class=\"headerlink\" title=\"回流与重绘\"></a>回流与重绘</h4><ol>\n<li>触发回流：（1）几何属性有 width、height、padding、margin、left、top、border （2）节点的增减、移动等操作。（3）获取一些也定属性的值（需要即时计算），offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</li>\n<li>（1）避免回流与重绘（用js变量将缓存属性值）（2）避免逐条改变样式（通过修改class修改style）(3)将DOM离线，设置display: none，之后再操作</li>\n<li>Flush对列</li>\n</ol>\n<ul>\n<li>浏览器会缓存flush对列，优化Layout和Paint。</li>\n</ul>\n<h4 id=\"Lazy-Load优化首屏体验\"><a href=\"#Lazy-Load优化首屏体验\" class=\"headerlink\" title=\"Lazy-Load优化首屏体验\"></a>Lazy-Load优化首屏体验</h4><ul>\n<li>监听屏幕加载页面</li>\n</ul>\n<h4 id=\"节流（throttle）与防抖（debounce）\"><a href=\"#节流（throttle）与防抖（debounce）\" class=\"headerlink\" title=\"节流（throttle）与防抖（debounce）\"></a>节流（throttle）与防抖（debounce）</h4><ul>\n<li><a href=\"https://crazyaguai.github.io/2018/11/15/js-%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/\">https://crazyaguai.github.io/2018/11/15/js-%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</a></li>\n</ul>\n<h4 id=\"性能监控\"><a href=\"#性能监控\" class=\"headerlink\" title=\"性能监控\"></a>性能监控</h4><ul>\n<li>chrome Performance面板</li>\n<li>LightHouse</li>\n</ul>\n"},{"title":"<工程化>git-使用","date":"2020-10-06T06:11:44.000Z","_content":"\n### git 概念\n\n- 工作区(workspace)：存放本地项目文件\n- 暂存区(stage)：通过add命令将工作区文件存放到暂存区\n- 本地仓库(repository)：使用commit命令将暂存区文件添加到本地仓库\n- 远程仓库(remote)：github、gitlab等托管仓库\n\n![git流程](https://wx4.sinaimg.cn/mw690/a4006e99ly1gjnexixmijj20ii06kaaf.jpg)\n\n### git config\n\n- 配置文件存储位置：--global /etc/gitconfig、--system ~/.gitconfig、--local 工作区/.git/config\n\n```\n-- global对当前用户所有仓库有效\n-- local 对某个仓库有效（缺省等同于local）\n-- system 对系统登录所有用户有效\n// 显示 cinfig 配置\ngit config --list\n\n// 设置用户\ngit config --global user.name \"yxc\"\ngit config --global user.email \"邮箱号\"\n\n// 设置编辑器\ngit config --global core.editor emacs\n\n// 配置比较工具\ngit config --global merge.tool vimdiff\n\n// 添加配置\ngit config -–add site.name yiibai\n\n// 删除配置\ngit config --local -–unset site.name\n\n// 获取帮助\ngit help\n```\n\n### git clone\n\n- 除了HTTP(s)以外，还支持SSH、Git、本地文件协议等\n\n```\ngit clone <版本库的网址> <本地目录名>\n```\n\n### git add\n\n- 将工作区修改添加到暂存区\n\n```\n// 添加当前目录所有修改\ngit add .\n\n// 添加.gitignore忽略的修改\ngit add -f .\n\n// 查看add状态，修改是否提交\ngit add -i .\n```\n\n### git clone\n\n- 除了HTTP(s)以外，还支持SSH、Git、本地文件协议等\n\n```\ngit clone <版本库的网址> <本地目录名>\n```\n\n### git status\n\n- 显示工作目录和暂存区的状态\n\n### git diff\n\n```\n// 显示工作区与暂存区的差别\ngit diff\n\n// 显示暂存区与HEAD的差别\ngit diff --cached\ngit diff --staged\n\n// 显示工作区与HEAD的差别\ngit diff HEAD\n\n// 显示两个分支的差别\ngit diff dev1 master\n\n// 显示工作区与其他分支差别\ngit diff dev1\n\n// 显示两次commit的差别\ngit diff SHA1 SHA2\n\n// 比较当前src目录与上次提交的差别\ngit diff HEAD -- ./src\n\n// 比较HEAD与上次提交的差别\ngit diff HEAD^ HEAD\n\n// --stat 参数查看简单diff结果\ngit diff --stat\n```\n\n### git commit\n\n```\n// 将暂存区提交\ngit commit -m \"change\"\n\n// 将工作区提交 -a\ngit commit -am \"change\"\n\n// 撤销上次commit，生成新的commit --amend\ngit commit --amend -m \"new change\"\n\n// 不验证eslint提交\ngit commit --no-verify -m \"修改\"\n\n// —fixup、—squash 当前添加的commit是之前某一个commit的修正，以后执行互动式的git rebase的时候，这两个 commit 将会合并成一个\ngit commit --fixup <commit>\n```\n\n### git reset\n\n- soft: 不改变工作区和暂存区，只移动 HEAD 到指定 commit。\n- mixed: 只改变暂存区，不改变工作区。这是默认参数，通常用于撤销git add。\n- hard：改变工作区和暂存区到指定 commit。该参数等同于重置，可能会引起数据损失。\n\n```\n// 将当前分支指针倒3个commit，并改变暂存区\ngit reset HEAD~3\n\n// 倒退指针，不改变暂存区\ngit reset --soft HEAD~3\n\n// 倒退指针，同时改变工作区\ngit reset --hard HEAD~3\n\n// 回到HEAD之前的commit\ngit reset HEAD^\n```\n\n- 一些撤销操作\n\n```\n// 撤销暂存区的内容\ngit reset || git reset --mixed\n\n// 撤销暂存区以及工作区的修改（回到HEAD状态）\ngit reset --hard\n\n// 撤销向暂存区提交的文件\ngit reset -- ./test.txt\n```\n\n### git rm\n\n- 用于从工作区或者索引中删除文件，提交commit时会将文件的删除操作提交\n- 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f。\n\n```\n// 删除工作区的文件\ngit rm a.txt\n\n// 如果已经修改并放到暂存区，需要使用 -f 删除\ngit rm -f a.txt\n\n// 从暂存区删除文件\ngit rm --cached a.txt\n```\n\n### git branch\n\n```\n// 查看分支列表\ngit branch -a\n\n// 创建分支并切换\ngit branch dev1\n\n// 删除分支\ngit branch -d dev1\ngit branch -D dev1 // 强制删除\n\n// 分支改名\ngit branch -m dev1\ngit branch -m dev1 dev2\n\n// 查看分支 merge 情况\ngit branch --merged\ngit branch --no-merged\n```\n\n### git checkout\n\n```\n// 切换分支\ngit checkout dev1\n\n// 将工作区文件恢复到HEAD状态\ngit checkout -- a.txt\ngit checkout HEAD -- a.txt\n\n// 创建新分支，并切换到新分支\ngit checkout -b dev1 origin/master\n```\n\n### git merge\n\n```\n// 将dev1合并到当前分支\ngit merge dev1\n\n// --abort 发生冲突后放弃合并\ngit merge --abort dev1\n```\n\n### git mergetool\n\n### git log\n\n```\n// 显示当前分支日志\ngit log\n\n// 显示其他分支日志\ngit log origin/master\n\n// --graph 显示连线、--oneline 一行展示、--decorate 显示分支\ngit log --graph --oneline --decorate\n```\n\n### git stash\n\n```\n// 暂时保存没有提交的工作\ngit stash\n\n// 列出所有暂时保存的工作\ngit stash list\n\n// 恢复某个暂时保存的工作\ngit stash apply stash@{1}\n\n// 恢复最近一次stash的文件\ngit stash pop\n\n// 丢弃最近一次stash的文件\ngit stash drop\n\n// 删除所有的stash\ngit stash clear\n```\n\n### git tag\n\n```\n// 列出tag\ngit tag\n\n// 添加标签，不使用 -m 会进入描述编辑模式\ngit tag -a v1.0 -m \"标签描述\"\n\n// 查看标签相关信息\ngit show v1.0\n\n// 给某次commit打标签\ngit tag -a v1.1 {commitid}\n\n// 推送标签到远端\ngit push v1.0\n\n// 删除标签\ngit tag -d v1.0\ngit push --delete origin v1.0\n```\n\n### git fetch\n\n```\n// 拉取所有远程分支\ngit fetch origin\n\n// 拉取指定远程分支\ngit fetch origin dev1\n\n// 拉取当前远程分支\ngit fetch\n```\n\n### git pull\n\n```\n// 拉取远程分支与本地分支合并\ngit pull origin dev1\ngit pull origin dev1:dev2\n\n// 本地分支与对应的远程合并\ngit pull origin\ngit pull\n\n// 使用rebase模式合并\ngit pull --rebase origin dev1\n```\n\n### git push\n\n```\n\n```\n\n### git remote\n\n### git rebase\n\n### git with ssh\n\n- 参考：[官方文档](https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)\n\n1. 查看是否存在ssh配置\n\n```\n// 查看.ssh文件夹里是否存在key相关文件(.pub文件)\ncd ~/.ssh\n```\n\n2. 新建ssh key文件\n\n```\n// 执行命令后第一步需要设置key文件名称\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\n```\n\n3. 修改config文件，编辑.ssh文件夹下config文件，没有创建\n\n```\nHost *\n  Preferredauthentications publickey\n  AddKeysToAgent yes\n  UseKeychain yes\n  IdentityFile ~/.ssh/yxc_git\n```\n\n4. 添加秘钥\n\n```\neval $(ssh-agent -s)\nssh-add ~/.ssh/yxc_git(你的秘钥)\n```\n\n5. github\\gitlab上添加公钥\n\n```\n// 测试连接情况\nssh -T git@github.com\n```\n\n\n","source":"_posts/[工程化]git-使用.md","raw":"---\ntitle: <工程化>git-使用\ndate: 2020-10-06 14:11:44\ntags: [工程化,git]\ncategories: git\n---\n\n### git 概念\n\n- 工作区(workspace)：存放本地项目文件\n- 暂存区(stage)：通过add命令将工作区文件存放到暂存区\n- 本地仓库(repository)：使用commit命令将暂存区文件添加到本地仓库\n- 远程仓库(remote)：github、gitlab等托管仓库\n\n![git流程](https://wx4.sinaimg.cn/mw690/a4006e99ly1gjnexixmijj20ii06kaaf.jpg)\n\n### git config\n\n- 配置文件存储位置：--global /etc/gitconfig、--system ~/.gitconfig、--local 工作区/.git/config\n\n```\n-- global对当前用户所有仓库有效\n-- local 对某个仓库有效（缺省等同于local）\n-- system 对系统登录所有用户有效\n// 显示 cinfig 配置\ngit config --list\n\n// 设置用户\ngit config --global user.name \"yxc\"\ngit config --global user.email \"邮箱号\"\n\n// 设置编辑器\ngit config --global core.editor emacs\n\n// 配置比较工具\ngit config --global merge.tool vimdiff\n\n// 添加配置\ngit config -–add site.name yiibai\n\n// 删除配置\ngit config --local -–unset site.name\n\n// 获取帮助\ngit help\n```\n\n### git clone\n\n- 除了HTTP(s)以外，还支持SSH、Git、本地文件协议等\n\n```\ngit clone <版本库的网址> <本地目录名>\n```\n\n### git add\n\n- 将工作区修改添加到暂存区\n\n```\n// 添加当前目录所有修改\ngit add .\n\n// 添加.gitignore忽略的修改\ngit add -f .\n\n// 查看add状态，修改是否提交\ngit add -i .\n```\n\n### git clone\n\n- 除了HTTP(s)以外，还支持SSH、Git、本地文件协议等\n\n```\ngit clone <版本库的网址> <本地目录名>\n```\n\n### git status\n\n- 显示工作目录和暂存区的状态\n\n### git diff\n\n```\n// 显示工作区与暂存区的差别\ngit diff\n\n// 显示暂存区与HEAD的差别\ngit diff --cached\ngit diff --staged\n\n// 显示工作区与HEAD的差别\ngit diff HEAD\n\n// 显示两个分支的差别\ngit diff dev1 master\n\n// 显示工作区与其他分支差别\ngit diff dev1\n\n// 显示两次commit的差别\ngit diff SHA1 SHA2\n\n// 比较当前src目录与上次提交的差别\ngit diff HEAD -- ./src\n\n// 比较HEAD与上次提交的差别\ngit diff HEAD^ HEAD\n\n// --stat 参数查看简单diff结果\ngit diff --stat\n```\n\n### git commit\n\n```\n// 将暂存区提交\ngit commit -m \"change\"\n\n// 将工作区提交 -a\ngit commit -am \"change\"\n\n// 撤销上次commit，生成新的commit --amend\ngit commit --amend -m \"new change\"\n\n// 不验证eslint提交\ngit commit --no-verify -m \"修改\"\n\n// —fixup、—squash 当前添加的commit是之前某一个commit的修正，以后执行互动式的git rebase的时候，这两个 commit 将会合并成一个\ngit commit --fixup <commit>\n```\n\n### git reset\n\n- soft: 不改变工作区和暂存区，只移动 HEAD 到指定 commit。\n- mixed: 只改变暂存区，不改变工作区。这是默认参数，通常用于撤销git add。\n- hard：改变工作区和暂存区到指定 commit。该参数等同于重置，可能会引起数据损失。\n\n```\n// 将当前分支指针倒3个commit，并改变暂存区\ngit reset HEAD~3\n\n// 倒退指针，不改变暂存区\ngit reset --soft HEAD~3\n\n// 倒退指针，同时改变工作区\ngit reset --hard HEAD~3\n\n// 回到HEAD之前的commit\ngit reset HEAD^\n```\n\n- 一些撤销操作\n\n```\n// 撤销暂存区的内容\ngit reset || git reset --mixed\n\n// 撤销暂存区以及工作区的修改（回到HEAD状态）\ngit reset --hard\n\n// 撤销向暂存区提交的文件\ngit reset -- ./test.txt\n```\n\n### git rm\n\n- 用于从工作区或者索引中删除文件，提交commit时会将文件的删除操作提交\n- 如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f。\n\n```\n// 删除工作区的文件\ngit rm a.txt\n\n// 如果已经修改并放到暂存区，需要使用 -f 删除\ngit rm -f a.txt\n\n// 从暂存区删除文件\ngit rm --cached a.txt\n```\n\n### git branch\n\n```\n// 查看分支列表\ngit branch -a\n\n// 创建分支并切换\ngit branch dev1\n\n// 删除分支\ngit branch -d dev1\ngit branch -D dev1 // 强制删除\n\n// 分支改名\ngit branch -m dev1\ngit branch -m dev1 dev2\n\n// 查看分支 merge 情况\ngit branch --merged\ngit branch --no-merged\n```\n\n### git checkout\n\n```\n// 切换分支\ngit checkout dev1\n\n// 将工作区文件恢复到HEAD状态\ngit checkout -- a.txt\ngit checkout HEAD -- a.txt\n\n// 创建新分支，并切换到新分支\ngit checkout -b dev1 origin/master\n```\n\n### git merge\n\n```\n// 将dev1合并到当前分支\ngit merge dev1\n\n// --abort 发生冲突后放弃合并\ngit merge --abort dev1\n```\n\n### git mergetool\n\n### git log\n\n```\n// 显示当前分支日志\ngit log\n\n// 显示其他分支日志\ngit log origin/master\n\n// --graph 显示连线、--oneline 一行展示、--decorate 显示分支\ngit log --graph --oneline --decorate\n```\n\n### git stash\n\n```\n// 暂时保存没有提交的工作\ngit stash\n\n// 列出所有暂时保存的工作\ngit stash list\n\n// 恢复某个暂时保存的工作\ngit stash apply stash@{1}\n\n// 恢复最近一次stash的文件\ngit stash pop\n\n// 丢弃最近一次stash的文件\ngit stash drop\n\n// 删除所有的stash\ngit stash clear\n```\n\n### git tag\n\n```\n// 列出tag\ngit tag\n\n// 添加标签，不使用 -m 会进入描述编辑模式\ngit tag -a v1.0 -m \"标签描述\"\n\n// 查看标签相关信息\ngit show v1.0\n\n// 给某次commit打标签\ngit tag -a v1.1 {commitid}\n\n// 推送标签到远端\ngit push v1.0\n\n// 删除标签\ngit tag -d v1.0\ngit push --delete origin v1.0\n```\n\n### git fetch\n\n```\n// 拉取所有远程分支\ngit fetch origin\n\n// 拉取指定远程分支\ngit fetch origin dev1\n\n// 拉取当前远程分支\ngit fetch\n```\n\n### git pull\n\n```\n// 拉取远程分支与本地分支合并\ngit pull origin dev1\ngit pull origin dev1:dev2\n\n// 本地分支与对应的远程合并\ngit pull origin\ngit pull\n\n// 使用rebase模式合并\ngit pull --rebase origin dev1\n```\n\n### git push\n\n```\n\n```\n\n### git remote\n\n### git rebase\n\n### git with ssh\n\n- 参考：[官方文档](https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent)\n\n1. 查看是否存在ssh配置\n\n```\n// 查看.ssh文件夹里是否存在key相关文件(.pub文件)\ncd ~/.ssh\n```\n\n2. 新建ssh key文件\n\n```\n// 执行命令后第一步需要设置key文件名称\nssh-keygen -t rsa -b 4096 -C \"your_email@example.com\"\n```\n\n3. 修改config文件，编辑.ssh文件夹下config文件，没有创建\n\n```\nHost *\n  Preferredauthentications publickey\n  AddKeysToAgent yes\n  UseKeychain yes\n  IdentityFile ~/.ssh/yxc_git\n```\n\n4. 添加秘钥\n\n```\neval $(ssh-agent -s)\nssh-add ~/.ssh/yxc_git(你的秘钥)\n```\n\n5. github\\gitlab上添加公钥\n\n```\n// 测试连接情况\nssh -T git@github.com\n```\n\n\n","slug":"[工程化]git-使用","published":1,"updated":"2021-03-15T14:34:33.524Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dl9003vwotj5ro9akqv","content":"<h3 id=\"git-概念\"><a href=\"#git-概念\" class=\"headerlink\" title=\"git 概念\"></a>git 概念</h3><ul>\n<li>工作区(workspace)：存放本地项目文件</li>\n<li>暂存区(stage)：通过add命令将工作区文件存放到暂存区</li>\n<li>本地仓库(repository)：使用commit命令将暂存区文件添加到本地仓库</li>\n<li>远程仓库(remote)：github、gitlab等托管仓库</li>\n</ul>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/a4006e99ly1gjnexixmijj20ii06kaaf.jpg\" alt=\"git流程\"></p>\n<h3 id=\"git-config\"><a href=\"#git-config\" class=\"headerlink\" title=\"git config\"></a>git config</h3><ul>\n<li>配置文件存储位置：–global /etc/gitconfig、–system ~/.gitconfig、–local 工作区/.git/config</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- global对当前用户所有仓库有效</span><br><span class=\"line\">-- local 对某个仓库有效（缺省等同于local）</span><br><span class=\"line\">-- system 对系统登录所有用户有效</span><br><span class=\"line\">&#x2F;&#x2F; 显示 cinfig 配置</span><br><span class=\"line\">git config --list</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 设置用户</span><br><span class=\"line\">git config --global user.name &quot;yxc&quot;</span><br><span class=\"line\">git config --global user.email &quot;邮箱号&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 设置编辑器</span><br><span class=\"line\">git config --global core.editor emacs</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 配置比较工具</span><br><span class=\"line\">git config --global merge.tool vimdiff</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 添加配置</span><br><span class=\"line\">git config -–add site.name yiibai</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 删除配置</span><br><span class=\"line\">git config --local -–unset site.name</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 获取帮助</span><br><span class=\"line\">git help</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-clone\"><a href=\"#git-clone\" class=\"headerlink\" title=\"git clone\"></a>git clone</h3><ul>\n<li>除了HTTP(s)以外，还支持SSH、Git、本地文件协议等</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add\"></a>git add</h3><ul>\n<li>将工作区修改添加到暂存区</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 添加当前目录所有修改</span><br><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 添加.gitignore忽略的修改</span><br><span class=\"line\">git add -f .</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 查看add状态，修改是否提交</span><br><span class=\"line\">git add -i .</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-clone-1\"><a href=\"#git-clone-1\" class=\"headerlink\" title=\"git clone\"></a>git clone</h3><ul>\n<li>除了HTTP(s)以外，还支持SSH、Git、本地文件协议等</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h3><ul>\n<li>显示工作目录和暂存区的状态</li>\n</ul>\n<h3 id=\"git-diff\"><a href=\"#git-diff\" class=\"headerlink\" title=\"git diff\"></a>git diff</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 显示工作区与暂存区的差别</span><br><span class=\"line\">git diff</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 显示暂存区与HEAD的差别</span><br><span class=\"line\">git diff --cached</span><br><span class=\"line\">git diff --staged</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 显示工作区与HEAD的差别</span><br><span class=\"line\">git diff HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 显示两个分支的差别</span><br><span class=\"line\">git diff dev1 master</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 显示工作区与其他分支差别</span><br><span class=\"line\">git diff dev1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 显示两次commit的差别</span><br><span class=\"line\">git diff SHA1 SHA2</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 比较当前src目录与上次提交的差别</span><br><span class=\"line\">git diff HEAD -- .&#x2F;src</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 比较HEAD与上次提交的差别</span><br><span class=\"line\">git diff HEAD^ HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; --stat 参数查看简单diff结果</span><br><span class=\"line\">git diff --stat</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-commit\"><a href=\"#git-commit\" class=\"headerlink\" title=\"git commit\"></a>git commit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 将暂存区提交</span><br><span class=\"line\">git commit -m &quot;change&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 将工作区提交 -a</span><br><span class=\"line\">git commit -am &quot;change&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 撤销上次commit，生成新的commit --amend</span><br><span class=\"line\">git commit --amend -m &quot;new change&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 不验证eslint提交</span><br><span class=\"line\">git commit --no-verify -m &quot;修改&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; —fixup、—squash 当前添加的commit是之前某一个commit的修正，以后执行互动式的git rebase的时候，这两个 commit 将会合并成一个</span><br><span class=\"line\">git commit --fixup &lt;commit&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h3><ul>\n<li>soft: 不改变工作区和暂存区，只移动 HEAD 到指定 commit。</li>\n<li>mixed: 只改变暂存区，不改变工作区。这是默认参数，通常用于撤销git add。</li>\n<li>hard：改变工作区和暂存区到指定 commit。该参数等同于重置，可能会引起数据损失。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 将当前分支指针倒3个commit，并改变暂存区</span><br><span class=\"line\">git reset HEAD~3</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 倒退指针，不改变暂存区</span><br><span class=\"line\">git reset --soft HEAD~3</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 倒退指针，同时改变工作区</span><br><span class=\"line\">git reset --hard HEAD~3</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 回到HEAD之前的commit</span><br><span class=\"line\">git reset HEAD^</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>一些撤销操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 撤销暂存区的内容</span><br><span class=\"line\">git reset || git reset --mixed</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 撤销暂存区以及工作区的修改（回到HEAD状态）</span><br><span class=\"line\">git reset --hard</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 撤销向暂存区提交的文件</span><br><span class=\"line\">git reset -- .&#x2F;test.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-rm\"><a href=\"#git-rm\" class=\"headerlink\" title=\"git rm\"></a>git rm</h3><ul>\n<li>用于从工作区或者索引中删除文件，提交commit时会将文件的删除操作提交</li>\n<li>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 删除工作区的文件</span><br><span class=\"line\">git rm a.txt</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 如果已经修改并放到暂存区，需要使用 -f 删除</span><br><span class=\"line\">git rm -f a.txt</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 从暂存区删除文件</span><br><span class=\"line\">git rm --cached a.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-branch\"><a href=\"#git-branch\" class=\"headerlink\" title=\"git branch\"></a>git branch</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 查看分支列表</span><br><span class=\"line\">git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 创建分支并切换</span><br><span class=\"line\">git branch dev1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 删除分支</span><br><span class=\"line\">git branch -d dev1</span><br><span class=\"line\">git branch -D dev1 &#x2F;&#x2F; 强制删除</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 分支改名</span><br><span class=\"line\">git branch -m dev1</span><br><span class=\"line\">git branch -m dev1 dev2</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 查看分支 merge 情况</span><br><span class=\"line\">git branch --merged</span><br><span class=\"line\">git branch --no-merged</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-checkout\"><a href=\"#git-checkout\" class=\"headerlink\" title=\"git checkout\"></a>git checkout</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 切换分支</span><br><span class=\"line\">git checkout dev1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 将工作区文件恢复到HEAD状态</span><br><span class=\"line\">git checkout -- a.txt</span><br><span class=\"line\">git checkout HEAD -- a.txt</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 创建新分支，并切换到新分支</span><br><span class=\"line\">git checkout -b dev1 origin&#x2F;master</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-merge\"><a href=\"#git-merge\" class=\"headerlink\" title=\"git merge\"></a>git merge</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 将dev1合并到当前分支</span><br><span class=\"line\">git merge dev1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; --abort 发生冲突后放弃合并</span><br><span class=\"line\">git merge --abort dev1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-mergetool\"><a href=\"#git-mergetool\" class=\"headerlink\" title=\"git mergetool\"></a>git mergetool</h3><h3 id=\"git-log\"><a href=\"#git-log\" class=\"headerlink\" title=\"git log\"></a>git log</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 显示当前分支日志</span><br><span class=\"line\">git log</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 显示其他分支日志</span><br><span class=\"line\">git log origin&#x2F;master</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; --graph 显示连线、--oneline 一行展示、--decorate 显示分支</span><br><span class=\"line\">git log --graph --oneline --decorate</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-stash\"><a href=\"#git-stash\" class=\"headerlink\" title=\"git stash\"></a>git stash</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 暂时保存没有提交的工作</span><br><span class=\"line\">git stash</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 列出所有暂时保存的工作</span><br><span class=\"line\">git stash list</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 恢复某个暂时保存的工作</span><br><span class=\"line\">git stash apply stash@&#123;1&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 恢复最近一次stash的文件</span><br><span class=\"line\">git stash pop</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 丢弃最近一次stash的文件</span><br><span class=\"line\">git stash drop</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 删除所有的stash</span><br><span class=\"line\">git stash clear</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-tag\"><a href=\"#git-tag\" class=\"headerlink\" title=\"git tag\"></a>git tag</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 列出tag</span><br><span class=\"line\">git tag</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 添加标签，不使用 -m 会进入描述编辑模式</span><br><span class=\"line\">git tag -a v1.0 -m &quot;标签描述&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 查看标签相关信息</span><br><span class=\"line\">git show v1.0</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 给某次commit打标签</span><br><span class=\"line\">git tag -a v1.1 &#123;commitid&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 推送标签到远端</span><br><span class=\"line\">git push v1.0</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 删除标签</span><br><span class=\"line\">git tag -d v1.0</span><br><span class=\"line\">git push --delete origin v1.0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-fetch\"><a href=\"#git-fetch\" class=\"headerlink\" title=\"git fetch\"></a>git fetch</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 拉取所有远程分支</span><br><span class=\"line\">git fetch origin</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 拉取指定远程分支</span><br><span class=\"line\">git fetch origin dev1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 拉取当前远程分支</span><br><span class=\"line\">git fetch</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull\"></a>git pull</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 拉取远程分支与本地分支合并</span><br><span class=\"line\">git pull origin dev1</span><br><span class=\"line\">git pull origin dev1:dev2</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 本地分支与对应的远程合并</span><br><span class=\"line\">git pull origin</span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 使用rebase模式合并</span><br><span class=\"line\">git pull --rebase origin dev1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push\"></a>git push</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-remote\"><a href=\"#git-remote\" class=\"headerlink\" title=\"git remote\"></a>git remote</h3><h3 id=\"git-rebase\"><a href=\"#git-rebase\" class=\"headerlink\" title=\"git rebase\"></a>git rebase</h3><h3 id=\"git-with-ssh\"><a href=\"#git-with-ssh\" class=\"headerlink\" title=\"git with ssh\"></a>git with ssh</h3><ul>\n<li>参考：<a href=\"https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\">官方文档</a></li>\n</ul>\n<ol>\n<li>查看是否存在ssh配置</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 查看.ssh文件夹里是否存在key相关文件(.pub文件)</span><br><span class=\"line\">cd ~&#x2F;.ssh</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>新建ssh key文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 执行命令后第一步需要设置key文件名称</span><br><span class=\"line\">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>修改config文件，编辑.ssh文件夹下config文件，没有创建</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host *</span><br><span class=\"line\">  Preferredauthentications publickey</span><br><span class=\"line\">  AddKeysToAgent yes</span><br><span class=\"line\">  UseKeychain yes</span><br><span class=\"line\">  IdentityFile ~&#x2F;.ssh&#x2F;yxc_git</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>添加秘钥</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval $(ssh-agent -s)</span><br><span class=\"line\">ssh-add ~&#x2F;.ssh&#x2F;yxc_git(你的秘钥)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>github\\gitlab上添加公钥</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 测试连接情况</span><br><span class=\"line\">ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"git-概念\"><a href=\"#git-概念\" class=\"headerlink\" title=\"git 概念\"></a>git 概念</h3><ul>\n<li>工作区(workspace)：存放本地项目文件</li>\n<li>暂存区(stage)：通过add命令将工作区文件存放到暂存区</li>\n<li>本地仓库(repository)：使用commit命令将暂存区文件添加到本地仓库</li>\n<li>远程仓库(remote)：github、gitlab等托管仓库</li>\n</ul>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/a4006e99ly1gjnexixmijj20ii06kaaf.jpg\" alt=\"git流程\"></p>\n<h3 id=\"git-config\"><a href=\"#git-config\" class=\"headerlink\" title=\"git config\"></a>git config</h3><ul>\n<li>配置文件存储位置：–global /etc/gitconfig、–system ~/.gitconfig、–local 工作区/.git/config</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-- global对当前用户所有仓库有效</span><br><span class=\"line\">-- local 对某个仓库有效（缺省等同于local）</span><br><span class=\"line\">-- system 对系统登录所有用户有效</span><br><span class=\"line\">&#x2F;&#x2F; 显示 cinfig 配置</span><br><span class=\"line\">git config --list</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 设置用户</span><br><span class=\"line\">git config --global user.name &quot;yxc&quot;</span><br><span class=\"line\">git config --global user.email &quot;邮箱号&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 设置编辑器</span><br><span class=\"line\">git config --global core.editor emacs</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 配置比较工具</span><br><span class=\"line\">git config --global merge.tool vimdiff</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 添加配置</span><br><span class=\"line\">git config -–add site.name yiibai</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 删除配置</span><br><span class=\"line\">git config --local -–unset site.name</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 获取帮助</span><br><span class=\"line\">git help</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-clone\"><a href=\"#git-clone\" class=\"headerlink\" title=\"git clone\"></a>git clone</h3><ul>\n<li>除了HTTP(s)以外，还支持SSH、Git、本地文件协议等</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-add\"><a href=\"#git-add\" class=\"headerlink\" title=\"git add\"></a>git add</h3><ul>\n<li>将工作区修改添加到暂存区</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 添加当前目录所有修改</span><br><span class=\"line\">git add .</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 添加.gitignore忽略的修改</span><br><span class=\"line\">git add -f .</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 查看add状态，修改是否提交</span><br><span class=\"line\">git add -i .</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-clone-1\"><a href=\"#git-clone-1\" class=\"headerlink\" title=\"git clone\"></a>git clone</h3><ul>\n<li>除了HTTP(s)以外，还支持SSH、Git、本地文件协议等</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-status\"><a href=\"#git-status\" class=\"headerlink\" title=\"git status\"></a>git status</h3><ul>\n<li>显示工作目录和暂存区的状态</li>\n</ul>\n<h3 id=\"git-diff\"><a href=\"#git-diff\" class=\"headerlink\" title=\"git diff\"></a>git diff</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 显示工作区与暂存区的差别</span><br><span class=\"line\">git diff</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 显示暂存区与HEAD的差别</span><br><span class=\"line\">git diff --cached</span><br><span class=\"line\">git diff --staged</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 显示工作区与HEAD的差别</span><br><span class=\"line\">git diff HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 显示两个分支的差别</span><br><span class=\"line\">git diff dev1 master</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 显示工作区与其他分支差别</span><br><span class=\"line\">git diff dev1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 显示两次commit的差别</span><br><span class=\"line\">git diff SHA1 SHA2</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 比较当前src目录与上次提交的差别</span><br><span class=\"line\">git diff HEAD -- .&#x2F;src</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 比较HEAD与上次提交的差别</span><br><span class=\"line\">git diff HEAD^ HEAD</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; --stat 参数查看简单diff结果</span><br><span class=\"line\">git diff --stat</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-commit\"><a href=\"#git-commit\" class=\"headerlink\" title=\"git commit\"></a>git commit</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 将暂存区提交</span><br><span class=\"line\">git commit -m &quot;change&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 将工作区提交 -a</span><br><span class=\"line\">git commit -am &quot;change&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 撤销上次commit，生成新的commit --amend</span><br><span class=\"line\">git commit --amend -m &quot;new change&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 不验证eslint提交</span><br><span class=\"line\">git commit --no-verify -m &quot;修改&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; —fixup、—squash 当前添加的commit是之前某一个commit的修正，以后执行互动式的git rebase的时候，这两个 commit 将会合并成一个</span><br><span class=\"line\">git commit --fixup &lt;commit&gt;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-reset\"><a href=\"#git-reset\" class=\"headerlink\" title=\"git reset\"></a>git reset</h3><ul>\n<li>soft: 不改变工作区和暂存区，只移动 HEAD 到指定 commit。</li>\n<li>mixed: 只改变暂存区，不改变工作区。这是默认参数，通常用于撤销git add。</li>\n<li>hard：改变工作区和暂存区到指定 commit。该参数等同于重置，可能会引起数据损失。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 将当前分支指针倒3个commit，并改变暂存区</span><br><span class=\"line\">git reset HEAD~3</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 倒退指针，不改变暂存区</span><br><span class=\"line\">git reset --soft HEAD~3</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 倒退指针，同时改变工作区</span><br><span class=\"line\">git reset --hard HEAD~3</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 回到HEAD之前的commit</span><br><span class=\"line\">git reset HEAD^</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>一些撤销操作</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 撤销暂存区的内容</span><br><span class=\"line\">git reset || git reset --mixed</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 撤销暂存区以及工作区的修改（回到HEAD状态）</span><br><span class=\"line\">git reset --hard</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 撤销向暂存区提交的文件</span><br><span class=\"line\">git reset -- .&#x2F;test.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-rm\"><a href=\"#git-rm\" class=\"headerlink\" title=\"git rm\"></a>git rm</h3><ul>\n<li>用于从工作区或者索引中删除文件，提交commit时会将文件的删除操作提交</li>\n<li>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 删除工作区的文件</span><br><span class=\"line\">git rm a.txt</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 如果已经修改并放到暂存区，需要使用 -f 删除</span><br><span class=\"line\">git rm -f a.txt</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 从暂存区删除文件</span><br><span class=\"line\">git rm --cached a.txt</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-branch\"><a href=\"#git-branch\" class=\"headerlink\" title=\"git branch\"></a>git branch</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 查看分支列表</span><br><span class=\"line\">git branch -a</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 创建分支并切换</span><br><span class=\"line\">git branch dev1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 删除分支</span><br><span class=\"line\">git branch -d dev1</span><br><span class=\"line\">git branch -D dev1 &#x2F;&#x2F; 强制删除</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 分支改名</span><br><span class=\"line\">git branch -m dev1</span><br><span class=\"line\">git branch -m dev1 dev2</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 查看分支 merge 情况</span><br><span class=\"line\">git branch --merged</span><br><span class=\"line\">git branch --no-merged</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-checkout\"><a href=\"#git-checkout\" class=\"headerlink\" title=\"git checkout\"></a>git checkout</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 切换分支</span><br><span class=\"line\">git checkout dev1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 将工作区文件恢复到HEAD状态</span><br><span class=\"line\">git checkout -- a.txt</span><br><span class=\"line\">git checkout HEAD -- a.txt</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 创建新分支，并切换到新分支</span><br><span class=\"line\">git checkout -b dev1 origin&#x2F;master</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-merge\"><a href=\"#git-merge\" class=\"headerlink\" title=\"git merge\"></a>git merge</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 将dev1合并到当前分支</span><br><span class=\"line\">git merge dev1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; --abort 发生冲突后放弃合并</span><br><span class=\"line\">git merge --abort dev1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-mergetool\"><a href=\"#git-mergetool\" class=\"headerlink\" title=\"git mergetool\"></a>git mergetool</h3><h3 id=\"git-log\"><a href=\"#git-log\" class=\"headerlink\" title=\"git log\"></a>git log</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 显示当前分支日志</span><br><span class=\"line\">git log</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 显示其他分支日志</span><br><span class=\"line\">git log origin&#x2F;master</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; --graph 显示连线、--oneline 一行展示、--decorate 显示分支</span><br><span class=\"line\">git log --graph --oneline --decorate</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-stash\"><a href=\"#git-stash\" class=\"headerlink\" title=\"git stash\"></a>git stash</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 暂时保存没有提交的工作</span><br><span class=\"line\">git stash</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 列出所有暂时保存的工作</span><br><span class=\"line\">git stash list</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 恢复某个暂时保存的工作</span><br><span class=\"line\">git stash apply stash@&#123;1&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 恢复最近一次stash的文件</span><br><span class=\"line\">git stash pop</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 丢弃最近一次stash的文件</span><br><span class=\"line\">git stash drop</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 删除所有的stash</span><br><span class=\"line\">git stash clear</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-tag\"><a href=\"#git-tag\" class=\"headerlink\" title=\"git tag\"></a>git tag</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 列出tag</span><br><span class=\"line\">git tag</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 添加标签，不使用 -m 会进入描述编辑模式</span><br><span class=\"line\">git tag -a v1.0 -m &quot;标签描述&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 查看标签相关信息</span><br><span class=\"line\">git show v1.0</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 给某次commit打标签</span><br><span class=\"line\">git tag -a v1.1 &#123;commitid&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 推送标签到远端</span><br><span class=\"line\">git push v1.0</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 删除标签</span><br><span class=\"line\">git tag -d v1.0</span><br><span class=\"line\">git push --delete origin v1.0</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-fetch\"><a href=\"#git-fetch\" class=\"headerlink\" title=\"git fetch\"></a>git fetch</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 拉取所有远程分支</span><br><span class=\"line\">git fetch origin</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 拉取指定远程分支</span><br><span class=\"line\">git fetch origin dev1</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 拉取当前远程分支</span><br><span class=\"line\">git fetch</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-pull\"><a href=\"#git-pull\" class=\"headerlink\" title=\"git pull\"></a>git pull</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 拉取远程分支与本地分支合并</span><br><span class=\"line\">git pull origin dev1</span><br><span class=\"line\">git pull origin dev1:dev2</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 本地分支与对应的远程合并</span><br><span class=\"line\">git pull origin</span><br><span class=\"line\">git pull</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 使用rebase模式合并</span><br><span class=\"line\">git pull --rebase origin dev1</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-push\"><a href=\"#git-push\" class=\"headerlink\" title=\"git push\"></a>git push</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"git-remote\"><a href=\"#git-remote\" class=\"headerlink\" title=\"git remote\"></a>git remote</h3><h3 id=\"git-rebase\"><a href=\"#git-rebase\" class=\"headerlink\" title=\"git rebase\"></a>git rebase</h3><h3 id=\"git-with-ssh\"><a href=\"#git-with-ssh\" class=\"headerlink\" title=\"git with ssh\"></a>git with ssh</h3><ul>\n<li>参考：<a href=\"https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/generating-a-new-ssh-key-and-adding-it-to-the-ssh-agent\">官方文档</a></li>\n</ul>\n<ol>\n<li>查看是否存在ssh配置</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 查看.ssh文件夹里是否存在key相关文件(.pub文件)</span><br><span class=\"line\">cd ~&#x2F;.ssh</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>新建ssh key文件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 执行命令后第一步需要设置key文件名称</span><br><span class=\"line\">ssh-keygen -t rsa -b 4096 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>修改config文件，编辑.ssh文件夹下config文件，没有创建</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Host *</span><br><span class=\"line\">  Preferredauthentications publickey</span><br><span class=\"line\">  AddKeysToAgent yes</span><br><span class=\"line\">  UseKeychain yes</span><br><span class=\"line\">  IdentityFile ~&#x2F;.ssh&#x2F;yxc_git</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>添加秘钥</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval $(ssh-agent -s)</span><br><span class=\"line\">ssh-add ~&#x2F;.ssh&#x2F;yxc_git(你的秘钥)</span><br></pre></td></tr></table></figure>\n\n<ol start=\"5\">\n<li>github\\gitlab上添加公钥</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 测试连接情况</span><br><span class=\"line\">ssh -T git@github.com</span><br></pre></td></tr></table></figure>\n\n\n"},{"title":"<工程化>npm使用","date":"2020-12-21T16:00:00.000Z","_content":"\n#### 安装机制\n执行npm install后流程\n- 检查获取npm配置\n配置获取优先级：项目级的 .npmrc 文件 > 用户级的 .npmrc 文件> 全局级的 .npmrc 文件 > npm 内置的 .npmrc 文件\n- 检查是否有package-lock.json文件\n有，检查 package-lock.json 和 package.json 中声明的依赖是否一致，一致，直接使用 package-lock.json 中的信息，从缓存或网络资源中加载依赖；不一致，按照 npm 版本进行处理（最新处理方式：按照package.json安装，并更新package-lock.json）；\n没有，则根据 package.json 递归构建依赖树，最后生成 package-lock.json\n- 安装依赖资源，检查是否缓存\n存在，则将缓存内容解压到 node_modules 中\n不存在，否则就先从 npm 远程仓库下载包，校验包的完整性，并添加到缓存，同时解压到 node_modules\n- 构建依赖树，扁平原则\n当前依赖项目不管其是直接依赖还是子依赖的依赖，优先将其放置在 node_modules 根目录，遇到相同模块就判断已放置在依赖树中的模块版本是否符合新模块的版本范围，如果符合则跳过；不符合则在当前模块的 node_modules 下放置该模块\n\n#### 缓存机制\n\n- 查看缓存目录 npm config get cache 缓存文件在 _cacache 文件夹下\n- _cacache文件夹目录：content-v2（二进制文件，将文件改名为.tgz后解压，可以得到npm包资源）、index-v5（描述文件，对应 content-v2 里文件的索引）、tmp\n- npm install下载依赖时，先下载到缓存中，在解压到node_modules下\n- 在每次安装资源时，根据 package-lock.json 中存储的 integrity、version、name 信息生成一个唯一的 key，这个 key 能够对应到 index-v5 目录下的缓存记录。如果发现有缓存资源，就会找到 tar 包的 hash，根据 hash 再去找缓存的 tar 包，省去了网络下载资源的开销\n\n#### npm 配置作用优先级\n\n- 命令行设置配置 > env环境变量npm配置 > 项目级配置 > 用户级配置 > 全局级配置 > npm内部.npmrc配置\n\n#### npm init\n\n- 调用shell脚本初始化package.json文件\n- 自定义 npm init 命令\n```\n// 需要自己编写.npm-init.js脚本\nnpm config set init-module ~\\.npm-init.js\n```\n\n#### npm link\n\n- 搞笑率调试本地包，验证包的可用性\n```\n// 调试react源码\ncd build/node_modules/react\n# 申明react指向\nnpm link\n# 解除指向\nnpm unlink\ncd build/node_modules/react-dom\n# 申明react-dom指向\nnpm link\n# 解除指向\nnpm unlink\n# 在react项目中引入全局指向\nnpm link react react-dom\n# 解除引用，在react项目中\nnpm unlink react react-dom\n# 强制解除全局引用\nnpm rm --global packageName\n```\n\n#### npx\n\n- 解决了 npm 的一些使用快速开发、调试，以及项目内使用全局模块的痛点\n- 优点\n1. 它可以直接执行 node_modules/.bin 文件夹下的文件。在运行命令时，npx 可以自动去 node_modules/.bin 路径和环境变量 $PATH 里面检查命令是否存在，而不需要再在 package.json 中定义相关的 script\n2. npx 执行模块时会优先安装依赖，但是在安装执行后便删除此依赖，这就避免了全局安装模块带来的问题\n\n#### 查看项目引用包版本\n- npm outdated\n\n#### 查看全局安装包\n- npm list -g --depth 0\n\n#### 设置安装源\n\n1. 使用nrm\n```\nnpm install -g nrm\nnrm ls\nnrm use taobao\n```\n2. 改变全局注册\n```\nnpm config get registry\nnpm config set registry https://registry.npm.taobao.org\nnpm info react\n```\n3. 命令行置顶源\n```\nnpm --registry https://registry.npm.taobao.org install [name]\n```\n4. 修改.npmrc文件\n```\nregistry = https://registry.npm.taobao.org\n```\n5. 使用cnpm\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\ncnpm install [name]\n```\n\n#### 部署私有npm源\n\n- 社区工具：nexus、verdaccio 以及 cnpm\n\n#### CI上的npm优化\n\n1. 使用 npm ci 安装依赖：npm ci 要求项目中必须存在 package-lock.json，npm ci 完全根据 package-lock.json 安装依赖，npm ci 在执行安装时，会先删除项目中现有的 node_modules，然后全新安装，npm ci 只能一次安装整个项目所有依赖包，无法安装单个依赖包，如果 package-lock.json 和 package.json 冲突，那么 npm ci 会直接报错，并非更新 lockfiles，npm ci 永远不会改变 package.json 和 package-lock.json\n2. 使用 package-lock.json 优化依赖安装时间：package-lock.json 中已经缓存了每个包的具体版本和下载链接，你不需要再去远程仓库进行查询，即可直接进入文件完整性校验环节，减少了大量网络请求\n\n#### package-lock.json相关\n\n1. package-lock.json 文件的作用是锁定依赖安装结构，目的是保证在任意机器上执行 npm install 都会得到完全相同的 node_modules 安装结果\n2. 不同版本的 npm 安装依赖策略和算法不同，package-lock.json 保证能够完整准确地还原项目依赖\n3. package-lock.json 构成：\n\tVersion：依赖包的版本号\n\tResolved：依赖包安装源（可简单理解为下载地址）\n\tIntegrity：表明包完整性的 Hash 值\n\tDev：表示该模块是否为顶级模块的开发依赖或者是一个的传递依赖关系\n\trequires：依赖包所需要的所有依赖项，对应依赖包 package.json 里 dependencies 中的依赖项\n\tdependencies：依赖包 node_modules 中依赖的包（特殊情况下才存在）\n4. 是否提交 package-lock.json 到仓库：\n\t如果开发应用，建议提交，保证项目成员、CI部署一致性\n\t如果开发给外部使用的库，不需要提交，库项目一般是被其他项目依赖的，在不使用 package-lock.json 的情况下，就可以复用主项目已经加载过的包，减少依赖重复和体积\n5. 把 package-lock.json 一起提交到代码库中，不需要 ignore。但是执行 npm publish 命令，发布一个库的时候，它应该被忽略而不是直接发布出去\n\n#### xxxDependencies\n\n- dependencies 项目依赖\n\t它关联的 npm 包被下载时，dependencies 下的模块也会作为依赖，一起被下载\n- devDependencies 开发依赖\n\t表示开发依赖，不会被自动下载，并不是只有在 dependencies 中的模块才会被一起打包，而在 devDependencies 中的依赖一定不会被打包。实际上，依赖是否被打包，完全取决于项目里是否被引入了该模块\n- peerDependencies 同版本依赖\n\t表示同版本依赖，简单来说就是：如果你安装我，那么你最好也安装我对应的依赖\n\t使用场景：\n\t插件不能单独运行\n\t插件正确运行的前提是核心依赖库必须先下载安装\n\t我们不希望核心依赖库被重复下载\n\t插件 API 的设计必须要符合核心依赖库的插件编写规范\n\t在项目中，同一插件体系下，核心依赖库版本最好相同\n- bundledDependencies 捆绑依赖\n\tbundledDependencies 和 npm pack 打包命令有关\n\t在 bundledDependencies 中指定的依赖包，必须先在 dependencies 和 devDependencies 声明过，否则在 npm pack 阶段会进行报错\n- optionalDependencies 可选依赖\n\t即使对应依赖项安装失败了，也不会影响整个安装过程，不建议使用\n\n#### npm script\n\n- 在 package.json 中，允许通过 script 字段定义脚本\n- npm 钩子：如pre、post，对应命令npm run build的钩子命令就是：prebuild和postbuild，使用npm run build时，会默认自动先执行npm run prebuild再执行npm run build，最后执行npm run postbuild\n\n```json\n{\n  \"scripts\": {\n    \"prebuild\": \"node prebuild.js\",\n    \"build\": \"node build.js\",\n    \"postbuild\": \"node postbuild.js\"\n  }\n}\n```\n\n- npm 提供 process.env.npm_lifecycle_even 环境变量，在相关 npm scripts 脚本中获得当前运行的脚本名称\n- 通过 npm_package_ 获取 package.json 中的相关字段\n\n```javascript\n  // 获取 package.json 中的 name 字段值\n  console.log(process.env.npm_package_name)\n  // 获取 package.json 中的 version 字段值\n  console.log(process.env.npm_package_version)\n```\n\n- 原理\n\tnpm run会自动创建一个 Shell（macOS 或 Linux 中指代的是 /bin/sh， 在 Windows 中使用的是 cmd.exe）\n\t只要是 shell 可以运行的命令，都可以作为 npm script 脚本\n\tnpm scripts 脚本可以使用 Shell 通配符等常规能力\n- npm run 创建出来的 Shell 需要将当前目录的node_modules/.bin子目录加入PATH 变量中，在 npm scripts 执行完成后，再将 PATH 变量恢复，因此可以在 npm run 中直接使用 webpack\n- 使用技巧：\n\t传参：使用--标记参数webpack --profile > stats.json\n\t串行脚本：npm run pre.js && npm run post.js\n\t并行脚本：npm run a.js & npm run b.js\n- npm script 需要考虑平台兼容性问题\n\tun-script-os：针对不同平台进行不同的定制化脚本\n\tcross-env：设置环境变量\n\n#### npm使用文章\n\n- [聊聊 NPM 镜像那些险象环生的坑]：https://mp.weixin.qq.com/s/2ntKGIkR3Uiy9cQfITg2NQ\n\n","source":"_posts/[工程化]npm使用.md","raw":"---\ntitle: <工程化>npm使用\ndate: 2020-12-22 00:00:00\ntags: [npm,工程化]\ncategories: npm\n---\n\n#### 安装机制\n执行npm install后流程\n- 检查获取npm配置\n配置获取优先级：项目级的 .npmrc 文件 > 用户级的 .npmrc 文件> 全局级的 .npmrc 文件 > npm 内置的 .npmrc 文件\n- 检查是否有package-lock.json文件\n有，检查 package-lock.json 和 package.json 中声明的依赖是否一致，一致，直接使用 package-lock.json 中的信息，从缓存或网络资源中加载依赖；不一致，按照 npm 版本进行处理（最新处理方式：按照package.json安装，并更新package-lock.json）；\n没有，则根据 package.json 递归构建依赖树，最后生成 package-lock.json\n- 安装依赖资源，检查是否缓存\n存在，则将缓存内容解压到 node_modules 中\n不存在，否则就先从 npm 远程仓库下载包，校验包的完整性，并添加到缓存，同时解压到 node_modules\n- 构建依赖树，扁平原则\n当前依赖项目不管其是直接依赖还是子依赖的依赖，优先将其放置在 node_modules 根目录，遇到相同模块就判断已放置在依赖树中的模块版本是否符合新模块的版本范围，如果符合则跳过；不符合则在当前模块的 node_modules 下放置该模块\n\n#### 缓存机制\n\n- 查看缓存目录 npm config get cache 缓存文件在 _cacache 文件夹下\n- _cacache文件夹目录：content-v2（二进制文件，将文件改名为.tgz后解压，可以得到npm包资源）、index-v5（描述文件，对应 content-v2 里文件的索引）、tmp\n- npm install下载依赖时，先下载到缓存中，在解压到node_modules下\n- 在每次安装资源时，根据 package-lock.json 中存储的 integrity、version、name 信息生成一个唯一的 key，这个 key 能够对应到 index-v5 目录下的缓存记录。如果发现有缓存资源，就会找到 tar 包的 hash，根据 hash 再去找缓存的 tar 包，省去了网络下载资源的开销\n\n#### npm 配置作用优先级\n\n- 命令行设置配置 > env环境变量npm配置 > 项目级配置 > 用户级配置 > 全局级配置 > npm内部.npmrc配置\n\n#### npm init\n\n- 调用shell脚本初始化package.json文件\n- 自定义 npm init 命令\n```\n// 需要自己编写.npm-init.js脚本\nnpm config set init-module ~\\.npm-init.js\n```\n\n#### npm link\n\n- 搞笑率调试本地包，验证包的可用性\n```\n// 调试react源码\ncd build/node_modules/react\n# 申明react指向\nnpm link\n# 解除指向\nnpm unlink\ncd build/node_modules/react-dom\n# 申明react-dom指向\nnpm link\n# 解除指向\nnpm unlink\n# 在react项目中引入全局指向\nnpm link react react-dom\n# 解除引用，在react项目中\nnpm unlink react react-dom\n# 强制解除全局引用\nnpm rm --global packageName\n```\n\n#### npx\n\n- 解决了 npm 的一些使用快速开发、调试，以及项目内使用全局模块的痛点\n- 优点\n1. 它可以直接执行 node_modules/.bin 文件夹下的文件。在运行命令时，npx 可以自动去 node_modules/.bin 路径和环境变量 $PATH 里面检查命令是否存在，而不需要再在 package.json 中定义相关的 script\n2. npx 执行模块时会优先安装依赖，但是在安装执行后便删除此依赖，这就避免了全局安装模块带来的问题\n\n#### 查看项目引用包版本\n- npm outdated\n\n#### 查看全局安装包\n- npm list -g --depth 0\n\n#### 设置安装源\n\n1. 使用nrm\n```\nnpm install -g nrm\nnrm ls\nnrm use taobao\n```\n2. 改变全局注册\n```\nnpm config get registry\nnpm config set registry https://registry.npm.taobao.org\nnpm info react\n```\n3. 命令行置顶源\n```\nnpm --registry https://registry.npm.taobao.org install [name]\n```\n4. 修改.npmrc文件\n```\nregistry = https://registry.npm.taobao.org\n```\n5. 使用cnpm\n```\nnpm install -g cnpm --registry=https://registry.npm.taobao.org\ncnpm install [name]\n```\n\n#### 部署私有npm源\n\n- 社区工具：nexus、verdaccio 以及 cnpm\n\n#### CI上的npm优化\n\n1. 使用 npm ci 安装依赖：npm ci 要求项目中必须存在 package-lock.json，npm ci 完全根据 package-lock.json 安装依赖，npm ci 在执行安装时，会先删除项目中现有的 node_modules，然后全新安装，npm ci 只能一次安装整个项目所有依赖包，无法安装单个依赖包，如果 package-lock.json 和 package.json 冲突，那么 npm ci 会直接报错，并非更新 lockfiles，npm ci 永远不会改变 package.json 和 package-lock.json\n2. 使用 package-lock.json 优化依赖安装时间：package-lock.json 中已经缓存了每个包的具体版本和下载链接，你不需要再去远程仓库进行查询，即可直接进入文件完整性校验环节，减少了大量网络请求\n\n#### package-lock.json相关\n\n1. package-lock.json 文件的作用是锁定依赖安装结构，目的是保证在任意机器上执行 npm install 都会得到完全相同的 node_modules 安装结果\n2. 不同版本的 npm 安装依赖策略和算法不同，package-lock.json 保证能够完整准确地还原项目依赖\n3. package-lock.json 构成：\n\tVersion：依赖包的版本号\n\tResolved：依赖包安装源（可简单理解为下载地址）\n\tIntegrity：表明包完整性的 Hash 值\n\tDev：表示该模块是否为顶级模块的开发依赖或者是一个的传递依赖关系\n\trequires：依赖包所需要的所有依赖项，对应依赖包 package.json 里 dependencies 中的依赖项\n\tdependencies：依赖包 node_modules 中依赖的包（特殊情况下才存在）\n4. 是否提交 package-lock.json 到仓库：\n\t如果开发应用，建议提交，保证项目成员、CI部署一致性\n\t如果开发给外部使用的库，不需要提交，库项目一般是被其他项目依赖的，在不使用 package-lock.json 的情况下，就可以复用主项目已经加载过的包，减少依赖重复和体积\n5. 把 package-lock.json 一起提交到代码库中，不需要 ignore。但是执行 npm publish 命令，发布一个库的时候，它应该被忽略而不是直接发布出去\n\n#### xxxDependencies\n\n- dependencies 项目依赖\n\t它关联的 npm 包被下载时，dependencies 下的模块也会作为依赖，一起被下载\n- devDependencies 开发依赖\n\t表示开发依赖，不会被自动下载，并不是只有在 dependencies 中的模块才会被一起打包，而在 devDependencies 中的依赖一定不会被打包。实际上，依赖是否被打包，完全取决于项目里是否被引入了该模块\n- peerDependencies 同版本依赖\n\t表示同版本依赖，简单来说就是：如果你安装我，那么你最好也安装我对应的依赖\n\t使用场景：\n\t插件不能单独运行\n\t插件正确运行的前提是核心依赖库必须先下载安装\n\t我们不希望核心依赖库被重复下载\n\t插件 API 的设计必须要符合核心依赖库的插件编写规范\n\t在项目中，同一插件体系下，核心依赖库版本最好相同\n- bundledDependencies 捆绑依赖\n\tbundledDependencies 和 npm pack 打包命令有关\n\t在 bundledDependencies 中指定的依赖包，必须先在 dependencies 和 devDependencies 声明过，否则在 npm pack 阶段会进行报错\n- optionalDependencies 可选依赖\n\t即使对应依赖项安装失败了，也不会影响整个安装过程，不建议使用\n\n#### npm script\n\n- 在 package.json 中，允许通过 script 字段定义脚本\n- npm 钩子：如pre、post，对应命令npm run build的钩子命令就是：prebuild和postbuild，使用npm run build时，会默认自动先执行npm run prebuild再执行npm run build，最后执行npm run postbuild\n\n```json\n{\n  \"scripts\": {\n    \"prebuild\": \"node prebuild.js\",\n    \"build\": \"node build.js\",\n    \"postbuild\": \"node postbuild.js\"\n  }\n}\n```\n\n- npm 提供 process.env.npm_lifecycle_even 环境变量，在相关 npm scripts 脚本中获得当前运行的脚本名称\n- 通过 npm_package_ 获取 package.json 中的相关字段\n\n```javascript\n  // 获取 package.json 中的 name 字段值\n  console.log(process.env.npm_package_name)\n  // 获取 package.json 中的 version 字段值\n  console.log(process.env.npm_package_version)\n```\n\n- 原理\n\tnpm run会自动创建一个 Shell（macOS 或 Linux 中指代的是 /bin/sh， 在 Windows 中使用的是 cmd.exe）\n\t只要是 shell 可以运行的命令，都可以作为 npm script 脚本\n\tnpm scripts 脚本可以使用 Shell 通配符等常规能力\n- npm run 创建出来的 Shell 需要将当前目录的node_modules/.bin子目录加入PATH 变量中，在 npm scripts 执行完成后，再将 PATH 变量恢复，因此可以在 npm run 中直接使用 webpack\n- 使用技巧：\n\t传参：使用--标记参数webpack --profile > stats.json\n\t串行脚本：npm run pre.js && npm run post.js\n\t并行脚本：npm run a.js & npm run b.js\n- npm script 需要考虑平台兼容性问题\n\tun-script-os：针对不同平台进行不同的定制化脚本\n\tcross-env：设置环境变量\n\n#### npm使用文章\n\n- [聊聊 NPM 镜像那些险象环生的坑]：https://mp.weixin.qq.com/s/2ntKGIkR3Uiy9cQfITg2NQ\n\n","slug":"[工程化]npm使用","published":1,"updated":"2021-03-15T14:34:42.145Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dla003ywotj84v00fth","content":"<h4 id=\"安装机制\"><a href=\"#安装机制\" class=\"headerlink\" title=\"安装机制\"></a>安装机制</h4><p>执行npm install后流程</p>\n<ul>\n<li>检查获取npm配置<br>配置获取优先级：项目级的 .npmrc 文件 &gt; 用户级的 .npmrc 文件&gt; 全局级的 .npmrc 文件 &gt; npm 内置的 .npmrc 文件</li>\n<li>检查是否有package-lock.json文件<br>有，检查 package-lock.json 和 package.json 中声明的依赖是否一致，一致，直接使用 package-lock.json 中的信息，从缓存或网络资源中加载依赖；不一致，按照 npm 版本进行处理（最新处理方式：按照package.json安装，并更新package-lock.json）；<br>没有，则根据 package.json 递归构建依赖树，最后生成 package-lock.json</li>\n<li>安装依赖资源，检查是否缓存<br>存在，则将缓存内容解压到 node_modules 中<br>不存在，否则就先从 npm 远程仓库下载包，校验包的完整性，并添加到缓存，同时解压到 node_modules</li>\n<li>构建依赖树，扁平原则<br>当前依赖项目不管其是直接依赖还是子依赖的依赖，优先将其放置在 node_modules 根目录，遇到相同模块就判断已放置在依赖树中的模块版本是否符合新模块的版本范围，如果符合则跳过；不符合则在当前模块的 node_modules 下放置该模块</li>\n</ul>\n<h4 id=\"缓存机制\"><a href=\"#缓存机制\" class=\"headerlink\" title=\"缓存机制\"></a>缓存机制</h4><ul>\n<li>查看缓存目录 npm config get cache 缓存文件在 _cacache 文件夹下</li>\n<li>_cacache文件夹目录：content-v2（二进制文件，将文件改名为.tgz后解压，可以得到npm包资源）、index-v5（描述文件，对应 content-v2 里文件的索引）、tmp</li>\n<li>npm install下载依赖时，先下载到缓存中，在解压到node_modules下</li>\n<li>在每次安装资源时，根据 package-lock.json 中存储的 integrity、version、name 信息生成一个唯一的 key，这个 key 能够对应到 index-v5 目录下的缓存记录。如果发现有缓存资源，就会找到 tar 包的 hash，根据 hash 再去找缓存的 tar 包，省去了网络下载资源的开销</li>\n</ul>\n<h4 id=\"npm-配置作用优先级\"><a href=\"#npm-配置作用优先级\" class=\"headerlink\" title=\"npm 配置作用优先级\"></a>npm 配置作用优先级</h4><ul>\n<li>命令行设置配置 &gt; env环境变量npm配置 &gt; 项目级配置 &gt; 用户级配置 &gt; 全局级配置 &gt; npm内部.npmrc配置</li>\n</ul>\n<h4 id=\"npm-init\"><a href=\"#npm-init\" class=\"headerlink\" title=\"npm init\"></a>npm init</h4><ul>\n<li>调用shell脚本初始化package.json文件</li>\n<li>自定义 npm init 命令<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 需要自己编写.npm-init.js脚本</span><br><span class=\"line\">npm config set init-module ~\\.npm-init.js</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"npm-link\"><a href=\"#npm-link\" class=\"headerlink\" title=\"npm link\"></a>npm link</h4><ul>\n<li>搞笑率调试本地包，验证包的可用性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 调试react源码</span><br><span class=\"line\">cd build&#x2F;node_modules&#x2F;react</span><br><span class=\"line\"># 申明react指向</span><br><span class=\"line\">npm link</span><br><span class=\"line\"># 解除指向</span><br><span class=\"line\">npm unlink</span><br><span class=\"line\">cd build&#x2F;node_modules&#x2F;react-dom</span><br><span class=\"line\"># 申明react-dom指向</span><br><span class=\"line\">npm link</span><br><span class=\"line\"># 解除指向</span><br><span class=\"line\">npm unlink</span><br><span class=\"line\"># 在react项目中引入全局指向</span><br><span class=\"line\">npm link react react-dom</span><br><span class=\"line\"># 解除引用，在react项目中</span><br><span class=\"line\">npm unlink react react-dom</span><br><span class=\"line\"># 强制解除全局引用</span><br><span class=\"line\">npm rm --global packageName</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"npx\"><a href=\"#npx\" class=\"headerlink\" title=\"npx\"></a>npx</h4><ul>\n<li>解决了 npm 的一些使用快速开发、调试，以及项目内使用全局模块的痛点</li>\n<li>优点</li>\n</ul>\n<ol>\n<li>它可以直接执行 node_modules/.bin 文件夹下的文件。在运行命令时，npx 可以自动去 node_modules/.bin 路径和环境变量 $PATH 里面检查命令是否存在，而不需要再在 package.json 中定义相关的 script</li>\n<li>npx 执行模块时会优先安装依赖，但是在安装执行后便删除此依赖，这就避免了全局安装模块带来的问题</li>\n</ol>\n<h4 id=\"查看项目引用包版本\"><a href=\"#查看项目引用包版本\" class=\"headerlink\" title=\"查看项目引用包版本\"></a>查看项目引用包版本</h4><ul>\n<li>npm outdated</li>\n</ul>\n<h4 id=\"查看全局安装包\"><a href=\"#查看全局安装包\" class=\"headerlink\" title=\"查看全局安装包\"></a>查看全局安装包</h4><ul>\n<li>npm list -g –depth 0</li>\n</ul>\n<h4 id=\"设置安装源\"><a href=\"#设置安装源\" class=\"headerlink\" title=\"设置安装源\"></a>设置安装源</h4><ol>\n<li>使用nrm<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g nrm</span><br><span class=\"line\">nrm ls</span><br><span class=\"line\">nrm use taobao</span><br></pre></td></tr></table></figure></li>\n<li>改变全局注册<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry</span><br><span class=\"line\">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class=\"line\">npm info react</span><br></pre></td></tr></table></figure></li>\n<li>命令行置顶源<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm --registry https:&#x2F;&#x2F;registry.npm.taobao.org install [name]</span><br></pre></td></tr></table></figure></li>\n<li>修改.npmrc文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registry &#x3D; https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li>\n<li>使用cnpm<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class=\"line\">cnpm install [name]</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"部署私有npm源\"><a href=\"#部署私有npm源\" class=\"headerlink\" title=\"部署私有npm源\"></a>部署私有npm源</h4><ul>\n<li>社区工具：nexus、verdaccio 以及 cnpm</li>\n</ul>\n<h4 id=\"CI上的npm优化\"><a href=\"#CI上的npm优化\" class=\"headerlink\" title=\"CI上的npm优化\"></a>CI上的npm优化</h4><ol>\n<li>使用 npm ci 安装依赖：npm ci 要求项目中必须存在 package-lock.json，npm ci 完全根据 package-lock.json 安装依赖，npm ci 在执行安装时，会先删除项目中现有的 node_modules，然后全新安装，npm ci 只能一次安装整个项目所有依赖包，无法安装单个依赖包，如果 package-lock.json 和 package.json 冲突，那么 npm ci 会直接报错，并非更新 lockfiles，npm ci 永远不会改变 package.json 和 package-lock.json</li>\n<li>使用 package-lock.json 优化依赖安装时间：package-lock.json 中已经缓存了每个包的具体版本和下载链接，你不需要再去远程仓库进行查询，即可直接进入文件完整性校验环节，减少了大量网络请求</li>\n</ol>\n<h4 id=\"package-lock-json相关\"><a href=\"#package-lock-json相关\" class=\"headerlink\" title=\"package-lock.json相关\"></a>package-lock.json相关</h4><ol>\n<li>package-lock.json 文件的作用是锁定依赖安装结构，目的是保证在任意机器上执行 npm install 都会得到完全相同的 node_modules 安装结果</li>\n<li>不同版本的 npm 安装依赖策略和算法不同，package-lock.json 保证能够完整准确地还原项目依赖</li>\n<li>package-lock.json 构成：<br> Version：依赖包的版本号<br> Resolved：依赖包安装源（可简单理解为下载地址）<br> Integrity：表明包完整性的 Hash 值<br> Dev：表示该模块是否为顶级模块的开发依赖或者是一个的传递依赖关系<br> requires：依赖包所需要的所有依赖项，对应依赖包 package.json 里 dependencies 中的依赖项<br> dependencies：依赖包 node_modules 中依赖的包（特殊情况下才存在）</li>\n<li>是否提交 package-lock.json 到仓库：<br> 如果开发应用，建议提交，保证项目成员、CI部署一致性<br> 如果开发给外部使用的库，不需要提交，库项目一般是被其他项目依赖的，在不使用 package-lock.json 的情况下，就可以复用主项目已经加载过的包，减少依赖重复和体积</li>\n<li>把 package-lock.json 一起提交到代码库中，不需要 ignore。但是执行 npm publish 命令，发布一个库的时候，它应该被忽略而不是直接发布出去</li>\n</ol>\n<h4 id=\"xxxDependencies\"><a href=\"#xxxDependencies\" class=\"headerlink\" title=\"xxxDependencies\"></a>xxxDependencies</h4><ul>\n<li>dependencies 项目依赖<br>  它关联的 npm 包被下载时，dependencies 下的模块也会作为依赖，一起被下载</li>\n<li>devDependencies 开发依赖<br>  表示开发依赖，不会被自动下载，并不是只有在 dependencies 中的模块才会被一起打包，而在 devDependencies 中的依赖一定不会被打包。实际上，依赖是否被打包，完全取决于项目里是否被引入了该模块</li>\n<li>peerDependencies 同版本依赖<br>  表示同版本依赖，简单来说就是：如果你安装我，那么你最好也安装我对应的依赖<br>  使用场景：<br>  插件不能单独运行<br>  插件正确运行的前提是核心依赖库必须先下载安装<br>  我们不希望核心依赖库被重复下载<br>  插件 API 的设计必须要符合核心依赖库的插件编写规范<br>  在项目中，同一插件体系下，核心依赖库版本最好相同</li>\n<li>bundledDependencies 捆绑依赖<br>  bundledDependencies 和 npm pack 打包命令有关<br>  在 bundledDependencies 中指定的依赖包，必须先在 dependencies 和 devDependencies 声明过，否则在 npm pack 阶段会进行报错</li>\n<li>optionalDependencies 可选依赖<br>  即使对应依赖项安装失败了，也不会影响整个安装过程，不建议使用</li>\n</ul>\n<h4 id=\"npm-script\"><a href=\"#npm-script\" class=\"headerlink\" title=\"npm script\"></a>npm script</h4><ul>\n<li>在 package.json 中，允许通过 script 字段定义脚本</li>\n<li>npm 钩子：如pre、post，对应命令npm run build的钩子命令就是：prebuild和postbuild，使用npm run build时，会默认自动先执行npm run prebuild再执行npm run build，最后执行npm run postbuild</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;prebuild&quot;</span>: <span class=\"string\">&quot;node prebuild.js&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;build&quot;</span>: <span class=\"string\">&quot;node build.js&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;postbuild&quot;</span>: <span class=\"string\">&quot;node postbuild.js&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>npm 提供 process.env.npm_lifecycle_even 环境变量，在相关 npm scripts 脚本中获得当前运行的脚本名称</li>\n<li>通过 npm_package_ 获取 package.json 中的相关字段</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取 package.json 中的 name 字段值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(process.env.npm_package_name)</span><br><span class=\"line\"><span class=\"comment\">// 获取 package.json 中的 version 字段值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(process.env.npm_package_version)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>原理<br>  npm run会自动创建一个 Shell（macOS 或 Linux 中指代的是 /bin/sh， 在 Windows 中使用的是 cmd.exe）<br>  只要是 shell 可以运行的命令，都可以作为 npm script 脚本<br>  npm scripts 脚本可以使用 Shell 通配符等常规能力</li>\n<li>npm run 创建出来的 Shell 需要将当前目录的node_modules/.bin子目录加入PATH 变量中，在 npm scripts 执行完成后，再将 PATH 变量恢复，因此可以在 npm run 中直接使用 webpack</li>\n<li>使用技巧：<br>  传参：使用–标记参数webpack –profile &gt; stats.json<br>  串行脚本：npm run pre.js &amp;&amp; npm run post.js<br>  并行脚本：npm run a.js &amp; npm run b.js</li>\n<li>npm script 需要考虑平台兼容性问题<br>  un-script-os：针对不同平台进行不同的定制化脚本<br>  cross-env：设置环境变量</li>\n</ul>\n<h4 id=\"npm使用文章\"><a href=\"#npm使用文章\" class=\"headerlink\" title=\"npm使用文章\"></a>npm使用文章</h4><ul>\n<li>[聊聊 NPM 镜像那些险象环生的坑]：<a href=\"https://mp.weixin.qq.com/s/2ntKGIkR3Uiy9cQfITg2NQ\">https://mp.weixin.qq.com/s/2ntKGIkR3Uiy9cQfITg2NQ</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"安装机制\"><a href=\"#安装机制\" class=\"headerlink\" title=\"安装机制\"></a>安装机制</h4><p>执行npm install后流程</p>\n<ul>\n<li>检查获取npm配置<br>配置获取优先级：项目级的 .npmrc 文件 &gt; 用户级的 .npmrc 文件&gt; 全局级的 .npmrc 文件 &gt; npm 内置的 .npmrc 文件</li>\n<li>检查是否有package-lock.json文件<br>有，检查 package-lock.json 和 package.json 中声明的依赖是否一致，一致，直接使用 package-lock.json 中的信息，从缓存或网络资源中加载依赖；不一致，按照 npm 版本进行处理（最新处理方式：按照package.json安装，并更新package-lock.json）；<br>没有，则根据 package.json 递归构建依赖树，最后生成 package-lock.json</li>\n<li>安装依赖资源，检查是否缓存<br>存在，则将缓存内容解压到 node_modules 中<br>不存在，否则就先从 npm 远程仓库下载包，校验包的完整性，并添加到缓存，同时解压到 node_modules</li>\n<li>构建依赖树，扁平原则<br>当前依赖项目不管其是直接依赖还是子依赖的依赖，优先将其放置在 node_modules 根目录，遇到相同模块就判断已放置在依赖树中的模块版本是否符合新模块的版本范围，如果符合则跳过；不符合则在当前模块的 node_modules 下放置该模块</li>\n</ul>\n<h4 id=\"缓存机制\"><a href=\"#缓存机制\" class=\"headerlink\" title=\"缓存机制\"></a>缓存机制</h4><ul>\n<li>查看缓存目录 npm config get cache 缓存文件在 _cacache 文件夹下</li>\n<li>_cacache文件夹目录：content-v2（二进制文件，将文件改名为.tgz后解压，可以得到npm包资源）、index-v5（描述文件，对应 content-v2 里文件的索引）、tmp</li>\n<li>npm install下载依赖时，先下载到缓存中，在解压到node_modules下</li>\n<li>在每次安装资源时，根据 package-lock.json 中存储的 integrity、version、name 信息生成一个唯一的 key，这个 key 能够对应到 index-v5 目录下的缓存记录。如果发现有缓存资源，就会找到 tar 包的 hash，根据 hash 再去找缓存的 tar 包，省去了网络下载资源的开销</li>\n</ul>\n<h4 id=\"npm-配置作用优先级\"><a href=\"#npm-配置作用优先级\" class=\"headerlink\" title=\"npm 配置作用优先级\"></a>npm 配置作用优先级</h4><ul>\n<li>命令行设置配置 &gt; env环境变量npm配置 &gt; 项目级配置 &gt; 用户级配置 &gt; 全局级配置 &gt; npm内部.npmrc配置</li>\n</ul>\n<h4 id=\"npm-init\"><a href=\"#npm-init\" class=\"headerlink\" title=\"npm init\"></a>npm init</h4><ul>\n<li>调用shell脚本初始化package.json文件</li>\n<li>自定义 npm init 命令<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 需要自己编写.npm-init.js脚本</span><br><span class=\"line\">npm config set init-module ~\\.npm-init.js</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"npm-link\"><a href=\"#npm-link\" class=\"headerlink\" title=\"npm link\"></a>npm link</h4><ul>\n<li>搞笑率调试本地包，验证包的可用性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 调试react源码</span><br><span class=\"line\">cd build&#x2F;node_modules&#x2F;react</span><br><span class=\"line\"># 申明react指向</span><br><span class=\"line\">npm link</span><br><span class=\"line\"># 解除指向</span><br><span class=\"line\">npm unlink</span><br><span class=\"line\">cd build&#x2F;node_modules&#x2F;react-dom</span><br><span class=\"line\"># 申明react-dom指向</span><br><span class=\"line\">npm link</span><br><span class=\"line\"># 解除指向</span><br><span class=\"line\">npm unlink</span><br><span class=\"line\"># 在react项目中引入全局指向</span><br><span class=\"line\">npm link react react-dom</span><br><span class=\"line\"># 解除引用，在react项目中</span><br><span class=\"line\">npm unlink react react-dom</span><br><span class=\"line\"># 强制解除全局引用</span><br><span class=\"line\">npm rm --global packageName</span><br></pre></td></tr></table></figure></li>\n</ul>\n<h4 id=\"npx\"><a href=\"#npx\" class=\"headerlink\" title=\"npx\"></a>npx</h4><ul>\n<li>解决了 npm 的一些使用快速开发、调试，以及项目内使用全局模块的痛点</li>\n<li>优点</li>\n</ul>\n<ol>\n<li>它可以直接执行 node_modules/.bin 文件夹下的文件。在运行命令时，npx 可以自动去 node_modules/.bin 路径和环境变量 $PATH 里面检查命令是否存在，而不需要再在 package.json 中定义相关的 script</li>\n<li>npx 执行模块时会优先安装依赖，但是在安装执行后便删除此依赖，这就避免了全局安装模块带来的问题</li>\n</ol>\n<h4 id=\"查看项目引用包版本\"><a href=\"#查看项目引用包版本\" class=\"headerlink\" title=\"查看项目引用包版本\"></a>查看项目引用包版本</h4><ul>\n<li>npm outdated</li>\n</ul>\n<h4 id=\"查看全局安装包\"><a href=\"#查看全局安装包\" class=\"headerlink\" title=\"查看全局安装包\"></a>查看全局安装包</h4><ul>\n<li>npm list -g –depth 0</li>\n</ul>\n<h4 id=\"设置安装源\"><a href=\"#设置安装源\" class=\"headerlink\" title=\"设置安装源\"></a>设置安装源</h4><ol>\n<li>使用nrm<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g nrm</span><br><span class=\"line\">nrm ls</span><br><span class=\"line\">nrm use taobao</span><br></pre></td></tr></table></figure></li>\n<li>改变全局注册<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm config get registry</span><br><span class=\"line\">npm config set registry https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class=\"line\">npm info react</span><br></pre></td></tr></table></figure></li>\n<li>命令行置顶源<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm --registry https:&#x2F;&#x2F;registry.npm.taobao.org install [name]</span><br></pre></td></tr></table></figure></li>\n<li>修改.npmrc文件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">registry &#x3D; https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li>\n<li>使用cnpm<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br><span class=\"line\">cnpm install [name]</span><br></pre></td></tr></table></figure></li>\n</ol>\n<h4 id=\"部署私有npm源\"><a href=\"#部署私有npm源\" class=\"headerlink\" title=\"部署私有npm源\"></a>部署私有npm源</h4><ul>\n<li>社区工具：nexus、verdaccio 以及 cnpm</li>\n</ul>\n<h4 id=\"CI上的npm优化\"><a href=\"#CI上的npm优化\" class=\"headerlink\" title=\"CI上的npm优化\"></a>CI上的npm优化</h4><ol>\n<li>使用 npm ci 安装依赖：npm ci 要求项目中必须存在 package-lock.json，npm ci 完全根据 package-lock.json 安装依赖，npm ci 在执行安装时，会先删除项目中现有的 node_modules，然后全新安装，npm ci 只能一次安装整个项目所有依赖包，无法安装单个依赖包，如果 package-lock.json 和 package.json 冲突，那么 npm ci 会直接报错，并非更新 lockfiles，npm ci 永远不会改变 package.json 和 package-lock.json</li>\n<li>使用 package-lock.json 优化依赖安装时间：package-lock.json 中已经缓存了每个包的具体版本和下载链接，你不需要再去远程仓库进行查询，即可直接进入文件完整性校验环节，减少了大量网络请求</li>\n</ol>\n<h4 id=\"package-lock-json相关\"><a href=\"#package-lock-json相关\" class=\"headerlink\" title=\"package-lock.json相关\"></a>package-lock.json相关</h4><ol>\n<li>package-lock.json 文件的作用是锁定依赖安装结构，目的是保证在任意机器上执行 npm install 都会得到完全相同的 node_modules 安装结果</li>\n<li>不同版本的 npm 安装依赖策略和算法不同，package-lock.json 保证能够完整准确地还原项目依赖</li>\n<li>package-lock.json 构成：<br> Version：依赖包的版本号<br> Resolved：依赖包安装源（可简单理解为下载地址）<br> Integrity：表明包完整性的 Hash 值<br> Dev：表示该模块是否为顶级模块的开发依赖或者是一个的传递依赖关系<br> requires：依赖包所需要的所有依赖项，对应依赖包 package.json 里 dependencies 中的依赖项<br> dependencies：依赖包 node_modules 中依赖的包（特殊情况下才存在）</li>\n<li>是否提交 package-lock.json 到仓库：<br> 如果开发应用，建议提交，保证项目成员、CI部署一致性<br> 如果开发给外部使用的库，不需要提交，库项目一般是被其他项目依赖的，在不使用 package-lock.json 的情况下，就可以复用主项目已经加载过的包，减少依赖重复和体积</li>\n<li>把 package-lock.json 一起提交到代码库中，不需要 ignore。但是执行 npm publish 命令，发布一个库的时候，它应该被忽略而不是直接发布出去</li>\n</ol>\n<h4 id=\"xxxDependencies\"><a href=\"#xxxDependencies\" class=\"headerlink\" title=\"xxxDependencies\"></a>xxxDependencies</h4><ul>\n<li>dependencies 项目依赖<br>  它关联的 npm 包被下载时，dependencies 下的模块也会作为依赖，一起被下载</li>\n<li>devDependencies 开发依赖<br>  表示开发依赖，不会被自动下载，并不是只有在 dependencies 中的模块才会被一起打包，而在 devDependencies 中的依赖一定不会被打包。实际上，依赖是否被打包，完全取决于项目里是否被引入了该模块</li>\n<li>peerDependencies 同版本依赖<br>  表示同版本依赖，简单来说就是：如果你安装我，那么你最好也安装我对应的依赖<br>  使用场景：<br>  插件不能单独运行<br>  插件正确运行的前提是核心依赖库必须先下载安装<br>  我们不希望核心依赖库被重复下载<br>  插件 API 的设计必须要符合核心依赖库的插件编写规范<br>  在项目中，同一插件体系下，核心依赖库版本最好相同</li>\n<li>bundledDependencies 捆绑依赖<br>  bundledDependencies 和 npm pack 打包命令有关<br>  在 bundledDependencies 中指定的依赖包，必须先在 dependencies 和 devDependencies 声明过，否则在 npm pack 阶段会进行报错</li>\n<li>optionalDependencies 可选依赖<br>  即使对应依赖项安装失败了，也不会影响整个安装过程，不建议使用</li>\n</ul>\n<h4 id=\"npm-script\"><a href=\"#npm-script\" class=\"headerlink\" title=\"npm script\"></a>npm script</h4><ul>\n<li>在 package.json 中，允许通过 script 字段定义脚本</li>\n<li>npm 钩子：如pre、post，对应命令npm run build的钩子命令就是：prebuild和postbuild，使用npm run build时，会默认自动先执行npm run prebuild再执行npm run build，最后执行npm run postbuild</li>\n</ul>\n<figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">&quot;scripts&quot;</span>: &#123;</span><br><span class=\"line\">    <span class=\"attr\">&quot;prebuild&quot;</span>: <span class=\"string\">&quot;node prebuild.js&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;build&quot;</span>: <span class=\"string\">&quot;node build.js&quot;</span>,</span><br><span class=\"line\">    <span class=\"attr\">&quot;postbuild&quot;</span>: <span class=\"string\">&quot;node postbuild.js&quot;</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>npm 提供 process.env.npm_lifecycle_even 环境变量，在相关 npm scripts 脚本中获得当前运行的脚本名称</li>\n<li>通过 npm_package_ 获取 package.json 中的相关字段</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 获取 package.json 中的 name 字段值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(process.env.npm_package_name)</span><br><span class=\"line\"><span class=\"comment\">// 获取 package.json 中的 version 字段值</span></span><br><span class=\"line\"><span class=\"built_in\">console</span>.log(process.env.npm_package_version)</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>原理<br>  npm run会自动创建一个 Shell（macOS 或 Linux 中指代的是 /bin/sh， 在 Windows 中使用的是 cmd.exe）<br>  只要是 shell 可以运行的命令，都可以作为 npm script 脚本<br>  npm scripts 脚本可以使用 Shell 通配符等常规能力</li>\n<li>npm run 创建出来的 Shell 需要将当前目录的node_modules/.bin子目录加入PATH 变量中，在 npm scripts 执行完成后，再将 PATH 变量恢复，因此可以在 npm run 中直接使用 webpack</li>\n<li>使用技巧：<br>  传参：使用–标记参数webpack –profile &gt; stats.json<br>  串行脚本：npm run pre.js &amp;&amp; npm run post.js<br>  并行脚本：npm run a.js &amp; npm run b.js</li>\n<li>npm script 需要考虑平台兼容性问题<br>  un-script-os：针对不同平台进行不同的定制化脚本<br>  cross-env：设置环境变量</li>\n</ul>\n<h4 id=\"npm使用文章\"><a href=\"#npm使用文章\" class=\"headerlink\" title=\"npm使用文章\"></a>npm使用文章</h4><ul>\n<li>[聊聊 NPM 镜像那些险象环生的坑]：<a href=\"https://mp.weixin.qq.com/s/2ntKGIkR3Uiy9cQfITg2NQ\">https://mp.weixin.qq.com/s/2ntKGIkR3Uiy9cQfITg2NQ</a></li>\n</ul>\n"},{"title":"<工程化>yarn使用","date":"2020-07-19T16:00:00.000Z","_content":"\n#### yarn解决的问题\n\n1. 确定性：通过 yarn.lock 等机制，保证了确定性。即不管安装顺序如何，相同的依赖关系在任何机器和环境下，都可以以相同的方式被安装（最新npm也有实现，package-lock.json 机制）\n2. 采用模块扁平安装模式：将依赖包的不同版本，按照一定策略，归结为单个版本，以避免创建多个副本造成冗余（最新npm也有实现）\n3. 网络性能更好：Yarn 采用了请求排队的理念，类似并发连接池，能够更好地利用网络资源；同时引入了更好的安装失败时的重试机制\n4. 采用缓存机制，实现了离线模式（最新npm也有实现）\n\n#### 与npm区别\n\n1. yarn.lock 并没有使用 JSON 格式，而是采用了一种自定义的标记格式\n2. 相比 npm，Yarn 显著区别是 yarn.lock 中子依赖的版本号不是固定版本，单独一个 yarn.lock 确定不了 node_modules 目录结构，还需要和 package.json 文件进行配合\n\n#### synp\n\n- 可以将 yarn.lock 、 package-lock.json 互相转换\n\n#### yarn缓存\n\n- yarn cache dir // 缓存目录\n- yarn cache list // 列出缓存的包\n- yarn cache list --pattern <pattern>  // 列出匹配指定模式的已缓存的包\n\n#### yarn安装机制\n\n- 检测（checking）→ 解析包（Resolving Packages） → 获取包（Fetching Packages）→ 链接包（Linking Packages）→ 构建包（Building Packages）\n1. 检测包：检测项目中是否存在一些 npm 相关文件，提示用户，也会检查系统 OS、CPU 等信息\n2. 解析包：解析依赖树中每一个包的版本信息\n （1）获取当前项目中 package.json 定义的 dependencies、devDependencies、optionalDependencies 的内容（首层依赖）\n （2）采用遍历首层依赖的方式获取依赖包的版本信息，以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过和正在解析的包用一个 Set 数据结构来存储，这样就能保证同一个版本范围内的包不会被重复解析\n \t获取首层依赖->解析依赖->已解析情况：放到对垒中->未解析情况：是否在yarn.lock中标记->存在：获取精确版本信息->不存在：向register请求符合条件版本->确定依赖具体版本以及下载地址\n3. 获取包：首先需要检查缓存中是否存在当前的依赖包，同时将缓存中不存在的依赖包下载到缓存目录，Yarn 会根据 cacheFolder+slug+node_modules+pkg.name 生成一个 path，判断系统中是否存在该 path，如果存在证明已经有缓存，不用重新下载。这个 path 也就是依赖包缓存的具体路径\n4. 链接包：将项目中的依赖复制到项目 node_modules 下，同时遵循扁平化原则。在复制依赖前，Yarn 会先解析 peerDependencies，如果找不到符合 peerDependencies 的包，则进行 warning 提示，并最终拷贝依赖到项目中\n5. 构建包：编译依赖包中存在的二进制包\n\n#### 依赖包管理困境\n\n- 早期npm中，在安装依赖时将依赖放到项目的 node_modules 文件中；同时如果某个直接依赖 A 还依赖其他模块 B，作为间接依赖，模块 B 将会被下载到 A 的 node_modules 文件夹中，依此递归执行，最终形成了一颗巨大的依赖模块树，会形成“嵌套地狱”\n- 存在问题：安装结果浪费了较大的空间资源、安装过程慢、层级太深文件路径过长，在weindows中出现node_modules删除失败问题\n- 解决方式：采用扁平化安装解决\n\n#### 镜像源\n\n- yarn config get registry\n- yarn config set registry https://registry.npm.taobao.org/\n\n#### 查看全局安装包\n\n- yarn global list --depth=0\n\n#### 命令\n\n1. yarn install\n\n```\n// 在本地 node_modules 目录安装 package.json 里列出的所有依赖\nyarn install\n\n// 重新拉取所有包，即使之前已经安装的（所以以后别在删除node-modules了...）\nyarn install --force\n\n// 为 node_modules 目录指定另一位置，代替默认的 ./node_modules\nyarn install --modules-folder <path>\n\n// 不读取或生成 yarn.lock 文件\nyarn install --no-lockfile\n\n// 只安装 dependence下的包，不安装 devDependencies 的包\nyarn install --production[=true|false] / --production / --prod\n```\n\n2. yarn add\n\n```\n// 会安装 latest 最新版本\nyarn add package-name\n\n// 安装包到dependencies中\nyarn add <package...>\n\n// 用 --dev 或 -D 安装包到 devDependencies\nyarn add <package...> [--dev/-D]\n\n// 用 --peer 或者 -P 安装包到 peerDependencies\nyarn add <package...> [--peer/-P]\n\n// 用 --optional 或者 -O 安装包到 optionalDependencies \nyarn add <package...> [--optional/-O]\n\n// 用 --exact 或者 -E 会安装包的精确版本。默认是安装包的主要版本里的最新版本。 比如说， yarn add foo@1.2.3 会接受 1.9.1 版，但是 yarn add foo@1.2.3 --exact 只会接受 1.2.3 版\nyarn add <package...> [--exact/-E]\n\n// 用 --tilde 或者 -T 来安装包的次要版本里的最新版。 默认是安装包的主要版本里的最新版本。 比如说，yarn add foo@1.2.3 --tilde 会接受 1.2.9，但不接受 1.3.0\nyarn add <package...> [--tilde/-T]\n```\n\n3. yarn config\n\n```\n// 查看配置key的值\nyarn config get <key>\n\n// 查看当前的配置\nyarn config list\n\n// 从配置中删除配置key\nyarn config delete <key>\n\n// 设置配置项 key 的值为 value\nyarn config set <key> <value> [-g|--global]\n```\n\n4. 其他\n\n```\n// 查询当前工作文件夹所有的依赖\nyarn list\n\n// 查看包信息，可以查看特定\nyarn info <package> [<field>]\n\n// 从依赖里移除名包，同时更新你 package.json 和 yarn.lock 文件\nyarn remove <package...>\n\n// 执行用户自定义的脚本\nyarn <script> [<args>]\n```","source":"_posts/[工程化]yarn使用.md","raw":"---\ntitle: <工程化>yarn使用\ndate: 2020-07-20 00:00:00\ntags: [yarn,工程化]\ncategories: yarn\n---\n\n#### yarn解决的问题\n\n1. 确定性：通过 yarn.lock 等机制，保证了确定性。即不管安装顺序如何，相同的依赖关系在任何机器和环境下，都可以以相同的方式被安装（最新npm也有实现，package-lock.json 机制）\n2. 采用模块扁平安装模式：将依赖包的不同版本，按照一定策略，归结为单个版本，以避免创建多个副本造成冗余（最新npm也有实现）\n3. 网络性能更好：Yarn 采用了请求排队的理念，类似并发连接池，能够更好地利用网络资源；同时引入了更好的安装失败时的重试机制\n4. 采用缓存机制，实现了离线模式（最新npm也有实现）\n\n#### 与npm区别\n\n1. yarn.lock 并没有使用 JSON 格式，而是采用了一种自定义的标记格式\n2. 相比 npm，Yarn 显著区别是 yarn.lock 中子依赖的版本号不是固定版本，单独一个 yarn.lock 确定不了 node_modules 目录结构，还需要和 package.json 文件进行配合\n\n#### synp\n\n- 可以将 yarn.lock 、 package-lock.json 互相转换\n\n#### yarn缓存\n\n- yarn cache dir // 缓存目录\n- yarn cache list // 列出缓存的包\n- yarn cache list --pattern <pattern>  // 列出匹配指定模式的已缓存的包\n\n#### yarn安装机制\n\n- 检测（checking）→ 解析包（Resolving Packages） → 获取包（Fetching Packages）→ 链接包（Linking Packages）→ 构建包（Building Packages）\n1. 检测包：检测项目中是否存在一些 npm 相关文件，提示用户，也会检查系统 OS、CPU 等信息\n2. 解析包：解析依赖树中每一个包的版本信息\n （1）获取当前项目中 package.json 定义的 dependencies、devDependencies、optionalDependencies 的内容（首层依赖）\n （2）采用遍历首层依赖的方式获取依赖包的版本信息，以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过和正在解析的包用一个 Set 数据结构来存储，这样就能保证同一个版本范围内的包不会被重复解析\n \t获取首层依赖->解析依赖->已解析情况：放到对垒中->未解析情况：是否在yarn.lock中标记->存在：获取精确版本信息->不存在：向register请求符合条件版本->确定依赖具体版本以及下载地址\n3. 获取包：首先需要检查缓存中是否存在当前的依赖包，同时将缓存中不存在的依赖包下载到缓存目录，Yarn 会根据 cacheFolder+slug+node_modules+pkg.name 生成一个 path，判断系统中是否存在该 path，如果存在证明已经有缓存，不用重新下载。这个 path 也就是依赖包缓存的具体路径\n4. 链接包：将项目中的依赖复制到项目 node_modules 下，同时遵循扁平化原则。在复制依赖前，Yarn 会先解析 peerDependencies，如果找不到符合 peerDependencies 的包，则进行 warning 提示，并最终拷贝依赖到项目中\n5. 构建包：编译依赖包中存在的二进制包\n\n#### 依赖包管理困境\n\n- 早期npm中，在安装依赖时将依赖放到项目的 node_modules 文件中；同时如果某个直接依赖 A 还依赖其他模块 B，作为间接依赖，模块 B 将会被下载到 A 的 node_modules 文件夹中，依此递归执行，最终形成了一颗巨大的依赖模块树，会形成“嵌套地狱”\n- 存在问题：安装结果浪费了较大的空间资源、安装过程慢、层级太深文件路径过长，在weindows中出现node_modules删除失败问题\n- 解决方式：采用扁平化安装解决\n\n#### 镜像源\n\n- yarn config get registry\n- yarn config set registry https://registry.npm.taobao.org/\n\n#### 查看全局安装包\n\n- yarn global list --depth=0\n\n#### 命令\n\n1. yarn install\n\n```\n// 在本地 node_modules 目录安装 package.json 里列出的所有依赖\nyarn install\n\n// 重新拉取所有包，即使之前已经安装的（所以以后别在删除node-modules了...）\nyarn install --force\n\n// 为 node_modules 目录指定另一位置，代替默认的 ./node_modules\nyarn install --modules-folder <path>\n\n// 不读取或生成 yarn.lock 文件\nyarn install --no-lockfile\n\n// 只安装 dependence下的包，不安装 devDependencies 的包\nyarn install --production[=true|false] / --production / --prod\n```\n\n2. yarn add\n\n```\n// 会安装 latest 最新版本\nyarn add package-name\n\n// 安装包到dependencies中\nyarn add <package...>\n\n// 用 --dev 或 -D 安装包到 devDependencies\nyarn add <package...> [--dev/-D]\n\n// 用 --peer 或者 -P 安装包到 peerDependencies\nyarn add <package...> [--peer/-P]\n\n// 用 --optional 或者 -O 安装包到 optionalDependencies \nyarn add <package...> [--optional/-O]\n\n// 用 --exact 或者 -E 会安装包的精确版本。默认是安装包的主要版本里的最新版本。 比如说， yarn add foo@1.2.3 会接受 1.9.1 版，但是 yarn add foo@1.2.3 --exact 只会接受 1.2.3 版\nyarn add <package...> [--exact/-E]\n\n// 用 --tilde 或者 -T 来安装包的次要版本里的最新版。 默认是安装包的主要版本里的最新版本。 比如说，yarn add foo@1.2.3 --tilde 会接受 1.2.9，但不接受 1.3.0\nyarn add <package...> [--tilde/-T]\n```\n\n3. yarn config\n\n```\n// 查看配置key的值\nyarn config get <key>\n\n// 查看当前的配置\nyarn config list\n\n// 从配置中删除配置key\nyarn config delete <key>\n\n// 设置配置项 key 的值为 value\nyarn config set <key> <value> [-g|--global]\n```\n\n4. 其他\n\n```\n// 查询当前工作文件夹所有的依赖\nyarn list\n\n// 查看包信息，可以查看特定\nyarn info <package> [<field>]\n\n// 从依赖里移除名包，同时更新你 package.json 和 yarn.lock 文件\nyarn remove <package...>\n\n// 执行用户自定义的脚本\nyarn <script> [<args>]\n```","slug":"[工程化]yarn使用","published":1,"updated":"2021-03-15T14:34:49.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dlb0041wotj4b07229d","content":"<h4 id=\"yarn解决的问题\"><a href=\"#yarn解决的问题\" class=\"headerlink\" title=\"yarn解决的问题\"></a>yarn解决的问题</h4><ol>\n<li>确定性：通过 yarn.lock 等机制，保证了确定性。即不管安装顺序如何，相同的依赖关系在任何机器和环境下，都可以以相同的方式被安装（最新npm也有实现，package-lock.json 机制）</li>\n<li>采用模块扁平安装模式：将依赖包的不同版本，按照一定策略，归结为单个版本，以避免创建多个副本造成冗余（最新npm也有实现）</li>\n<li>网络性能更好：Yarn 采用了请求排队的理念，类似并发连接池，能够更好地利用网络资源；同时引入了更好的安装失败时的重试机制</li>\n<li>采用缓存机制，实现了离线模式（最新npm也有实现）</li>\n</ol>\n<h4 id=\"与npm区别\"><a href=\"#与npm区别\" class=\"headerlink\" title=\"与npm区别\"></a>与npm区别</h4><ol>\n<li>yarn.lock 并没有使用 JSON 格式，而是采用了一种自定义的标记格式</li>\n<li>相比 npm，Yarn 显著区别是 yarn.lock 中子依赖的版本号不是固定版本，单独一个 yarn.lock 确定不了 node_modules 目录结构，还需要和 package.json 文件进行配合</li>\n</ol>\n<h4 id=\"synp\"><a href=\"#synp\" class=\"headerlink\" title=\"synp\"></a>synp</h4><ul>\n<li>可以将 yarn.lock 、 package-lock.json 互相转换</li>\n</ul>\n<h4 id=\"yarn缓存\"><a href=\"#yarn缓存\" class=\"headerlink\" title=\"yarn缓存\"></a>yarn缓存</h4><ul>\n<li>yarn cache dir // 缓存目录</li>\n<li>yarn cache list // 列出缓存的包</li>\n<li>yarn cache list –pattern <pattern>  // 列出匹配指定模式的已缓存的包</li>\n</ul>\n<h4 id=\"yarn安装机制\"><a href=\"#yarn安装机制\" class=\"headerlink\" title=\"yarn安装机制\"></a>yarn安装机制</h4><ul>\n<li>检测（checking）→ 解析包（Resolving Packages） → 获取包（Fetching Packages）→ 链接包（Linking Packages）→ 构建包（Building Packages）</li>\n</ul>\n<ol>\n<li>检测包：检测项目中是否存在一些 npm 相关文件，提示用户，也会检查系统 OS、CPU 等信息</li>\n<li>解析包：解析依赖树中每一个包的版本信息<br>（1）获取当前项目中 package.json 定义的 dependencies、devDependencies、optionalDependencies 的内容（首层依赖）<br>（2）采用遍历首层依赖的方式获取依赖包的版本信息，以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过和正在解析的包用一个 Set 数据结构来存储，这样就能保证同一个版本范围内的包不会被重复解析<br>  获取首层依赖-&gt;解析依赖-&gt;已解析情况：放到对垒中-&gt;未解析情况：是否在yarn.lock中标记-&gt;存在：获取精确版本信息-&gt;不存在：向register请求符合条件版本-&gt;确定依赖具体版本以及下载地址</li>\n<li>获取包：首先需要检查缓存中是否存在当前的依赖包，同时将缓存中不存在的依赖包下载到缓存目录，Yarn 会根据 cacheFolder+slug+node_modules+pkg.name 生成一个 path，判断系统中是否存在该 path，如果存在证明已经有缓存，不用重新下载。这个 path 也就是依赖包缓存的具体路径</li>\n<li>链接包：将项目中的依赖复制到项目 node_modules 下，同时遵循扁平化原则。在复制依赖前，Yarn 会先解析 peerDependencies，如果找不到符合 peerDependencies 的包，则进行 warning 提示，并最终拷贝依赖到项目中</li>\n<li>构建包：编译依赖包中存在的二进制包</li>\n</ol>\n<h4 id=\"依赖包管理困境\"><a href=\"#依赖包管理困境\" class=\"headerlink\" title=\"依赖包管理困境\"></a>依赖包管理困境</h4><ul>\n<li>早期npm中，在安装依赖时将依赖放到项目的 node_modules 文件中；同时如果某个直接依赖 A 还依赖其他模块 B，作为间接依赖，模块 B 将会被下载到 A 的 node_modules 文件夹中，依此递归执行，最终形成了一颗巨大的依赖模块树，会形成“嵌套地狱”</li>\n<li>存在问题：安装结果浪费了较大的空间资源、安装过程慢、层级太深文件路径过长，在weindows中出现node_modules删除失败问题</li>\n<li>解决方式：采用扁平化安装解决</li>\n</ul>\n<h4 id=\"镜像源\"><a href=\"#镜像源\" class=\"headerlink\" title=\"镜像源\"></a>镜像源</h4><ul>\n<li>yarn config get registry</li>\n<li>yarn config set registry <a href=\"https://registry.npm.taobao.org/\">https://registry.npm.taobao.org/</a></li>\n</ul>\n<h4 id=\"查看全局安装包\"><a href=\"#查看全局安装包\" class=\"headerlink\" title=\"查看全局安装包\"></a>查看全局安装包</h4><ul>\n<li>yarn global list –depth=0</li>\n</ul>\n<h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>yarn install</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 在本地 node_modules 目录安装 package.json 里列出的所有依赖</span><br><span class=\"line\">yarn install</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 重新拉取所有包，即使之前已经安装的（所以以后别在删除node-modules了...）</span><br><span class=\"line\">yarn install --force</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 为 node_modules 目录指定另一位置，代替默认的 .&#x2F;node_modules</span><br><span class=\"line\">yarn install --modules-folder &lt;path&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 不读取或生成 yarn.lock 文件</span><br><span class=\"line\">yarn install --no-lockfile</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 只安装 dependence下的包，不安装 devDependencies 的包</span><br><span class=\"line\">yarn install --production[&#x3D;true|false] &#x2F; --production &#x2F; --prod</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>yarn add</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 会安装 latest 最新版本</span><br><span class=\"line\">yarn add package-name</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 安装包到dependencies中</span><br><span class=\"line\">yarn add &lt;package...&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 用 --dev 或 -D 安装包到 devDependencies</span><br><span class=\"line\">yarn add &lt;package...&gt; [--dev&#x2F;-D]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 用 --peer 或者 -P 安装包到 peerDependencies</span><br><span class=\"line\">yarn add &lt;package...&gt; [--peer&#x2F;-P]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 用 --optional 或者 -O 安装包到 optionalDependencies </span><br><span class=\"line\">yarn add &lt;package...&gt; [--optional&#x2F;-O]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 用 --exact 或者 -E 会安装包的精确版本。默认是安装包的主要版本里的最新版本。 比如说， yarn add foo@1.2.3 会接受 1.9.1 版，但是 yarn add foo@1.2.3 --exact 只会接受 1.2.3 版</span><br><span class=\"line\">yarn add &lt;package...&gt; [--exact&#x2F;-E]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 用 --tilde 或者 -T 来安装包的次要版本里的最新版。 默认是安装包的主要版本里的最新版本。 比如说，yarn add foo@1.2.3 --tilde 会接受 1.2.9，但不接受 1.3.0</span><br><span class=\"line\">yarn add &lt;package...&gt; [--tilde&#x2F;-T]</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>yarn config</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 查看配置key的值</span><br><span class=\"line\">yarn config get &lt;key&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 查看当前的配置</span><br><span class=\"line\">yarn config list</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 从配置中删除配置key</span><br><span class=\"line\">yarn config delete &lt;key&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 设置配置项 key 的值为 value</span><br><span class=\"line\">yarn config set &lt;key&gt; &lt;value&gt; [-g|--global]</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>其他</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 查询当前工作文件夹所有的依赖</span><br><span class=\"line\">yarn list</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 查看包信息，可以查看特定</span><br><span class=\"line\">yarn info &lt;package&gt; [&lt;field&gt;]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 从依赖里移除名包，同时更新你 package.json 和 yarn.lock 文件</span><br><span class=\"line\">yarn remove &lt;package...&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 执行用户自定义的脚本</span><br><span class=\"line\">yarn &lt;script&gt; [&lt;args&gt;]</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h4 id=\"yarn解决的问题\"><a href=\"#yarn解决的问题\" class=\"headerlink\" title=\"yarn解决的问题\"></a>yarn解决的问题</h4><ol>\n<li>确定性：通过 yarn.lock 等机制，保证了确定性。即不管安装顺序如何，相同的依赖关系在任何机器和环境下，都可以以相同的方式被安装（最新npm也有实现，package-lock.json 机制）</li>\n<li>采用模块扁平安装模式：将依赖包的不同版本，按照一定策略，归结为单个版本，以避免创建多个副本造成冗余（最新npm也有实现）</li>\n<li>网络性能更好：Yarn 采用了请求排队的理念，类似并发连接池，能够更好地利用网络资源；同时引入了更好的安装失败时的重试机制</li>\n<li>采用缓存机制，实现了离线模式（最新npm也有实现）</li>\n</ol>\n<h4 id=\"与npm区别\"><a href=\"#与npm区别\" class=\"headerlink\" title=\"与npm区别\"></a>与npm区别</h4><ol>\n<li>yarn.lock 并没有使用 JSON 格式，而是采用了一种自定义的标记格式</li>\n<li>相比 npm，Yarn 显著区别是 yarn.lock 中子依赖的版本号不是固定版本，单独一个 yarn.lock 确定不了 node_modules 目录结构，还需要和 package.json 文件进行配合</li>\n</ol>\n<h4 id=\"synp\"><a href=\"#synp\" class=\"headerlink\" title=\"synp\"></a>synp</h4><ul>\n<li>可以将 yarn.lock 、 package-lock.json 互相转换</li>\n</ul>\n<h4 id=\"yarn缓存\"><a href=\"#yarn缓存\" class=\"headerlink\" title=\"yarn缓存\"></a>yarn缓存</h4><ul>\n<li>yarn cache dir // 缓存目录</li>\n<li>yarn cache list // 列出缓存的包</li>\n<li>yarn cache list –pattern <pattern>  // 列出匹配指定模式的已缓存的包</li>\n</ul>\n<h4 id=\"yarn安装机制\"><a href=\"#yarn安装机制\" class=\"headerlink\" title=\"yarn安装机制\"></a>yarn安装机制</h4><ul>\n<li>检测（checking）→ 解析包（Resolving Packages） → 获取包（Fetching Packages）→ 链接包（Linking Packages）→ 构建包（Building Packages）</li>\n</ul>\n<ol>\n<li>检测包：检测项目中是否存在一些 npm 相关文件，提示用户，也会检查系统 OS、CPU 等信息</li>\n<li>解析包：解析依赖树中每一个包的版本信息<br>（1）获取当前项目中 package.json 定义的 dependencies、devDependencies、optionalDependencies 的内容（首层依赖）<br>（2）采用遍历首层依赖的方式获取依赖包的版本信息，以及递归查找每个依赖下嵌套依赖的版本信息，并将解析过和正在解析的包用一个 Set 数据结构来存储，这样就能保证同一个版本范围内的包不会被重复解析<br>  获取首层依赖-&gt;解析依赖-&gt;已解析情况：放到对垒中-&gt;未解析情况：是否在yarn.lock中标记-&gt;存在：获取精确版本信息-&gt;不存在：向register请求符合条件版本-&gt;确定依赖具体版本以及下载地址</li>\n<li>获取包：首先需要检查缓存中是否存在当前的依赖包，同时将缓存中不存在的依赖包下载到缓存目录，Yarn 会根据 cacheFolder+slug+node_modules+pkg.name 生成一个 path，判断系统中是否存在该 path，如果存在证明已经有缓存，不用重新下载。这个 path 也就是依赖包缓存的具体路径</li>\n<li>链接包：将项目中的依赖复制到项目 node_modules 下，同时遵循扁平化原则。在复制依赖前，Yarn 会先解析 peerDependencies，如果找不到符合 peerDependencies 的包，则进行 warning 提示，并最终拷贝依赖到项目中</li>\n<li>构建包：编译依赖包中存在的二进制包</li>\n</ol>\n<h4 id=\"依赖包管理困境\"><a href=\"#依赖包管理困境\" class=\"headerlink\" title=\"依赖包管理困境\"></a>依赖包管理困境</h4><ul>\n<li>早期npm中，在安装依赖时将依赖放到项目的 node_modules 文件中；同时如果某个直接依赖 A 还依赖其他模块 B，作为间接依赖，模块 B 将会被下载到 A 的 node_modules 文件夹中，依此递归执行，最终形成了一颗巨大的依赖模块树，会形成“嵌套地狱”</li>\n<li>存在问题：安装结果浪费了较大的空间资源、安装过程慢、层级太深文件路径过长，在weindows中出现node_modules删除失败问题</li>\n<li>解决方式：采用扁平化安装解决</li>\n</ul>\n<h4 id=\"镜像源\"><a href=\"#镜像源\" class=\"headerlink\" title=\"镜像源\"></a>镜像源</h4><ul>\n<li>yarn config get registry</li>\n<li>yarn config set registry <a href=\"https://registry.npm.taobao.org/\">https://registry.npm.taobao.org/</a></li>\n</ul>\n<h4 id=\"查看全局安装包\"><a href=\"#查看全局安装包\" class=\"headerlink\" title=\"查看全局安装包\"></a>查看全局安装包</h4><ul>\n<li>yarn global list –depth=0</li>\n</ul>\n<h4 id=\"命令\"><a href=\"#命令\" class=\"headerlink\" title=\"命令\"></a>命令</h4><ol>\n<li>yarn install</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 在本地 node_modules 目录安装 package.json 里列出的所有依赖</span><br><span class=\"line\">yarn install</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 重新拉取所有包，即使之前已经安装的（所以以后别在删除node-modules了...）</span><br><span class=\"line\">yarn install --force</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 为 node_modules 目录指定另一位置，代替默认的 .&#x2F;node_modules</span><br><span class=\"line\">yarn install --modules-folder &lt;path&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 不读取或生成 yarn.lock 文件</span><br><span class=\"line\">yarn install --no-lockfile</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 只安装 dependence下的包，不安装 devDependencies 的包</span><br><span class=\"line\">yarn install --production[&#x3D;true|false] &#x2F; --production &#x2F; --prod</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>yarn add</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 会安装 latest 最新版本</span><br><span class=\"line\">yarn add package-name</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 安装包到dependencies中</span><br><span class=\"line\">yarn add &lt;package...&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 用 --dev 或 -D 安装包到 devDependencies</span><br><span class=\"line\">yarn add &lt;package...&gt; [--dev&#x2F;-D]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 用 --peer 或者 -P 安装包到 peerDependencies</span><br><span class=\"line\">yarn add &lt;package...&gt; [--peer&#x2F;-P]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 用 --optional 或者 -O 安装包到 optionalDependencies </span><br><span class=\"line\">yarn add &lt;package...&gt; [--optional&#x2F;-O]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 用 --exact 或者 -E 会安装包的精确版本。默认是安装包的主要版本里的最新版本。 比如说， yarn add foo@1.2.3 会接受 1.9.1 版，但是 yarn add foo@1.2.3 --exact 只会接受 1.2.3 版</span><br><span class=\"line\">yarn add &lt;package...&gt; [--exact&#x2F;-E]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 用 --tilde 或者 -T 来安装包的次要版本里的最新版。 默认是安装包的主要版本里的最新版本。 比如说，yarn add foo@1.2.3 --tilde 会接受 1.2.9，但不接受 1.3.0</span><br><span class=\"line\">yarn add &lt;package...&gt; [--tilde&#x2F;-T]</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>yarn config</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 查看配置key的值</span><br><span class=\"line\">yarn config get &lt;key&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 查看当前的配置</span><br><span class=\"line\">yarn config list</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 从配置中删除配置key</span><br><span class=\"line\">yarn config delete &lt;key&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 设置配置项 key 的值为 value</span><br><span class=\"line\">yarn config set &lt;key&gt; &lt;value&gt; [-g|--global]</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>其他</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F; 查询当前工作文件夹所有的依赖</span><br><span class=\"line\">yarn list</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 查看包信息，可以查看特定</span><br><span class=\"line\">yarn info &lt;package&gt; [&lt;field&gt;]</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 从依赖里移除名包，同时更新你 package.json 和 yarn.lock 文件</span><br><span class=\"line\">yarn remove &lt;package...&gt;</span><br><span class=\"line\"></span><br><span class=\"line\">&#x2F;&#x2F; 执行用户自定义的脚本</span><br><span class=\"line\">yarn &lt;script&gt; [&lt;args&gt;]</span><br></pre></td></tr></table></figure>"},{"title":"<浏览器>js执行机制","date":"2020-01-19T16:00:00.000Z","_content":"\n## javascript在浏览器中的执行机制\n\n### 变量提升\n\n![变量提升、执行流程](https://wx2.sinaimg.cn/mw690/a4006e99ly1gk5wngg8fdj20on0feaas.jpg)\n\n#### 声明、赋值\n\n```javascript\nvar a;//变量声明\na = 1;//变量赋值\n\nfunction fun1(){}//函数声明\nvar fun2 = ()=>{}//函数赋值\n```\n\n#### 变量提升\n\n- 所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。\n\n#### JavaScript 代码的执行流程\n\n- 实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中。\n- JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。\n\n1. 编译阶段\n\n- 可以将代码分为变量**提升部分**、**执行部分**\n- 输入一段代码，经过编译后，会生成两部分内容：**执行上下文**（Execution context）和**可执行代码**。\n- 执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。\n- 在执行上下文中存在一个变量环境的对象，保存了变量提升的内容。\n- 变量声明：经过 var 声明的，因此 JavaScript 引擎将在环境对象中创建一个的属性，并使用 undefined 对其初始化\n- 函数声明：JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建对应属性，然后将该属性值指向堆中函数的位置\n\n2. 执行阶段\n\n- 当执行到对应属性时，JavaScript 引擎便开始在变量环境对象中查找该属性，执行函数或查找值\n\n3. 注意情况\n\n- 如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。\n- 如果变量和函数同名，那么在编译阶段，变量的声明会被忽略\n\n### 调用栈\n\n![调用栈](https://wx1.sinaimg.cn/mw690/a4006e99ly1gk5x4zrtsaj20hd0i3myp.jpg)\n\n- 调用栈是用来管理函数调用关系的一种数据结构。\n\n#### JavaScript 的调用栈\n\n- js用栈结构管理执行上下文\n\n1. 创建全局上下文，并将其压入栈底\n2. 执行函数时，创建函数一个执行上下文，并压入栈中\n3. 当函数返回时，该函数的执行上下文就会从栈顶弹出\n \n- 可以使用 console.trace() 来输出当前的函数调用关系\n \n#### 栈溢出\n\n- 调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。\n\n### 作用域\n\n- 作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。\n \n#### js中的作用域\n\n- 全局作用域，生命周期伴随着页面的生命周期。\n- 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。\n- 块级作用域，ES6新增，块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。\n\n#### 变量提升问题\n\n- 变量会被覆盖\n\n```javascript\nvar a = 1\nfunction fun(){\n  if(false){\n\tvar a = 2 // 变量提升至函数作用域中\n  }\n  console.log(a)\n}\nfun() // log undefined\n```\n- 变量没有被销毁\n\n```javascript\nfunction fun(){\n  for(var a = 1;a<5;a++){}\n  console.log(a) // log 5\n}\nfun()\n```\n\n#### es6解决变量提升缺陷\n\n- ES6 引入了 let 和 const 关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。\n- 执行上下文的角度解释es6块级作用域\n\n1. 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里。\n2. 通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。\n3. 作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量。\n4. 在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。\n5. 变量查找方法：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。\n6. 当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出\n\n### 作用域链和闭包\n\n![作用域链](https://wx2.sinaimg.cn/mw690/a4006e99ly1gk735v2yv2j212d0mtq5p.jpg)\n\n![闭包](https://wx4.sinaimg.cn/mw690/a4006e99ly1gkcv752lmzj20xy0jn77g.jpg)\n#### 作用域链\n\n- 每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。\n- JavaScript 引擎会去全局执行上下文中查找。我们把这个查找的链条就称为作用域链。\n- 词法作用域：词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。\n- 词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。\n\n#### 闭包\n\n- 在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。\n- 闭包是如何回收\n\n1. 如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。\n2. 如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。\n3. 如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。\n\n- **内存模型解释闭包**：当js引擎发现闭包引用时，会在堆空间中创建闭包对象，用来保存闭包引用的值，执行上下文中创建闭包内部变量，引用闭包对象的地址。\n\n### js中的this\n\n- this 是和执行上下文绑定\n- 全局对象中的 this 是指向 window 对象\n- 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；\n- 当函数作为对象的方法调用时，函数中的 this 就是该对象；\n- 嵌套函数中的 this 不会继承外层函数的 this 值，可以通过声明一个变量保存this，或者箭头函数解决\n- 箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。\n- 可以通过call、bind和apply方法改变this\n- 构造函数的this\n\n1. 首先创建了一个空对象 tempObj；\n2. 接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；\n3. 然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；\n4. 最后返回 tempObj 对象。**strong text**","source":"_posts/[浏览器]js执行机制.md","raw":"---\ntitle: <浏览器>js执行机制\ndate: 2020-01-20 00:00:00\ntags: [js,浏览器]\ncategories: 浏览器\n---\n\n## javascript在浏览器中的执行机制\n\n### 变量提升\n\n![变量提升、执行流程](https://wx2.sinaimg.cn/mw690/a4006e99ly1gk5wngg8fdj20on0feaas.jpg)\n\n#### 声明、赋值\n\n```javascript\nvar a;//变量声明\na = 1;//变量赋值\n\nfunction fun1(){}//函数声明\nvar fun2 = ()=>{}//函数赋值\n```\n\n#### 变量提升\n\n- 所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。\n\n#### JavaScript 代码的执行流程\n\n- 实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中。\n- JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。\n\n1. 编译阶段\n\n- 可以将代码分为变量**提升部分**、**执行部分**\n- 输入一段代码，经过编译后，会生成两部分内容：**执行上下文**（Execution context）和**可执行代码**。\n- 执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。\n- 在执行上下文中存在一个变量环境的对象，保存了变量提升的内容。\n- 变量声明：经过 var 声明的，因此 JavaScript 引擎将在环境对象中创建一个的属性，并使用 undefined 对其初始化\n- 函数声明：JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建对应属性，然后将该属性值指向堆中函数的位置\n\n2. 执行阶段\n\n- 当执行到对应属性时，JavaScript 引擎便开始在变量环境对象中查找该属性，执行函数或查找值\n\n3. 注意情况\n\n- 如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。\n- 如果变量和函数同名，那么在编译阶段，变量的声明会被忽略\n\n### 调用栈\n\n![调用栈](https://wx1.sinaimg.cn/mw690/a4006e99ly1gk5x4zrtsaj20hd0i3myp.jpg)\n\n- 调用栈是用来管理函数调用关系的一种数据结构。\n\n#### JavaScript 的调用栈\n\n- js用栈结构管理执行上下文\n\n1. 创建全局上下文，并将其压入栈底\n2. 执行函数时，创建函数一个执行上下文，并压入栈中\n3. 当函数返回时，该函数的执行上下文就会从栈顶弹出\n \n- 可以使用 console.trace() 来输出当前的函数调用关系\n \n#### 栈溢出\n\n- 调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。\n\n### 作用域\n\n- 作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。\n \n#### js中的作用域\n\n- 全局作用域，生命周期伴随着页面的生命周期。\n- 函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。\n- 块级作用域，ES6新增，块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。\n\n#### 变量提升问题\n\n- 变量会被覆盖\n\n```javascript\nvar a = 1\nfunction fun(){\n  if(false){\n\tvar a = 2 // 变量提升至函数作用域中\n  }\n  console.log(a)\n}\nfun() // log undefined\n```\n- 变量没有被销毁\n\n```javascript\nfunction fun(){\n  for(var a = 1;a<5;a++){}\n  console.log(a) // log 5\n}\nfun()\n```\n\n#### es6解决变量提升缺陷\n\n- ES6 引入了 let 和 const 关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。\n- 执行上下文的角度解释es6块级作用域\n\n1. 函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里。\n2. 通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。\n3. 作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量。\n4. 在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。\n5. 变量查找方法：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。\n6. 当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出\n\n### 作用域链和闭包\n\n![作用域链](https://wx2.sinaimg.cn/mw690/a4006e99ly1gk735v2yv2j212d0mtq5p.jpg)\n\n![闭包](https://wx4.sinaimg.cn/mw690/a4006e99ly1gkcv752lmzj20xy0jn77g.jpg)\n#### 作用域链\n\n- 每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。\n- JavaScript 引擎会去全局执行上下文中查找。我们把这个查找的链条就称为作用域链。\n- 词法作用域：词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。\n- 词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。\n\n#### 闭包\n\n- 在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。\n- 闭包是如何回收\n\n1. 如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。\n2. 如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。\n3. 如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。\n\n- **内存模型解释闭包**：当js引擎发现闭包引用时，会在堆空间中创建闭包对象，用来保存闭包引用的值，执行上下文中创建闭包内部变量，引用闭包对象的地址。\n\n### js中的this\n\n- this 是和执行上下文绑定\n- 全局对象中的 this 是指向 window 对象\n- 当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；\n- 当函数作为对象的方法调用时，函数中的 this 就是该对象；\n- 嵌套函数中的 this 不会继承外层函数的 this 值，可以通过声明一个变量保存this，或者箭头函数解决\n- 箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。\n- 可以通过call、bind和apply方法改变this\n- 构造函数的this\n\n1. 首先创建了一个空对象 tempObj；\n2. 接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；\n3. 然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；\n4. 最后返回 tempObj 对象。**strong text**","slug":"[浏览器]js执行机制","published":1,"updated":"2021-03-15T14:35:02.001Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dld0044wotjao27hfeu","content":"<h2 id=\"javascript在浏览器中的执行机制\"><a href=\"#javascript在浏览器中的执行机制\" class=\"headerlink\" title=\"javascript在浏览器中的执行机制\"></a>javascript在浏览器中的执行机制</h2><h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><p><img src=\"https://wx2.sinaimg.cn/mw690/a4006e99ly1gk5wngg8fdj20on0feaas.jpg\" alt=\"变量提升、执行流程\"></p>\n<h4 id=\"声明、赋值\"><a href=\"#声明、赋值\" class=\"headerlink\" title=\"声明、赋值\"></a>声明、赋值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;<span class=\"comment\">//变量声明</span></span><br><span class=\"line\">a = <span class=\"number\">1</span>;<span class=\"comment\">//变量赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun1</span>(<span class=\"params\"></span>)</span>&#123;&#125;<span class=\"comment\">//函数声明</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fun2 = <span class=\"function\">()=&gt;</span>&#123;&#125;<span class=\"comment\">//函数赋值</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"变量提升-1\"><a href=\"#变量提升-1\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h4><ul>\n<li>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。</li>\n</ul>\n<h4 id=\"JavaScript-代码的执行流程\"><a href=\"#JavaScript-代码的执行流程\" class=\"headerlink\" title=\"JavaScript 代码的执行流程\"></a>JavaScript 代码的执行流程</h4><ul>\n<li>实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中。</li>\n<li>JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。</li>\n</ul>\n<ol>\n<li>编译阶段</li>\n</ol>\n<ul>\n<li>可以将代码分为变量<strong>提升部分</strong>、<strong>执行部分</strong></li>\n<li>输入一段代码，经过编译后，会生成两部分内容：<strong>执行上下文</strong>（Execution context）和<strong>可执行代码</strong>。</li>\n<li>执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。</li>\n<li>在执行上下文中存在一个变量环境的对象，保存了变量提升的内容。</li>\n<li>变量声明：经过 var 声明的，因此 JavaScript 引擎将在环境对象中创建一个的属性，并使用 undefined 对其初始化</li>\n<li>函数声明：JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建对应属性，然后将该属性值指向堆中函数的位置</li>\n</ul>\n<ol start=\"2\">\n<li>执行阶段</li>\n</ol>\n<ul>\n<li>当执行到对应属性时，JavaScript 引擎便开始在变量环境对象中查找该属性，执行函数或查找值</li>\n</ul>\n<ol start=\"3\">\n<li>注意情况</li>\n</ol>\n<ul>\n<li>如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。</li>\n<li>如果变量和函数同名，那么在编译阶段，变量的声明会被忽略</li>\n</ul>\n<h3 id=\"调用栈\"><a href=\"#调用栈\" class=\"headerlink\" title=\"调用栈\"></a>调用栈</h3><p><img src=\"https://wx1.sinaimg.cn/mw690/a4006e99ly1gk5x4zrtsaj20hd0i3myp.jpg\" alt=\"调用栈\"></p>\n<ul>\n<li>调用栈是用来管理函数调用关系的一种数据结构。</li>\n</ul>\n<h4 id=\"JavaScript-的调用栈\"><a href=\"#JavaScript-的调用栈\" class=\"headerlink\" title=\"JavaScript 的调用栈\"></a>JavaScript 的调用栈</h4><ul>\n<li>js用栈结构管理执行上下文</li>\n</ul>\n<ol>\n<li>创建全局上下文，并将其压入栈底</li>\n<li>执行函数时，创建函数一个执行上下文，并压入栈中</li>\n<li>当函数返回时，该函数的执行上下文就会从栈顶弹出</li>\n</ol>\n<ul>\n<li>可以使用 console.trace() 来输出当前的函数调用关系</li>\n</ul>\n<h4 id=\"栈溢出\"><a href=\"#栈溢出\" class=\"headerlink\" title=\"栈溢出\"></a>栈溢出</h4><ul>\n<li>调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。</li>\n</ul>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><ul>\n<li>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</li>\n</ul>\n<h4 id=\"js中的作用域\"><a href=\"#js中的作用域\" class=\"headerlink\" title=\"js中的作用域\"></a>js中的作用域</h4><ul>\n<li>全局作用域，生命周期伴随着页面的生命周期。</li>\n<li>函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。</li>\n<li>块级作用域，ES6新增，块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。</li>\n</ul>\n<h4 id=\"变量提升问题\"><a href=\"#变量提升问题\" class=\"headerlink\" title=\"变量提升问题\"></a>变量提升问题</h4><ul>\n<li>变量会被覆盖</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"literal\">false</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">2</span> <span class=\"comment\">// 变量提升至函数作用域中</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun() <span class=\"comment\">// log undefined</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>变量没有被销毁</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;a&lt;<span class=\"number\">5</span>;a++)&#123;&#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// log 5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"es6解决变量提升缺陷\"><a href=\"#es6解决变量提升缺陷\" class=\"headerlink\" title=\"es6解决变量提升缺陷\"></a>es6解决变量提升缺陷</h4><ul>\n<li>ES6 引入了 let 和 const 关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。</li>\n<li>执行上下文的角度解释es6块级作用域</li>\n</ul>\n<ol>\n<li>函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里。</li>\n<li>通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。</li>\n<li>作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量。</li>\n<li>在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。</li>\n<li>变量查找方法：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。</li>\n<li>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出</li>\n</ol>\n<h3 id=\"作用域链和闭包\"><a href=\"#作用域链和闭包\" class=\"headerlink\" title=\"作用域链和闭包\"></a>作用域链和闭包</h3><p><img src=\"https://wx2.sinaimg.cn/mw690/a4006e99ly1gk735v2yv2j212d0mtq5p.jpg\" alt=\"作用域链\"></p>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/a4006e99ly1gkcv752lmzj20xy0jn77g.jpg\" alt=\"闭包\"></p>\n<h4 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h4><ul>\n<li>每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。</li>\n<li>JavaScript 引擎会去全局执行上下文中查找。我们把这个查找的链条就称为作用域链。</li>\n<li>词法作用域：词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</li>\n<li>词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。</li>\n</ul>\n<h4 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><ul>\n<li>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。</li>\n<li>闭包是如何回收</li>\n</ul>\n<ol>\n<li>如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。</li>\n<li>如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。</li>\n<li>如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</li>\n</ol>\n<ul>\n<li><strong>内存模型解释闭包</strong>：当js引擎发现闭包引用时，会在堆空间中创建闭包对象，用来保存闭包引用的值，执行上下文中创建闭包内部变量，引用闭包对象的地址。</li>\n</ul>\n<h3 id=\"js中的this\"><a href=\"#js中的this\" class=\"headerlink\" title=\"js中的this\"></a>js中的this</h3><ul>\n<li>this 是和执行上下文绑定</li>\n<li>全局对象中的 this 是指向 window 对象</li>\n<li>当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；</li>\n<li>当函数作为对象的方法调用时，函数中的 this 就是该对象；</li>\n<li>嵌套函数中的 this 不会继承外层函数的 this 值，可以通过声明一个变量保存this，或者箭头函数解决</li>\n<li>箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。</li>\n<li>可以通过call、bind和apply方法改变this</li>\n<li>构造函数的this</li>\n</ul>\n<ol>\n<li>首先创建了一个空对象 tempObj；</li>\n<li>接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；</li>\n<li>然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；</li>\n<li>最后返回 tempObj 对象。<strong>strong text</strong></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"javascript在浏览器中的执行机制\"><a href=\"#javascript在浏览器中的执行机制\" class=\"headerlink\" title=\"javascript在浏览器中的执行机制\"></a>javascript在浏览器中的执行机制</h2><h3 id=\"变量提升\"><a href=\"#变量提升\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h3><p><img src=\"https://wx2.sinaimg.cn/mw690/a4006e99ly1gk5wngg8fdj20on0feaas.jpg\" alt=\"变量提升、执行流程\"></p>\n<h4 id=\"声明、赋值\"><a href=\"#声明、赋值\" class=\"headerlink\" title=\"声明、赋值\"></a>声明、赋值</h4><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a;<span class=\"comment\">//变量声明</span></span><br><span class=\"line\">a = <span class=\"number\">1</span>;<span class=\"comment\">//变量赋值</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun1</span>(<span class=\"params\"></span>)</span>&#123;&#125;<span class=\"comment\">//函数声明</span></span><br><span class=\"line\"><span class=\"keyword\">var</span> fun2 = <span class=\"function\">()=&gt;</span>&#123;&#125;<span class=\"comment\">//函数赋值</span></span><br></pre></td></tr></table></figure>\n\n<h4 id=\"变量提升-1\"><a href=\"#变量提升-1\" class=\"headerlink\" title=\"变量提升\"></a>变量提升</h4><ul>\n<li>所谓的变量提升，是指在 JavaScript 代码执行过程中，JavaScript 引擎把变量的声明部分和函数的声明部分提升到代码开头的“行为”。变量被提升后，会给变量设置默认值，这个默认值就是我们熟悉的 undefined。</li>\n</ul>\n<h4 id=\"JavaScript-代码的执行流程\"><a href=\"#JavaScript-代码的执行流程\" class=\"headerlink\" title=\"JavaScript 代码的执行流程\"></a>JavaScript 代码的执行流程</h4><ul>\n<li>实际上变量和函数声明在代码里的位置是不会改变的，而且是在编译阶段被 JavaScript 引擎放入内存中。</li>\n<li>JavaScript 代码在执行之前需要被 JavaScript 引擎编译，编译完成之后，才会进入执行阶段。</li>\n</ul>\n<ol>\n<li>编译阶段</li>\n</ol>\n<ul>\n<li>可以将代码分为变量<strong>提升部分</strong>、<strong>执行部分</strong></li>\n<li>输入一段代码，经过编译后，会生成两部分内容：<strong>执行上下文</strong>（Execution context）和<strong>可执行代码</strong>。</li>\n<li>执行上下文是 JavaScript 执行一段代码时的运行环境，比如调用一个函数，就会进入这个函数的执行上下文，确定该函数在执行期间用到的诸如 this、变量、对象以及函数等。</li>\n<li>在执行上下文中存在一个变量环境的对象，保存了变量提升的内容。</li>\n<li>变量声明：经过 var 声明的，因此 JavaScript 引擎将在环境对象中创建一个的属性，并使用 undefined 对其初始化</li>\n<li>函数声明：JavaScript 引擎发现了一个通过 function 定义的函数，所以它将函数定义存储到堆 (HEAP）中，并在环境对象中创建对应属性，然后将该属性值指向堆中函数的位置</li>\n</ul>\n<ol start=\"2\">\n<li>执行阶段</li>\n</ol>\n<ul>\n<li>当执行到对应属性时，JavaScript 引擎便开始在变量环境对象中查找该属性，执行函数或查找值</li>\n</ul>\n<ol start=\"3\">\n<li>注意情况</li>\n</ol>\n<ul>\n<li>如果是同名的函数，JavaScript编译阶段会选择最后声明的那个。</li>\n<li>如果变量和函数同名，那么在编译阶段，变量的声明会被忽略</li>\n</ul>\n<h3 id=\"调用栈\"><a href=\"#调用栈\" class=\"headerlink\" title=\"调用栈\"></a>调用栈</h3><p><img src=\"https://wx1.sinaimg.cn/mw690/a4006e99ly1gk5x4zrtsaj20hd0i3myp.jpg\" alt=\"调用栈\"></p>\n<ul>\n<li>调用栈是用来管理函数调用关系的一种数据结构。</li>\n</ul>\n<h4 id=\"JavaScript-的调用栈\"><a href=\"#JavaScript-的调用栈\" class=\"headerlink\" title=\"JavaScript 的调用栈\"></a>JavaScript 的调用栈</h4><ul>\n<li>js用栈结构管理执行上下文</li>\n</ul>\n<ol>\n<li>创建全局上下文，并将其压入栈底</li>\n<li>执行函数时，创建函数一个执行上下文，并压入栈中</li>\n<li>当函数返回时，该函数的执行上下文就会从栈顶弹出</li>\n</ol>\n<ul>\n<li>可以使用 console.trace() 来输出当前的函数调用关系</li>\n</ul>\n<h4 id=\"栈溢出\"><a href=\"#栈溢出\" class=\"headerlink\" title=\"栈溢出\"></a>栈溢出</h4><ul>\n<li>调用栈是有大小的，当入栈的执行上下文超过一定数目，JavaScript 引擎就会报错，我们把这种错误叫做栈溢出。</li>\n</ul>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><ul>\n<li>作用域是指在程序中定义变量的区域，该位置决定了变量的生命周期。通俗地理解，作用域就是变量与函数的可访问范围，即作用域控制着变量和函数的可见性和生命周期。</li>\n</ul>\n<h4 id=\"js中的作用域\"><a href=\"#js中的作用域\" class=\"headerlink\" title=\"js中的作用域\"></a>js中的作用域</h4><ul>\n<li>全局作用域，生命周期伴随着页面的生命周期。</li>\n<li>函数作用域就是在函数内部定义的变量或者函数，并且定义的变量或者函数只能在函数内部被访问。函数执行结束之后，函数内部定义的变量会被销毁。</li>\n<li>块级作用域，ES6新增，块级作用域就是使用一对大括号包裹的一段代码，比如函数、判断语句、循环语句，甚至单独的一个{}都可以被看作是一个块级作用域。</li>\n</ul>\n<h4 id=\"变量提升问题\"><a href=\"#变量提升问题\" class=\"headerlink\" title=\"变量提升问题\"></a>变量提升问题</h4><ul>\n<li>变量会被覆盖</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> a = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"literal\">false</span>)&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">var</span> a = <span class=\"number\">2</span> <span class=\"comment\">// 变量提升至函数作用域中</span></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun() <span class=\"comment\">// log undefined</span></span><br></pre></td></tr></table></figure>\n<ul>\n<li>变量没有被销毁</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">fun</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">for</span>(<span class=\"keyword\">var</span> a = <span class=\"number\">1</span>;a&lt;<span class=\"number\">5</span>;a++)&#123;&#125;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(a) <span class=\"comment\">// log 5</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">fun()</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"es6解决变量提升缺陷\"><a href=\"#es6解决变量提升缺陷\" class=\"headerlink\" title=\"es6解决变量提升缺陷\"></a>es6解决变量提升缺陷</h4><ul>\n<li>ES6 引入了 let 和 const 关键字，从而使 JavaScript 也能像其他语言一样拥有了块级作用域。</li>\n<li>执行上下文的角度解释es6块级作用域</li>\n</ul>\n<ol>\n<li>函数内部通过 var 声明的变量，在编译阶段全都被存放到变量环境里。</li>\n<li>通过 let 声明的变量，在编译阶段会被存放到词法环境（Lexical Environment）中。</li>\n<li>作用域块中通过 let 声明的变量，会被存放在词法环境的一个单独的区域中，这个区域中的变量并不影响作用域块外面的变量。</li>\n<li>在词法环境内部，维护了一个小型栈结构，栈底是函数最外层的变量，进入一个作用域块后，就会把该作用域块内部的变量压到栈顶；当作用域执行完成之后，该作用域的信息就会从栈顶弹出，这就是词法环境的结构。</li>\n<li>变量查找方法：沿着词法环境的栈顶向下查询，如果在词法环境中的某个块中查找到了，就直接返回给 JavaScript 引擎，如果没有查找到，那么继续在变量环境中查找。</li>\n<li>当作用域块执行结束之后，其内部定义的变量就会从词法环境的栈顶弹出</li>\n</ol>\n<h3 id=\"作用域链和闭包\"><a href=\"#作用域链和闭包\" class=\"headerlink\" title=\"作用域链和闭包\"></a>作用域链和闭包</h3><p><img src=\"https://wx2.sinaimg.cn/mw690/a4006e99ly1gk735v2yv2j212d0mtq5p.jpg\" alt=\"作用域链\"></p>\n<p><img src=\"https://wx4.sinaimg.cn/mw690/a4006e99ly1gkcv752lmzj20xy0jn77g.jpg\" alt=\"闭包\"></p>\n<h4 id=\"作用域链\"><a href=\"#作用域链\" class=\"headerlink\" title=\"作用域链\"></a>作用域链</h4><ul>\n<li>每个执行上下文的变量环境中，都包含了一个外部引用，用来指向外部的执行上下文，我们把这个外部引用称为outer。</li>\n<li>JavaScript 引擎会去全局执行上下文中查找。我们把这个查找的链条就称为作用域链。</li>\n<li>词法作用域：词法作用域就是指作用域是由代码中函数声明的位置来决定的，所以词法作用域是静态的作用域，通过它就能够预测代码在执行过程中如何查找标识符。</li>\n<li>词法作用域是代码阶段就决定好的，和函数是怎么调用的没有关系。</li>\n</ul>\n<h4 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h4><ul>\n<li>在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。</li>\n<li>闭包是如何回收</li>\n</ul>\n<ol>\n<li>如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。</li>\n<li>如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。</li>\n<li>如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。</li>\n</ol>\n<ul>\n<li><strong>内存模型解释闭包</strong>：当js引擎发现闭包引用时，会在堆空间中创建闭包对象，用来保存闭包引用的值，执行上下文中创建闭包内部变量，引用闭包对象的地址。</li>\n</ul>\n<h3 id=\"js中的this\"><a href=\"#js中的this\" class=\"headerlink\" title=\"js中的this\"></a>js中的this</h3><ul>\n<li>this 是和执行上下文绑定</li>\n<li>全局对象中的 this 是指向 window 对象</li>\n<li>当函数被正常调用时，在严格模式下，this 值是 undefined，非严格模式下 this 指向的是全局对象 window；</li>\n<li>当函数作为对象的方法调用时，函数中的 this 就是该对象；</li>\n<li>嵌套函数中的 this 不会继承外层函数的 this 值，可以通过声明一个变量保存this，或者箭头函数解决</li>\n<li>箭头函数没有自己的执行上下文，所以箭头函数的 this 就是它外层函数的 this。</li>\n<li>可以通过call、bind和apply方法改变this</li>\n<li>构造函数的this</li>\n</ul>\n<ol>\n<li>首先创建了一个空对象 tempObj；</li>\n<li>接着调用 CreateObj.call 方法，并将 tempObj 作为 call 方法的参数，这样当 CreateObj 的执行上下文创建时，它的 this 就指向了 tempObj 对象；</li>\n<li>然后执行 CreateObj 函数，此时的 CreateObj 函数执行上下文中的 this 指向了 tempObj 对象；</li>\n<li>最后返回 tempObj 对象。<strong>strong text</strong></li>\n</ol>\n"},{"title":"<浏览器>url输入执行过程","date":"2020-01-29T16:00:00.000Z","_content":"\n### 输入URL到页面展示过程\n\n#### 输入url\n\n- 判断是搜索还是访问链接，如果是链接，会加上协议，拼成完整链接\n\n#### url请求过程\n\n- 浏览器进程将url发送至网络进程\n- 网络进程查找是否有缓存，如果有缓存资源，那么直接返回资源给浏览器进程。没有缓存进入网络请求流程：DNS 解析，获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，还需要建立 TLS 连接、利用 IP 地址和服务器建立 TCP 连接、向服务器发送构建的请求信息（请求行、请求头、Cookie添加至请求头）、网络进程接收了响应行和响应头开始解析响应头内容。\n \n 1. 重定向：状态码301、302，从响应头的 Location 字段里面读取重定向的地址，再次发送请求，例如：http重定向为https\n 2. 响应数据类型处理：根据Content-Type决定如何显示响应体的内容，例如：text/html->html内容、application/octet-stream->字节流类型，浏览器会按照下载类型处理。\n\n#### 准备渲染进程\n\n- 渲染进程策略：通常情况下，打开新的页面都会使用单独的渲染进程，如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程。\n- 同一站点：相同的协议和根域名。\n\n#### 提交文档给渲染进程\n\n- 浏览器进程将url请求响应体数据提交给渲染进程，等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程，浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。\n\n#### 构建DOM树\n\n- 将 HTML 转换为浏览器能够理解的结构——DOM 树\n\n#### 样式计算\n\n1. 把 CSS 转换为浏览器能够理解的结构\n \n - css来源：link标签、style标签、style属性\n - 将 CSS 文本转换为浏览器可以理解的结构——styleSheets，可以通过document.styleSheets查看\n\n2. 转换样式表中的属性值，使其标准化\n3. 计算出 DOM 树中每个节点的具体样式\n\n- 根据CSS 的继承规则和层叠规则计算每个DOM节点的样式\n \n#### 布局阶段\n\n- 计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。\n\n1. 创建布局树\n\n- 在显示之前，我们还要额外地构建一棵只包含可见元素布局树。\n- 遍历 DOM 树中的所有可见节点，并把这些节点加到布局中，不可见的节点会被布局树忽略掉，如head中的内容。\n\n2. 布局计算\n\n- 计算布局树节点的坐标位置了\n\n#### 分层\n\n- 渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）\n- 拥有[层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)属性的元素会被提升为单独的一、需要剪裁（clip）的地方也会被创建为图层（例如：文字显示超过区域）\n\n#### 图层绘制\n\n- 渲染引擎会将一个图层的绘制拆分成很多小的绘制指令，再把这些指令按照顺序组成一个待绘制列表。\n\n#### 栅格化（raster）操作\n\n- 绘制操作是由渲染引擎中的合成线程来完成。\n- 当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。\n- 合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512。\n- 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。\n- 渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。\n- 栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。GPU 操作是运行在 GPU 进程中，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。\n \n #### 合成和显示\n \n - 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。\n - 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。\n\n### 重排、重绘、合成\n\n1. 更新了元素的几何属性（重排）\n\n- 改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。\n\n2. 更新元素的绘制属性（重绘）\n\n- 如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。\n\n3. 直接合成阶段\n\n- 更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。\n- 使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。相对于重绘和重排，合成能大大提升绘制效率。","source":"_posts/[浏览器]url输入执行过程.md","raw":"---\ntitle: <浏览器>url输入执行过程\ndate: 2020-01-30 00:00:00\ntags: [js,浏览器]\ncategories: 浏览器\n---\n\n### 输入URL到页面展示过程\n\n#### 输入url\n\n- 判断是搜索还是访问链接，如果是链接，会加上协议，拼成完整链接\n\n#### url请求过程\n\n- 浏览器进程将url发送至网络进程\n- 网络进程查找是否有缓存，如果有缓存资源，那么直接返回资源给浏览器进程。没有缓存进入网络请求流程：DNS 解析，获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，还需要建立 TLS 连接、利用 IP 地址和服务器建立 TCP 连接、向服务器发送构建的请求信息（请求行、请求头、Cookie添加至请求头）、网络进程接收了响应行和响应头开始解析响应头内容。\n \n 1. 重定向：状态码301、302，从响应头的 Location 字段里面读取重定向的地址，再次发送请求，例如：http重定向为https\n 2. 响应数据类型处理：根据Content-Type决定如何显示响应体的内容，例如：text/html->html内容、application/octet-stream->字节流类型，浏览器会按照下载类型处理。\n\n#### 准备渲染进程\n\n- 渲染进程策略：通常情况下，打开新的页面都会使用单独的渲染进程，如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程。\n- 同一站点：相同的协议和根域名。\n\n#### 提交文档给渲染进程\n\n- 浏览器进程将url请求响应体数据提交给渲染进程，等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程，浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。\n\n#### 构建DOM树\n\n- 将 HTML 转换为浏览器能够理解的结构——DOM 树\n\n#### 样式计算\n\n1. 把 CSS 转换为浏览器能够理解的结构\n \n - css来源：link标签、style标签、style属性\n - 将 CSS 文本转换为浏览器可以理解的结构——styleSheets，可以通过document.styleSheets查看\n\n2. 转换样式表中的属性值，使其标准化\n3. 计算出 DOM 树中每个节点的具体样式\n\n- 根据CSS 的继承规则和层叠规则计算每个DOM节点的样式\n \n#### 布局阶段\n\n- 计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。\n\n1. 创建布局树\n\n- 在显示之前，我们还要额外地构建一棵只包含可见元素布局树。\n- 遍历 DOM 树中的所有可见节点，并把这些节点加到布局中，不可见的节点会被布局树忽略掉，如head中的内容。\n\n2. 布局计算\n\n- 计算布局树节点的坐标位置了\n\n#### 分层\n\n- 渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）\n- 拥有[层叠上下文](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context)属性的元素会被提升为单独的一、需要剪裁（clip）的地方也会被创建为图层（例如：文字显示超过区域）\n\n#### 图层绘制\n\n- 渲染引擎会将一个图层的绘制拆分成很多小的绘制指令，再把这些指令按照顺序组成一个待绘制列表。\n\n#### 栅格化（raster）操作\n\n- 绘制操作是由渲染引擎中的合成线程来完成。\n- 当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。\n- 合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512。\n- 合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。\n- 渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。\n- 栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。GPU 操作是运行在 GPU 进程中，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。\n \n #### 合成和显示\n \n - 一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。\n - 浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。\n\n### 重排、重绘、合成\n\n1. 更新了元素的几何属性（重排）\n\n- 改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。\n\n2. 更新元素的绘制属性（重绘）\n\n- 如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。\n\n3. 直接合成阶段\n\n- 更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。\n- 使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。相对于重绘和重排，合成能大大提升绘制效率。","slug":"[浏览器]url输入执行过程","published":1,"updated":"2021-03-15T14:35:08.551Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dlk005jwotjg97h8aau","content":"<h3 id=\"输入URL到页面展示过程\"><a href=\"#输入URL到页面展示过程\" class=\"headerlink\" title=\"输入URL到页面展示过程\"></a>输入URL到页面展示过程</h3><h4 id=\"输入url\"><a href=\"#输入url\" class=\"headerlink\" title=\"输入url\"></a>输入url</h4><ul>\n<li>判断是搜索还是访问链接，如果是链接，会加上协议，拼成完整链接</li>\n</ul>\n<h4 id=\"url请求过程\"><a href=\"#url请求过程\" class=\"headerlink\" title=\"url请求过程\"></a>url请求过程</h4><ul>\n<li>浏览器进程将url发送至网络进程</li>\n<li>网络进程查找是否有缓存，如果有缓存资源，那么直接返回资源给浏览器进程。没有缓存进入网络请求流程：DNS 解析，获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，还需要建立 TLS 连接、利用 IP 地址和服务器建立 TCP 连接、向服务器发送构建的请求信息（请求行、请求头、Cookie添加至请求头）、网络进程接收了响应行和响应头开始解析响应头内容。</li>\n</ul>\n<ol>\n<li>重定向：状态码301、302，从响应头的 Location 字段里面读取重定向的地址，再次发送请求，例如：http重定向为https</li>\n<li>响应数据类型处理：根据Content-Type决定如何显示响应体的内容，例如：text/html-&gt;html内容、application/octet-stream-&gt;字节流类型，浏览器会按照下载类型处理。</li>\n</ol>\n<h4 id=\"准备渲染进程\"><a href=\"#准备渲染进程\" class=\"headerlink\" title=\"准备渲染进程\"></a>准备渲染进程</h4><ul>\n<li>渲染进程策略：通常情况下，打开新的页面都会使用单独的渲染进程，如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程。</li>\n<li>同一站点：相同的协议和根域名。</li>\n</ul>\n<h4 id=\"提交文档给渲染进程\"><a href=\"#提交文档给渲染进程\" class=\"headerlink\" title=\"提交文档给渲染进程\"></a>提交文档给渲染进程</h4><ul>\n<li>浏览器进程将url请求响应体数据提交给渲染进程，等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程，浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li>\n</ul>\n<h4 id=\"构建DOM树\"><a href=\"#构建DOM树\" class=\"headerlink\" title=\"构建DOM树\"></a>构建DOM树</h4><ul>\n<li>将 HTML 转换为浏览器能够理解的结构——DOM 树</li>\n</ul>\n<h4 id=\"样式计算\"><a href=\"#样式计算\" class=\"headerlink\" title=\"样式计算\"></a>样式计算</h4><ol>\n<li>把 CSS 转换为浏览器能够理解的结构</li>\n</ol>\n<ul>\n<li>css来源：link标签、style标签、style属性</li>\n<li>将 CSS 文本转换为浏览器可以理解的结构——styleSheets，可以通过document.styleSheets查看</li>\n</ul>\n<ol start=\"2\">\n<li>转换样式表中的属性值，使其标准化</li>\n<li>计算出 DOM 树中每个节点的具体样式</li>\n</ol>\n<ul>\n<li>根据CSS 的继承规则和层叠规则计算每个DOM节点的样式</li>\n</ul>\n<h4 id=\"布局阶段\"><a href=\"#布局阶段\" class=\"headerlink\" title=\"布局阶段\"></a>布局阶段</h4><ul>\n<li>计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</li>\n</ul>\n<ol>\n<li>创建布局树</li>\n</ol>\n<ul>\n<li>在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</li>\n<li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局中，不可见的节点会被布局树忽略掉，如head中的内容。</li>\n</ul>\n<ol start=\"2\">\n<li>布局计算</li>\n</ol>\n<ul>\n<li>计算布局树节点的坐标位置了</li>\n</ul>\n<h4 id=\"分层\"><a href=\"#分层\" class=\"headerlink\" title=\"分层\"></a>分层</h4><ul>\n<li>渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）</li>\n<li>拥有<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context\">层叠上下文</a>属性的元素会被提升为单独的一、需要剪裁（clip）的地方也会被创建为图层（例如：文字显示超过区域）</li>\n</ul>\n<h4 id=\"图层绘制\"><a href=\"#图层绘制\" class=\"headerlink\" title=\"图层绘制\"></a>图层绘制</h4><ul>\n<li>渲染引擎会将一个图层的绘制拆分成很多小的绘制指令，再把这些指令按照顺序组成一个待绘制列表。</li>\n</ul>\n<h4 id=\"栅格化（raster）操作\"><a href=\"#栅格化（raster）操作\" class=\"headerlink\" title=\"栅格化（raster）操作\"></a>栅格化（raster）操作</h4><ul>\n<li>绘制操作是由渲染引擎中的合成线程来完成。</li>\n<li>当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。</li>\n<li>合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512。</li>\n<li>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。</li>\n<li>渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。</li>\n<li>栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。GPU 操作是运行在 GPU 进程中，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</li>\n</ul>\n<h4 id=\"合成和显示\"><a href=\"#合成和显示\" class=\"headerlink\" title=\"合成和显示\"></a>合成和显示</h4><ul>\n<li>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</li>\n<li>浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</li>\n</ul>\n<h3 id=\"重排、重绘、合成\"><a href=\"#重排、重绘、合成\" class=\"headerlink\" title=\"重排、重绘、合成\"></a>重排、重绘、合成</h3><ol>\n<li>更新了元素的几何属性（重排）</li>\n</ol>\n<ul>\n<li>改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。</li>\n</ul>\n<ol start=\"2\">\n<li>更新元素的绘制属性（重绘）</li>\n</ol>\n<ul>\n<li>如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</li>\n</ul>\n<ol start=\"3\">\n<li>直接合成阶段</li>\n</ol>\n<ul>\n<li>更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。</li>\n<li>使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。相对于重绘和重排，合成能大大提升绘制效率。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"输入URL到页面展示过程\"><a href=\"#输入URL到页面展示过程\" class=\"headerlink\" title=\"输入URL到页面展示过程\"></a>输入URL到页面展示过程</h3><h4 id=\"输入url\"><a href=\"#输入url\" class=\"headerlink\" title=\"输入url\"></a>输入url</h4><ul>\n<li>判断是搜索还是访问链接，如果是链接，会加上协议，拼成完整链接</li>\n</ul>\n<h4 id=\"url请求过程\"><a href=\"#url请求过程\" class=\"headerlink\" title=\"url请求过程\"></a>url请求过程</h4><ul>\n<li>浏览器进程将url发送至网络进程</li>\n<li>网络进程查找是否有缓存，如果有缓存资源，那么直接返回资源给浏览器进程。没有缓存进入网络请求流程：DNS 解析，获取请求域名的服务器 IP 地址。如果请求协议是 HTTPS，还需要建立 TLS 连接、利用 IP 地址和服务器建立 TCP 连接、向服务器发送构建的请求信息（请求行、请求头、Cookie添加至请求头）、网络进程接收了响应行和响应头开始解析响应头内容。</li>\n</ul>\n<ol>\n<li>重定向：状态码301、302，从响应头的 Location 字段里面读取重定向的地址，再次发送请求，例如：http重定向为https</li>\n<li>响应数据类型处理：根据Content-Type决定如何显示响应体的内容，例如：text/html-&gt;html内容、application/octet-stream-&gt;字节流类型，浏览器会按照下载类型处理。</li>\n</ol>\n<h4 id=\"准备渲染进程\"><a href=\"#准备渲染进程\" class=\"headerlink\" title=\"准备渲染进程\"></a>准备渲染进程</h4><ul>\n<li>渲染进程策略：通常情况下，打开新的页面都会使用单独的渲染进程，如果从 A 页面打开 B 页面，且 A 和 B 都属于同一站点的话，那么 B 页面复用 A 页面的渲染进程。</li>\n<li>同一站点：相同的协议和根域名。</li>\n</ul>\n<h4 id=\"提交文档给渲染进程\"><a href=\"#提交文档给渲染进程\" class=\"headerlink\" title=\"提交文档给渲染进程\"></a>提交文档给渲染进程</h4><ul>\n<li>浏览器进程将url请求响应体数据提交给渲染进程，等文档数据传输完成之后，渲染进程会返回“确认提交”的消息给浏览器进程，浏览器进程在收到“确认提交”的消息后，会更新浏览器界面状态，包括了安全状态、地址栏的 URL、前进后退的历史状态，并更新 Web 页面。</li>\n</ul>\n<h4 id=\"构建DOM树\"><a href=\"#构建DOM树\" class=\"headerlink\" title=\"构建DOM树\"></a>构建DOM树</h4><ul>\n<li>将 HTML 转换为浏览器能够理解的结构——DOM 树</li>\n</ul>\n<h4 id=\"样式计算\"><a href=\"#样式计算\" class=\"headerlink\" title=\"样式计算\"></a>样式计算</h4><ol>\n<li>把 CSS 转换为浏览器能够理解的结构</li>\n</ol>\n<ul>\n<li>css来源：link标签、style标签、style属性</li>\n<li>将 CSS 文本转换为浏览器可以理解的结构——styleSheets，可以通过document.styleSheets查看</li>\n</ul>\n<ol start=\"2\">\n<li>转换样式表中的属性值，使其标准化</li>\n<li>计算出 DOM 树中每个节点的具体样式</li>\n</ol>\n<ul>\n<li>根据CSS 的继承规则和层叠规则计算每个DOM节点的样式</li>\n</ul>\n<h4 id=\"布局阶段\"><a href=\"#布局阶段\" class=\"headerlink\" title=\"布局阶段\"></a>布局阶段</h4><ul>\n<li>计算出 DOM 树中可见元素的几何位置，我们把这个计算过程叫做布局。</li>\n</ul>\n<ol>\n<li>创建布局树</li>\n</ol>\n<ul>\n<li>在显示之前，我们还要额外地构建一棵只包含可见元素布局树。</li>\n<li>遍历 DOM 树中的所有可见节点，并把这些节点加到布局中，不可见的节点会被布局树忽略掉，如head中的内容。</li>\n</ul>\n<ol start=\"2\">\n<li>布局计算</li>\n</ol>\n<ul>\n<li>计算布局树节点的坐标位置了</li>\n</ul>\n<h4 id=\"分层\"><a href=\"#分层\" class=\"headerlink\" title=\"分层\"></a>分层</h4><ul>\n<li>渲染引擎需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）</li>\n<li>拥有<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context\">层叠上下文</a>属性的元素会被提升为单独的一、需要剪裁（clip）的地方也会被创建为图层（例如：文字显示超过区域）</li>\n</ul>\n<h4 id=\"图层绘制\"><a href=\"#图层绘制\" class=\"headerlink\" title=\"图层绘制\"></a>图层绘制</h4><ul>\n<li>渲染引擎会将一个图层的绘制拆分成很多小的绘制指令，再把这些指令按照顺序组成一个待绘制列表。</li>\n</ul>\n<h4 id=\"栅格化（raster）操作\"><a href=\"#栅格化（raster）操作\" class=\"headerlink\" title=\"栅格化（raster）操作\"></a>栅格化（raster）操作</h4><ul>\n<li>绘制操作是由渲染引擎中的合成线程来完成。</li>\n<li>当图层的绘制列表准备好之后，主线程会把该绘制列表提交（commit）给合成线程。</li>\n<li>合成线程会将图层划分为图块（tile），这些图块的大小通常是 256x256 或者 512x512。</li>\n<li>合成线程会按照视口附近的图块来优先生成位图，实际生成位图的操作是由栅格化来执行的。所谓栅格化，是指将图块转换为位图。</li>\n<li>渲染进程维护了一个栅格化的线程池，所有的图块栅格化都是在线程池内执行的。</li>\n<li>栅格化过程都会使用 GPU 来加速生成，使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中。GPU 操作是运行在 GPU 进程中，渲染进程把生成图块的指令发送给 GPU，然后在 GPU 中执行生成图块的位图，并保存在 GPU 的内存中。</li>\n</ul>\n<h4 id=\"合成和显示\"><a href=\"#合成和显示\" class=\"headerlink\" title=\"合成和显示\"></a>合成和显示</h4><ul>\n<li>一旦所有图块都被光栅化，合成线程就会生成一个绘制图块的命令——“DrawQuad”，然后将该命令提交给浏览器进程。</li>\n<li>浏览器进程根据 DrawQuad 消息生成页面，并显示到显示器上。</li>\n</ul>\n<h3 id=\"重排、重绘、合成\"><a href=\"#重排、重绘、合成\" class=\"headerlink\" title=\"重排、重绘、合成\"></a>重排、重绘、合成</h3><ol>\n<li>更新了元素的几何属性（重排）</li>\n</ol>\n<ul>\n<li>改变元素的宽度、高度等，那么浏览器会触发重新布局，解析之后的一系列子阶段，这个过程就叫重排。无疑，重排需要更新完整的渲染流水线，所以开销也是最大的。</li>\n</ul>\n<ol start=\"2\">\n<li>更新元素的绘制属性（重绘）</li>\n</ol>\n<ul>\n<li>如果修改了元素的背景颜色，那么布局阶段将不会被执行，因为并没有引起几何位置的变换，所以就直接进入了绘制阶段，然后执行之后的一系列子阶段，这个过程就叫重绘。相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些。</li>\n</ul>\n<ol start=\"3\">\n<li>直接合成阶段</li>\n</ol>\n<ul>\n<li>更改一个既不要布局也不要绘制的属性，渲染引擎将跳过布局和绘制，只执行后续的合成操作，我们把这个过程叫做合成。</li>\n<li>使用了 CSS 的 transform 来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。相对于重绘和重排，合成能大大提升绘制效率。</li>\n</ul>\n"},{"title":"<浏览器>v8工作原理","date":"2020-02-21T16:00:00.000Z","_content":"\n## v8工作原理\n\n### 堆空间、栈空间\n\n#### 语言类型\n\n- 强类型：不支持隐式类型转换\n- 弱类型：支持隐式类型转换\n- 静态类型：使用前需要确认变量类型\n- 动态类型：使用过程中需要检查变量类型\n\n#### js数据类型\n\n- 原始类型：String\\Number\\Boolean\\Null\\Undefined\\Symbol\\BigInt\n- 引用类型：Object\n\n#### js内存空间\n\n- 代码空间：存储可执行代码\n- 栈空间：js用栈空间维护执行程序期间上下文的状态，原始类型保存在栈空间，通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。\n- 堆空间：引用类型保存在堆空间，引用类型一般占用空间大，堆空间很大，能存放很多大的数据，内存回收占用更多时间。\n\n- 原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。\n- 如果所有数据都存储在栈空间，会影响上下文切换效率，从而影响程序执行效率。\n\n#### 闭包原理\n\n- 当js引擎发现闭包引用时，会在堆空间中创建闭包对象，用来保存闭包引用的值，执行上下文中创建闭包内部变量，引用闭包对象的地址。\n\n### 垃圾回收\n\n- js中产生的垃圾是由垃圾回收器来释放的，不需要手动通过代码释放。\n\n#### 调用栈中的垃圾回收\n\n- js函数执行时，会有一个记录当前执行上下文的指针（成为ESP），指向调用栈中正在执行函数的执行上下文，表示正在执行的函数。\n- 当函数执行完毕，执行流程进入新的函数，此时要销毁老函数的执行上下文，此时js的ESP会移动到新函数的执行上下文，这个下移操作就是销毁老函数执行上下文的过程。\n- JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。\n\n#### 堆中的垃圾回收\n\n- 堆中的垃圾数据回收利用js的垃圾回收器。\n\n- 代际假说：\n\n1. 大部分内存存在时间很短，很多对象一分配内存，很快就不可以访问\n2. 不死的对象，会存活很久\n\n- 基于代际假说，v8来实现垃圾回收。\n-  在 V8 中会把堆分为**新生代**和**老生代**两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。\n-  **副垃圾回收器**，主要负责新生代的垃圾回收。\n- **主垃圾回收器**，主要负责老生代的垃圾回收。\n\n- 垃圾回收器工作流程\n\n1. 标记空间中活动和非活动对象\n2. 回收非活动对象的内存，在标记完成后，统一清理可回收对象\n3. 内存整理，整理不连续空间（内存碎片），防止分配较大连续内存时内存不足。\n\n- 副垃圾回收器执行过程\n\n1. 新生代采用Scavenge 算法来处理，将新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。\n2. 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。\n3. 垃圾回收过程：对对象区域中的垃圾做标记-》垃圾清理阶段，将存活的对象复制到空闲区域中，同时排列这些对象，完成整理工作-》复制完成后，对象区域和空闲区域进行对调，完成垃圾回收。\n4. 角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。\n5. 为了执行效率，一般新生区的空间会被设置得比较小，js采用**对象晋升策略**，经过两次垃圾回收依然存在的对象，移动到老生区。\n\n- 主垃圾回收器执行过程\n\n1. 主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。\n2. 标记阶段：从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。\n3. 清除阶段：清除掉标记的垃圾数据\n4. 清除算法会产生大量不连续的内存碎片，使用标记-整理算法整理内存，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n- 全停顿\n\n1. 一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。\n\n- 增量标记\n\n1. 了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。\n2. 增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。\n\n### 编译器解释器\n\n#### 编译器（Compiler）\n\n- 编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。\n- 在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。\n\n#### 解释器（Interpreter）\n\n- 而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。\n- 在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。\n\n#### 抽象语法树（AST）\n#### 字节码（Bytecode）\n#### 即时编译器（JIT）\n#### v8如何执行代码\n\n1. 生成抽象语法树（AST）和执行上下文（代码在执行过程中的环境信息）\n\n- 生成 AST 需要经过两个阶段。第一阶段是分词（tokenize），又称为词法分析，将一行行的源码拆解成一个个 token，第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。\n\n2. 生成字节码\n\n- 字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过**解释器**将其转换为机器码后才能执行。\n\n3. 执行代码\n\n- 如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码。\n- 即时编译（JIT）:字节码配合解释器和编译器的技术。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。\n\n#### 性能优化\n\n- 提升脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；\n- 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；\n- 减少js文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。","source":"_posts/[浏览器]v8工作原理.md","raw":"---\ntitle: <浏览器>v8工作原理\ndate: 2020-02-22 00:00:00\ntags: [js,浏览器]\ncategories: 浏览器\n---\n\n## v8工作原理\n\n### 堆空间、栈空间\n\n#### 语言类型\n\n- 强类型：不支持隐式类型转换\n- 弱类型：支持隐式类型转换\n- 静态类型：使用前需要确认变量类型\n- 动态类型：使用过程中需要检查变量类型\n\n#### js数据类型\n\n- 原始类型：String\\Number\\Boolean\\Null\\Undefined\\Symbol\\BigInt\n- 引用类型：Object\n\n#### js内存空间\n\n- 代码空间：存储可执行代码\n- 栈空间：js用栈空间维护执行程序期间上下文的状态，原始类型保存在栈空间，通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。\n- 堆空间：引用类型保存在堆空间，引用类型一般占用空间大，堆空间很大，能存放很多大的数据，内存回收占用更多时间。\n\n- 原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。\n- 如果所有数据都存储在栈空间，会影响上下文切换效率，从而影响程序执行效率。\n\n#### 闭包原理\n\n- 当js引擎发现闭包引用时，会在堆空间中创建闭包对象，用来保存闭包引用的值，执行上下文中创建闭包内部变量，引用闭包对象的地址。\n\n### 垃圾回收\n\n- js中产生的垃圾是由垃圾回收器来释放的，不需要手动通过代码释放。\n\n#### 调用栈中的垃圾回收\n\n- js函数执行时，会有一个记录当前执行上下文的指针（成为ESP），指向调用栈中正在执行函数的执行上下文，表示正在执行的函数。\n- 当函数执行完毕，执行流程进入新的函数，此时要销毁老函数的执行上下文，此时js的ESP会移动到新函数的执行上下文，这个下移操作就是销毁老函数执行上下文的过程。\n- JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。\n\n#### 堆中的垃圾回收\n\n- 堆中的垃圾数据回收利用js的垃圾回收器。\n\n- 代际假说：\n\n1. 大部分内存存在时间很短，很多对象一分配内存，很快就不可以访问\n2. 不死的对象，会存活很久\n\n- 基于代际假说，v8来实现垃圾回收。\n-  在 V8 中会把堆分为**新生代**和**老生代**两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。\n-  **副垃圾回收器**，主要负责新生代的垃圾回收。\n- **主垃圾回收器**，主要负责老生代的垃圾回收。\n\n- 垃圾回收器工作流程\n\n1. 标记空间中活动和非活动对象\n2. 回收非活动对象的内存，在标记完成后，统一清理可回收对象\n3. 内存整理，整理不连续空间（内存碎片），防止分配较大连续内存时内存不足。\n\n- 副垃圾回收器执行过程\n\n1. 新生代采用Scavenge 算法来处理，将新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。\n2. 新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。\n3. 垃圾回收过程：对对象区域中的垃圾做标记-》垃圾清理阶段，将存活的对象复制到空闲区域中，同时排列这些对象，完成整理工作-》复制完成后，对象区域和空闲区域进行对调，完成垃圾回收。\n4. 角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。\n5. 为了执行效率，一般新生区的空间会被设置得比较小，js采用**对象晋升策略**，经过两次垃圾回收依然存在的对象，移动到老生区。\n\n- 主垃圾回收器执行过程\n\n1. 主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。\n2. 标记阶段：从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。\n3. 清除阶段：清除掉标记的垃圾数据\n4. 清除算法会产生大量不连续的内存碎片，使用标记-整理算法整理内存，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n- 全停顿\n\n1. 一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。\n\n- 增量标记\n\n1. 了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。\n2. 增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。\n\n### 编译器解释器\n\n#### 编译器（Compiler）\n\n- 编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。\n- 在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。\n\n#### 解释器（Interpreter）\n\n- 而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。\n- 在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。\n\n#### 抽象语法树（AST）\n#### 字节码（Bytecode）\n#### 即时编译器（JIT）\n#### v8如何执行代码\n\n1. 生成抽象语法树（AST）和执行上下文（代码在执行过程中的环境信息）\n\n- 生成 AST 需要经过两个阶段。第一阶段是分词（tokenize），又称为词法分析，将一行行的源码拆解成一个个 token，第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。\n\n2. 生成字节码\n\n- 字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过**解释器**将其转换为机器码后才能执行。\n\n3. 执行代码\n\n- 如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码。\n- 即时编译（JIT）:字节码配合解释器和编译器的技术。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。\n\n#### 性能优化\n\n- 提升脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；\n- 避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；\n- 减少js文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。","slug":"[浏览器]v8工作原理","published":1,"updated":"2021-03-15T14:35:15.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dll005kwotjcag64o3c","content":"<h2 id=\"v8工作原理\"><a href=\"#v8工作原理\" class=\"headerlink\" title=\"v8工作原理\"></a>v8工作原理</h2><h3 id=\"堆空间、栈空间\"><a href=\"#堆空间、栈空间\" class=\"headerlink\" title=\"堆空间、栈空间\"></a>堆空间、栈空间</h3><h4 id=\"语言类型\"><a href=\"#语言类型\" class=\"headerlink\" title=\"语言类型\"></a>语言类型</h4><ul>\n<li>强类型：不支持隐式类型转换</li>\n<li>弱类型：支持隐式类型转换</li>\n<li>静态类型：使用前需要确认变量类型</li>\n<li>动态类型：使用过程中需要检查变量类型</li>\n</ul>\n<h4 id=\"js数据类型\"><a href=\"#js数据类型\" class=\"headerlink\" title=\"js数据类型\"></a>js数据类型</h4><ul>\n<li>原始类型：String\\Number\\Boolean\\Null\\Undefined\\Symbol\\BigInt</li>\n<li>引用类型：Object</li>\n</ul>\n<h4 id=\"js内存空间\"><a href=\"#js内存空间\" class=\"headerlink\" title=\"js内存空间\"></a>js内存空间</h4><ul>\n<li><p>代码空间：存储可执行代码</p>\n</li>\n<li><p>栈空间：js用栈空间维护执行程序期间上下文的状态，原始类型保存在栈空间，通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。</p>\n</li>\n<li><p>堆空间：引用类型保存在堆空间，引用类型一般占用空间大，堆空间很大，能存放很多大的数据，内存回收占用更多时间。</p>\n</li>\n<li><p>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</p>\n</li>\n<li><p>如果所有数据都存储在栈空间，会影响上下文切换效率，从而影响程序执行效率。</p>\n</li>\n</ul>\n<h4 id=\"闭包原理\"><a href=\"#闭包原理\" class=\"headerlink\" title=\"闭包原理\"></a>闭包原理</h4><ul>\n<li>当js引擎发现闭包引用时，会在堆空间中创建闭包对象，用来保存闭包引用的值，执行上下文中创建闭包内部变量，引用闭包对象的地址。</li>\n</ul>\n<h3 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h3><ul>\n<li>js中产生的垃圾是由垃圾回收器来释放的，不需要手动通过代码释放。</li>\n</ul>\n<h4 id=\"调用栈中的垃圾回收\"><a href=\"#调用栈中的垃圾回收\" class=\"headerlink\" title=\"调用栈中的垃圾回收\"></a>调用栈中的垃圾回收</h4><ul>\n<li>js函数执行时，会有一个记录当前执行上下文的指针（成为ESP），指向调用栈中正在执行函数的执行上下文，表示正在执行的函数。</li>\n<li>当函数执行完毕，执行流程进入新的函数，此时要销毁老函数的执行上下文，此时js的ESP会移动到新函数的执行上下文，这个下移操作就是销毁老函数执行上下文的过程。</li>\n<li>JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。</li>\n</ul>\n<h4 id=\"堆中的垃圾回收\"><a href=\"#堆中的垃圾回收\" class=\"headerlink\" title=\"堆中的垃圾回收\"></a>堆中的垃圾回收</h4><ul>\n<li><p>堆中的垃圾数据回收利用js的垃圾回收器。</p>\n</li>\n<li><p>代际假说：</p>\n</li>\n</ul>\n<ol>\n<li>大部分内存存在时间很短，很多对象一分配内存，很快就不可以访问</li>\n<li>不死的对象，会存活很久</li>\n</ol>\n<ul>\n<li><p>基于代际假说，v8来实现垃圾回收。</p>\n</li>\n<li><p> 在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</p>\n</li>\n<li><p> <strong>副垃圾回收器</strong>，主要负责新生代的垃圾回收。</p>\n</li>\n<li><p><strong>主垃圾回收器</strong>，主要负责老生代的垃圾回收。</p>\n</li>\n<li><p>垃圾回收器工作流程</p>\n</li>\n</ul>\n<ol>\n<li>标记空间中活动和非活动对象</li>\n<li>回收非活动对象的内存，在标记完成后，统一清理可回收对象</li>\n<li>内存整理，整理不连续空间（内存碎片），防止分配较大连续内存时内存不足。</li>\n</ol>\n<ul>\n<li>副垃圾回收器执行过程</li>\n</ul>\n<ol>\n<li>新生代采用Scavenge 算法来处理，将新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。</li>\n<li>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</li>\n<li>垃圾回收过程：对对象区域中的垃圾做标记-》垃圾清理阶段，将存活的对象复制到空闲区域中，同时排列这些对象，完成整理工作-》复制完成后，对象区域和空闲区域进行对调，完成垃圾回收。</li>\n<li>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</li>\n<li>为了执行效率，一般新生区的空间会被设置得比较小，js采用<strong>对象晋升策略</strong>，经过两次垃圾回收依然存在的对象，移动到老生区。</li>\n</ol>\n<ul>\n<li>主垃圾回收器执行过程</li>\n</ul>\n<ol>\n<li>主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。</li>\n<li>标记阶段：从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</li>\n<li>清除阶段：清除掉标记的垃圾数据</li>\n<li>清除算法会产生大量不连续的内存碎片，使用标记-整理算法整理内存，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</li>\n</ol>\n<ul>\n<li>全停顿</li>\n</ul>\n<ol>\n<li>一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</li>\n</ol>\n<ul>\n<li>增量标记</li>\n</ul>\n<ol>\n<li>了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。</li>\n<li>增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</li>\n</ol>\n<h3 id=\"编译器解释器\"><a href=\"#编译器解释器\" class=\"headerlink\" title=\"编译器解释器\"></a>编译器解释器</h3><h4 id=\"编译器（Compiler）\"><a href=\"#编译器（Compiler）\" class=\"headerlink\" title=\"编译器（Compiler）\"></a>编译器（Compiler）</h4><ul>\n<li>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。</li>\n<li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</li>\n</ul>\n<h4 id=\"解释器（Interpreter）\"><a href=\"#解释器（Interpreter）\" class=\"headerlink\" title=\"解释器（Interpreter）\"></a>解释器（Interpreter）</h4><ul>\n<li>而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。</li>\n<li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</li>\n</ul>\n<h4 id=\"抽象语法树（AST）\"><a href=\"#抽象语法树（AST）\" class=\"headerlink\" title=\"抽象语法树（AST）\"></a>抽象语法树（AST）</h4><h4 id=\"字节码（Bytecode）\"><a href=\"#字节码（Bytecode）\" class=\"headerlink\" title=\"字节码（Bytecode）\"></a>字节码（Bytecode）</h4><h4 id=\"即时编译器（JIT）\"><a href=\"#即时编译器（JIT）\" class=\"headerlink\" title=\"即时编译器（JIT）\"></a>即时编译器（JIT）</h4><h4 id=\"v8如何执行代码\"><a href=\"#v8如何执行代码\" class=\"headerlink\" title=\"v8如何执行代码\"></a>v8如何执行代码</h4><ol>\n<li>生成抽象语法树（AST）和执行上下文（代码在执行过程中的环境信息）</li>\n</ol>\n<ul>\n<li>生成 AST 需要经过两个阶段。第一阶段是分词（tokenize），又称为词法分析，将一行行的源码拆解成一个个 token，第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。</li>\n</ul>\n<ol start=\"2\">\n<li>生成字节码</li>\n</ol>\n<ul>\n<li>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过<strong>解释器</strong>将其转换为机器码后才能执行。</li>\n</ul>\n<ol start=\"3\">\n<li>执行代码</li>\n</ol>\n<ul>\n<li>如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码。</li>\n<li>即时编译（JIT）:字节码配合解释器和编译器的技术。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。</li>\n</ul>\n<h4 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h4><ul>\n<li>提升脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>\n<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>\n<li>减少js文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"v8工作原理\"><a href=\"#v8工作原理\" class=\"headerlink\" title=\"v8工作原理\"></a>v8工作原理</h2><h3 id=\"堆空间、栈空间\"><a href=\"#堆空间、栈空间\" class=\"headerlink\" title=\"堆空间、栈空间\"></a>堆空间、栈空间</h3><h4 id=\"语言类型\"><a href=\"#语言类型\" class=\"headerlink\" title=\"语言类型\"></a>语言类型</h4><ul>\n<li>强类型：不支持隐式类型转换</li>\n<li>弱类型：支持隐式类型转换</li>\n<li>静态类型：使用前需要确认变量类型</li>\n<li>动态类型：使用过程中需要检查变量类型</li>\n</ul>\n<h4 id=\"js数据类型\"><a href=\"#js数据类型\" class=\"headerlink\" title=\"js数据类型\"></a>js数据类型</h4><ul>\n<li>原始类型：String\\Number\\Boolean\\Null\\Undefined\\Symbol\\BigInt</li>\n<li>引用类型：Object</li>\n</ul>\n<h4 id=\"js内存空间\"><a href=\"#js内存空间\" class=\"headerlink\" title=\"js内存空间\"></a>js内存空间</h4><ul>\n<li><p>代码空间：存储可执行代码</p>\n</li>\n<li><p>栈空间：js用栈空间维护执行程序期间上下文的状态，原始类型保存在栈空间，通常情况下，栈空间都不会设置太大，主要用来存放一些原始类型的小数据。</p>\n</li>\n<li><p>堆空间：引用类型保存在堆空间，引用类型一般占用空间大，堆空间很大，能存放很多大的数据，内存回收占用更多时间。</p>\n</li>\n<li><p>原始类型的赋值会完整复制变量值，而引用类型的赋值是复制引用地址。</p>\n</li>\n<li><p>如果所有数据都存储在栈空间，会影响上下文切换效率，从而影响程序执行效率。</p>\n</li>\n</ul>\n<h4 id=\"闭包原理\"><a href=\"#闭包原理\" class=\"headerlink\" title=\"闭包原理\"></a>闭包原理</h4><ul>\n<li>当js引擎发现闭包引用时，会在堆空间中创建闭包对象，用来保存闭包引用的值，执行上下文中创建闭包内部变量，引用闭包对象的地址。</li>\n</ul>\n<h3 id=\"垃圾回收\"><a href=\"#垃圾回收\" class=\"headerlink\" title=\"垃圾回收\"></a>垃圾回收</h3><ul>\n<li>js中产生的垃圾是由垃圾回收器来释放的，不需要手动通过代码释放。</li>\n</ul>\n<h4 id=\"调用栈中的垃圾回收\"><a href=\"#调用栈中的垃圾回收\" class=\"headerlink\" title=\"调用栈中的垃圾回收\"></a>调用栈中的垃圾回收</h4><ul>\n<li>js函数执行时，会有一个记录当前执行上下文的指针（成为ESP），指向调用栈中正在执行函数的执行上下文，表示正在执行的函数。</li>\n<li>当函数执行完毕，执行流程进入新的函数，此时要销毁老函数的执行上下文，此时js的ESP会移动到新函数的执行上下文，这个下移操作就是销毁老函数执行上下文的过程。</li>\n<li>JavaScript 引擎会通过向下移动 ESP 来销毁该函数保存在栈中的执行上下文。</li>\n</ul>\n<h4 id=\"堆中的垃圾回收\"><a href=\"#堆中的垃圾回收\" class=\"headerlink\" title=\"堆中的垃圾回收\"></a>堆中的垃圾回收</h4><ul>\n<li><p>堆中的垃圾数据回收利用js的垃圾回收器。</p>\n</li>\n<li><p>代际假说：</p>\n</li>\n</ul>\n<ol>\n<li>大部分内存存在时间很短，很多对象一分配内存，很快就不可以访问</li>\n<li>不死的对象，会存活很久</li>\n</ol>\n<ul>\n<li><p>基于代际假说，v8来实现垃圾回收。</p>\n</li>\n<li><p> 在 V8 中会把堆分为<strong>新生代</strong>和<strong>老生代</strong>两个区域，新生代中存放的是生存时间短的对象，老生代中存放的生存时间久的对象。</p>\n</li>\n<li><p> <strong>副垃圾回收器</strong>，主要负责新生代的垃圾回收。</p>\n</li>\n<li><p><strong>主垃圾回收器</strong>，主要负责老生代的垃圾回收。</p>\n</li>\n<li><p>垃圾回收器工作流程</p>\n</li>\n</ul>\n<ol>\n<li>标记空间中活动和非活动对象</li>\n<li>回收非活动对象的内存，在标记完成后，统一清理可回收对象</li>\n<li>内存整理，整理不连续空间（内存碎片），防止分配较大连续内存时内存不足。</li>\n</ol>\n<ul>\n<li>副垃圾回收器执行过程</li>\n</ul>\n<ol>\n<li>新生代采用Scavenge 算法来处理，将新生代空间对半划分为两个区域，一半是对象区域，一半是空闲区域。</li>\n<li>新加入的对象都会存放到对象区域，当对象区域快被写满时，就需要执行一次垃圾清理操作。</li>\n<li>垃圾回收过程：对对象区域中的垃圾做标记-》垃圾清理阶段，将存活的对象复制到空闲区域中，同时排列这些对象，完成整理工作-》复制完成后，对象区域和空闲区域进行对调，完成垃圾回收。</li>\n<li>角色翻转的操作还能让新生代中的这两块区域无限重复使用下去。</li>\n<li>为了执行效率，一般新生区的空间会被设置得比较小，js采用<strong>对象晋升策略</strong>，经过两次垃圾回收依然存在的对象，移动到老生区。</li>\n</ol>\n<ul>\n<li>主垃圾回收器执行过程</li>\n</ul>\n<ol>\n<li>主垃圾回收器是采用标记 - 清除（Mark-Sweep）的算法进行垃圾回收的。</li>\n<li>标记阶段：从一组根元素开始，递归遍历这组根元素，在这个遍历过程中，能到达的元素称为活动对象，没有到达的元素就可以判断为垃圾数据。</li>\n<li>清除阶段：清除掉标记的垃圾数据</li>\n<li>清除算法会产生大量不连续的内存碎片，使用标记-整理算法整理内存，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</li>\n</ol>\n<ul>\n<li>全停顿</li>\n</ul>\n<ol>\n<li>一旦执行垃圾回收算法，都需要将正在执行的 JavaScript 脚本暂停下来，待垃圾回收完毕后再恢复脚本执行。我们把这种行为叫做全停顿（Stop-The-World）。</li>\n</ol>\n<ul>\n<li>增量标记</li>\n</ul>\n<ol>\n<li>了降低老生代的垃圾回收而造成的卡顿，V8 将标记过程分为一个个的子标记过程，同时让垃圾回收标记和 JavaScript 应用逻辑交替进行，直到标记阶段完成，我们把这个算法称为增量标记（Incremental Marking）算法。</li>\n<li>增量标记算法，可以把一个完整的垃圾回收任务拆分为很多小的任务，这些小的任务执行时间比较短，可以穿插在其他的 JavaScript 任务中间执行，这样当执行上述动画效果时，就不会让用户因为垃圾回收任务而感受到页面的卡顿了。</li>\n</ol>\n<h3 id=\"编译器解释器\"><a href=\"#编译器解释器\" class=\"headerlink\" title=\"编译器解释器\"></a>编译器解释器</h3><h4 id=\"编译器（Compiler）\"><a href=\"#编译器（Compiler）\" class=\"headerlink\" title=\"编译器（Compiler）\"></a>编译器（Compiler）</h4><ul>\n<li>编译型语言在程序执行之前，需要经过编译器的编译过程，并且编译之后会直接保留机器能读懂的二进制文件，这样每次运行程序时，都可以直接运行该二进制文件，而不需要再次重新编译了。比如 C/C++、GO 等都是编译型语言。</li>\n<li>在编译型语言的编译过程中，编译器首先会依次对源代码进行词法分析、语法分析，生成抽象语法树（AST），然后是优化代码，最后再生成处理器能够理解的机器码。如果编译成功，将会生成一个可执行的文件。但如果编译过程发生了语法或者其他的错误，那么编译器就会抛出异常，最后的二进制文件也不会生成成功。</li>\n</ul>\n<h4 id=\"解释器（Interpreter）\"><a href=\"#解释器（Interpreter）\" class=\"headerlink\" title=\"解释器（Interpreter）\"></a>解释器（Interpreter）</h4><ul>\n<li>而由解释型语言编写的程序，在每次运行时都需要通过解释器对程序进行动态解释和执行。比如 Python、JavaScript 等都属于解释型语言。</li>\n<li>在解释型语言的解释过程中，同样解释器也会对源代码进行词法分析、语法分析，并生成抽象语法树（AST），不过它会再基于抽象语法树生成字节码，最后再根据字节码来执行程序、输出结果。</li>\n</ul>\n<h4 id=\"抽象语法树（AST）\"><a href=\"#抽象语法树（AST）\" class=\"headerlink\" title=\"抽象语法树（AST）\"></a>抽象语法树（AST）</h4><h4 id=\"字节码（Bytecode）\"><a href=\"#字节码（Bytecode）\" class=\"headerlink\" title=\"字节码（Bytecode）\"></a>字节码（Bytecode）</h4><h4 id=\"即时编译器（JIT）\"><a href=\"#即时编译器（JIT）\" class=\"headerlink\" title=\"即时编译器（JIT）\"></a>即时编译器（JIT）</h4><h4 id=\"v8如何执行代码\"><a href=\"#v8如何执行代码\" class=\"headerlink\" title=\"v8如何执行代码\"></a>v8如何执行代码</h4><ol>\n<li>生成抽象语法树（AST）和执行上下文（代码在执行过程中的环境信息）</li>\n</ol>\n<ul>\n<li>生成 AST 需要经过两个阶段。第一阶段是分词（tokenize），又称为词法分析，将一行行的源码拆解成一个个 token，第二阶段是解析（parse），又称为语法分析，其作用是将上一步生成的 token 数据，根据语法规则转为 AST。</li>\n</ul>\n<ol start=\"2\">\n<li>生成字节码</li>\n</ol>\n<ul>\n<li>字节码就是介于 AST 和机器码之间的一种代码。但是与特定类型的机器码无关，字节码需要通过<strong>解释器</strong>将其转换为机器码后才能执行。</li>\n</ul>\n<ol start=\"3\">\n<li>执行代码</li>\n</ol>\n<ul>\n<li>如一段代码被重复执行多次，这种就称为热点代码，那么后台的编译器 TurboFan 就会把该段热点的字节码编译为高效的机器码。</li>\n<li>即时编译（JIT）:字节码配合解释器和编译器的技术。具体到 V8，就是指解释器 Ignition 在解释执行字节码的同时，收集代码信息，当它发现某一部分代码变热了之后，TurboFan 编译器便闪亮登场，把热点的字节码转换为机器码，并把转换后的机器码保存起来，以备下次使用。</li>\n</ul>\n<h4 id=\"性能优化\"><a href=\"#性能优化\" class=\"headerlink\" title=\"性能优化\"></a>性能优化</h4><ul>\n<li>提升脚本的执行速度，避免 JavaScript 的长任务霸占主线程，这样可以使得页面快速响应交互；</li>\n<li>避免大的内联脚本，因为在解析 HTML 的过程中，解析和编译也会占用主线程；</li>\n<li>减少js文件的容量，因为更小的文件会提升下载速度，并且占用更低的内存。</li>\n</ul>\n"},{"title":"<浏览器>浏览器缓存","date":"2018-09-06T14:13:21.000Z","_content":"\n![image](https://crazyaguai.github.io/images/浏览器缓存.png)\n\n### 强制缓存\n\n- 当浏览器对某个资源的请求命中了强制缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。\n\n### Expires：\n\n- Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：\n\n1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header。\n2. 浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；\n\n- Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题。\n\n### Cache-Control：\n\n- Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示\n\n- 参数：\n\n1. public：所有内容都将被缓存（客户端和代理服务器都可缓存）\n2. private：所有内容只有客户端可以缓存，Cache-Control的默认取值\n3. no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n4. no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n5. max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效\n6. s-maxage=xxx：代理服务器的缓存时间\n\n### 缓存原理：\n\n1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header\n2. 浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；\n3. 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。\n4. 如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。\n\n### Cache-Control与Expires不同\n\n- Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。\n- Cache-Control优先级高于Expires。\n\n### 启用强制缓存\n\n- 通常有2种方式来设置是否启用强缓存：\n\n1. 通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；\n2. 通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。\n\n### from memory cache与from disk cache\n\n- from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –> disk。\n- 对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:\n\n#### 内存缓存(from memory cache)：\n\n- 内存缓存具有两个特点，分别是快速读取和时效性：\n- 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。\n- 时效性：一旦该进程关闭，则该进程的内存则会清空。\n\n#### 硬盘缓存(from disk cache)：\n- 硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。\n- 在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。\n\n### 协商缓存\n\n- 当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。\n- 协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。\n\n#### 【Last-Modified，If-Modified-Since】\n\n- 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间。\n- 浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值。\n- 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 NotModified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header。\n- 浏览器收到304的响应后，就会从缓存中加载资源。\n- 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。\n\n#### 【ETag、If-None-Match】\n\n- 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题。\n- 浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值。\n- 服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。\n浏览器收到304的响应后，就会从缓存中加载资源。\n\n####  Etag / If-None-Match比较\n- 其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高\n\n#### 注意：\n\n- 【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：\n- 分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；\n- 分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；\n\n### 浏览器刷新与缓存方式：\n\n- 当ctrl+f5(command+shift+r)强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；\n当f5(commond+r)刷新网页时，跳过强缓存，但是会检查协商缓存\n\n### 参考\n\n- https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA\n- https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=402202185&idx=3&sn=abbc03511d2c393d7a4867ff532224ab&scene=21#wechat_redirect\n- https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651221145&idx=1&sn=ce8cc0dd80142980026eb156d5b1f269&scene=21#wechat_redirect\n- https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651226347&idx=1&sn=6dbccc54406f0b075671884b738b1e88&chksm=bd49596f8a3ed079f79cda4b90ac3cb3b1dbdb5bfb8aade962a16a323563bf26a0c75b0a5d7b&scene=21#wechat_redirect\n","source":"_posts/[浏览器]浏览器缓存.md","raw":"---\ntitle: <浏览器>浏览器缓存\ndate: 2018-09-06 22:13:21\ntags: [缓存,浏览器]\ncategories: 缓存\n---\n\n![image](https://crazyaguai.github.io/images/浏览器缓存.png)\n\n### 强制缓存\n\n- 当浏览器对某个资源的请求命中了强制缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。\n\n### Expires：\n\n- Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：\n\n1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header。\n2. 浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；\n\n- Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题。\n\n### Cache-Control：\n\n- Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示\n\n- 参数：\n\n1. public：所有内容都将被缓存（客户端和代理服务器都可缓存）\n2. private：所有内容只有客户端可以缓存，Cache-Control的默认取值\n3. no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n4. no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n5. max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效\n6. s-maxage=xxx：代理服务器的缓存时间\n\n### 缓存原理：\n\n1. 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header\n2. 浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；\n3. 浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。\n4. 如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。\n\n### Cache-Control与Expires不同\n\n- Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。\n- Cache-Control优先级高于Expires。\n\n### 启用强制缓存\n\n- 通常有2种方式来设置是否启用强缓存：\n\n1. 通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；\n2. 通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。\n\n### from memory cache与from disk cache\n\n- from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –> disk。\n- 对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:\n\n#### 内存缓存(from memory cache)：\n\n- 内存缓存具有两个特点，分别是快速读取和时效性：\n- 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。\n- 时效性：一旦该进程关闭，则该进程的内存则会清空。\n\n#### 硬盘缓存(from disk cache)：\n- 硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。\n- 在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。\n\n### 协商缓存\n\n- 当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。\n- 协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。\n\n#### 【Last-Modified，If-Modified-Since】\n\n- 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间。\n- 浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值。\n- 服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 NotModified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header。\n- 浏览器收到304的响应后，就会从缓存中加载资源。\n- 如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。\n\n#### 【ETag、If-None-Match】\n\n- 浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题。\n- 浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值。\n- 服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。\n浏览器收到304的响应后，就会从缓存中加载资源。\n\n####  Etag / If-None-Match比较\n- 其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高\n\n#### 注意：\n\n- 【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：\n- 分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；\n- 分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；\n\n### 浏览器刷新与缓存方式：\n\n- 当ctrl+f5(command+shift+r)强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；\n当f5(commond+r)刷新网页时，跳过强缓存，但是会检查协商缓存\n\n### 参考\n\n- https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA\n- https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=402202185&idx=3&sn=abbc03511d2c393d7a4867ff532224ab&scene=21#wechat_redirect\n- https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651221145&idx=1&sn=ce8cc0dd80142980026eb156d5b1f269&scene=21#wechat_redirect\n- https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651226347&idx=1&sn=6dbccc54406f0b075671884b738b1e88&chksm=bd49596f8a3ed079f79cda4b90ac3cb3b1dbdb5bfb8aade962a16a323563bf26a0c75b0a5d7b&scene=21#wechat_redirect\n","slug":"[浏览器]浏览器缓存","published":1,"updated":"2021-03-15T14:34:55.420Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dll005mwotjfo0v9hos","content":"<p><img src=\"https://crazyaguai.github.io/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.png\" alt=\"image\"></p>\n<h3 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h3><ul>\n<li>当浏览器对某个资源的请求命中了强制缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。</li>\n</ul>\n<h3 id=\"Expires：\"><a href=\"#Expires：\" class=\"headerlink\" title=\"Expires：\"></a>Expires：</h3><ul>\n<li>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：</li>\n</ul>\n<ol>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header。</li>\n<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</li>\n</ol>\n<ul>\n<li>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题。</li>\n</ul>\n<h3 id=\"Cache-Control：\"><a href=\"#Cache-Control：\" class=\"headerlink\" title=\"Cache-Control：\"></a>Cache-Control：</h3><ul>\n<li><p>Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示</p>\n</li>\n<li><p>参数：</p>\n</li>\n</ul>\n<ol>\n<li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li>\n<li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li>\n<li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>\n<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>\n<li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li>\n<li>s-maxage=xxx：代理服务器的缓存时间</li>\n</ol>\n<h3 id=\"缓存原理：\"><a href=\"#缓存原理：\" class=\"headerlink\" title=\"缓存原理：\"></a>缓存原理：</h3><ol>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header</li>\n<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</li>\n<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</li>\n<li>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</li>\n</ol>\n<h3 id=\"Cache-Control与Expires不同\"><a href=\"#Cache-Control与Expires不同\" class=\"headerlink\" title=\"Cache-Control与Expires不同\"></a>Cache-Control与Expires不同</h3><ul>\n<li>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</li>\n<li>Cache-Control优先级高于Expires。</li>\n</ul>\n<h3 id=\"启用强制缓存\"><a href=\"#启用强制缓存\" class=\"headerlink\" title=\"启用强制缓存\"></a>启用强制缓存</h3><ul>\n<li>通常有2种方式来设置是否启用强缓存：</li>\n</ul>\n<ol>\n<li>通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</li>\n<li>通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。</li>\n</ol>\n<h3 id=\"from-memory-cache与from-disk-cache\"><a href=\"#from-memory-cache与from-disk-cache\" class=\"headerlink\" title=\"from memory cache与from disk cache\"></a>from memory cache与from disk cache</h3><ul>\n<li>from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</li>\n<li>对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:</li>\n</ul>\n<h4 id=\"内存缓存-from-memory-cache-：\"><a href=\"#内存缓存-from-memory-cache-：\" class=\"headerlink\" title=\"内存缓存(from memory cache)：\"></a>内存缓存(from memory cache)：</h4><ul>\n<li>内存缓存具有两个特点，分别是快速读取和时效性：</li>\n<li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li>\n<li>时效性：一旦该进程关闭，则该进程的内存则会清空。</li>\n</ul>\n<h4 id=\"硬盘缓存-from-disk-cache-：\"><a href=\"#硬盘缓存-from-disk-cache-：\" class=\"headerlink\" title=\"硬盘缓存(from disk cache)：\"></a>硬盘缓存(from disk cache)：</h4><ul>\n<li>硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</li>\n<li>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</li>\n</ul>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><ul>\n<li>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。</li>\n<li>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</li>\n</ul>\n<h4 id=\"【Last-Modified，If-Modified-Since】\"><a href=\"#【Last-Modified，If-Modified-Since】\" class=\"headerlink\" title=\"【Last-Modified，If-Modified-Since】\"></a>【Last-Modified，If-Modified-Since】</h4><ul>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间。</li>\n<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值。</li>\n<li>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 NotModified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header。</li>\n<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>\n<li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</li>\n</ul>\n<h4 id=\"【ETag、If-None-Match】\"><a href=\"#【ETag、If-None-Match】\" class=\"headerlink\" title=\"【ETag、If-None-Match】\"></a>【ETag、If-None-Match】</h4><ul>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题。</li>\n<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值。</li>\n<li>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。<br>浏览器收到304的响应后，就会从缓存中加载资源。</li>\n</ul>\n<h4 id=\"Etag-If-None-Match比较\"><a href=\"#Etag-If-None-Match比较\" class=\"headerlink\" title=\"Etag / If-None-Match比较\"></a>Etag / If-None-Match比较</h4><ul>\n<li>其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高</li>\n</ul>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><ul>\n<li>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：</li>\n<li>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</li>\n<li>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；</li>\n</ul>\n<h3 id=\"浏览器刷新与缓存方式：\"><a href=\"#浏览器刷新与缓存方式：\" class=\"headerlink\" title=\"浏览器刷新与缓存方式：\"></a>浏览器刷新与缓存方式：</h3><ul>\n<li>当ctrl+f5(command+shift+r)强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；<br>当f5(commond+r)刷新网页时，跳过强缓存，但是会检查协商缓存</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA\">https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=402202185&amp;idx=3&amp;sn=abbc03511d2c393d7a4867ff532224ab&amp;scene=21#wechat_redirect\">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=402202185&amp;idx=3&amp;sn=abbc03511d2c393d7a4867ff532224ab&amp;scene=21#wechat_redirect</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651221145&amp;idx=1&amp;sn=ce8cc0dd80142980026eb156d5b1f269&amp;scene=21#wechat_redirect\">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651221145&amp;idx=1&amp;sn=ce8cc0dd80142980026eb156d5b1f269&amp;scene=21#wechat_redirect</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226347&amp;idx=1&amp;sn=6dbccc54406f0b075671884b738b1e88&amp;chksm=bd49596f8a3ed079f79cda4b90ac3cb3b1dbdb5bfb8aade962a16a323563bf26a0c75b0a5d7b&amp;scene=21#wechat_redirect\">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226347&amp;idx=1&amp;sn=6dbccc54406f0b075671884b738b1e88&amp;chksm=bd49596f8a3ed079f79cda4b90ac3cb3b1dbdb5bfb8aade962a16a323563bf26a0c75b0a5d7b&amp;scene=21#wechat_redirect</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://crazyaguai.github.io/images/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98.png\" alt=\"image\"></p>\n<h3 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h3><ul>\n<li>当浏览器对某个资源的请求命中了强制缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。</li>\n</ul>\n<h3 id=\"Expires：\"><a href=\"#Expires：\" class=\"headerlink\" title=\"Expires：\"></a>Expires：</h3><ul>\n<li>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：</li>\n</ul>\n<ol>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header。</li>\n<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；</li>\n</ol>\n<ul>\n<li>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题。</li>\n</ul>\n<h3 id=\"Cache-Control：\"><a href=\"#Cache-Control：\" class=\"headerlink\" title=\"Cache-Control：\"></a>Cache-Control：</h3><ul>\n<li><p>Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示</p>\n</li>\n<li><p>参数：</p>\n</li>\n</ul>\n<ol>\n<li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li>\n<li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li>\n<li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>\n<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>\n<li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li>\n<li>s-maxage=xxx：代理服务器的缓存时间</li>\n</ol>\n<h3 id=\"缓存原理：\"><a href=\"#缓存原理：\" class=\"headerlink\" title=\"缓存原理：\"></a>缓存原理：</h3><ol>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header</li>\n<li>浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</li>\n<li>浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</li>\n<li>如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</li>\n</ol>\n<h3 id=\"Cache-Control与Expires不同\"><a href=\"#Cache-Control与Expires不同\" class=\"headerlink\" title=\"Cache-Control与Expires不同\"></a>Cache-Control与Expires不同</h3><ul>\n<li>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</li>\n<li>Cache-Control优先级高于Expires。</li>\n</ul>\n<h3 id=\"启用强制缓存\"><a href=\"#启用强制缓存\" class=\"headerlink\" title=\"启用强制缓存\"></a>启用强制缓存</h3><ul>\n<li>通常有2种方式来设置是否启用强缓存：</li>\n</ul>\n<ol>\n<li>通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</li>\n<li>通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。</li>\n</ol>\n<h3 id=\"from-memory-cache与from-disk-cache\"><a href=\"#from-memory-cache与from-disk-cache\" class=\"headerlink\" title=\"from memory cache与from disk cache\"></a>from memory cache与from disk cache</h3><ul>\n<li>from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</li>\n<li>对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:</li>\n</ul>\n<h4 id=\"内存缓存-from-memory-cache-：\"><a href=\"#内存缓存-from-memory-cache-：\" class=\"headerlink\" title=\"内存缓存(from memory cache)：\"></a>内存缓存(from memory cache)：</h4><ul>\n<li>内存缓存具有两个特点，分别是快速读取和时效性：</li>\n<li>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</li>\n<li>时效性：一旦该进程关闭，则该进程的内存则会清空。</li>\n</ul>\n<h4 id=\"硬盘缓存-from-disk-cache-：\"><a href=\"#硬盘缓存-from-disk-cache-：\" class=\"headerlink\" title=\"硬盘缓存(from disk cache)：\"></a>硬盘缓存(from disk cache)：</h4><ul>\n<li>硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</li>\n<li>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</li>\n</ul>\n<h3 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h3><ul>\n<li>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。</li>\n<li>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</li>\n</ul>\n<h4 id=\"【Last-Modified，If-Modified-Since】\"><a href=\"#【Last-Modified，If-Modified-Since】\" class=\"headerlink\" title=\"【Last-Modified，If-Modified-Since】\"></a>【Last-Modified，If-Modified-Since】</h4><ul>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间。</li>\n<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值。</li>\n<li>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 NotModified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header。</li>\n<li>浏览器收到304的响应后，就会从缓存中加载资源。</li>\n<li>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</li>\n</ul>\n<h4 id=\"【ETag、If-None-Match】\"><a href=\"#【ETag、If-None-Match】\" class=\"headerlink\" title=\"【ETag、If-None-Match】\"></a>【ETag、If-None-Match】</h4><ul>\n<li>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题。</li>\n<li>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值。</li>\n<li>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。<br>浏览器收到304的响应后，就会从缓存中加载资源。</li>\n</ul>\n<h4 id=\"Etag-If-None-Match比较\"><a href=\"#Etag-If-None-Match比较\" class=\"headerlink\" title=\"Etag / If-None-Match比较\"></a>Etag / If-None-Match比较</h4><ul>\n<li>其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高</li>\n</ul>\n<h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><ul>\n<li>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：</li>\n<li>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</li>\n<li>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；</li>\n</ul>\n<h3 id=\"浏览器刷新与缓存方式：\"><a href=\"#浏览器刷新与缓存方式：\" class=\"headerlink\" title=\"浏览器刷新与缓存方式：\"></a>浏览器刷新与缓存方式：</h3><ul>\n<li>当ctrl+f5(command+shift+r)强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；<br>当f5(commond+r)刷新网页时，跳过强缓存，但是会检查协商缓存</li>\n</ul>\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA\">https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=402202185&amp;idx=3&amp;sn=abbc03511d2c393d7a4867ff532224ab&amp;scene=21#wechat_redirect\">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=402202185&amp;idx=3&amp;sn=abbc03511d2c393d7a4867ff532224ab&amp;scene=21#wechat_redirect</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651221145&amp;idx=1&amp;sn=ce8cc0dd80142980026eb156d5b1f269&amp;scene=21#wechat_redirect\">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651221145&amp;idx=1&amp;sn=ce8cc0dd80142980026eb156d5b1f269&amp;scene=21#wechat_redirect</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226347&amp;idx=1&amp;sn=6dbccc54406f0b075671884b738b1e88&amp;chksm=bd49596f8a3ed079f79cda4b90ac3cb3b1dbdb5bfb8aade962a16a323563bf26a0c75b0a5d7b&amp;scene=21#wechat_redirect\">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226347&amp;idx=1&amp;sn=6dbccc54406f0b075671884b738b1e88&amp;chksm=bd49596f8a3ed079f79cda4b90ac3cb3b1dbdb5bfb8aade962a16a323563bf26a0c75b0a5d7b&amp;scene=21#wechat_redirect</a></li>\n</ul>\n"},{"title":"<算法>一些排序算法","date":"2019-03-02T16:00:00.000Z","_content":"\n### 效率比较\n\n```\n//---------------------------------------------------------------\n//| 排序算法 | 平均情况         | 最好情况   | 最坏情况   | 稳定性 |\n//---------------------------------------------------------------\n//| 冒泡排序 |  O(n²)          |  O(n)     |  O(n²)    | 稳定   |\n//---------------------------------------------------------------\n//| 选择排序 |  O(n²)          |  O(n²)    |  O(n²)    | 不稳定 |\n//---------------------------------------------------------------\n//| 插入排序 |  O(n²)          |  O(n)     |  O(n²)    | 稳定   |\n//---------------------------------------------------------------\n//| 希尔排序 |  O(nlogn)~O(n²) |  O(n^1.5) |  O(n²)    | 不稳定 |\n//---------------------------------------------------------------\n//| 归并排序 |  O(nlogn)       |  O(nlogn) |  O(nlogn) | 稳定   |\n//---------------------------------------------------------------\n//| 快速排序 |  O(nlogn)       |  O(nlogn) |  O(n²)    | 不稳定 |\n//---------------------------------------------------------------\n```\n\n### 冒泡排序\n\n- 步骤\n\n1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n3. 针对所有的元素重复以上的步骤，除了最后一个。\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n- 小到大排序：大的向上冒泡移动\n\n```javascript\nfunction bableSort(arr = []) {\n  const len = arr.length;\n  if (len < 2) {\n    return arr;\n  }\n  for (let i = len - 1; i > 0; i--) {\n    let change = false;\n    for (let j = 0; j < i; j++) {\n      let a = arr[j];\n      let b = arr[j + 1];\n      if (a > b) {\n        arr[j] = b;\n        arr[j + 1] = a;\n        change = true;\n      }\n    }\n    // 如果没有交换，不需要继续处理\n    if (!change) {\n      break;\n    }\n  }\n  return arr;\n}\n```\n\n### 选择排序\n\n- 步骤\n\n1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n3. 重复第二步，直到所有元素均排序完毕。\n\n- 小到大排序：从首位开始，依次找到剩余最小的交换\n\n```javascript\nfunction selectSort(arr = []) {\n  const len = arr.length;\n  if (len < 2) {\n    return arr;\n  }\n  for (let i = 0; i < len; i++) {\n    const temp = arr[i];\n    let minIndex = i;\n    for (let j = i + 1; j < len; j++) {\n      if (arr[minIndex] > arr[j]) {\n        minIndex = j;\n      }\n    }\n    if (i !== minIndex) {\n      arr[i] = arr[minIndex];\n      arr[minIndex] = temp;\n    }\n  }\n  return arr;\n}\n```\n\n### 插入排序\n\n- 步骤\n\n1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n\n- 小到大排序：从第二位开始，缓存当前值，向前寻找，如果值比缓存值大，移动位置，最后插入合适位置\n\n```javascript\nfunction insertSort(arr) {\n  let len = arr.length;\n  if (len < 2) {\n    return arr;\n  }\n  for (let i = 1; i < len; i++) {\n    let j = i;\n    const temp = arr[i];\n    while (j > 0 && arr[j - 1] > temp) {\n      //寻找第 i 项应该插入位置\n      arr[j] = arr[j - 1]; // 移动数据，空出位置\n      j--;\n    }\n    arr[j] = temp;\n  }\n  return arr;\n}\n```\n\n### 快速排序\n\n- 步骤\n\n1. 从数列中挑出一个元素，称为 “基准”（pivot）\n2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作\n3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序\n\n```javascript\nfunction quickSort(arr = []) {\n  const len = arr.length;\n  if (len < 2) {\n    return [];\n  }\n  // 找基准\n  const index = Math.floor(len / 2);\n  const indexVal = arr.splice(index, 1)[0]; // 原数组排除基准\n  const left = [];\n  const right = [];\n  for (let d of arr) {\n    if (d < indexVal) {\n      left.push(d);\n    } else {\n      right.push(d);\n    }\n  }\n  //递归调用，并拼接数组\n  return quickSort(left).concat(indexVal).concat(right);\n}\n```\n\n- 三路快排：添加等于基准的数组\n\n```javascript\nfunction quickSort(arr = []) {\n  const len = arr.length;\n  if (len < 2) {\n    return [];\n  }\n  const index = Math.floor(len / 2);\n  const indexVal = arr.splice(index, 1)[0];\n  const left = [];\n  const center = [indexVal]; // 添加等于基准数组\n  const right = [];\n  for (let d of arr) {\n    if (d < indexVal) {\n      left.push(d);\n    } else if (d === indexVal) {\n      center.push(d);\n    } else {\n      right.push(d);\n    }\n  }\n  return quickSort(left).concat(center).concat(right);\n}\n```\n\n### 归并排序\n\n- firefox safary Arr.sort()使用归并排序实现\n- 步骤\n\n1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n4. 重复步骤 3 直到某一指针达到序列尾；\n5. 将另一序列剩下的所有元素直接复制到合并序列尾。\n\n```javascript\nfunction merge(left, right) {\n  //将两个有序的数组合并\n  let result = [];\n  while (left.length > 0 && right.length > 0) {\n    if (left[0] < right[0]) {\n      result.push(left.shift());\n    } else {\n      result.push(right.shift());\n    }\n  }\n  return result.concat(left).concat(right);\n}\nfunction mergeSort(arr) {\n  //将数组分开\n  if (arr.length == 1) {\n    return arr;\n  }\n  let middle = Math.floor(arr.length / 2),\n    left = arr.slice(0, middle),\n    right = arr.slice(middle);\n  return merge(mergeSort(left), mergeSort(right));\n}\n```\n\n### 希尔排序\n\n- 步骤\n\n1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；\n2. 按增量序列个数 k，对序列进行 k 趟排序；\n3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n```javascript\nfunction shellSort(arr) {\n  if (arr.length < 2) {\n    return arr;\n  }\n  let n = arr.length;\n  let temp;\n  for (gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {\n    for (i = gap; i < n; ++i) {\n      for (j = i - gap; j >= 0 && arr[j + gap] < arr[j]; j -= gap) {\n        temp = arr[j];\n        arr[j] = arr[j + gap];\n        arr[j + gap] = temp;\n      }\n    }\n  }\n  return arr;\n}\n```\n\n### 参考\n\n- http://www.admin10000.com/document/19841.html\n- https://cloud.tencent.com/developer/article/1113549\n- https://cloud.tencent.com/developer/article/1022586\n","source":"_posts/[算法]一些排序算法.md","raw":"---\ntitle: <算法>一些排序算法\ndate: 2019-03-03 00:00:00\ntags: [js,算法]\ncategories: 算法\n---\n\n### 效率比较\n\n```\n//---------------------------------------------------------------\n//| 排序算法 | 平均情况         | 最好情况   | 最坏情况   | 稳定性 |\n//---------------------------------------------------------------\n//| 冒泡排序 |  O(n²)          |  O(n)     |  O(n²)    | 稳定   |\n//---------------------------------------------------------------\n//| 选择排序 |  O(n²)          |  O(n²)    |  O(n²)    | 不稳定 |\n//---------------------------------------------------------------\n//| 插入排序 |  O(n²)          |  O(n)     |  O(n²)    | 稳定   |\n//---------------------------------------------------------------\n//| 希尔排序 |  O(nlogn)~O(n²) |  O(n^1.5) |  O(n²)    | 不稳定 |\n//---------------------------------------------------------------\n//| 归并排序 |  O(nlogn)       |  O(nlogn) |  O(nlogn) | 稳定   |\n//---------------------------------------------------------------\n//| 快速排序 |  O(nlogn)       |  O(nlogn) |  O(n²)    | 不稳定 |\n//---------------------------------------------------------------\n```\n\n### 冒泡排序\n\n- 步骤\n\n1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。\n2. 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。\n3. 针对所有的元素重复以上的步骤，除了最后一个。\n4. 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。\n\n- 小到大排序：大的向上冒泡移动\n\n```javascript\nfunction bableSort(arr = []) {\n  const len = arr.length;\n  if (len < 2) {\n    return arr;\n  }\n  for (let i = len - 1; i > 0; i--) {\n    let change = false;\n    for (let j = 0; j < i; j++) {\n      let a = arr[j];\n      let b = arr[j + 1];\n      if (a > b) {\n        arr[j] = b;\n        arr[j + 1] = a;\n        change = true;\n      }\n    }\n    // 如果没有交换，不需要继续处理\n    if (!change) {\n      break;\n    }\n  }\n  return arr;\n}\n```\n\n### 选择排序\n\n- 步骤\n\n1. 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置\n2. 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。\n3. 重复第二步，直到所有元素均排序完毕。\n\n- 小到大排序：从首位开始，依次找到剩余最小的交换\n\n```javascript\nfunction selectSort(arr = []) {\n  const len = arr.length;\n  if (len < 2) {\n    return arr;\n  }\n  for (let i = 0; i < len; i++) {\n    const temp = arr[i];\n    let minIndex = i;\n    for (let j = i + 1; j < len; j++) {\n      if (arr[minIndex] > arr[j]) {\n        minIndex = j;\n      }\n    }\n    if (i !== minIndex) {\n      arr[i] = arr[minIndex];\n      arr[minIndex] = temp;\n    }\n  }\n  return arr;\n}\n```\n\n### 插入排序\n\n- 步骤\n\n1. 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。\n2. 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）\n\n- 小到大排序：从第二位开始，缓存当前值，向前寻找，如果值比缓存值大，移动位置，最后插入合适位置\n\n```javascript\nfunction insertSort(arr) {\n  let len = arr.length;\n  if (len < 2) {\n    return arr;\n  }\n  for (let i = 1; i < len; i++) {\n    let j = i;\n    const temp = arr[i];\n    while (j > 0 && arr[j - 1] > temp) {\n      //寻找第 i 项应该插入位置\n      arr[j] = arr[j - 1]; // 移动数据，空出位置\n      j--;\n    }\n    arr[j] = temp;\n  }\n  return arr;\n}\n```\n\n### 快速排序\n\n- 步骤\n\n1. 从数列中挑出一个元素，称为 “基准”（pivot）\n2. 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作\n3. 递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序\n\n```javascript\nfunction quickSort(arr = []) {\n  const len = arr.length;\n  if (len < 2) {\n    return [];\n  }\n  // 找基准\n  const index = Math.floor(len / 2);\n  const indexVal = arr.splice(index, 1)[0]; // 原数组排除基准\n  const left = [];\n  const right = [];\n  for (let d of arr) {\n    if (d < indexVal) {\n      left.push(d);\n    } else {\n      right.push(d);\n    }\n  }\n  //递归调用，并拼接数组\n  return quickSort(left).concat(indexVal).concat(right);\n}\n```\n\n- 三路快排：添加等于基准的数组\n\n```javascript\nfunction quickSort(arr = []) {\n  const len = arr.length;\n  if (len < 2) {\n    return [];\n  }\n  const index = Math.floor(len / 2);\n  const indexVal = arr.splice(index, 1)[0];\n  const left = [];\n  const center = [indexVal]; // 添加等于基准数组\n  const right = [];\n  for (let d of arr) {\n    if (d < indexVal) {\n      left.push(d);\n    } else if (d === indexVal) {\n      center.push(d);\n    } else {\n      right.push(d);\n    }\n  }\n  return quickSort(left).concat(center).concat(right);\n}\n```\n\n### 归并排序\n\n- firefox safary Arr.sort()使用归并排序实现\n- 步骤\n\n1. 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；\n2. 设定两个指针，最初位置分别为两个已经排序序列的起始位置；\n3. 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；\n4. 重复步骤 3 直到某一指针达到序列尾；\n5. 将另一序列剩下的所有元素直接复制到合并序列尾。\n\n```javascript\nfunction merge(left, right) {\n  //将两个有序的数组合并\n  let result = [];\n  while (left.length > 0 && right.length > 0) {\n    if (left[0] < right[0]) {\n      result.push(left.shift());\n    } else {\n      result.push(right.shift());\n    }\n  }\n  return result.concat(left).concat(right);\n}\nfunction mergeSort(arr) {\n  //将数组分开\n  if (arr.length == 1) {\n    return arr;\n  }\n  let middle = Math.floor(arr.length / 2),\n    left = arr.slice(0, middle),\n    right = arr.slice(middle);\n  return merge(mergeSort(left), mergeSort(right));\n}\n```\n\n### 希尔排序\n\n- 步骤\n\n1. 选择一个增量序列 t1，t2，……，tk，其中 ti > tj, tk = 1；\n2. 按增量序列个数 k，对序列进行 k 趟排序；\n3. 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。\n\n```javascript\nfunction shellSort(arr) {\n  if (arr.length < 2) {\n    return arr;\n  }\n  let n = arr.length;\n  let temp;\n  for (gap = Math.floor(n / 2); gap > 0; gap = Math.floor(gap / 2)) {\n    for (i = gap; i < n; ++i) {\n      for (j = i - gap; j >= 0 && arr[j + gap] < arr[j]; j -= gap) {\n        temp = arr[j];\n        arr[j] = arr[j + gap];\n        arr[j + gap] = temp;\n      }\n    }\n  }\n  return arr;\n}\n```\n\n### 参考\n\n- http://www.admin10000.com/document/19841.html\n- https://cloud.tencent.com/developer/article/1113549\n- https://cloud.tencent.com/developer/article/1022586\n","slug":"[算法]一些排序算法","published":1,"updated":"2021-03-15T14:35:32.515Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dlm005owotjh1qq75yr","content":"<h3 id=\"效率比较\"><a href=\"#效率比较\" class=\"headerlink\" title=\"效率比较\"></a>效率比较</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;| 排序算法 | 平均情况         | 最好情况   | 最坏情况   | 稳定性 |</span><br><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;| 冒泡排序 |  O(n²)          |  O(n)     |  O(n²)    | 稳定   |</span><br><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;| 选择排序 |  O(n²)          |  O(n²)    |  O(n²)    | 不稳定 |</span><br><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;| 插入排序 |  O(n²)          |  O(n)     |  O(n²)    | 稳定   |</span><br><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;| 希尔排序 |  O(nlogn)~O(n²) |  O(n^1.5) |  O(n²)    | 不稳定 |</span><br><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;| 归并排序 |  O(nlogn)       |  O(nlogn) |  O(nlogn) | 稳定   |</span><br><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;| 快速排序 |  O(nlogn)       |  O(nlogn) |  O(n²)    | 不稳定 |</span><br><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li>步骤</li>\n</ul>\n<ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>\n</ol>\n<ul>\n<li>小到大排序：大的向上冒泡移动</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bableSort</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = len - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> change = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> a = arr[j];</span><br><span class=\"line\">      <span class=\"keyword\">let</span> b = arr[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (a &gt; b) &#123;</span><br><span class=\"line\">        arr[j] = b;</span><br><span class=\"line\">        arr[j + <span class=\"number\">1</span>] = a;</span><br><span class=\"line\">        change = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果没有交换，不需要继续处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!change) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><ul>\n<li>步骤</li>\n</ul>\n<ol>\n<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>\n<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>\n<li>重复第二步，直到所有元素均排序完毕。</li>\n</ol>\n<ul>\n<li>小到大排序：从首位开始，依次找到剩余最小的交换</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectSort</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> temp = arr[i];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> minIndex = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class=\"line\">        minIndex = j;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i !== minIndex) &#123;</span><br><span class=\"line\">      arr[i] = arr[minIndex];</span><br><span class=\"line\">      arr[minIndex] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><ul>\n<li>步骤</li>\n</ul>\n<ol>\n<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>\n<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>\n</ol>\n<ul>\n<li>小到大排序：从第二位开始，缓存当前值，向前寻找，如果值比缓存值大，移动位置，最后插入合适位置</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> j = i;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> temp = arr[i];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; arr[j - <span class=\"number\">1</span>] &gt; temp) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//寻找第 i 项应该插入位置</span></span><br><span class=\"line\">      arr[j] = arr[j - <span class=\"number\">1</span>]; <span class=\"comment\">// 移动数据，空出位置</span></span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[j] = temp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li>步骤</li>\n</ul>\n<ol>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 找基准</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> index = <span class=\"built_in\">Math</span>.floor(len / <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> indexVal = arr.splice(index, <span class=\"number\">1</span>)[<span class=\"number\">0</span>]; <span class=\"comment\">// 原数组排除基准</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> left = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> right = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> d <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (d &lt; indexVal) &#123;</span><br><span class=\"line\">      left.push(d);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      right.push(d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//递归调用，并拼接数组</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> quickSort(left).concat(indexVal).concat(right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>三路快排：添加等于基准的数组</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> index = <span class=\"built_in\">Math</span>.floor(len / <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> indexVal = arr.splice(index, <span class=\"number\">1</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> left = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> center = [indexVal]; <span class=\"comment\">// 添加等于基准数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> right = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> d <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (d &lt; indexVal) &#123;</span><br><span class=\"line\">      left.push(d);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (d === indexVal) &#123;</span><br><span class=\"line\">      center.push(d);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      right.push(d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quickSort(left).concat(center).concat(right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><ul>\n<li>firefox safary Arr.sort()使用归并排序实现</li>\n<li>步骤</li>\n</ul>\n<ol>\n<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>\n<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>\n<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>\n<li>重复步骤 3 直到某一指针达到序列尾；</li>\n<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">left, right</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//将两个有序的数组合并</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left.length &gt; <span class=\"number\">0</span> &amp;&amp; right.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left[<span class=\"number\">0</span>] &lt; right[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">      result.push(left.shift());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result.push(right.shift());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.concat(left).concat(right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//将数组分开</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> middle = <span class=\"built_in\">Math</span>.floor(arr.length / <span class=\"number\">2</span>),</span><br><span class=\"line\">    left = arr.slice(<span class=\"number\">0</span>, middle),</span><br><span class=\"line\">    right = arr.slice(middle);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><ul>\n<li>步骤</li>\n</ul>\n<ol>\n<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li>\n<li>按增量序列个数 k，对序列进行 k 趟排序；</li>\n<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shellSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (gap = <span class=\"built_in\">Math</span>.floor(n / <span class=\"number\">2</span>); gap &gt; <span class=\"number\">0</span>; gap = <span class=\"built_in\">Math</span>.floor(gap / <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = gap; i &lt; n; ++i) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (j = i - gap; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j + gap] &lt; arr[j]; j -= gap) &#123;</span><br><span class=\"line\">        temp = arr[j];</span><br><span class=\"line\">        arr[j] = arr[j + gap];</span><br><span class=\"line\">        arr[j + gap] = temp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://www.admin10000.com/document/19841.html\">http://www.admin10000.com/document/19841.html</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1113549\">https://cloud.tencent.com/developer/article/1113549</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1022586\">https://cloud.tencent.com/developer/article/1022586</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"效率比较\"><a href=\"#效率比较\" class=\"headerlink\" title=\"效率比较\"></a>效率比较</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;| 排序算法 | 平均情况         | 最好情况   | 最坏情况   | 稳定性 |</span><br><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;| 冒泡排序 |  O(n²)          |  O(n)     |  O(n²)    | 稳定   |</span><br><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;| 选择排序 |  O(n²)          |  O(n²)    |  O(n²)    | 不稳定 |</span><br><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;| 插入排序 |  O(n²)          |  O(n)     |  O(n²)    | 稳定   |</span><br><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;| 希尔排序 |  O(nlogn)~O(n²) |  O(n^1.5) |  O(n²)    | 不稳定 |</span><br><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;| 归并排序 |  O(nlogn)       |  O(nlogn) |  O(nlogn) | 稳定   |</span><br><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br><span class=\"line\">&#x2F;&#x2F;| 快速排序 |  O(nlogn)       |  O(nlogn) |  O(n²)    | 不稳定 |</span><br><span class=\"line\">&#x2F;&#x2F;---------------------------------------------------------------</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li>步骤</li>\n</ul>\n<ol>\n<li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li>\n<li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li>\n<li>针对所有的元素重复以上的步骤，除了最后一个。</li>\n<li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li>\n</ol>\n<ul>\n<li>小到大排序：大的向上冒泡移动</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">bableSort</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = len - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> change = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">let</span> a = arr[j];</span><br><span class=\"line\">      <span class=\"keyword\">let</span> b = arr[j + <span class=\"number\">1</span>];</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (a &gt; b) &#123;</span><br><span class=\"line\">        arr[j] = b;</span><br><span class=\"line\">        arr[j + <span class=\"number\">1</span>] = a;</span><br><span class=\"line\">        change = <span class=\"literal\">true</span>;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// 如果没有交换，不需要继续处理</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!change) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">break</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><ul>\n<li>步骤</li>\n</ul>\n<ol>\n<li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li>\n<li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li>\n<li>重复第二步，直到所有元素均排序完毕。</li>\n</ol>\n<ul>\n<li>小到大排序：从首位开始，依次找到剩余最小的交换</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">selectSort</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">0</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> temp = arr[i];</span><br><span class=\"line\">    <span class=\"keyword\">let</span> minIndex = i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> j = i + <span class=\"number\">1</span>; j &lt; len; j++) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">if</span> (arr[minIndex] &gt; arr[j]) &#123;</span><br><span class=\"line\">        minIndex = j;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (i !== minIndex) &#123;</span><br><span class=\"line\">      arr[i] = arr[minIndex];</span><br><span class=\"line\">      arr[minIndex] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><ul>\n<li>步骤</li>\n</ul>\n<ol>\n<li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li>\n<li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li>\n</ol>\n<ul>\n<li>小到大排序：从第二位开始，缓存当前值，向前寻找，如果值比缓存值大，移动位置，最后插入合适位置</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">insertSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> i = <span class=\"number\">1</span>; i &lt; len; i++) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">let</span> j = i;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> temp = arr[i];</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (j &gt; <span class=\"number\">0</span> &amp;&amp; arr[j - <span class=\"number\">1</span>] &gt; temp) &#123;</span><br><span class=\"line\">      <span class=\"comment\">//寻找第 i 项应该插入位置</span></span><br><span class=\"line\">      arr[j] = arr[j - <span class=\"number\">1</span>]; <span class=\"comment\">// 移动数据，空出位置</span></span><br><span class=\"line\">      j--;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    arr[j] = temp;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li>步骤</li>\n</ul>\n<ol>\n<li>从数列中挑出一个元素，称为 “基准”（pivot）</li>\n<li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作</li>\n<li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">// 找基准</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> index = <span class=\"built_in\">Math</span>.floor(len / <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> indexVal = arr.splice(index, <span class=\"number\">1</span>)[<span class=\"number\">0</span>]; <span class=\"comment\">// 原数组排除基准</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> left = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> right = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> d <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (d &lt; indexVal) &#123;</span><br><span class=\"line\">      left.push(d);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      right.push(d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//递归调用，并拼接数组</span></span><br><span class=\"line\">  <span class=\"keyword\">return</span> quickSort(left).concat(indexVal).concat(right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>三路快排：添加等于基准的数组</li>\n</ul>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">quickSort</span>(<span class=\"params\">arr = []</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> len = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (len &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> [];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">const</span> index = <span class=\"built_in\">Math</span>.floor(len / <span class=\"number\">2</span>);</span><br><span class=\"line\">  <span class=\"keyword\">const</span> indexVal = arr.splice(index, <span class=\"number\">1</span>)[<span class=\"number\">0</span>];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> left = [];</span><br><span class=\"line\">  <span class=\"keyword\">const</span> center = [indexVal]; <span class=\"comment\">// 添加等于基准数组</span></span><br><span class=\"line\">  <span class=\"keyword\">const</span> right = [];</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (<span class=\"keyword\">let</span> d <span class=\"keyword\">of</span> arr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (d &lt; indexVal) &#123;</span><br><span class=\"line\">      left.push(d);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (d === indexVal) &#123;</span><br><span class=\"line\">      center.push(d);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      right.push(d);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> quickSort(left).concat(center).concat(right);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3><ul>\n<li>firefox safary Arr.sort()使用归并排序实现</li>\n<li>步骤</li>\n</ul>\n<ol>\n<li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li>\n<li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li>\n<li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li>\n<li>重复步骤 3 直到某一指针达到序列尾；</li>\n<li>将另一序列剩下的所有元素直接复制到合并序列尾。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">merge</span>(<span class=\"params\">left, right</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//将两个有序的数组合并</span></span><br><span class=\"line\">  <span class=\"keyword\">let</span> result = [];</span><br><span class=\"line\">  <span class=\"keyword\">while</span> (left.length &gt; <span class=\"number\">0</span> &amp;&amp; right.length &gt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (left[<span class=\"number\">0</span>] &lt; right[<span class=\"number\">0</span>]) &#123;</span><br><span class=\"line\">      result.push(left.shift());</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">      result.push(right.shift());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> result.concat(left).concat(right);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">mergeSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//将数组分开</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> middle = <span class=\"built_in\">Math</span>.floor(arr.length / <span class=\"number\">2</span>),</span><br><span class=\"line\">    left = arr.slice(<span class=\"number\">0</span>, middle),</span><br><span class=\"line\">    right = arr.slice(middle);</span><br><span class=\"line\">  <span class=\"keyword\">return</span> merge(mergeSort(left), mergeSort(right));</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><ul>\n<li>步骤</li>\n</ul>\n<ol>\n<li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li>\n<li>按增量序列个数 k，对序列进行 k 趟排序；</li>\n<li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li>\n</ol>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">shellSort</span>(<span class=\"params\">arr</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span> (arr.length &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> n = arr.length;</span><br><span class=\"line\">  <span class=\"keyword\">let</span> temp;</span><br><span class=\"line\">  <span class=\"keyword\">for</span> (gap = <span class=\"built_in\">Math</span>.floor(n / <span class=\"number\">2</span>); gap &gt; <span class=\"number\">0</span>; gap = <span class=\"built_in\">Math</span>.floor(gap / <span class=\"number\">2</span>)) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (i = gap; i &lt; n; ++i) &#123;</span><br><span class=\"line\">      <span class=\"keyword\">for</span> (j = i - gap; j &gt;= <span class=\"number\">0</span> &amp;&amp; arr[j + gap] &lt; arr[j]; j -= gap) &#123;</span><br><span class=\"line\">        temp = arr[j];</span><br><span class=\"line\">        arr[j] = arr[j + gap];</span><br><span class=\"line\">        arr[j + gap] = temp;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ul>\n<li><a href=\"http://www.admin10000.com/document/19841.html\">http://www.admin10000.com/document/19841.html</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1113549\">https://cloud.tencent.com/developer/article/1113549</a></li>\n<li><a href=\"https://cloud.tencent.com/developer/article/1022586\">https://cloud.tencent.com/developer/article/1022586</a></li>\n</ul>\n"},{"title":"<js>类型","date":"2019-03-02T16:00:00.000Z","_content":"\n### 类型\n\n#### 内置类型\n\n- 7种内置类型\n\nnull,undefined,object,string,number,boolean,symbol\n\n- 检查类型\n\n使用typeof检查，注意：\n\n```\ntypeof null//\"object\"\ntypeof []//\"object\"\ntypeof function(){}//\"function\"\n```\n\n#### 基本类型\n\nnull,undefined,string,number,boolean,symbol\n\n#### 值和类型\n\n- js中变量没有类型，值才有类型，变量可以随时持有任何类型的值。\n- 执行typeof时，得到的是变量持有值的类型。\n- undefined声明但还没有赋值的变量，undeclared作用域中还没有声明过得变量\n- 试图访问\"undeclared\" 变量时这样报错：ReferenceError: a is not defined， 并且typeof对undefined 和undeclared 变量都返回\"undefined\"。\n\n### 值\n\n#### 数组\n\n- 数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组（多维数组）\n- delete运算符可以删除数组元素，但是不会改变length\n- 类数组：DOM元素列表，arguments对象\n\n```\n//类数组转换为数组\nfunction f(){\n    let arr = Array.prototype.slice.call( arguments )\n    let arr1 = Array.from(arguments)//ES6\n}\n```\n\n#### 字符串\n\n- 字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。\n- 借用数组非变更方法处理字符串\n\n```\nlet a = '123'\nlet b = Array.prototype.join.call(a,'_')\nconsole.log(a)//123\nconsole.log(b)//1_2_3\n```\n\n- 数组有一个字符串没有的可变更成员函数reverse()，反转数组。\n\n```\n//实现字符串反转\nlet a = '123'\nlet b = a.split('').reverse().join('')\nconsole.log(a)//123\nconsole.log(b)//321\n```\n\n#### 数字\n\n- 0.1 + 0.2是一个比较接近的数字0.30000000000000004\n- 机器精度：js中2^-52 (2.220446049250313e-16)，ES6中该值定义在Number.EPSILON中\n- 安全范围：最大整数是2^53 - 1（Number.MAX_SAFE_INTEGER），最整数（-2^53 - 1）-9007199254740991（Number.\nMIN_SAFE_INTEGER）\n- 检测整数：Number.isInteger() 方法\n- 检测安全整数：Number.isSafeInteger()\n\n#### 特殊的值\n\n1. undefined,null\n\n- null 指空值（empty value），undefined 指没有值（missing value）\n- 不要给全局标识符undefined赋值\n\n2. 特殊数字\n\n- NaN：理解为“无效数值”“失败数值”或者“坏数值\n- NaN和自身不相等，isNaN() 来判断一个值是否是NaN，ES6可以使用Number.isNaN()判断\n- Object.is(NaN,NaN)返回true\n- 无穷数：\n\n```\nlet a = 1 / 0; // Infinity\nlet b = -1 / 0; // -Infinity\n```\n\n- 0值：0和-0\n- 加法和减法运算不会得到负零（negative zero）。\n\n```\nvar a = 0 / -3; // -0\nvar b = 0 * -3; // -0\n0===-0//true\nObject.is(0,-0)//false\n//判断-0\nfunction isNegZero(n) {\n    n = Number( n );\n    return (n === 0) && (1 / n === -Infinity);\n}\n```\n\n#### 值和引用\n\n- JavaScript 中的引用和其他语言中的引用/ 指针不同，它们不能指向别的变量/ 引用，只能指向值。\n- JavaScript引用指向的是值。如果一个值有10个引用，这些引用指向的都是同一个值，它们相互之间没有引/指向关系。\n- 简单值（即标量基本类型值，scalar primitive）总是通过**值复制**的方式来赋/传递，包括null、undefined、字符串、数字、布尔ES6中symbol。\n- 复合值（compound value）对象和函数，则总是通过**引用复制**的方式来赋/传递。\n- 我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定。\n\n### 原生函数\n\n#### 常用原生函数\n\n- 常用原生函数：String()，Number()，Boolean()，Array()，Object()，Function()，RegExp()，Date()，Error()，Symbol()\n- 原生函数可以当做构造函数使用，但是构造出来的是对象\n\n```\nlet s = new String('123')\n//，new String(\"123\")创建的是字符\"123\"的封装对象，而非基本类型\"123\"\nconsole.log(typeof s)//object\ns instanceof String; // true\nObject.prototype.toString.call( s ); // \"[object String]\"\n```\n\n#### 内部属性[[Class]]\n\n- 所typeof返回值\"object\"的对象（如数组）都包含一个内部属[[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类。\n- Object.prototype.toString()来查看[[Class]]\n- 多数情况，对象的内[[Class]]属性和创建该对象的内建原生构造函数相对应。\n\n```\nObject.prototype.toString.call( [1,2,3] );// \"[object Array]\"\n```\n\n- 虽Null()Undefined()这样的原生构造函数并不存在，但是内[[Class]]属性值仍然为\"Null\"和\"Undefined\"。\n\n```\nObject.prototype.toString.call( null );// \"[object Null]\"\nObject.prototype.toString.call( undefined );// \"[object Undefined]\"\n```\n\n#### 封装对象\n\n- 一般情况不直接使用封装对象，让js引擎自己决定使用。\n- 使用封装对象注意\n\n```\nlet a = new Boolean(false)\nif(a){//判断通过，因为a是对象，是真值（truthy）,不是false\n    console.log(123)\n}\n```\n\n- 自行封装基本类型，可以使用Object()（不带new关键字）\n\n```\nlet a = 'aaa'\nlet b = new String(a)\nlet c = Object(a)\nconsole.log(typeof a)//string\nconsole.log(typeof b)//object\nconsole.log(typeof c)//object\n```\n\n- 拆封：得到封装对象基本类型值，可以使用valueOf()函数\n\n```\nlet a = new Boolean(false)\nconsole.log(a)//Boolean {false}__proto__: Boolean[[PrimitiveValue]]: false\nconsole.log(a.valueOf())//false\n```\n\n#### 原生函数作为构造函数\n\n- 避免使用构造函数\n- 构造函数Array()，不要求带new关键字，会自己补上\n- Array()只带一个**数字参数**时，作为预设长度\n- ES5规范开始就允许在列表（数组值、属性列表等）末尾多加一个逗号，（在实际处理中会被忽略不计。\n- 永远不要创建使用空单元数组，会产生问题\n- RegExp()有时还是很有用的，比如动态定义正则表达式时。\n- Date()\n\n```\n(new Date()).getTime()\n+new Date()\nDate.now()\n```\n\n- Symbol：使Symbol()原生构造函数来自定义符号\n\n#### 原生原型\n\n- 原生构造函数有自己的.prototype对象，这些对象包含对应子类的行为特征\n- Function.prototype 是一个函数，RegExp.prototype 是一个正则表达式，而Array.prototype 是一个数组\n- 原型作为默认值\n\n```\nfunction f(val) {\n    val = val || Array.prototype\n}\n```\n\n### 强制类型转换\n\n#### 值类型转换\n\n- 显式类型转换，隐式类型转换（强制类型转换）\n- js中强制类型转换总是返回标量基本类型：字符串、数字、布尔值\n- 强制类型转换发生在动态语言的运行时\n\n#### 抽象值操作\n\n- 字符串、数字、布尔值之间类型转换的基本规则\n\n1. ToString\n\n- 负责处理非字符串到字符串的强制类型转换\n- 基本类型的规则：null->'null',undefined->'undefined',true->'true',数字遵循通用规则\n- 对于普通对象：非自定义情况下，toString()（Object.prototype.toString()）返回内部属性[[Class]]，如果自定义了toString()方法，调用该方法使用其返回值。\n- 数组：数字默认toString()重新定义，用,连接单元字符。\n- JSON字符串化：JSON.stringify()用到了toString()，不安全的JSON值（undefined,function.symbol,循环引用）不符合JSON解构标准，无法处理。\n- 如果对象中定义了toJSON()方法，会先调用该方法，然后将返回值序列化。\n- JSON.stringify()，可以传递一个可选参数replacer，数组或者函数，用来指定哪些属性被处理。第三个参数space，用来指定缩进格式\n\n```\nlet obj = {\n    a: {\n        b: 1\n    }\n}\nlet a = JSON.stringify(obj,function (k,v) {\n    return v\n})\nlet b = JSON.stringify(obj,['a','b'])\nconsole.log(a)//{\"a\":{\"b\":1}}\nconsole.log(b)//{\"a\":{\"b\":1}}\n```\n\n2. ToNumber\n\n- 非数字值当做数字使用，比如数学运算时\n- true->1,false->0,undefined->NaN,null->0\n- 处理字符串遵循数字常量规则，处理失败返回NaN，**''->0**\n- ToNumber对于0开头的16进制数按照十进制处理\n- 对象（包含数组）会先转换为相应的基本类型，如果是非数字的基本类型，再按照以上规则转换为数字\n- 为了将值转换为基本类型，抽象操作ToPromitive会先检查该值是否有valueOf()方法，如果有并且返回基本类型值，就使用该值进行强制类型转换，如果没有就使用toString()的返回值进行强制类型转换。\n- 如果valueOf()和toString()都不返回基本类型，会产生typeError错误\n- 使用Object.create(null)创建的对象[[Prototypr]]为null，没有valueOf(),toString()方法，因此无法进行强制类型转换。\n\n```\nNumber(new Boolean(''))//0,valueOf()->false,false->0\nNumber(new Array('22'))//22,toString()->'22','22'->22\n```\n\n3. ToBoolean\n\n- 虽然我们可以将1 强制类型转换为true，将0强制类型转换为false，反之亦然，但它们并不是一回事。\n- js中的值分为两类\n\n(1)可以被强制类型转换为false的值\n(2)其他（被强制类型转换为true的值）\n\n- 假值：**undefined,null,false,+0,-0,NaN,''**，假值的布尔类型强制转换为false\n- 假值对象（并非封装了假值的对象，比如new Boolean('')，而是js语法创建的外来值）：假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为false。\n\n```\n//封装了假值的对象\nconsole.log(Boolean(false))//false\n//document.all假值对象\nconsole.log(Boolean(document.all))//false\n```\n\n- 真值：真值就是假值列表之外的值\n\n### 显示强制类型转换\n\n#### 字符串和数字之间的显示转换\n\n- 字符串和数字之间的转换通过String(),和Number()连个内建函数实现的\n- String()遵循ToString规则，将值转换为字符串基本类型\n- Number()遵循ToNumber规则，将至转换为数字基本类型\n- a.toString(),+c转换\n- 日期显式转换为数字：+new Date(),(new Date()).getTime(),Date.now()\n- ~运算符（非运算符）：首先将值强制类型转换为32位数字，然后执行字位操作“非”（对每一个字位进行反转）。\n\n#### 显式解析数字字符串\n\n- 解析和转换的差别：解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回NaN。\n- 解析方法：parseInt(),parseFload()，针对字符串处理，注意传true等值会转换为字符串，第二个参数指定转换进制，默认为十进制\n\n```\n//parseInt会转换为字符串处理\nlet obj = {\n    toString(){\n        return '1'\n    }\n}\nconsole.log(parseInt(obj))\n```\n\n#### 显示转换为布尔值\n\n- Boolean()是显示的ToBoolean强制类型转换\n- 一元运算符!，显式地将值强制类型转换为布尔值\n- 因此最常用方法是!!\n\n### 隐式强制类型转换\n\n- 可以较少冗余，让代码更简洁\n\n#### 字符串与数字之间的隐式强制类型转换\n\n- +操作：如果某个操作数是字符串或者能够通过**以下步骤**转换为字符串的话，+ 将进行拼接操作，如果其中一个操作数是对象（包括数组），则首先对其调用ToPrimitive 抽象操作，该抽象操作再调用[[DefaultValue]]，以数字作为上下文。\n\n```\n//数组valueOf()无法得到简单基本类型，因此调用toString()转换为字符串，然后拼接\nlet a = [1,2]\nlet b = [3,4]\nconsole.log(a+b)//1,23,4\n```\n```\nlet obj = {\n    valueOf(){\n        return 1\n    },\n    toString(){\n        return '2'\n    }\n}\nconsole.log(obj+'1')//11,valueOf()返回基本类型1，然后1转换为字符串'1'拼接\n```\n\n- 如果+其中一个操作数是字符串（或者通过转换可以得到），则进行字符串拼接，否则进行数字加法。\n- 减法运算：a 和b 都需要被转换为数字\n\n#### 布尔值到数字的隐式强制类型转换\n\n- true->1,false->0\n\n```\nconsole.log(true+2)//3\n```\n\n#### 隐式强制类型转换为布尔值\n\n- 发生布尔值隐式强制类型转换（非布尔值转换为布尔值）的情况：\n\n(1) if (..) 语句中的条件判断表达式。\n(2) for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。\n(3) while (..) 和do..while(..) 循环中的条件判断表达式。\n(4) ? : 中的条件判断表达式。\n(5) 逻辑运算符||（逻辑或）和&&（逻辑与）左边的操作数（作为条件判断表达式）。\n\n- || 与 &&：js中称为选择器运算符更合适（不像其他语言的逻辑运算符），因为他们在js中的返回值不是布尔值，它们的返回值是两个操作数中的一个。\n- || 和&& 首先会对第一个操作数（a和c）执行条件判断，如果其不是布尔值（如上例）就先进行ToBoolean 强制类型转换，然后再执行条件判断。\n\n```\nlet a = 1\nlet b = a && 0\nlet c = b || 1\nconsole.log(b)//0\nconsole.log(c)//1\n```\n```\nvar a = 42;\nvar b = null;\nvar c = \"foo\";\nif (a && (b || c)) {\n    console.log( \"yep\" );\n}\n//这里a && (b || c) 的结果实际上是\"foo\"而非true，然后再由if将foo强制类型转换为布尔值，所以最后结果为true。\n```\n\n#### 符号（symbol）的强制类型转换\n\n- ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。\n- 符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是true）。\n\n### 宽松相等和严格相等\n\n- 对于两者差别的正确的解释是：“**== 允许在相等比较中进行强制类型转换，而=== 不允许。**”\n\n#### 抽象相等\n\n- 定义==运算符的行为\n- 特殊情况：NaN与NaN不相等，+0与-0相等\n\n1. 字符串和数字之间的比较\n\n- 规则\n\n(1) 如果Type(x) 是数字，Type(y) 是字符串，则返回x == ToNumber(y) 的结果。\n(2) 如果Type(x) 是字符串，Type(y) 是数字，则返回ToNumber(x) == y 的结果。\n\n2. 其他类型和布尔类型之间的比较\n\n- 规则\n\n(1) 如果Type(x) 是布尔类型，则返回ToNumber(x) == y 的结果；\n(2) 如果Type(y) 是布尔类型，则返回x == ToNumber(y) 的结果。\n\n- 真值假值与==没有关系\n- if判断中无论什么情况下都不要使用== true 和== false\n\n```\n'42' == true//false\n//true转换为数字1，与'42'比较，注意这里不涉及真值假值概念\n```\n\n3. null和undefined之间的比较\n\n- 规则\n\n(1) 如果x 为null，y 为undefined，则结果为true。\n(2) 如果x 为undefined，y 为null，则结果为true。\n\n4. 对象和非对象之间的相等比较\n\n- 规则\n\n(1) 如果Type(x) 是字符串或数字，Type(y) 是对象，则返回x == ToPrimitive(y) 的结果；\n(2) 如果Type(x) 是对象，Type(y) 是字符串或数字，则返回ToPromitive(x) == y 的结果。\n\n5. 少见情况\n\n- 返回其他数字，更改了valueOf()方法\n- 假值的相等比较\n\n```\n'0' == false//true，false先转换为数字0\nfalse == 0//true\nfalse == ''//true，false->0，''->0，再比较\nfalse == []//true\n'' == 0//true\n'' == []//true\n0 == []//true\n```\n\n- [] == ![]//true，![]->false\n- '' == [null]//true，[null].toString()->''\n- 0 == '\\n'//true，\"\"、\"\\n\"（或者\" \" 等其他空格组合）等空字符串被ToNumber 强制类型转换\n为0\n- 完整性检查：如果两边的值中有true 或者false，千万不要使用==。如果两边的值中有[]、\"\" 或者0，尽量不要使用==。\n\n6. 两个对象比较\n\n- 两个对象指向同一个值时即视为相等，不发生强制类型转换。\n\n```\nlet a = {}\nlet b = {}\nlet c = a\nconsole.log(a == b)//false\nconsole.log(a == c)//true，指向同一个值\n```\n\n### 抽象关系比较><\n\n#### 比较双方都是字符串\n\n- 按照字母顺序比较\n\n#### 其他情况\n\n- 比较双方首先调用ToPrimitive，**如果结果出现非字符串**，就根据ToNumber规则将双方强制类型转换为数字来进行比较。\n\n```\ntrue > 0//true，true->1比较\n```\n\n#### <= 与>=\n\n- 根据规范a <= b 被处理为b < a，然后将结果反转。因为b < a 的结果是false，所以a <= b 的结果是true\n- 实际上JavaScript 中<= 是“不大于”的意思（即!(a > b)，处理为!(b < a)）。同理a >= b 处理为b <= a。\n\n```\nlet a = {}\nlet b = {}\nconsole.log(a == b)//false，两个对象不指向同一个值，不相等\nconsole.log(a < b)//false\nconsole.log(a > b)//false\nconsole.log(a <= b)//true\nconsole.log(a >= b)//true\n```\n\n","source":"_posts/[js]类型.md","raw":"---\ntitle: <js>类型\ndate: 2019-03-03 00:00:00\ntags: [js,js类型]\ncategories: js\n---\n\n### 类型\n\n#### 内置类型\n\n- 7种内置类型\n\nnull,undefined,object,string,number,boolean,symbol\n\n- 检查类型\n\n使用typeof检查，注意：\n\n```\ntypeof null//\"object\"\ntypeof []//\"object\"\ntypeof function(){}//\"function\"\n```\n\n#### 基本类型\n\nnull,undefined,string,number,boolean,symbol\n\n#### 值和类型\n\n- js中变量没有类型，值才有类型，变量可以随时持有任何类型的值。\n- 执行typeof时，得到的是变量持有值的类型。\n- undefined声明但还没有赋值的变量，undeclared作用域中还没有声明过得变量\n- 试图访问\"undeclared\" 变量时这样报错：ReferenceError: a is not defined， 并且typeof对undefined 和undeclared 变量都返回\"undefined\"。\n\n### 值\n\n#### 数组\n\n- 数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组（多维数组）\n- delete运算符可以删除数组元素，但是不会改变length\n- 类数组：DOM元素列表，arguments对象\n\n```\n//类数组转换为数组\nfunction f(){\n    let arr = Array.prototype.slice.call( arguments )\n    let arr1 = Array.from(arguments)//ES6\n}\n```\n\n#### 字符串\n\n- 字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。\n- 借用数组非变更方法处理字符串\n\n```\nlet a = '123'\nlet b = Array.prototype.join.call(a,'_')\nconsole.log(a)//123\nconsole.log(b)//1_2_3\n```\n\n- 数组有一个字符串没有的可变更成员函数reverse()，反转数组。\n\n```\n//实现字符串反转\nlet a = '123'\nlet b = a.split('').reverse().join('')\nconsole.log(a)//123\nconsole.log(b)//321\n```\n\n#### 数字\n\n- 0.1 + 0.2是一个比较接近的数字0.30000000000000004\n- 机器精度：js中2^-52 (2.220446049250313e-16)，ES6中该值定义在Number.EPSILON中\n- 安全范围：最大整数是2^53 - 1（Number.MAX_SAFE_INTEGER），最整数（-2^53 - 1）-9007199254740991（Number.\nMIN_SAFE_INTEGER）\n- 检测整数：Number.isInteger() 方法\n- 检测安全整数：Number.isSafeInteger()\n\n#### 特殊的值\n\n1. undefined,null\n\n- null 指空值（empty value），undefined 指没有值（missing value）\n- 不要给全局标识符undefined赋值\n\n2. 特殊数字\n\n- NaN：理解为“无效数值”“失败数值”或者“坏数值\n- NaN和自身不相等，isNaN() 来判断一个值是否是NaN，ES6可以使用Number.isNaN()判断\n- Object.is(NaN,NaN)返回true\n- 无穷数：\n\n```\nlet a = 1 / 0; // Infinity\nlet b = -1 / 0; // -Infinity\n```\n\n- 0值：0和-0\n- 加法和减法运算不会得到负零（negative zero）。\n\n```\nvar a = 0 / -3; // -0\nvar b = 0 * -3; // -0\n0===-0//true\nObject.is(0,-0)//false\n//判断-0\nfunction isNegZero(n) {\n    n = Number( n );\n    return (n === 0) && (1 / n === -Infinity);\n}\n```\n\n#### 值和引用\n\n- JavaScript 中的引用和其他语言中的引用/ 指针不同，它们不能指向别的变量/ 引用，只能指向值。\n- JavaScript引用指向的是值。如果一个值有10个引用，这些引用指向的都是同一个值，它们相互之间没有引/指向关系。\n- 简单值（即标量基本类型值，scalar primitive）总是通过**值复制**的方式来赋/传递，包括null、undefined、字符串、数字、布尔ES6中symbol。\n- 复合值（compound value）对象和函数，则总是通过**引用复制**的方式来赋/传递。\n- 我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定。\n\n### 原生函数\n\n#### 常用原生函数\n\n- 常用原生函数：String()，Number()，Boolean()，Array()，Object()，Function()，RegExp()，Date()，Error()，Symbol()\n- 原生函数可以当做构造函数使用，但是构造出来的是对象\n\n```\nlet s = new String('123')\n//，new String(\"123\")创建的是字符\"123\"的封装对象，而非基本类型\"123\"\nconsole.log(typeof s)//object\ns instanceof String; // true\nObject.prototype.toString.call( s ); // \"[object String]\"\n```\n\n#### 内部属性[[Class]]\n\n- 所typeof返回值\"object\"的对象（如数组）都包含一个内部属[[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类。\n- Object.prototype.toString()来查看[[Class]]\n- 多数情况，对象的内[[Class]]属性和创建该对象的内建原生构造函数相对应。\n\n```\nObject.prototype.toString.call( [1,2,3] );// \"[object Array]\"\n```\n\n- 虽Null()Undefined()这样的原生构造函数并不存在，但是内[[Class]]属性值仍然为\"Null\"和\"Undefined\"。\n\n```\nObject.prototype.toString.call( null );// \"[object Null]\"\nObject.prototype.toString.call( undefined );// \"[object Undefined]\"\n```\n\n#### 封装对象\n\n- 一般情况不直接使用封装对象，让js引擎自己决定使用。\n- 使用封装对象注意\n\n```\nlet a = new Boolean(false)\nif(a){//判断通过，因为a是对象，是真值（truthy）,不是false\n    console.log(123)\n}\n```\n\n- 自行封装基本类型，可以使用Object()（不带new关键字）\n\n```\nlet a = 'aaa'\nlet b = new String(a)\nlet c = Object(a)\nconsole.log(typeof a)//string\nconsole.log(typeof b)//object\nconsole.log(typeof c)//object\n```\n\n- 拆封：得到封装对象基本类型值，可以使用valueOf()函数\n\n```\nlet a = new Boolean(false)\nconsole.log(a)//Boolean {false}__proto__: Boolean[[PrimitiveValue]]: false\nconsole.log(a.valueOf())//false\n```\n\n#### 原生函数作为构造函数\n\n- 避免使用构造函数\n- 构造函数Array()，不要求带new关键字，会自己补上\n- Array()只带一个**数字参数**时，作为预设长度\n- ES5规范开始就允许在列表（数组值、属性列表等）末尾多加一个逗号，（在实际处理中会被忽略不计。\n- 永远不要创建使用空单元数组，会产生问题\n- RegExp()有时还是很有用的，比如动态定义正则表达式时。\n- Date()\n\n```\n(new Date()).getTime()\n+new Date()\nDate.now()\n```\n\n- Symbol：使Symbol()原生构造函数来自定义符号\n\n#### 原生原型\n\n- 原生构造函数有自己的.prototype对象，这些对象包含对应子类的行为特征\n- Function.prototype 是一个函数，RegExp.prototype 是一个正则表达式，而Array.prototype 是一个数组\n- 原型作为默认值\n\n```\nfunction f(val) {\n    val = val || Array.prototype\n}\n```\n\n### 强制类型转换\n\n#### 值类型转换\n\n- 显式类型转换，隐式类型转换（强制类型转换）\n- js中强制类型转换总是返回标量基本类型：字符串、数字、布尔值\n- 强制类型转换发生在动态语言的运行时\n\n#### 抽象值操作\n\n- 字符串、数字、布尔值之间类型转换的基本规则\n\n1. ToString\n\n- 负责处理非字符串到字符串的强制类型转换\n- 基本类型的规则：null->'null',undefined->'undefined',true->'true',数字遵循通用规则\n- 对于普通对象：非自定义情况下，toString()（Object.prototype.toString()）返回内部属性[[Class]]，如果自定义了toString()方法，调用该方法使用其返回值。\n- 数组：数字默认toString()重新定义，用,连接单元字符。\n- JSON字符串化：JSON.stringify()用到了toString()，不安全的JSON值（undefined,function.symbol,循环引用）不符合JSON解构标准，无法处理。\n- 如果对象中定义了toJSON()方法，会先调用该方法，然后将返回值序列化。\n- JSON.stringify()，可以传递一个可选参数replacer，数组或者函数，用来指定哪些属性被处理。第三个参数space，用来指定缩进格式\n\n```\nlet obj = {\n    a: {\n        b: 1\n    }\n}\nlet a = JSON.stringify(obj,function (k,v) {\n    return v\n})\nlet b = JSON.stringify(obj,['a','b'])\nconsole.log(a)//{\"a\":{\"b\":1}}\nconsole.log(b)//{\"a\":{\"b\":1}}\n```\n\n2. ToNumber\n\n- 非数字值当做数字使用，比如数学运算时\n- true->1,false->0,undefined->NaN,null->0\n- 处理字符串遵循数字常量规则，处理失败返回NaN，**''->0**\n- ToNumber对于0开头的16进制数按照十进制处理\n- 对象（包含数组）会先转换为相应的基本类型，如果是非数字的基本类型，再按照以上规则转换为数字\n- 为了将值转换为基本类型，抽象操作ToPromitive会先检查该值是否有valueOf()方法，如果有并且返回基本类型值，就使用该值进行强制类型转换，如果没有就使用toString()的返回值进行强制类型转换。\n- 如果valueOf()和toString()都不返回基本类型，会产生typeError错误\n- 使用Object.create(null)创建的对象[[Prototypr]]为null，没有valueOf(),toString()方法，因此无法进行强制类型转换。\n\n```\nNumber(new Boolean(''))//0,valueOf()->false,false->0\nNumber(new Array('22'))//22,toString()->'22','22'->22\n```\n\n3. ToBoolean\n\n- 虽然我们可以将1 强制类型转换为true，将0强制类型转换为false，反之亦然，但它们并不是一回事。\n- js中的值分为两类\n\n(1)可以被强制类型转换为false的值\n(2)其他（被强制类型转换为true的值）\n\n- 假值：**undefined,null,false,+0,-0,NaN,''**，假值的布尔类型强制转换为false\n- 假值对象（并非封装了假值的对象，比如new Boolean('')，而是js语法创建的外来值）：假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为false。\n\n```\n//封装了假值的对象\nconsole.log(Boolean(false))//false\n//document.all假值对象\nconsole.log(Boolean(document.all))//false\n```\n\n- 真值：真值就是假值列表之外的值\n\n### 显示强制类型转换\n\n#### 字符串和数字之间的显示转换\n\n- 字符串和数字之间的转换通过String(),和Number()连个内建函数实现的\n- String()遵循ToString规则，将值转换为字符串基本类型\n- Number()遵循ToNumber规则，将至转换为数字基本类型\n- a.toString(),+c转换\n- 日期显式转换为数字：+new Date(),(new Date()).getTime(),Date.now()\n- ~运算符（非运算符）：首先将值强制类型转换为32位数字，然后执行字位操作“非”（对每一个字位进行反转）。\n\n#### 显式解析数字字符串\n\n- 解析和转换的差别：解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回NaN。\n- 解析方法：parseInt(),parseFload()，针对字符串处理，注意传true等值会转换为字符串，第二个参数指定转换进制，默认为十进制\n\n```\n//parseInt会转换为字符串处理\nlet obj = {\n    toString(){\n        return '1'\n    }\n}\nconsole.log(parseInt(obj))\n```\n\n#### 显示转换为布尔值\n\n- Boolean()是显示的ToBoolean强制类型转换\n- 一元运算符!，显式地将值强制类型转换为布尔值\n- 因此最常用方法是!!\n\n### 隐式强制类型转换\n\n- 可以较少冗余，让代码更简洁\n\n#### 字符串与数字之间的隐式强制类型转换\n\n- +操作：如果某个操作数是字符串或者能够通过**以下步骤**转换为字符串的话，+ 将进行拼接操作，如果其中一个操作数是对象（包括数组），则首先对其调用ToPrimitive 抽象操作，该抽象操作再调用[[DefaultValue]]，以数字作为上下文。\n\n```\n//数组valueOf()无法得到简单基本类型，因此调用toString()转换为字符串，然后拼接\nlet a = [1,2]\nlet b = [3,4]\nconsole.log(a+b)//1,23,4\n```\n```\nlet obj = {\n    valueOf(){\n        return 1\n    },\n    toString(){\n        return '2'\n    }\n}\nconsole.log(obj+'1')//11,valueOf()返回基本类型1，然后1转换为字符串'1'拼接\n```\n\n- 如果+其中一个操作数是字符串（或者通过转换可以得到），则进行字符串拼接，否则进行数字加法。\n- 减法运算：a 和b 都需要被转换为数字\n\n#### 布尔值到数字的隐式强制类型转换\n\n- true->1,false->0\n\n```\nconsole.log(true+2)//3\n```\n\n#### 隐式强制类型转换为布尔值\n\n- 发生布尔值隐式强制类型转换（非布尔值转换为布尔值）的情况：\n\n(1) if (..) 语句中的条件判断表达式。\n(2) for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。\n(3) while (..) 和do..while(..) 循环中的条件判断表达式。\n(4) ? : 中的条件判断表达式。\n(5) 逻辑运算符||（逻辑或）和&&（逻辑与）左边的操作数（作为条件判断表达式）。\n\n- || 与 &&：js中称为选择器运算符更合适（不像其他语言的逻辑运算符），因为他们在js中的返回值不是布尔值，它们的返回值是两个操作数中的一个。\n- || 和&& 首先会对第一个操作数（a和c）执行条件判断，如果其不是布尔值（如上例）就先进行ToBoolean 强制类型转换，然后再执行条件判断。\n\n```\nlet a = 1\nlet b = a && 0\nlet c = b || 1\nconsole.log(b)//0\nconsole.log(c)//1\n```\n```\nvar a = 42;\nvar b = null;\nvar c = \"foo\";\nif (a && (b || c)) {\n    console.log( \"yep\" );\n}\n//这里a && (b || c) 的结果实际上是\"foo\"而非true，然后再由if将foo强制类型转换为布尔值，所以最后结果为true。\n```\n\n#### 符号（symbol）的强制类型转换\n\n- ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。\n- 符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是true）。\n\n### 宽松相等和严格相等\n\n- 对于两者差别的正确的解释是：“**== 允许在相等比较中进行强制类型转换，而=== 不允许。**”\n\n#### 抽象相等\n\n- 定义==运算符的行为\n- 特殊情况：NaN与NaN不相等，+0与-0相等\n\n1. 字符串和数字之间的比较\n\n- 规则\n\n(1) 如果Type(x) 是数字，Type(y) 是字符串，则返回x == ToNumber(y) 的结果。\n(2) 如果Type(x) 是字符串，Type(y) 是数字，则返回ToNumber(x) == y 的结果。\n\n2. 其他类型和布尔类型之间的比较\n\n- 规则\n\n(1) 如果Type(x) 是布尔类型，则返回ToNumber(x) == y 的结果；\n(2) 如果Type(y) 是布尔类型，则返回x == ToNumber(y) 的结果。\n\n- 真值假值与==没有关系\n- if判断中无论什么情况下都不要使用== true 和== false\n\n```\n'42' == true//false\n//true转换为数字1，与'42'比较，注意这里不涉及真值假值概念\n```\n\n3. null和undefined之间的比较\n\n- 规则\n\n(1) 如果x 为null，y 为undefined，则结果为true。\n(2) 如果x 为undefined，y 为null，则结果为true。\n\n4. 对象和非对象之间的相等比较\n\n- 规则\n\n(1) 如果Type(x) 是字符串或数字，Type(y) 是对象，则返回x == ToPrimitive(y) 的结果；\n(2) 如果Type(x) 是对象，Type(y) 是字符串或数字，则返回ToPromitive(x) == y 的结果。\n\n5. 少见情况\n\n- 返回其他数字，更改了valueOf()方法\n- 假值的相等比较\n\n```\n'0' == false//true，false先转换为数字0\nfalse == 0//true\nfalse == ''//true，false->0，''->0，再比较\nfalse == []//true\n'' == 0//true\n'' == []//true\n0 == []//true\n```\n\n- [] == ![]//true，![]->false\n- '' == [null]//true，[null].toString()->''\n- 0 == '\\n'//true，\"\"、\"\\n\"（或者\" \" 等其他空格组合）等空字符串被ToNumber 强制类型转换\n为0\n- 完整性检查：如果两边的值中有true 或者false，千万不要使用==。如果两边的值中有[]、\"\" 或者0，尽量不要使用==。\n\n6. 两个对象比较\n\n- 两个对象指向同一个值时即视为相等，不发生强制类型转换。\n\n```\nlet a = {}\nlet b = {}\nlet c = a\nconsole.log(a == b)//false\nconsole.log(a == c)//true，指向同一个值\n```\n\n### 抽象关系比较><\n\n#### 比较双方都是字符串\n\n- 按照字母顺序比较\n\n#### 其他情况\n\n- 比较双方首先调用ToPrimitive，**如果结果出现非字符串**，就根据ToNumber规则将双方强制类型转换为数字来进行比较。\n\n```\ntrue > 0//true，true->1比较\n```\n\n#### <= 与>=\n\n- 根据规范a <= b 被处理为b < a，然后将结果反转。因为b < a 的结果是false，所以a <= b 的结果是true\n- 实际上JavaScript 中<= 是“不大于”的意思（即!(a > b)，处理为!(b < a)）。同理a >= b 处理为b <= a。\n\n```\nlet a = {}\nlet b = {}\nconsole.log(a == b)//false，两个对象不指向同一个值，不相等\nconsole.log(a < b)//false\nconsole.log(a > b)//false\nconsole.log(a <= b)//true\nconsole.log(a >= b)//true\n```\n\n","slug":"[js]类型","published":1,"updated":"2021-03-15T14:37:44.651Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ckmap4dln005rwotjcite7c1a","content":"<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><h4 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h4><ul>\n<li>7种内置类型</li>\n</ul>\n<p>null,undefined,object,string,number,boolean,symbol</p>\n<ul>\n<li>检查类型</li>\n</ul>\n<p>使用typeof检查，注意：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof null&#x2F;&#x2F;&quot;object&quot;</span><br><span class=\"line\">typeof []&#x2F;&#x2F;&quot;object&quot;</span><br><span class=\"line\">typeof function()&#123;&#125;&#x2F;&#x2F;&quot;function&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h4><p>null,undefined,string,number,boolean,symbol</p>\n<h4 id=\"值和类型\"><a href=\"#值和类型\" class=\"headerlink\" title=\"值和类型\"></a>值和类型</h4><ul>\n<li>js中变量没有类型，值才有类型，变量可以随时持有任何类型的值。</li>\n<li>执行typeof时，得到的是变量持有值的类型。</li>\n<li>undefined声明但还没有赋值的变量，undeclared作用域中还没有声明过得变量</li>\n<li>试图访问”undeclared” 变量时这样报错：ReferenceError: a is not defined， 并且typeof对undefined 和undeclared 变量都返回”undefined”。</li>\n</ul>\n<h3 id=\"值\"><a href=\"#值\" class=\"headerlink\" title=\"值\"></a>值</h3><h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><ul>\n<li>数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组（多维数组）</li>\n<li>delete运算符可以删除数组元素，但是不会改变length</li>\n<li>类数组：DOM元素列表，arguments对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;类数组转换为数组</span><br><span class=\"line\">function f()&#123;</span><br><span class=\"line\">    let arr &#x3D; Array.prototype.slice.call( arguments )</span><br><span class=\"line\">    let arr1 &#x3D; Array.from(arguments)&#x2F;&#x2F;ES6</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><ul>\n<li>字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。</li>\n<li>借用数组非变更方法处理字符串</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; &#39;123&#39;</span><br><span class=\"line\">let b &#x3D; Array.prototype.join.call(a,&#39;_&#39;)</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;123</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;1_2_3</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数组有一个字符串没有的可变更成员函数reverse()，反转数组。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;实现字符串反转</span><br><span class=\"line\">let a &#x3D; &#39;123&#39;</span><br><span class=\"line\">let b &#x3D; a.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;123</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;321</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h4><ul>\n<li>0.1 + 0.2是一个比较接近的数字0.30000000000000004</li>\n<li>机器精度：js中2^-52 (2.220446049250313e-16)，ES6中该值定义在Number.EPSILON中</li>\n<li>安全范围：最大整数是2^53 - 1（Number.MAX_SAFE_INTEGER），最整数（-2^53 - 1）-9007199254740991（Number.<br>MIN_SAFE_INTEGER）</li>\n<li>检测整数：Number.isInteger() 方法</li>\n<li>检测安全整数：Number.isSafeInteger()</li>\n</ul>\n<h4 id=\"特殊的值\"><a href=\"#特殊的值\" class=\"headerlink\" title=\"特殊的值\"></a>特殊的值</h4><ol>\n<li>undefined,null</li>\n</ol>\n<ul>\n<li>null 指空值（empty value），undefined 指没有值（missing value）</li>\n<li>不要给全局标识符undefined赋值</li>\n</ul>\n<ol start=\"2\">\n<li>特殊数字</li>\n</ol>\n<ul>\n<li>NaN：理解为“无效数值”“失败数值”或者“坏数值</li>\n<li>NaN和自身不相等，isNaN() 来判断一个值是否是NaN，ES6可以使用Number.isNaN()判断</li>\n<li>Object.is(NaN,NaN)返回true</li>\n<li>无穷数：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; 1 &#x2F; 0; &#x2F;&#x2F; Infinity</span><br><span class=\"line\">let b &#x3D; -1 &#x2F; 0; &#x2F;&#x2F; -Infinity</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>0值：0和-0</li>\n<li>加法和减法运算不会得到负零（negative zero）。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; 0 &#x2F; -3; &#x2F;&#x2F; -0</span><br><span class=\"line\">var b &#x3D; 0 * -3; &#x2F;&#x2F; -0</span><br><span class=\"line\">0&#x3D;&#x3D;&#x3D;-0&#x2F;&#x2F;true</span><br><span class=\"line\">Object.is(0,-0)&#x2F;&#x2F;false</span><br><span class=\"line\">&#x2F;&#x2F;判断-0</span><br><span class=\"line\">function isNegZero(n) &#123;</span><br><span class=\"line\">    n &#x3D; Number( n );</span><br><span class=\"line\">    return (n &#x3D;&#x3D;&#x3D; 0) &amp;&amp; (1 &#x2F; n &#x3D;&#x3D;&#x3D; -Infinity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"值和引用\"><a href=\"#值和引用\" class=\"headerlink\" title=\"值和引用\"></a>值和引用</h4><ul>\n<li>JavaScript 中的引用和其他语言中的引用/ 指针不同，它们不能指向别的变量/ 引用，只能指向值。</li>\n<li>JavaScript引用指向的是值。如果一个值有10个引用，这些引用指向的都是同一个值，它们相互之间没有引/指向关系。</li>\n<li>简单值（即标量基本类型值，scalar primitive）总是通过<strong>值复制</strong>的方式来赋/传递，包括null、undefined、字符串、数字、布尔ES6中symbol。</li>\n<li>复合值（compound value）对象和函数，则总是通过<strong>引用复制</strong>的方式来赋/传递。</li>\n<li>我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定。</li>\n</ul>\n<h3 id=\"原生函数\"><a href=\"#原生函数\" class=\"headerlink\" title=\"原生函数\"></a>原生函数</h3><h4 id=\"常用原生函数\"><a href=\"#常用原生函数\" class=\"headerlink\" title=\"常用原生函数\"></a>常用原生函数</h4><ul>\n<li>常用原生函数：String()，Number()，Boolean()，Array()，Object()，Function()，RegExp()，Date()，Error()，Symbol()</li>\n<li>原生函数可以当做构造函数使用，但是构造出来的是对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let s &#x3D; new String(&#39;123&#39;)</span><br><span class=\"line\">&#x2F;&#x2F;，new String(&quot;123&quot;)创建的是字符&quot;123&quot;的封装对象，而非基本类型&quot;123&quot;</span><br><span class=\"line\">console.log(typeof s)&#x2F;&#x2F;object</span><br><span class=\"line\">s instanceof String; &#x2F;&#x2F; true</span><br><span class=\"line\">Object.prototype.toString.call( s ); &#x2F;&#x2F; &quot;[object String]&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内部属性-Class\"><a href=\"#内部属性-Class\" class=\"headerlink\" title=\"内部属性[[Class]]\"></a>内部属性[[Class]]</h4><ul>\n<li>所typeof返回值”object”的对象（如数组）都包含一个内部属[[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类。</li>\n<li>Object.prototype.toString()来查看[[Class]]</li>\n<li>多数情况，对象的内[[Class]]属性和创建该对象的内建原生构造函数相对应。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call( [1,2,3] );&#x2F;&#x2F; &quot;[object Array]&quot;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>虽Null()Undefined()这样的原生构造函数并不存在，但是内[[Class]]属性值仍然为”Null”和”Undefined”。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call( null );&#x2F;&#x2F; &quot;[object Null]&quot;</span><br><span class=\"line\">Object.prototype.toString.call( undefined );&#x2F;&#x2F; &quot;[object Undefined]&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"封装对象\"><a href=\"#封装对象\" class=\"headerlink\" title=\"封装对象\"></a>封装对象</h4><ul>\n<li>一般情况不直接使用封装对象，让js引擎自己决定使用。</li>\n<li>使用封装对象注意</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; new Boolean(false)</span><br><span class=\"line\">if(a)&#123;&#x2F;&#x2F;判断通过，因为a是对象，是真值（truthy）,不是false</span><br><span class=\"line\">    console.log(123)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>自行封装基本类型，可以使用Object()（不带new关键字）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; &#39;aaa&#39;</span><br><span class=\"line\">let b &#x3D; new String(a)</span><br><span class=\"line\">let c &#x3D; Object(a)</span><br><span class=\"line\">console.log(typeof a)&#x2F;&#x2F;string</span><br><span class=\"line\">console.log(typeof b)&#x2F;&#x2F;object</span><br><span class=\"line\">console.log(typeof c)&#x2F;&#x2F;object</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>拆封：得到封装对象基本类型值，可以使用valueOf()函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; new Boolean(false)</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;Boolean &#123;false&#125;__proto__: Boolean[[PrimitiveValue]]: false</span><br><span class=\"line\">console.log(a.valueOf())&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原生函数作为构造函数\"><a href=\"#原生函数作为构造函数\" class=\"headerlink\" title=\"原生函数作为构造函数\"></a>原生函数作为构造函数</h4><ul>\n<li>避免使用构造函数</li>\n<li>构造函数Array()，不要求带new关键字，会自己补上</li>\n<li>Array()只带一个<strong>数字参数</strong>时，作为预设长度</li>\n<li>ES5规范开始就允许在列表（数组值、属性列表等）末尾多加一个逗号，（在实际处理中会被忽略不计。</li>\n<li>永远不要创建使用空单元数组，会产生问题</li>\n<li>RegExp()有时还是很有用的，比如动态定义正则表达式时。</li>\n<li>Date()</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(new Date()).getTime()</span><br><span class=\"line\">+new Date()</span><br><span class=\"line\">Date.now()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Symbol：使Symbol()原生构造函数来自定义符号</li>\n</ul>\n<h4 id=\"原生原型\"><a href=\"#原生原型\" class=\"headerlink\" title=\"原生原型\"></a>原生原型</h4><ul>\n<li>原生构造函数有自己的.prototype对象，这些对象包含对应子类的行为特征</li>\n<li>Function.prototype 是一个函数，RegExp.prototype 是一个正则表达式，而Array.prototype 是一个数组</li>\n<li>原型作为默认值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(val) &#123;</span><br><span class=\"line\">    val &#x3D; val || Array.prototype</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h3><h4 id=\"值类型转换\"><a href=\"#值类型转换\" class=\"headerlink\" title=\"值类型转换\"></a>值类型转换</h4><ul>\n<li>显式类型转换，隐式类型转换（强制类型转换）</li>\n<li>js中强制类型转换总是返回标量基本类型：字符串、数字、布尔值</li>\n<li>强制类型转换发生在动态语言的运行时</li>\n</ul>\n<h4 id=\"抽象值操作\"><a href=\"#抽象值操作\" class=\"headerlink\" title=\"抽象值操作\"></a>抽象值操作</h4><ul>\n<li>字符串、数字、布尔值之间类型转换的基本规则</li>\n</ul>\n<ol>\n<li>ToString</li>\n</ol>\n<ul>\n<li>负责处理非字符串到字符串的强制类型转换</li>\n<li>基本类型的规则：null-&gt;’null’,undefined-&gt;’undefined’,true-&gt;’true’,数字遵循通用规则</li>\n<li>对于普通对象：非自定义情况下，toString()（Object.prototype.toString()）返回内部属性[[Class]]，如果自定义了toString()方法，调用该方法使用其返回值。</li>\n<li>数组：数字默认toString()重新定义，用,连接单元字符。</li>\n<li>JSON字符串化：JSON.stringify()用到了toString()，不安全的JSON值（undefined,function.symbol,循环引用）不符合JSON解构标准，无法处理。</li>\n<li>如果对象中定义了toJSON()方法，会先调用该方法，然后将返回值序列化。</li>\n<li>JSON.stringify()，可以传递一个可选参数replacer，数组或者函数，用来指定哪些属性被处理。第三个参数space，用来指定缩进格式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    a: &#123;</span><br><span class=\"line\">        b: 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let a &#x3D; JSON.stringify(obj,function (k,v) &#123;</span><br><span class=\"line\">    return v</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let b &#x3D; JSON.stringify(obj,[&#39;a&#39;,&#39;b&#39;])</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;&#123;&quot;a&quot;:&#123;&quot;b&quot;:1&#125;&#125;</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;&#123;&quot;a&quot;:&#123;&quot;b&quot;:1&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>ToNumber</li>\n</ol>\n<ul>\n<li>非数字值当做数字使用，比如数学运算时</li>\n<li>true-&gt;1,false-&gt;0,undefined-&gt;NaN,null-&gt;0</li>\n<li>处理字符串遵循数字常量规则，处理失败返回NaN，**’’-&gt;0**</li>\n<li>ToNumber对于0开头的16进制数按照十进制处理</li>\n<li>对象（包含数组）会先转换为相应的基本类型，如果是非数字的基本类型，再按照以上规则转换为数字</li>\n<li>为了将值转换为基本类型，抽象操作ToPromitive会先检查该值是否有valueOf()方法，如果有并且返回基本类型值，就使用该值进行强制类型转换，如果没有就使用toString()的返回值进行强制类型转换。</li>\n<li>如果valueOf()和toString()都不返回基本类型，会产生typeError错误</li>\n<li>使用Object.create(null)创建的对象[[Prototypr]]为null，没有valueOf(),toString()方法，因此无法进行强制类型转换。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number(new Boolean(&#39;&#39;))&#x2F;&#x2F;0,valueOf()-&gt;false,false-&gt;0</span><br><span class=\"line\">Number(new Array(&#39;22&#39;))&#x2F;&#x2F;22,toString()-&gt;&#39;22&#39;,&#39;22&#39;-&gt;22</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>ToBoolean</li>\n</ol>\n<ul>\n<li>虽然我们可以将1 强制类型转换为true，将0强制类型转换为false，反之亦然，但它们并不是一回事。</li>\n<li>js中的值分为两类</li>\n</ul>\n<p>(1)可以被强制类型转换为false的值<br>(2)其他（被强制类型转换为true的值）</p>\n<ul>\n<li>假值：**undefined,null,false,+0,-0,NaN,’’**，假值的布尔类型强制转换为false</li>\n<li>假值对象（并非封装了假值的对象，比如new Boolean(‘’)，而是js语法创建的外来值）：假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为false。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;封装了假值的对象</span><br><span class=\"line\">console.log(Boolean(false))&#x2F;&#x2F;false</span><br><span class=\"line\">&#x2F;&#x2F;document.all假值对象</span><br><span class=\"line\">console.log(Boolean(document.all))&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>真值：真值就是假值列表之外的值</li>\n</ul>\n<h3 id=\"显示强制类型转换\"><a href=\"#显示强制类型转换\" class=\"headerlink\" title=\"显示强制类型转换\"></a>显示强制类型转换</h3><h4 id=\"字符串和数字之间的显示转换\"><a href=\"#字符串和数字之间的显示转换\" class=\"headerlink\" title=\"字符串和数字之间的显示转换\"></a>字符串和数字之间的显示转换</h4><ul>\n<li>字符串和数字之间的转换通过String(),和Number()连个内建函数实现的</li>\n<li>String()遵循ToString规则，将值转换为字符串基本类型</li>\n<li>Number()遵循ToNumber规则，将至转换为数字基本类型</li>\n<li>a.toString(),+c转换</li>\n<li>日期显式转换为数字：+new Date(),(new Date()).getTime(),Date.now()</li>\n<li>~运算符（非运算符）：首先将值强制类型转换为32位数字，然后执行字位操作“非”（对每一个字位进行反转）。</li>\n</ul>\n<h4 id=\"显式解析数字字符串\"><a href=\"#显式解析数字字符串\" class=\"headerlink\" title=\"显式解析数字字符串\"></a>显式解析数字字符串</h4><ul>\n<li>解析和转换的差别：解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回NaN。</li>\n<li>解析方法：parseInt(),parseFload()，针对字符串处理，注意传true等值会转换为字符串，第二个参数指定转换进制，默认为十进制</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;parseInt会转换为字符串处理</span><br><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    toString()&#123;</span><br><span class=\"line\">        return &#39;1&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(parseInt(obj))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"显示转换为布尔值\"><a href=\"#显示转换为布尔值\" class=\"headerlink\" title=\"显示转换为布尔值\"></a>显示转换为布尔值</h4><ul>\n<li>Boolean()是显示的ToBoolean强制类型转换</li>\n<li>一元运算符!，显式地将值强制类型转换为布尔值</li>\n<li>因此最常用方法是!!</li>\n</ul>\n<h3 id=\"隐式强制类型转换\"><a href=\"#隐式强制类型转换\" class=\"headerlink\" title=\"隐式强制类型转换\"></a>隐式强制类型转换</h3><ul>\n<li>可以较少冗余，让代码更简洁</li>\n</ul>\n<h4 id=\"字符串与数字之间的隐式强制类型转换\"><a href=\"#字符串与数字之间的隐式强制类型转换\" class=\"headerlink\" title=\"字符串与数字之间的隐式强制类型转换\"></a>字符串与数字之间的隐式强制类型转换</h4><ul>\n<li>+操作：如果某个操作数是字符串或者能够通过<strong>以下步骤</strong>转换为字符串的话，+ 将进行拼接操作，如果其中一个操作数是对象（包括数组），则首先对其调用ToPrimitive 抽象操作，该抽象操作再调用[[DefaultValue]]，以数字作为上下文。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;数组valueOf()无法得到简单基本类型，因此调用toString()转换为字符串，然后拼接</span><br><span class=\"line\">let a &#x3D; [1,2]</span><br><span class=\"line\">let b &#x3D; [3,4]</span><br><span class=\"line\">console.log(a+b)&#x2F;&#x2F;1,23,4</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    valueOf()&#123;</span><br><span class=\"line\">        return 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    toString()&#123;</span><br><span class=\"line\">        return &#39;2&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(obj+&#39;1&#39;)&#x2F;&#x2F;11,valueOf()返回基本类型1，然后1转换为字符串&#39;1&#39;拼接</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果+其中一个操作数是字符串（或者通过转换可以得到），则进行字符串拼接，否则进行数字加法。</li>\n<li>减法运算：a 和b 都需要被转换为数字</li>\n</ul>\n<h4 id=\"布尔值到数字的隐式强制类型转换\"><a href=\"#布尔值到数字的隐式强制类型转换\" class=\"headerlink\" title=\"布尔值到数字的隐式强制类型转换\"></a>布尔值到数字的隐式强制类型转换</h4><ul>\n<li>true-&gt;1,false-&gt;0</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(true+2)&#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"隐式强制类型转换为布尔值\"><a href=\"#隐式强制类型转换为布尔值\" class=\"headerlink\" title=\"隐式强制类型转换为布尔值\"></a>隐式强制类型转换为布尔值</h4><ul>\n<li>发生布尔值隐式强制类型转换（非布尔值转换为布尔值）的情况：</li>\n</ul>\n<p>(1) if (..) 语句中的条件判断表达式。<br>(2) for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。<br>(3) while (..) 和do..while(..) 循环中的条件判断表达式。<br>(4) ? : 中的条件判断表达式。<br>(5) 逻辑运算符||（逻辑或）和&amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</p>\n<ul>\n<li>|| 与 &amp;&amp;：js中称为选择器运算符更合适（不像其他语言的逻辑运算符），因为他们在js中的返回值不是布尔值，它们的返回值是两个操作数中的一个。</li>\n<li>|| 和&amp;&amp; 首先会对第一个操作数（a和c）执行条件判断，如果其不是布尔值（如上例）就先进行ToBoolean 强制类型转换，然后再执行条件判断。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; 1</span><br><span class=\"line\">let b &#x3D; a &amp;&amp; 0</span><br><span class=\"line\">let c &#x3D; b || 1</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;0</span><br><span class=\"line\">console.log(c)&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; 42;</span><br><span class=\"line\">var b &#x3D; null;</span><br><span class=\"line\">var c &#x3D; &quot;foo&quot;;</span><br><span class=\"line\">if (a &amp;&amp; (b || c)) &#123;</span><br><span class=\"line\">    console.log( &quot;yep&quot; );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;这里a &amp;&amp; (b || c) 的结果实际上是&quot;foo&quot;而非true，然后再由if将foo强制类型转换为布尔值，所以最后结果为true。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"符号（symbol）的强制类型转换\"><a href=\"#符号（symbol）的强制类型转换\" class=\"headerlink\" title=\"符号（symbol）的强制类型转换\"></a>符号（symbol）的强制类型转换</h4><ul>\n<li>ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。</li>\n<li>符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是true）。</li>\n</ul>\n<h3 id=\"宽松相等和严格相等\"><a href=\"#宽松相等和严格相等\" class=\"headerlink\" title=\"宽松相等和严格相等\"></a>宽松相等和严格相等</h3><ul>\n<li>对于两者差别的正确的解释是：“**== 允许在相等比较中进行强制类型转换，而=== 不允许。**”</li>\n</ul>\n<h4 id=\"抽象相等\"><a href=\"#抽象相等\" class=\"headerlink\" title=\"抽象相等\"></a>抽象相等</h4><ul>\n<li>定义==运算符的行为</li>\n<li>特殊情况：NaN与NaN不相等，+0与-0相等</li>\n</ul>\n<ol>\n<li>字符串和数字之间的比较</li>\n</ol>\n<ul>\n<li>规则</li>\n</ul>\n<p>(1) 如果Type(x) 是数字，Type(y) 是字符串，则返回x == ToNumber(y) 的结果。<br>(2) 如果Type(x) 是字符串，Type(y) 是数字，则返回ToNumber(x) == y 的结果。</p>\n<ol start=\"2\">\n<li>其他类型和布尔类型之间的比较</li>\n</ol>\n<ul>\n<li>规则</li>\n</ul>\n<p>(1) 如果Type(x) 是布尔类型，则返回ToNumber(x) == y 的结果；<br>(2) 如果Type(y) 是布尔类型，则返回x == ToNumber(y) 的结果。</p>\n<ul>\n<li>真值假值与==没有关系</li>\n<li>if判断中无论什么情况下都不要使用== true 和== false</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;42&#39; &#x3D;&#x3D; true&#x2F;&#x2F;false</span><br><span class=\"line\">&#x2F;&#x2F;true转换为数字1，与&#39;42&#39;比较，注意这里不涉及真值假值概念</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>null和undefined之间的比较</li>\n</ol>\n<ul>\n<li>规则</li>\n</ul>\n<p>(1) 如果x 为null，y 为undefined，则结果为true。<br>(2) 如果x 为undefined，y 为null，则结果为true。</p>\n<ol start=\"4\">\n<li>对象和非对象之间的相等比较</li>\n</ol>\n<ul>\n<li>规则</li>\n</ul>\n<p>(1) 如果Type(x) 是字符串或数字，Type(y) 是对象，则返回x == ToPrimitive(y) 的结果；<br>(2) 如果Type(x) 是对象，Type(y) 是字符串或数字，则返回ToPromitive(x) == y 的结果。</p>\n<ol start=\"5\">\n<li>少见情况</li>\n</ol>\n<ul>\n<li>返回其他数字，更改了valueOf()方法</li>\n<li>假值的相等比较</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;0&#39; &#x3D;&#x3D; false&#x2F;&#x2F;true，false先转换为数字0</span><br><span class=\"line\">false &#x3D;&#x3D; 0&#x2F;&#x2F;true</span><br><span class=\"line\">false &#x3D;&#x3D; &#39;&#39;&#x2F;&#x2F;true，false-&gt;0，&#39;&#39;-&gt;0，再比较</span><br><span class=\"line\">false &#x3D;&#x3D; []&#x2F;&#x2F;true</span><br><span class=\"line\">&#39;&#39; &#x3D;&#x3D; 0&#x2F;&#x2F;true</span><br><span class=\"line\">&#39;&#39; &#x3D;&#x3D; []&#x2F;&#x2F;true</span><br><span class=\"line\">0 &#x3D;&#x3D; []&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>[] == ![]//true，![]-&gt;false</li>\n<li>‘’ == [null]//true，[null].toString()-&gt;’’</li>\n<li>0 == ‘\\n’//true，””、”\\n”（或者” “ 等其他空格组合）等空字符串被ToNumber 强制类型转换<br>为0</li>\n<li>完整性检查：如果两边的值中有true 或者false，千万不要使用==。如果两边的值中有[]、”” 或者0，尽量不要使用==。</li>\n</ul>\n<ol start=\"6\">\n<li>两个对象比较</li>\n</ol>\n<ul>\n<li>两个对象指向同一个值时即视为相等，不发生强制类型转换。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; &#123;&#125;</span><br><span class=\"line\">let b &#x3D; &#123;&#125;</span><br><span class=\"line\">let c &#x3D; a</span><br><span class=\"line\">console.log(a &#x3D;&#x3D; b)&#x2F;&#x2F;false</span><br><span class=\"line\">console.log(a &#x3D;&#x3D; c)&#x2F;&#x2F;true，指向同一个值</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"抽象关系比较-gt-lt\"><a href=\"#抽象关系比较-gt-lt\" class=\"headerlink\" title=\"抽象关系比较&gt;&lt;\"></a>抽象关系比较&gt;&lt;</h3><h4 id=\"比较双方都是字符串\"><a href=\"#比较双方都是字符串\" class=\"headerlink\" title=\"比较双方都是字符串\"></a>比较双方都是字符串</h4><ul>\n<li>按照字母顺序比较</li>\n</ul>\n<h4 id=\"其他情况\"><a href=\"#其他情况\" class=\"headerlink\" title=\"其他情况\"></a>其他情况</h4><ul>\n<li>比较双方首先调用ToPrimitive，<strong>如果结果出现非字符串</strong>，就根据ToNumber规则将双方强制类型转换为数字来进行比较。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">true &gt; 0&#x2F;&#x2F;true，true-&gt;1比较</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"lt-与-gt\"><a href=\"#lt-与-gt\" class=\"headerlink\" title=\"&lt;= 与&gt;=\"></a>&lt;= 与&gt;=</h4><ul>\n<li>根据规范a &lt;= b 被处理为b &lt; a，然后将结果反转。因为b &lt; a 的结果是false，所以a &lt;= b 的结果是true</li>\n<li>实际上JavaScript 中&lt;= 是“不大于”的意思（即!(a &gt; b)，处理为!(b &lt; a)）。同理a &gt;= b 处理为b &lt;= a。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; &#123;&#125;</span><br><span class=\"line\">let b &#x3D; &#123;&#125;</span><br><span class=\"line\">console.log(a &#x3D;&#x3D; b)&#x2F;&#x2F;false，两个对象不指向同一个值，不相等</span><br><span class=\"line\">console.log(a &lt; b)&#x2F;&#x2F;false</span><br><span class=\"line\">console.log(a &gt; b)&#x2F;&#x2F;false</span><br><span class=\"line\">console.log(a &lt;&#x3D; b)&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(a &gt;&#x3D; b)&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"类型\"><a href=\"#类型\" class=\"headerlink\" title=\"类型\"></a>类型</h3><h4 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h4><ul>\n<li>7种内置类型</li>\n</ul>\n<p>null,undefined,object,string,number,boolean,symbol</p>\n<ul>\n<li>检查类型</li>\n</ul>\n<p>使用typeof检查，注意：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">typeof null&#x2F;&#x2F;&quot;object&quot;</span><br><span class=\"line\">typeof []&#x2F;&#x2F;&quot;object&quot;</span><br><span class=\"line\">typeof function()&#123;&#125;&#x2F;&#x2F;&quot;function&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"基本类型\"><a href=\"#基本类型\" class=\"headerlink\" title=\"基本类型\"></a>基本类型</h4><p>null,undefined,string,number,boolean,symbol</p>\n<h4 id=\"值和类型\"><a href=\"#值和类型\" class=\"headerlink\" title=\"值和类型\"></a>值和类型</h4><ul>\n<li>js中变量没有类型，值才有类型，变量可以随时持有任何类型的值。</li>\n<li>执行typeof时，得到的是变量持有值的类型。</li>\n<li>undefined声明但还没有赋值的变量，undeclared作用域中还没有声明过得变量</li>\n<li>试图访问”undeclared” 变量时这样报错：ReferenceError: a is not defined， 并且typeof对undefined 和undeclared 变量都返回”undefined”。</li>\n</ul>\n<h3 id=\"值\"><a href=\"#值\" class=\"headerlink\" title=\"值\"></a>值</h3><h4 id=\"数组\"><a href=\"#数组\" class=\"headerlink\" title=\"数组\"></a>数组</h4><ul>\n<li>数组可以容纳任何类型的值，可以是字符串、数字、对象（object），甚至是其他数组（多维数组）</li>\n<li>delete运算符可以删除数组元素，但是不会改变length</li>\n<li>类数组：DOM元素列表，arguments对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;类数组转换为数组</span><br><span class=\"line\">function f()&#123;</span><br><span class=\"line\">    let arr &#x3D; Array.prototype.slice.call( arguments )</span><br><span class=\"line\">    let arr1 &#x3D; Array.from(arguments)&#x2F;&#x2F;ES6</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h4><ul>\n<li>字符串不可变是指字符串的成员函数不会改变其原始值，而是创建并返回一个新的字符串。而数组的成员函数都是在其原始值上进行操作。</li>\n<li>借用数组非变更方法处理字符串</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; &#39;123&#39;</span><br><span class=\"line\">let b &#x3D; Array.prototype.join.call(a,&#39;_&#39;)</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;123</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;1_2_3</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>数组有一个字符串没有的可变更成员函数reverse()，反转数组。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;实现字符串反转</span><br><span class=\"line\">let a &#x3D; &#39;123&#39;</span><br><span class=\"line\">let b &#x3D; a.split(&#39;&#39;).reverse().join(&#39;&#39;)</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;123</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;321</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h4><ul>\n<li>0.1 + 0.2是一个比较接近的数字0.30000000000000004</li>\n<li>机器精度：js中2^-52 (2.220446049250313e-16)，ES6中该值定义在Number.EPSILON中</li>\n<li>安全范围：最大整数是2^53 - 1（Number.MAX_SAFE_INTEGER），最整数（-2^53 - 1）-9007199254740991（Number.<br>MIN_SAFE_INTEGER）</li>\n<li>检测整数：Number.isInteger() 方法</li>\n<li>检测安全整数：Number.isSafeInteger()</li>\n</ul>\n<h4 id=\"特殊的值\"><a href=\"#特殊的值\" class=\"headerlink\" title=\"特殊的值\"></a>特殊的值</h4><ol>\n<li>undefined,null</li>\n</ol>\n<ul>\n<li>null 指空值（empty value），undefined 指没有值（missing value）</li>\n<li>不要给全局标识符undefined赋值</li>\n</ul>\n<ol start=\"2\">\n<li>特殊数字</li>\n</ol>\n<ul>\n<li>NaN：理解为“无效数值”“失败数值”或者“坏数值</li>\n<li>NaN和自身不相等，isNaN() 来判断一个值是否是NaN，ES6可以使用Number.isNaN()判断</li>\n<li>Object.is(NaN,NaN)返回true</li>\n<li>无穷数：</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; 1 &#x2F; 0; &#x2F;&#x2F; Infinity</span><br><span class=\"line\">let b &#x3D; -1 &#x2F; 0; &#x2F;&#x2F; -Infinity</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>0值：0和-0</li>\n<li>加法和减法运算不会得到负零（negative zero）。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; 0 &#x2F; -3; &#x2F;&#x2F; -0</span><br><span class=\"line\">var b &#x3D; 0 * -3; &#x2F;&#x2F; -0</span><br><span class=\"line\">0&#x3D;&#x3D;&#x3D;-0&#x2F;&#x2F;true</span><br><span class=\"line\">Object.is(0,-0)&#x2F;&#x2F;false</span><br><span class=\"line\">&#x2F;&#x2F;判断-0</span><br><span class=\"line\">function isNegZero(n) &#123;</span><br><span class=\"line\">    n &#x3D; Number( n );</span><br><span class=\"line\">    return (n &#x3D;&#x3D;&#x3D; 0) &amp;&amp; (1 &#x2F; n &#x3D;&#x3D;&#x3D; -Infinity);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"值和引用\"><a href=\"#值和引用\" class=\"headerlink\" title=\"值和引用\"></a>值和引用</h4><ul>\n<li>JavaScript 中的引用和其他语言中的引用/ 指针不同，它们不能指向别的变量/ 引用，只能指向值。</li>\n<li>JavaScript引用指向的是值。如果一个值有10个引用，这些引用指向的都是同一个值，它们相互之间没有引/指向关系。</li>\n<li>简单值（即标量基本类型值，scalar primitive）总是通过<strong>值复制</strong>的方式来赋/传递，包括null、undefined、字符串、数字、布尔ES6中symbol。</li>\n<li>复合值（compound value）对象和函数，则总是通过<strong>引用复制</strong>的方式来赋/传递。</li>\n<li>我们无法自行决定使用值复制还是引用复制，一切由值的类型来决定。</li>\n</ul>\n<h3 id=\"原生函数\"><a href=\"#原生函数\" class=\"headerlink\" title=\"原生函数\"></a>原生函数</h3><h4 id=\"常用原生函数\"><a href=\"#常用原生函数\" class=\"headerlink\" title=\"常用原生函数\"></a>常用原生函数</h4><ul>\n<li>常用原生函数：String()，Number()，Boolean()，Array()，Object()，Function()，RegExp()，Date()，Error()，Symbol()</li>\n<li>原生函数可以当做构造函数使用，但是构造出来的是对象</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let s &#x3D; new String(&#39;123&#39;)</span><br><span class=\"line\">&#x2F;&#x2F;，new String(&quot;123&quot;)创建的是字符&quot;123&quot;的封装对象，而非基本类型&quot;123&quot;</span><br><span class=\"line\">console.log(typeof s)&#x2F;&#x2F;object</span><br><span class=\"line\">s instanceof String; &#x2F;&#x2F; true</span><br><span class=\"line\">Object.prototype.toString.call( s ); &#x2F;&#x2F; &quot;[object String]&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"内部属性-Class\"><a href=\"#内部属性-Class\" class=\"headerlink\" title=\"内部属性[[Class]]\"></a>内部属性[[Class]]</h4><ul>\n<li>所typeof返回值”object”的对象（如数组）都包含一个内部属[[Class]]（我们可以把它看作一个内部的分类，而非传统的面向对象意义上的类。</li>\n<li>Object.prototype.toString()来查看[[Class]]</li>\n<li>多数情况，对象的内[[Class]]属性和创建该对象的内建原生构造函数相对应。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call( [1,2,3] );&#x2F;&#x2F; &quot;[object Array]&quot;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>虽Null()Undefined()这样的原生构造函数并不存在，但是内[[Class]]属性值仍然为”Null”和”Undefined”。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call( null );&#x2F;&#x2F; &quot;[object Null]&quot;</span><br><span class=\"line\">Object.prototype.toString.call( undefined );&#x2F;&#x2F; &quot;[object Undefined]&quot;</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"封装对象\"><a href=\"#封装对象\" class=\"headerlink\" title=\"封装对象\"></a>封装对象</h4><ul>\n<li>一般情况不直接使用封装对象，让js引擎自己决定使用。</li>\n<li>使用封装对象注意</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; new Boolean(false)</span><br><span class=\"line\">if(a)&#123;&#x2F;&#x2F;判断通过，因为a是对象，是真值（truthy）,不是false</span><br><span class=\"line\">    console.log(123)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>自行封装基本类型，可以使用Object()（不带new关键字）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; &#39;aaa&#39;</span><br><span class=\"line\">let b &#x3D; new String(a)</span><br><span class=\"line\">let c &#x3D; Object(a)</span><br><span class=\"line\">console.log(typeof a)&#x2F;&#x2F;string</span><br><span class=\"line\">console.log(typeof b)&#x2F;&#x2F;object</span><br><span class=\"line\">console.log(typeof c)&#x2F;&#x2F;object</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>拆封：得到封装对象基本类型值，可以使用valueOf()函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; new Boolean(false)</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;Boolean &#123;false&#125;__proto__: Boolean[[PrimitiveValue]]: false</span><br><span class=\"line\">console.log(a.valueOf())&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"原生函数作为构造函数\"><a href=\"#原生函数作为构造函数\" class=\"headerlink\" title=\"原生函数作为构造函数\"></a>原生函数作为构造函数</h4><ul>\n<li>避免使用构造函数</li>\n<li>构造函数Array()，不要求带new关键字，会自己补上</li>\n<li>Array()只带一个<strong>数字参数</strong>时，作为预设长度</li>\n<li>ES5规范开始就允许在列表（数组值、属性列表等）末尾多加一个逗号，（在实际处理中会被忽略不计。</li>\n<li>永远不要创建使用空单元数组，会产生问题</li>\n<li>RegExp()有时还是很有用的，比如动态定义正则表达式时。</li>\n<li>Date()</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(new Date()).getTime()</span><br><span class=\"line\">+new Date()</span><br><span class=\"line\">Date.now()</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Symbol：使Symbol()原生构造函数来自定义符号</li>\n</ul>\n<h4 id=\"原生原型\"><a href=\"#原生原型\" class=\"headerlink\" title=\"原生原型\"></a>原生原型</h4><ul>\n<li>原生构造函数有自己的.prototype对象，这些对象包含对应子类的行为特征</li>\n<li>Function.prototype 是一个函数，RegExp.prototype 是一个正则表达式，而Array.prototype 是一个数组</li>\n<li>原型作为默认值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f(val) &#123;</span><br><span class=\"line\">    val &#x3D; val || Array.prototype</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"强制类型转换\"><a href=\"#强制类型转换\" class=\"headerlink\" title=\"强制类型转换\"></a>强制类型转换</h3><h4 id=\"值类型转换\"><a href=\"#值类型转换\" class=\"headerlink\" title=\"值类型转换\"></a>值类型转换</h4><ul>\n<li>显式类型转换，隐式类型转换（强制类型转换）</li>\n<li>js中强制类型转换总是返回标量基本类型：字符串、数字、布尔值</li>\n<li>强制类型转换发生在动态语言的运行时</li>\n</ul>\n<h4 id=\"抽象值操作\"><a href=\"#抽象值操作\" class=\"headerlink\" title=\"抽象值操作\"></a>抽象值操作</h4><ul>\n<li>字符串、数字、布尔值之间类型转换的基本规则</li>\n</ul>\n<ol>\n<li>ToString</li>\n</ol>\n<ul>\n<li>负责处理非字符串到字符串的强制类型转换</li>\n<li>基本类型的规则：null-&gt;’null’,undefined-&gt;’undefined’,true-&gt;’true’,数字遵循通用规则</li>\n<li>对于普通对象：非自定义情况下，toString()（Object.prototype.toString()）返回内部属性[[Class]]，如果自定义了toString()方法，调用该方法使用其返回值。</li>\n<li>数组：数字默认toString()重新定义，用,连接单元字符。</li>\n<li>JSON字符串化：JSON.stringify()用到了toString()，不安全的JSON值（undefined,function.symbol,循环引用）不符合JSON解构标准，无法处理。</li>\n<li>如果对象中定义了toJSON()方法，会先调用该方法，然后将返回值序列化。</li>\n<li>JSON.stringify()，可以传递一个可选参数replacer，数组或者函数，用来指定哪些属性被处理。第三个参数space，用来指定缩进格式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    a: &#123;</span><br><span class=\"line\">        b: 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let a &#x3D; JSON.stringify(obj,function (k,v) &#123;</span><br><span class=\"line\">    return v</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">let b &#x3D; JSON.stringify(obj,[&#39;a&#39;,&#39;b&#39;])</span><br><span class=\"line\">console.log(a)&#x2F;&#x2F;&#123;&quot;a&quot;:&#123;&quot;b&quot;:1&#125;&#125;</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;&#123;&quot;a&quot;:&#123;&quot;b&quot;:1&#125;&#125;</span><br></pre></td></tr></table></figure>\n\n<ol start=\"2\">\n<li>ToNumber</li>\n</ol>\n<ul>\n<li>非数字值当做数字使用，比如数学运算时</li>\n<li>true-&gt;1,false-&gt;0,undefined-&gt;NaN,null-&gt;0</li>\n<li>处理字符串遵循数字常量规则，处理失败返回NaN，**’’-&gt;0**</li>\n<li>ToNumber对于0开头的16进制数按照十进制处理</li>\n<li>对象（包含数组）会先转换为相应的基本类型，如果是非数字的基本类型，再按照以上规则转换为数字</li>\n<li>为了将值转换为基本类型，抽象操作ToPromitive会先检查该值是否有valueOf()方法，如果有并且返回基本类型值，就使用该值进行强制类型转换，如果没有就使用toString()的返回值进行强制类型转换。</li>\n<li>如果valueOf()和toString()都不返回基本类型，会产生typeError错误</li>\n<li>使用Object.create(null)创建的对象[[Prototypr]]为null，没有valueOf(),toString()方法，因此无法进行强制类型转换。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Number(new Boolean(&#39;&#39;))&#x2F;&#x2F;0,valueOf()-&gt;false,false-&gt;0</span><br><span class=\"line\">Number(new Array(&#39;22&#39;))&#x2F;&#x2F;22,toString()-&gt;&#39;22&#39;,&#39;22&#39;-&gt;22</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>ToBoolean</li>\n</ol>\n<ul>\n<li>虽然我们可以将1 强制类型转换为true，将0强制类型转换为false，反之亦然，但它们并不是一回事。</li>\n<li>js中的值分为两类</li>\n</ul>\n<p>(1)可以被强制类型转换为false的值<br>(2)其他（被强制类型转换为true的值）</p>\n<ul>\n<li>假值：**undefined,null,false,+0,-0,NaN,’’**，假值的布尔类型强制转换为false</li>\n<li>假值对象（并非封装了假值的对象，比如new Boolean(‘’)，而是js语法创建的外来值）：假值对象看起来和普通对象并无二致（都有属性，等等），但将它们强制类型转换为布尔值时结果为false。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;封装了假值的对象</span><br><span class=\"line\">console.log(Boolean(false))&#x2F;&#x2F;false</span><br><span class=\"line\">&#x2F;&#x2F;document.all假值对象</span><br><span class=\"line\">console.log(Boolean(document.all))&#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>真值：真值就是假值列表之外的值</li>\n</ul>\n<h3 id=\"显示强制类型转换\"><a href=\"#显示强制类型转换\" class=\"headerlink\" title=\"显示强制类型转换\"></a>显示强制类型转换</h3><h4 id=\"字符串和数字之间的显示转换\"><a href=\"#字符串和数字之间的显示转换\" class=\"headerlink\" title=\"字符串和数字之间的显示转换\"></a>字符串和数字之间的显示转换</h4><ul>\n<li>字符串和数字之间的转换通过String(),和Number()连个内建函数实现的</li>\n<li>String()遵循ToString规则，将值转换为字符串基本类型</li>\n<li>Number()遵循ToNumber规则，将至转换为数字基本类型</li>\n<li>a.toString(),+c转换</li>\n<li>日期显式转换为数字：+new Date(),(new Date()).getTime(),Date.now()</li>\n<li>~运算符（非运算符）：首先将值强制类型转换为32位数字，然后执行字位操作“非”（对每一个字位进行反转）。</li>\n</ul>\n<h4 id=\"显式解析数字字符串\"><a href=\"#显式解析数字字符串\" class=\"headerlink\" title=\"显式解析数字字符串\"></a>显式解析数字字符串</h4><ul>\n<li>解析和转换的差别：解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回NaN。</li>\n<li>解析方法：parseInt(),parseFload()，针对字符串处理，注意传true等值会转换为字符串，第二个参数指定转换进制，默认为十进制</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;parseInt会转换为字符串处理</span><br><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    toString()&#123;</span><br><span class=\"line\">        return &#39;1&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(parseInt(obj))</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"显示转换为布尔值\"><a href=\"#显示转换为布尔值\" class=\"headerlink\" title=\"显示转换为布尔值\"></a>显示转换为布尔值</h4><ul>\n<li>Boolean()是显示的ToBoolean强制类型转换</li>\n<li>一元运算符!，显式地将值强制类型转换为布尔值</li>\n<li>因此最常用方法是!!</li>\n</ul>\n<h3 id=\"隐式强制类型转换\"><a href=\"#隐式强制类型转换\" class=\"headerlink\" title=\"隐式强制类型转换\"></a>隐式强制类型转换</h3><ul>\n<li>可以较少冗余，让代码更简洁</li>\n</ul>\n<h4 id=\"字符串与数字之间的隐式强制类型转换\"><a href=\"#字符串与数字之间的隐式强制类型转换\" class=\"headerlink\" title=\"字符串与数字之间的隐式强制类型转换\"></a>字符串与数字之间的隐式强制类型转换</h4><ul>\n<li>+操作：如果某个操作数是字符串或者能够通过<strong>以下步骤</strong>转换为字符串的话，+ 将进行拼接操作，如果其中一个操作数是对象（包括数组），则首先对其调用ToPrimitive 抽象操作，该抽象操作再调用[[DefaultValue]]，以数字作为上下文。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;&#x2F;数组valueOf()无法得到简单基本类型，因此调用toString()转换为字符串，然后拼接</span><br><span class=\"line\">let a &#x3D; [1,2]</span><br><span class=\"line\">let b &#x3D; [3,4]</span><br><span class=\"line\">console.log(a+b)&#x2F;&#x2F;1,23,4</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj &#x3D; &#123;</span><br><span class=\"line\">    valueOf()&#123;</span><br><span class=\"line\">        return 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    toString()&#123;</span><br><span class=\"line\">        return &#39;2&#39;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(obj+&#39;1&#39;)&#x2F;&#x2F;11,valueOf()返回基本类型1，然后1转换为字符串&#39;1&#39;拼接</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>如果+其中一个操作数是字符串（或者通过转换可以得到），则进行字符串拼接，否则进行数字加法。</li>\n<li>减法运算：a 和b 都需要被转换为数字</li>\n</ul>\n<h4 id=\"布尔值到数字的隐式强制类型转换\"><a href=\"#布尔值到数字的隐式强制类型转换\" class=\"headerlink\" title=\"布尔值到数字的隐式强制类型转换\"></a>布尔值到数字的隐式强制类型转换</h4><ul>\n<li>true-&gt;1,false-&gt;0</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(true+2)&#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"隐式强制类型转换为布尔值\"><a href=\"#隐式强制类型转换为布尔值\" class=\"headerlink\" title=\"隐式强制类型转换为布尔值\"></a>隐式强制类型转换为布尔值</h4><ul>\n<li>发生布尔值隐式强制类型转换（非布尔值转换为布尔值）的情况：</li>\n</ul>\n<p>(1) if (..) 语句中的条件判断表达式。<br>(2) for ( .. ; .. ; .. ) 语句中的条件判断表达式（第二个）。<br>(3) while (..) 和do..while(..) 循环中的条件判断表达式。<br>(4) ? : 中的条件判断表达式。<br>(5) 逻辑运算符||（逻辑或）和&amp;&amp;（逻辑与）左边的操作数（作为条件判断表达式）。</p>\n<ul>\n<li>|| 与 &amp;&amp;：js中称为选择器运算符更合适（不像其他语言的逻辑运算符），因为他们在js中的返回值不是布尔值，它们的返回值是两个操作数中的一个。</li>\n<li>|| 和&amp;&amp; 首先会对第一个操作数（a和c）执行条件判断，如果其不是布尔值（如上例）就先进行ToBoolean 强制类型转换，然后再执行条件判断。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; 1</span><br><span class=\"line\">let b &#x3D; a &amp;&amp; 0</span><br><span class=\"line\">let c &#x3D; b || 1</span><br><span class=\"line\">console.log(b)&#x2F;&#x2F;0</span><br><span class=\"line\">console.log(c)&#x2F;&#x2F;1</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a &#x3D; 42;</span><br><span class=\"line\">var b &#x3D; null;</span><br><span class=\"line\">var c &#x3D; &quot;foo&quot;;</span><br><span class=\"line\">if (a &amp;&amp; (b || c)) &#123;</span><br><span class=\"line\">    console.log( &quot;yep&quot; );</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#x2F;&#x2F;这里a &amp;&amp; (b || c) 的结果实际上是&quot;foo&quot;而非true，然后再由if将foo强制类型转换为布尔值，所以最后结果为true。</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"符号（symbol）的强制类型转换\"><a href=\"#符号（symbol）的强制类型转换\" class=\"headerlink\" title=\"符号（symbol）的强制类型转换\"></a>符号（symbol）的强制类型转换</h4><ul>\n<li>ES6 允许从符号到字符串的显式强制类型转换，然而隐式强制类型转换会产生错误。</li>\n<li>符号不能够被强制类型转换为数字（显式和隐式都会产生错误），但可以被强制类型转换为布尔值（显式和隐式结果都是true）。</li>\n</ul>\n<h3 id=\"宽松相等和严格相等\"><a href=\"#宽松相等和严格相等\" class=\"headerlink\" title=\"宽松相等和严格相等\"></a>宽松相等和严格相等</h3><ul>\n<li>对于两者差别的正确的解释是：“**== 允许在相等比较中进行强制类型转换，而=== 不允许。**”</li>\n</ul>\n<h4 id=\"抽象相等\"><a href=\"#抽象相等\" class=\"headerlink\" title=\"抽象相等\"></a>抽象相等</h4><ul>\n<li>定义==运算符的行为</li>\n<li>特殊情况：NaN与NaN不相等，+0与-0相等</li>\n</ul>\n<ol>\n<li>字符串和数字之间的比较</li>\n</ol>\n<ul>\n<li>规则</li>\n</ul>\n<p>(1) 如果Type(x) 是数字，Type(y) 是字符串，则返回x == ToNumber(y) 的结果。<br>(2) 如果Type(x) 是字符串，Type(y) 是数字，则返回ToNumber(x) == y 的结果。</p>\n<ol start=\"2\">\n<li>其他类型和布尔类型之间的比较</li>\n</ol>\n<ul>\n<li>规则</li>\n</ul>\n<p>(1) 如果Type(x) 是布尔类型，则返回ToNumber(x) == y 的结果；<br>(2) 如果Type(y) 是布尔类型，则返回x == ToNumber(y) 的结果。</p>\n<ul>\n<li>真值假值与==没有关系</li>\n<li>if判断中无论什么情况下都不要使用== true 和== false</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;42&#39; &#x3D;&#x3D; true&#x2F;&#x2F;false</span><br><span class=\"line\">&#x2F;&#x2F;true转换为数字1，与&#39;42&#39;比较，注意这里不涉及真值假值概念</span><br></pre></td></tr></table></figure>\n\n<ol start=\"3\">\n<li>null和undefined之间的比较</li>\n</ol>\n<ul>\n<li>规则</li>\n</ul>\n<p>(1) 如果x 为null，y 为undefined，则结果为true。<br>(2) 如果x 为undefined，y 为null，则结果为true。</p>\n<ol start=\"4\">\n<li>对象和非对象之间的相等比较</li>\n</ol>\n<ul>\n<li>规则</li>\n</ul>\n<p>(1) 如果Type(x) 是字符串或数字，Type(y) 是对象，则返回x == ToPrimitive(y) 的结果；<br>(2) 如果Type(x) 是对象，Type(y) 是字符串或数字，则返回ToPromitive(x) == y 的结果。</p>\n<ol start=\"5\">\n<li>少见情况</li>\n</ol>\n<ul>\n<li>返回其他数字，更改了valueOf()方法</li>\n<li>假值的相等比较</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#39;0&#39; &#x3D;&#x3D; false&#x2F;&#x2F;true，false先转换为数字0</span><br><span class=\"line\">false &#x3D;&#x3D; 0&#x2F;&#x2F;true</span><br><span class=\"line\">false &#x3D;&#x3D; &#39;&#39;&#x2F;&#x2F;true，false-&gt;0，&#39;&#39;-&gt;0，再比较</span><br><span class=\"line\">false &#x3D;&#x3D; []&#x2F;&#x2F;true</span><br><span class=\"line\">&#39;&#39; &#x3D;&#x3D; 0&#x2F;&#x2F;true</span><br><span class=\"line\">&#39;&#39; &#x3D;&#x3D; []&#x2F;&#x2F;true</span><br><span class=\"line\">0 &#x3D;&#x3D; []&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>[] == ![]//true，![]-&gt;false</li>\n<li>‘’ == [null]//true，[null].toString()-&gt;’’</li>\n<li>0 == ‘\\n’//true，””、”\\n”（或者” “ 等其他空格组合）等空字符串被ToNumber 强制类型转换<br>为0</li>\n<li>完整性检查：如果两边的值中有true 或者false，千万不要使用==。如果两边的值中有[]、”” 或者0，尽量不要使用==。</li>\n</ul>\n<ol start=\"6\">\n<li>两个对象比较</li>\n</ol>\n<ul>\n<li>两个对象指向同一个值时即视为相等，不发生强制类型转换。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; &#123;&#125;</span><br><span class=\"line\">let b &#x3D; &#123;&#125;</span><br><span class=\"line\">let c &#x3D; a</span><br><span class=\"line\">console.log(a &#x3D;&#x3D; b)&#x2F;&#x2F;false</span><br><span class=\"line\">console.log(a &#x3D;&#x3D; c)&#x2F;&#x2F;true，指向同一个值</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"抽象关系比较-gt-lt\"><a href=\"#抽象关系比较-gt-lt\" class=\"headerlink\" title=\"抽象关系比较&gt;&lt;\"></a>抽象关系比较&gt;&lt;</h3><h4 id=\"比较双方都是字符串\"><a href=\"#比较双方都是字符串\" class=\"headerlink\" title=\"比较双方都是字符串\"></a>比较双方都是字符串</h4><ul>\n<li>按照字母顺序比较</li>\n</ul>\n<h4 id=\"其他情况\"><a href=\"#其他情况\" class=\"headerlink\" title=\"其他情况\"></a>其他情况</h4><ul>\n<li>比较双方首先调用ToPrimitive，<strong>如果结果出现非字符串</strong>，就根据ToNumber规则将双方强制类型转换为数字来进行比较。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">true &gt; 0&#x2F;&#x2F;true，true-&gt;1比较</span><br></pre></td></tr></table></figure>\n\n<h4 id=\"lt-与-gt\"><a href=\"#lt-与-gt\" class=\"headerlink\" title=\"&lt;= 与&gt;=\"></a>&lt;= 与&gt;=</h4><ul>\n<li>根据规范a &lt;= b 被处理为b &lt; a，然后将结果反转。因为b &lt; a 的结果是false，所以a &lt;= b 的结果是true</li>\n<li>实际上JavaScript 中&lt;= 是“不大于”的意思（即!(a &gt; b)，处理为!(b &lt; a)）。同理a &gt;= b 处理为b &lt;= a。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a &#x3D; &#123;&#125;</span><br><span class=\"line\">let b &#x3D; &#123;&#125;</span><br><span class=\"line\">console.log(a &#x3D;&#x3D; b)&#x2F;&#x2F;false，两个对象不指向同一个值，不相等</span><br><span class=\"line\">console.log(a &lt; b)&#x2F;&#x2F;false</span><br><span class=\"line\">console.log(a &gt; b)&#x2F;&#x2F;false</span><br><span class=\"line\">console.log(a &lt;&#x3D; b)&#x2F;&#x2F;true</span><br><span class=\"line\">console.log(a &gt;&#x3D; b)&#x2F;&#x2F;true</span><br></pre></td></tr></table></figure>\n\n"}],"PostAsset":[],"PostCategory":[{"post_id":"ckmaospgc0000d0tja6n3hcvl","category_id":"ckm1jn1il005hrctjauj23r5z","_id":"ckmaospgx0005d0tjhi8j6ucu"},{"post_id":"ckmaospgh0001d0tj638k3601","category_id":"ckmaospgk0003d0tj1kpd7r7c","_id":"ckmaospgy0007d0tj2j452wwh"},{"post_id":"ckmap4djr0000wotjerg0d3vy","category_id":"ckm1jn1fq0002rctjf6bpb4y7","_id":"ckmap4djy0006wotjaj0i6xa7"},{"post_id":"ckmap4djv0001wotj49g08sx6","category_id":"ckm1jn1fq0002rctjf6bpb4y7","_id":"ckmap4djz0009wotj39392o9q"},{"post_id":"ckmap4djx0003wotjglx0emzt","category_id":"ckm1jn1g4000jrctj791a1gzr","_id":"ckmap4dk1000cwotjazfrat4i"},{"post_id":"ckmap4djy0005wotj9t490jyb","category_id":"ckm1jn1fq0002rctjf6bpb4y7","_id":"ckmap4dk2000fwotjg8y3fmeb"},{"post_id":"ckmap4djz0008wotj2evsb0n5","category_id":"ckm1jn1fq0002rctjf6bpb4y7","_id":"ckmap4dk3000iwotjc6h3ff9e"},{"post_id":"ckmap4dk0000bwotj94q1e8sq","category_id":"ckm1jn1fq0002rctjf6bpb4y7","_id":"ckmap4dk4000lwotj7146735n"},{"post_id":"ckmap4dk1000ewotj14ymh44s","category_id":"ckm1jn1fq0002rctjf6bpb4y7","_id":"ckmap4dk5000owotje0fp6owq"},{"post_id":"ckmap4dk2000hwotj85vk1s7p","category_id":"ckm1jn1fq0002rctjf6bpb4y7","_id":"ckmap4dk6000rwotj5zifdj4z"},{"post_id":"ckmap4dk3000kwotj9tus2wle","category_id":"ckm1jn1fq0002rctjf6bpb4y7","_id":"ckmap4dk7000uwotj4uddb3sk"},{"post_id":"ckmap4dk5000nwotj92uehy4f","category_id":"ckm1jn1fq0002rctjf6bpb4y7","_id":"ckmap4dk8000xwotj6nejho49"},{"post_id":"ckmap4dk6000qwotj6svv7rn9","category_id":"ckm1jn1fq0002rctjf6bpb4y7","_id":"ckmap4dk90010wotj9zu6595m"},{"post_id":"ckmap4dk7000twotjfcy43b9i","category_id":"ckm1jn1gc0013rctjc2alb5vh","_id":"ckmap4dka0013wotjde2gcluc"},{"post_id":"ckmap4dk8000wwotj92sv9qks","category_id":"ckm1jn1fq0002rctjf6bpb4y7","_id":"ckmap4dkb0016wotjf3ux07pp"},{"post_id":"ckmap4dk9000zwotj04ar0sma","category_id":"ckm1jn1gl001rrctjfa04e9zv","_id":"ckmap4dkc0019wotj6n6931at"},{"post_id":"ckmap4dka0012wotj65fg1eom","category_id":"ckm1jn1gg001drctjfeh74x06","_id":"ckmap4dkd001cwotj2a3d6zxq"},{"post_id":"ckmap4dkb0015wotj9xcygqlq","category_id":"ckm1jn1gg001drctjfeh74x06","_id":"ckmap4dkd001fwotjbg0o51jq"},{"post_id":"ckmap4dkb0018wotj3ih58qto","category_id":"ckm1jn1gg001drctjfeh74x06","_id":"ckmap4dke001iwotj5l2veb8w"},{"post_id":"ckmap4dkc001bwotjc5kc1xub","category_id":"ckm1jn1ix006drctjf74o1vcz","_id":"ckmap4dkf001lwotjereraj0l"},{"post_id":"ckmap4dkd001ewotjeoo06xtj","category_id":"ckm1jn1gm001xrctjcra8b0u4","_id":"ckmap4dkg001owotj1fxkdn6y"},{"post_id":"ckmap4dke001hwotjamve3ab2","category_id":"ckm1jn1fq0002rctjf6bpb4y7","_id":"ckmap4dkg001rwotj2pnfgegg"},{"post_id":"ckmap4dke001kwotjhr62c9r6","category_id":"ckm1jn1g4000jrctj791a1gzr","_id":"ckmap4dkh001uwotj6lms8z5i"},{"post_id":"ckmap4dkf001nwotjdow06e9y","category_id":"ckm1jn1hg0031rctj9sj24gim","_id":"ckmap4dki001xwotjdk2ra9iv"},{"post_id":"ckmap4dkg001qwotj9tkxa4aa","category_id":"ckm1jn1hk0037rctj520p1zq4","_id":"ckmap4dkj0020wotjdhzda44k"},{"post_id":"ckmap4dkh001twotj6clv4cw1","category_id":"ckm1jn1g4000jrctj791a1gzr","_id":"ckmap4dkk0023wotj9z4sbzea"},{"post_id":"ckmap4dki001wwotj4hx8egkn","category_id":"ckm1jn1g4000jrctj791a1gzr","_id":"ckmap4dkm0026wotj0nt5hu1b"},{"post_id":"ckmap4dkj001zwotjesro4o7s","category_id":"ckm1jn1hn003drctjh90x3vjo","_id":"ckmap4dkn0029wotjbavvezv2"},{"post_id":"ckmap4dkj0022wotj76wwaj0k","category_id":"ckm1jn1hq003lrctj17ny7pv0","_id":"ckmap4dko002cwotjejhg06jf"},{"post_id":"ckmap4dkk0025wotjcs2a4usa","category_id":"ckm1jn1g4000jrctj791a1gzr","_id":"ckmap4dks002gwotj9mmk1d2x"},{"post_id":"ckmap4dkn0028wotjelj9bo7e","category_id":"ckm1jn1g4000jrctj791a1gzr","_id":"ckmap4dkt002jwotj72it505m"},{"post_id":"ckmap4dkn002bwotj62c686gg","category_id":"ckm1jn1g4000jrctj791a1gzr","_id":"ckmap4dku002mwotj2egfgsan"},{"post_id":"ckmap4dks002fwotjbxbwbjbn","category_id":"ckm1jn1g4000jrctj791a1gzr","_id":"ckmap4dky002pwotjaviy12ox"},{"post_id":"ckmap4dks002iwotj56bc8h14","category_id":"ckm1jn1g4000jrctj791a1gzr","_id":"ckmap4dkz002twotjea4x7rqs"},{"post_id":"ckmap4dkt002lwotj0qm2eti5","category_id":"ckm1jn1g4000jrctj791a1gzr","_id":"ckmap4dkz002wwotjfkt56ak7"},{"post_id":"ckmap4dku002owotj29ti6f9n","category_id":"ckm1jn1iv0068rctj4oq811jq","_id":"ckmap4dl0002zwotjb8magelc"},{"post_id":"ckmap4dky002swotj0g080vme","category_id":"ckm1jn1g4000jrctj791a1gzr","_id":"ckmap4dl10032wotjet92drwy"},{"post_id":"ckmap4dkz002vwotj0b1qdg11","category_id":"ckm1jn1ir005vrctj18mp78zz","_id":"ckmap4dl10035wotjhda24dvw"},{"post_id":"ckmap4dl0002ywotj3mumdug5","category_id":"ckm1jn1iv0068rctj4oq811jq","_id":"ckmap4dl30038wotj9ewehq1q"},{"post_id":"ckmap4dl00031wotj14xb7ueu","category_id":"ckm1jn1hs003trctj9eigc0b2","_id":"ckmap4dl4003bwotjelynazby"},{"post_id":"ckmap4dl10034wotjhphm7963","category_id":"ckm1jn1hs003trctj9eigc0b2","_id":"ckmap4dl5003ewotj4u44fbiu"},{"post_id":"ckmap4dl20037wotj0kn5e5hc","category_id":"ckm1jn1i0004crctj00z55wbd","_id":"ckmap4dl6003hwotj6moy7621"},{"post_id":"ckmap4dl4003awotj021ggnnl","category_id":"ckm1jn1hs003trctj9eigc0b2","_id":"ckmap4dl7003kwotjc2977gx5"},{"post_id":"ckmap4dl5003dwotj1u76b69n","category_id":"ckm1jn1hs003trctj9eigc0b2","_id":"ckmap4dl7003nwotj3ukt00ka"},{"post_id":"ckmap4dl6003gwotj0ynf863k","category_id":"ckm1jn1i0004crctj00z55wbd","_id":"ckmap4dl8003qwotjcjcl5mm3"},{"post_id":"ckmap4dl6003jwotj89vafisn","category_id":"ckm1jn1i0004crctj00z55wbd","_id":"ckmap4dl9003twotj5hc4385i"},{"post_id":"ckmap4dl7003mwotjdu4k4o20","category_id":"ckm1jn1i0004crctj00z55wbd","_id":"ckmap4dla003wwotj8pntfuuh"},{"post_id":"ckmap4dl8003pwotjcvk34dee","category_id":"ckm1jn1i0004crctj00z55wbd","_id":"ckmap4dlb003zwotj9kyu1sdk"},{"post_id":"ckmap4dl8003swotj1xs7ev1q","category_id":"ckm1jn1iz006hrctj74f729df","_id":"ckmap4dlb0042wotj8n66b2do"},{"post_id":"ckmap4dl9003vwotj5ro9akqv","category_id":"ckm1jn1io005prctj5bbf9kus","_id":"ckmap4dld0045wotj40ad0nrt"},{"post_id":"ckmap4dla003ywotj84v00fth","category_id":"ckm1jn1is0060rctjgvspabaq","_id":"ckmap4dle0047wotjd8kmboqc"},{"post_id":"ckmap4dlb0041wotj4b07229d","category_id":"ckm1jn1it0063rctj32fahebi","_id":"ckmap4dle004awotjedqc3q0u"},{"post_id":"ckmap4dld0044wotjao27hfeu","category_id":"ckmap4dle0048wotj8ikw7j9j","_id":"ckmap4dlf004fwotjcw9gfruq"},{"post_id":"ckmap4dlk005jwotjg97h8aau","category_id":"ckmap4dle0048wotj8ikw7j9j","_id":"ckmap4dlm005pwotj5ioq1fid"},{"post_id":"ckmap4dll005kwotjcag64o3c","category_id":"ckmap4dle0048wotj8ikw7j9j","_id":"ckmap4dln005swotj3lwnby1m"},{"post_id":"ckmap4dll005mwotjfo0v9hos","category_id":"ckm1jn1ih0059rctj2kry2so1","_id":"ckmap4dln005uwotjfrp8fqlh"},{"post_id":"ckmap4dlm005owotjh1qq75yr","category_id":"ckm1jn1ib0050rctj268vb2pc","_id":"ckmap4dlo005wwotj4ea7ddz9"},{"post_id":"ckmap4dln005rwotjcite7c1a","category_id":"ckm1jn1g4000jrctj791a1gzr","_id":"ckmap4dlo005ywotj7ssmgg2j"}],"PostTag":[{"post_id":"ckmaospgc0000d0tja6n3hcvl","tag_id":"ckm1jn1j3006vrctj9qy11cl6","_id":"ckmaospgk0002d0tj5rrzg2oy"},{"post_id":"ckmaospgh0001d0tj638k3601","tag_id":"ckmaospgw0004d0tj6r2a1t70","_id":"ckmaospgy0008d0tjga1m59xb"},{"post_id":"ckmaospgh0001d0tj638k3601","tag_id":"ckmaospgx0006d0tjetsm89xa","_id":"ckmaospgy0009d0tjfmk41rpa"},{"post_id":"ckmap4djr0000wotjerg0d3vy","tag_id":"ckm1jn1fr0003rctjfiik5z7g","_id":"ckmap4djx0002wotj8s3ve9p9"},{"post_id":"ckmap4djr0000wotjerg0d3vy","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4djy0004wotjdc24d2ji"},{"post_id":"ckmap4djv0001wotj49g08sx6","tag_id":"ckm1jn1fr0003rctjfiik5z7g","_id":"ckmap4djy0007wotj6zkr5gyd"},{"post_id":"ckmap4djv0001wotj49g08sx6","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dk0000awotj5dn9hh7o"},{"post_id":"ckmap4djx0003wotjglx0emzt","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dk1000dwotjajogeigi"},{"post_id":"ckmap4djx0003wotjglx0emzt","tag_id":"ckm1jn1gh001frctjg4jngbth","_id":"ckmap4dk2000gwotj4pmafg7k"},{"post_id":"ckmap4djy0005wotj9t490jyb","tag_id":"ckm1jn1fr0003rctjfiik5z7g","_id":"ckmap4dk3000jwotj1im9fyid"},{"post_id":"ckmap4djy0005wotj9t490jyb","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dk5000mwotj4xvt108m"},{"post_id":"ckmap4djz0008wotj2evsb0n5","tag_id":"ckm1jn1fr0003rctjfiik5z7g","_id":"ckmap4dk6000pwotj5gumfr7l"},{"post_id":"ckmap4djz0008wotj2evsb0n5","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dk7000swotj9fki3r28"},{"post_id":"ckmap4dk0000bwotj94q1e8sq","tag_id":"ckm1jn1fr0003rctjfiik5z7g","_id":"ckmap4dk8000vwotj9c30eelk"},{"post_id":"ckmap4dk0000bwotj94q1e8sq","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dk9000ywotjdvuf1wmu"},{"post_id":"ckmap4dk1000ewotj14ymh44s","tag_id":"ckm1jn1fr0003rctjfiik5z7g","_id":"ckmap4dka0011wotj9873fold"},{"post_id":"ckmap4dk1000ewotj14ymh44s","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dka0014wotj9v6w53wo"},{"post_id":"ckmap4dk2000hwotj85vk1s7p","tag_id":"ckm1jn1fr0003rctjfiik5z7g","_id":"ckmap4dkb0017wotjfesugf0p"},{"post_id":"ckmap4dk2000hwotj85vk1s7p","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dkc001awotjgir5adf3"},{"post_id":"ckmap4dk3000kwotj9tus2wle","tag_id":"ckm1jn1fr0003rctjfiik5z7g","_id":"ckmap4dkd001dwotj84ddcfih"},{"post_id":"ckmap4dk3000kwotj9tus2wle","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dke001gwotj4vmvbqyz"},{"post_id":"ckmap4dk3000kwotj9tus2wle","tag_id":"ckm1jn1gl001srctjchjg7an8","_id":"ckmap4dke001jwotjbenjdyte"},{"post_id":"ckmap4dk5000nwotj92uehy4f","tag_id":"ckm1jn1fr0003rctjfiik5z7g","_id":"ckmap4dkf001mwotjd14c0ome"},{"post_id":"ckmap4dk5000nwotj92uehy4f","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dkg001pwotjchhja44f"},{"post_id":"ckmap4dk6000qwotj6svv7rn9","tag_id":"ckm1jn1fr0003rctjfiik5z7g","_id":"ckmap4dkh001swotj5vha5q23"},{"post_id":"ckmap4dk6000qwotj6svv7rn9","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dki001vwotj2epmfw7q"},{"post_id":"ckmap4dk7000twotjfcy43b9i","tag_id":"ckm1jn1gm001zrctjfad62g8k","_id":"ckmap4dki001ywotj81qfhslo"},{"post_id":"ckmap4dk7000twotjfcy43b9i","tag_id":"ckm1jn1gq0024rctj9jq68pne","_id":"ckmap4dkj0021wotjhy52gekz"},{"post_id":"ckmap4dk8000wwotj92sv9qks","tag_id":"ckm1jn1fr0003rctjfiik5z7g","_id":"ckmap4dkk0024wotj5urp936z"},{"post_id":"ckmap4dk8000wwotj92sv9qks","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dkn0027wotjcjfi2b6l"},{"post_id":"ckmap4dk9000zwotj04ar0sma","tag_id":"ckm1jn1gr0028rctjd1y29p8v","_id":"ckmap4dkn002awotjbe6b4utw"},{"post_id":"ckmap4dk9000zwotj04ar0sma","tag_id":"ckm1jn1gu002orctja3m1gw5g","_id":"ckmap4dkr002ewotj911409xo"},{"post_id":"ckmap4dka0012wotj65fg1eom","tag_id":"ckm1jn1gr0028rctjd1y29p8v","_id":"ckmap4dks002hwotj0i5m5xf2"},{"post_id":"ckmap4dka0012wotj65fg1eom","tag_id":"ckm1jn1gt002irctj5mff5p5k","_id":"ckmap4dkt002kwotj1d6ggh0u"},{"post_id":"ckmap4dkb0015wotj9xcygqlq","tag_id":"ckm1jn1gr0028rctjd1y29p8v","_id":"ckmap4dku002nwotjem236iwh"},{"post_id":"ckmap4dkb0015wotj9xcygqlq","tag_id":"ckm1jn1gr002brctj86ik2bes","_id":"ckmap4dky002rwotjgrab9yzx"},{"post_id":"ckmap4dkb0018wotj3ih58qto","tag_id":"ckm1jn1gr0028rctjd1y29p8v","_id":"ckmap4dkz002uwotj7hyt96ek"},{"post_id":"ckmap4dkc001bwotjc5kc1xub","tag_id":"ckm1jn1j7007arctjfgzkd1d4","_id":"ckmap4dl0002xwotjcypnf9lf"},{"post_id":"ckmap4dkd001ewotjeoo06xtj","tag_id":"ckm1jn1gv002prctj0vy1189s","_id":"ckmap4dl00030wotj3d7a3uox"},{"post_id":"ckmap4dkd001ewotjeoo06xtj","tag_id":"ckm1jn1gq0024rctj9jq68pne","_id":"ckmap4dl10033wotj35nn78ip"},{"post_id":"ckmap4dke001hwotjamve3ab2","tag_id":"ckm1jn1fr0003rctjfiik5z7g","_id":"ckmap4dl20036wotjc50y63g1"},{"post_id":"ckmap4dke001hwotjamve3ab2","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dl40039wotj90ubehim"},{"post_id":"ckmap4dke001hwotjamve3ab2","tag_id":"ckm1jn1j3006srctj6i3w9pli","_id":"ckmap4dl5003cwotj84k4gdnd"},{"post_id":"ckmap4dke001kwotjhr62c9r6","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dl6003fwotj24wo7ibi"},{"post_id":"ckmap4dkf001nwotjdow06e9y","tag_id":"ckm1jn1hh0032rctjacbc2wop","_id":"ckmap4dl6003iwotj1ed41y6z"},{"post_id":"ckmap4dkf001nwotjdow06e9y","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dl7003lwotjdlnb6c18"},{"post_id":"ckmap4dkf001nwotjdow06e9y","tag_id":"ckm1jn1hk0038rctjf30d1vh4","_id":"ckmap4dl8003owotj5sec97vq"},{"post_id":"ckmap4dkg001qwotj9tkxa4aa","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dl8003rwotjgxy99pmn"},{"post_id":"ckmap4dkg001qwotj9tkxa4aa","tag_id":"ckm1jn1hn003erctjdaf47mjd","_id":"ckmap4dl9003uwotjgxfh95yo"},{"post_id":"ckmap4dkg001qwotj9tkxa4aa","tag_id":"ckm1jn1hq003mrctjfl7jdsk8","_id":"ckmap4dla003xwotjenzd4tvm"},{"post_id":"ckmap4dkh001twotj6clv4cw1","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dlb0040wotj3gigdhds"},{"post_id":"ckmap4dki001wwotj4hx8egkn","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dld0043wotj7cbm4qyk"},{"post_id":"ckmap4dkj001zwotjesro4o7s","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dle0046wotj6lkg3ne6"},{"post_id":"ckmap4dkj001zwotjesro4o7s","tag_id":"ckm1jn1ht003urctj6deo48so","_id":"ckmap4dle0049wotjbvf485eg"},{"post_id":"ckmap4dkj0022wotj76wwaj0k","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dlf004bwotj3kr51izn"},{"post_id":"ckmap4dkj0022wotj76wwaj0k","tag_id":"ckm1jn1hw0043rctjd3nggr52","_id":"ckmap4dlf004cwotj1x0shzfw"},{"post_id":"ckmap4dkj0022wotj76wwaj0k","tag_id":"ckm1jn1gr0028rctjd1y29p8v","_id":"ckmap4dlf004dwotjhf1o306c"},{"post_id":"ckmap4dkk0025wotjcs2a4usa","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dlf004ewotj1vvv5c17"},{"post_id":"ckmap4dkn002bwotj62c686gg","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dlf004gwotj9y9016fv"},{"post_id":"ckmap4dkn002bwotj62c686gg","tag_id":"ckm1jn1hz004arctj1ljpbogv","_id":"ckmap4dlf004hwotjbfnsfmf6"},{"post_id":"ckmap4dks002fwotjbxbwbjbn","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dlf004iwotjdk0ggg27"},{"post_id":"ckmap4dks002fwotjbxbwbjbn","tag_id":"ckm1jn1ii005arctja9t093hg","_id":"ckmap4dlf004jwotj9h0s4pmg"},{"post_id":"ckmap4dks002iwotj56bc8h14","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dlf004kwotj0trp4unv"},{"post_id":"ckmap4dks002iwotj56bc8h14","tag_id":"ckm1jn1i5004rrctjfq91hk05","_id":"ckmap4dlf004lwotjcos25jde"},{"post_id":"ckmap4dkn0028wotjelj9bo7e","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dlf004mwotjdum2g1f4"},{"post_id":"ckmap4dkn0028wotjelj9bo7e","tag_id":"ckmap4dko002dwotj868v122d","_id":"ckmap4dlf004nwotj1k1rfw4z"},{"post_id":"ckmap4dku002owotj29ti6f9n","tag_id":"ckm1jn1j60077rctj9cr76ys7","_id":"ckmap4dlg004owotj4kzz5fbd"},{"post_id":"ckmap4dku002owotj29ti6f9n","tag_id":"ckm1jn1j60079rctj1kn3bykf","_id":"ckmap4dlg004pwotjb0xc9rqk"},{"post_id":"ckmap4dky002swotj0g080vme","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dlg004qwotjcupd45dz"},{"post_id":"ckmap4dky002swotj0g080vme","tag_id":"ckm1jn1ic0052rctjfaa2eini","_id":"ckmap4dlg004rwotjbe3d9vok"},{"post_id":"ckmap4dkz002vwotj0b1qdg11","tag_id":"ckm1jn1j40071rctjdmwg0ctn","_id":"ckmap4dlg004swotj2cpi3oma"},{"post_id":"ckmap4dkt002lwotj0qm2eti5","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dlg004twotj9i9de7hb"},{"post_id":"ckmap4dkt002lwotj0qm2eti5","tag_id":"ckmap4dky002qwotj08kb6e6k","_id":"ckmap4dlg004uwotjfw6jfex7"},{"post_id":"ckmap4dl0002ywotj3mumdug5","tag_id":"ckm1jn1j60079rctj1kn3bykf","_id":"ckmap4dlg004vwotjdm2he2a5"},{"post_id":"ckmap4dl00031wotj14xb7ueu","tag_id":"ckm1jn1i2004irctjftxjh973","_id":"ckmap4dlh004wwotjf8xc63ep"},{"post_id":"ckmap4dl10034wotjhphm7963","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dlh004xwotjfkr0enlp"},{"post_id":"ckmap4dl10034wotjhphm7963","tag_id":"ckm1jn1i2004irctjftxjh973","_id":"ckmap4dlh004ywotj3sd7gd5r"},{"post_id":"ckmap4dl20037wotj0kn5e5hc","tag_id":"ckm1jn1is0061rctj92rb95ov","_id":"ckmap4dlh004zwotj6uofe4e7"},{"post_id":"ckmap4dl4003awotj021ggnnl","tag_id":"ckm1jn1i2004irctjftxjh973","_id":"ckmap4dlh0050wotj810b4y92"},{"post_id":"ckmap4dl4003awotj021ggnnl","tag_id":"ckm1jn1ir005yrctj3dqcfdvs","_id":"ckmap4dlh0051wotj3mce0bi7"},{"post_id":"ckmap4dl5003dwotj1u76b69n","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dli0052wotj3z9q5ego"},{"post_id":"ckmap4dl5003dwotj1u76b69n","tag_id":"ckm1jn1i2004irctjftxjh973","_id":"ckmap4dli0053wotjg23le2zu"},{"post_id":"ckmap4dl6003gwotj0ynf863k","tag_id":"ckm1jn1is0061rctj92rb95ov","_id":"ckmap4dli0054wotj1ax323ue"},{"post_id":"ckmap4dl6003jwotj89vafisn","tag_id":"ckm1jn1is0061rctj92rb95ov","_id":"ckmap4dli0055wotjgqwz9dad"},{"post_id":"ckmap4dl7003mwotjdu4k4o20","tag_id":"ckm1jn1is0061rctj92rb95ov","_id":"ckmap4dli0056wotjh3d0ewr5"},{"post_id":"ckmap4dl8003pwotjcvk34dee","tag_id":"ckm1jn1is0061rctj92rb95ov","_id":"ckmap4dli0057wotjcjwx2i94"},{"post_id":"ckmap4dl8003swotj1xs7ev1q","tag_id":"ckm1jn1j7007drctjhe62clu9","_id":"ckmap4dli0058wotj7xrxgqtw"},{"post_id":"ckmap4dl8003swotj1xs7ev1q","tag_id":"ckm1jn1j2006rrctj9exd6dtg","_id":"ckmap4dlj0059wotjdtb65wps"},{"post_id":"ckmap4dl8003swotj1xs7ev1q","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dlj005awotjg69d0xyq"},{"post_id":"ckmap4dl9003vwotj5ro9akqv","tag_id":"ckmaospgw0004d0tj6r2a1t70","_id":"ckmap4dlj005bwotjem9ah8ra"},{"post_id":"ckmap4dl9003vwotj5ro9akqv","tag_id":"ckm1jn1j4006yrctjfpcqff3z","_id":"ckmap4dlj005cwotjfdt8goix"},{"post_id":"ckmap4dla003ywotj84v00fth","tag_id":"ckm1jn1j50073rctj5t90b8i7","_id":"ckmap4dlj005dwotj5uu02brm"},{"post_id":"ckmap4dla003ywotj84v00fth","tag_id":"ckmaospgw0004d0tj6r2a1t70","_id":"ckmap4dlj005ewotj8r5g2hph"},{"post_id":"ckmap4dlb0041wotj4b07229d","tag_id":"ckm1jn1j50075rctj9m1t830m","_id":"ckmap4dlj005fwotjhsdkdpos"},{"post_id":"ckmap4dlb0041wotj4b07229d","tag_id":"ckmaospgw0004d0tj6r2a1t70","_id":"ckmap4dlj005gwotjajvrgd9z"},{"post_id":"ckmap4dld0044wotjao27hfeu","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dlk005hwotjamohgts4"},{"post_id":"ckmap4dld0044wotjao27hfeu","tag_id":"ckm1jn1j2006rrctj9exd6dtg","_id":"ckmap4dlk005iwotj3du352v1"},{"post_id":"ckmap4dlk005jwotjg97h8aau","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dll005lwotjg4mu4dg3"},{"post_id":"ckmap4dlk005jwotjg97h8aau","tag_id":"ckm1jn1j2006rrctj9exd6dtg","_id":"ckmap4dlm005nwotj063mcwe7"},{"post_id":"ckmap4dll005kwotjcag64o3c","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dln005qwotj62z45b7j"},{"post_id":"ckmap4dll005kwotjcag64o3c","tag_id":"ckm1jn1j2006rrctj9exd6dtg","_id":"ckmap4dln005twotj5ixsdguq"},{"post_id":"ckmap4dll005mwotjfo0v9hos","tag_id":"ckm1jn1j2006orctjcr3e8oki","_id":"ckmap4dln005vwotjev2n2rn1"},{"post_id":"ckmap4dll005mwotjfo0v9hos","tag_id":"ckm1jn1j2006rrctj9exd6dtg","_id":"ckmap4dlo005xwotj7x1u9xii"},{"post_id":"ckmap4dlm005owotjh1qq75yr","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dlo005zwotj1rnthowb"},{"post_id":"ckmap4dlm005owotjh1qq75yr","tag_id":"ckm1jn1j0006lrctjcwb16xa9","_id":"ckmap4dlo0060wotj4i14fdwg"},{"post_id":"ckmap4dln005rwotjcite7c1a","tag_id":"ckm1jn1fv0008rctjfy9fhac4","_id":"ckmap4dlo0061wotj5t3ncqvy"},{"post_id":"ckmap4dln005rwotjcite7c1a","tag_id":"ckm1jn1hz004arctj1ljpbogv","_id":"ckmap4dlo0062wotj58rw6jmu"}],"Tag":[{"name":"ES6","_id":"ckm1jn1fr0003rctjfiik5z7g"},{"name":"js","_id":"ckm1jn1fv0008rctjfy9fhac4"},{"name":"async&await","_id":"ckm1jn1gh001frctjg4jngbth"},{"name":"Array","_id":"ckm1jn1gl001srctjchjg7an8"},{"name":"flexible","_id":"ckm1jn1gm001zrctjfad62g8k"},{"name":"h5","_id":"ckm1jn1gq0024rctj9jq68pne"},{"name":"css","_id":"ckm1jn1gr0028rctjd1y29p8v"},{"name":"动画","_id":"ckm1jn1gr002brctj86ik2bes"},{"name":"css动画","_id":"ckm1jn1gt002irctj5mff5p5k"},{"name":"postcss","_id":"ckm1jn1gu002orctja3m1gw5g"},{"name":"视口","_id":"ckm1jn1gv002prctj0vy1189s"},{"name":"大数","_id":"ckm1jn1hh0032rctjacbc2wop"},{"name":"小数","_id":"ckm1jn1hk0038rctjf30d1vh4"},{"name":"文件","_id":"ckm1jn1hn003erctjdaf47mjd"},{"name":"file","_id":"ckm1jn1hq003mrctjfl7jdsk8"},{"name":"scroll","_id":"ckm1jn1ht003urctj6deo48so"},{"name":"DOM","_id":"ckm1jn1hw0043rctjd3nggr52"},{"name":"js类型","_id":"ckm1jn1hz004arctj1ljpbogv"},{"name":"react","_id":"ckm1jn1i2004irctjftxjh973"},{"name":"深拷贝","_id":"ckm1jn1i5004rrctjfq91hk05"},{"name":"节流与防抖","_id":"ckm1jn1ic0052rctjfaa2eini"},{"name":"正则表达式","_id":"ckm1jn1ii005arctja9t093hg"},{"name":"redux","_id":"ckm1jn1ir005yrctj3dqcfdvs"},{"name":"webpack","_id":"ckm1jn1is0061rctj92rb95ov"},{"name":"算法","_id":"ckm1jn1j0006lrctjcwb16xa9"},{"name":"缓存","_id":"ckm1jn1j2006orctjcr3e8oki"},{"name":"浏览器","_id":"ckm1jn1j2006rrctj9exd6dtg"},{"name":"Babel","_id":"ckm1jn1j3006srctj6i3w9pli"},{"name":"docker","_id":"ckm1jn1j3006vrctj9qy11cl6"},{"name":"git","_id":"ckm1jn1j4006yrctjfpcqff3z"},{"name":"linux","_id":"ckm1jn1j40071rctjdmwg0ctn"},{"name":"npm","_id":"ckm1jn1j50073rctj5t90b8i7"},{"name":"yarn","_id":"ckm1jn1j50075rctj9m1t830m"},{"name":"pm2","_id":"ckm1jn1j60077rctj9cr76ys7"},{"name":"node","_id":"ckm1jn1j60079rctj1kn3bykf"},{"name":"hexo","_id":"ckm1jn1j7007arctjfgzkd1d4"},{"name":"性能优化","_id":"ckm1jn1j7007drctjhe62clu9"},{"name":"工程化","_id":"ckmaospgw0004d0tj6r2a1t70"},{"name":"代码检查","_id":"ckmaospgx0006d0tjetsm89xa"},{"name":"数组","_id":"ckmap4dko002dwotj868v122d"},{"name":"js继承","_id":"ckmap4dky002qwotj08kb6e6k"}]}}