{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/logo.gif","path":"images/logo.gif","modified":1,"renderable":0},{"_id":"source/images/my_head.jpeg","path":"images/my_head.jpeg","modified":1,"renderable":0},{"_id":"source/images/favicon.ico","path":"images/favicon.ico","modified":1,"renderable":0},{"_id":"source/images/git_icon.jpg","path":"images/git_icon.jpg","modified":1,"renderable":0},{"_id":"source/images/浏览器缓存.png","path":"images/浏览器缓存.png","modified":1,"renderable":0},{"_id":"themes/git_them/source/css/base.styl","path":"css/base.styl","modified":1,"renderable":1},{"_id":"themes/git_them/source/css/calendar.styl","path":"css/calendar.styl","modified":1,"renderable":1},{"_id":"themes/git_them/source/css/code.styl","path":"css/code.styl","modified":1,"renderable":1},{"_id":"themes/git_them/source/css/footer.styl","path":"css/footer.styl","modified":1,"renderable":1},{"_id":"themes/git_them/source/css/main.css","path":"css/main.css","modified":1,"renderable":1},{"_id":"themes/git_them/source/css/navbar.styl","path":"css/navbar.styl","modified":1,"renderable":1},{"_id":"themes/git_them/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/git_them/source/css/header.styl","path":"css/header.styl","modified":1,"renderable":1},{"_id":"themes/git_them/source/css/post.styl","path":"css/post.styl","modified":1,"renderable":1},{"_id":"themes/git_them/source/js/main.js","path":"js/main.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/git_them/LICENSE","hash":"dae982bca6e2d3d0527e4619de459419c7c838fc","modified":1534815648000},{"_id":"themes/git_them/README.md","hash":"0f0056a2cf0ee8c001ae17e34e29ab1556738ad8","modified":1534815648000},{"_id":"themes/git_them/_config.yml","hash":"1340f39b1b2ef266884de98e1f31175ec8626e4f","modified":1550283611998},{"_id":"themes/git_them/.gitignore","hash":"b9c4d3cfcf0530fa5ee6eacf43499be4b0fd0505","modified":1534815648000},{"_id":"source/.DS_Store","hash":"df2fbeb1400acda0909a32c1cf6bf492f1121e07","modified":1550290574629},{"_id":"themes/git_them/layout/archive.ejs","hash":"a1d44d86d47310b0bc972adc619803864cba5945","modified":1550302817935},{"_id":"themes/git_them/layout/index.ejs","hash":"7cb81af3c423608401f9614e28678abd92b94f8a","modified":1550289524085},{"_id":"themes/git_them/layout/page.ejs","hash":"f9b3d303225b32893b411f3638a3885c56e90cdb","modified":1534815648000},{"_id":"themes/git_them/layout/layout.ejs","hash":"f6a45300b7e765a360de6903cb500fffdf5c7a74","modified":1550290391472},{"_id":"themes/git_them/layout/post.ejs","hash":"851e9404a79274d2cb8a13808116dfcb53d069d4","modified":1534815648000},{"_id":"themes/git_them/test/main.test.js","hash":"f754846394a9e01b6e0feb590dd1d9ccd0d5d4de","modified":1534815648000},{"_id":"source/categories/index.md","hash":"dddedc30b306f6643f76836d5337dfa85febf00a","modified":1534430032724},{"_id":"source/_posts/.DS_Store","hash":"4d4f16417c3389c696aee0cb3e58eace1c664aef","modified":1550283214602},{"_id":"source/_posts/ES6-Set&Map.md","hash":"fdd5378ee41d7990f442b14bd5d3fa23af008db7","modified":1542183888859},{"_id":"source/_posts/Babel配置.md","hash":"a08f1d0cd629f84c51aa498ea65cc299259b681a","modified":1542205563962},{"_id":"source/_posts/ES6-Symbol.md","hash":"f4f7821603172ece80102cef227eb076e9e0adb5","modified":1550018832968},{"_id":"source/_posts/ES6-async-await.md","hash":"071d92979afd64afa42954deca719b51d4dfa03c","modified":1546431484295},{"_id":"source/_posts/ES6-class.md","hash":"d28f810e1dfd19263f21171b28977114b16bbd85","modified":1550301424811},{"_id":"source/_posts/ES6-promise.md","hash":"ba1d87015669840d0973a9646ce7de3a427b224e","modified":1550047832638},{"_id":"source/_posts/ES6-代理-Proxy-与反射-Reflection.md","hash":"ee372db2f3dcf1a838a2581342e4635b862a4758","modified":1550298627940},{"_id":"source/_posts/ES6-函数.md","hash":"c3bb1b54a0438fb9393c8bcae6b9656807c0cdb1","modified":1546955165639},{"_id":"source/_posts/ES6-扩展对象属性.md","hash":"53fadaba99582af975ced41bffc784e84dcad6ba","modified":1550053216675},{"_id":"source/_posts/ES6-改进数组功能.md","hash":"1dde4e83d5b51b43170e47734e303f4e67fd0c29","modified":1550240054897},{"_id":"source/_posts/ES6-模块化.md","hash":"d4b30ed073df2c97f75f7da5cb37596d0d706eae","modified":1550297501920},{"_id":"source/_posts/ES6-解构.md","hash":"392eb3b427e9c059ebd41108b17b4f6e32486afa","modified":1538104197807},{"_id":"source/_posts/ES6-迭代器iterator&生成器generator.md","hash":"73f8bd3b9d5848280960c04aee5856077f5d6828","modified":1550044674489},{"_id":"source/_posts/decimal处理数字问题.md","hash":"b4b0708ef7d49ab069e9d192c422064904a527b2","modified":1548938440523},{"_id":"source/_posts/js-eventLoop.md","hash":"1dd7497583f16ec6d085d41e2293acfea61dac41","modified":1546431231766},{"_id":"source/_posts/flexible布局以及1px边框解决方案.md","hash":"45c6dd45ddb612058a6b27a40ef5ff3e4e6a02cf","modified":1547997169669},{"_id":"source/_posts/js-file相关.md","hash":"52e72f6296d29395bded9d0cbf9c1f65216dee85","modified":1548936102597},{"_id":"source/_posts/js-深浅拷贝.md","hash":"086e08013b78e8263d7c299f553b1df7e4723ffb","modified":1546743366974},{"_id":"source/_posts/js数据类型检测.md","hash":"bf99e46e867244a0dc819a9e522bfbaea587e469","modified":1550036266161},{"_id":"source/_posts/js-节流与防抖.md","hash":"6b66f24e1241722ab595fa0e77c27df8b4c5ed4e","modified":1546431344710},{"_id":"source/_posts/js正则表达式.md","hash":"ca401026edf1568f016d3e65d7698a7a6367c260","modified":1542810344694},{"_id":"source/_posts/postcss相关.md","hash":"696f173db5acbed20816200e7933290f1586870b","modified":1548937794527},{"_id":"source/_posts/translateY-实现列表hover的box-shadow动画.md","hash":"e8dc9bccb750a04e29bcd8bb9352625bce974589","modified":1546431016410},{"_id":"source/_posts/webpack-CommonsChunkPlugin与optimization-splitChunks.md","hash":"814679489e9bc42c40336651f3913fc6a4ae0382","modified":1547538845562},{"_id":"source/_posts/webpack-打包文件相关.md","hash":"ab24f8527f05ca7ac87fc876efef48a484de0314","modified":1546743785129},{"_id":"source/_posts/webpack-搭建环境以及相关优化.md","hash":"03094118c64abebc1541c2b8c727982a15630e0b","modified":1546743843459},{"_id":"source/_posts/webpack配置全局常量.md","hash":"537429377210547a5220ec5f6002de0207f997d8","modified":1537943081823},{"_id":"source/_posts/webpack-简介以及相关概念.md","hash":"bd622ed0330ba0ae71d5d6f7010e3845784d1cda","modified":1546743716337},{"_id":"source/_posts/你不知道的js学习笔记.md","hash":"742982296218e7b3ecb3a490b7f8d1acdacaa6a6","modified":1546431709447},{"_id":"source/_posts/创建Hexo-github博客流程.md","hash":"b2574edf98dd47778b9bee73df17c44388632ee7","modified":1534809319214},{"_id":"source/_posts/性能优化.md","hash":"4bad24dd427b7634b6c65fb194d71f26b64fe6d5","modified":1550131031070},{"_id":"source/_posts/浏览器缓存.md","hash":"4af58959e136f2ecf7ee432420c86f6074388900","modified":1549894233149},{"_id":"source/_posts/视口概念.md","hash":"05cb95bba409e58b3f100856a5e5a5457bb182d0","modified":1547995399461},{"_id":"source/images/logo.gif","hash":"10572efb24a57b3818a2cd6004c9b8e6e8223bbc","modified":1526185982000},{"_id":"source/images/my_head.jpeg","hash":"d390c0b494a9dda39f25540bf08e5cf021b244f7","modified":1544082051859},{"_id":"source/search/index.md","hash":"79534eae7fbda695bf2eb79074cc0f43c76d3658","modified":1534430032721},{"_id":"source/tags/index.md","hash":"b096f35017854e5aa727cea789be704a996bde06","modified":1534429644522},{"_id":"source/images/favicon.ico","hash":"2f09f7d3759d6aa21960878df30abc43ade67814","modified":1534427019000},{"_id":"source/images/git_icon.jpg","hash":"eec74bf82b2d730da0f3abd6bfa804e47cdbc4e1","modified":1550245658998},{"_id":"source/images/浏览器缓存.png","hash":"b10df7f3685800a6f53e98b7c0d404df98565bb8","modified":1536245072602},{"_id":"themes/git_them/layout/_partial/article.ejs","hash":"83b37692e1d8139a10a2088a7ede450f1a007529","modified":1550300851914},{"_id":"themes/git_them/layout/_partial/calendar.ejs","hash":"e17e44850eb7ad71c07169f228acd74a0b061b51","modified":1550295629736},{"_id":"themes/git_them/layout/_partial/footer.ejs","hash":"f50801f50f5cf07985896682da8c7e958d9976db","modified":1550298311155},{"_id":"themes/git_them/layout/_partial/head.ejs","hash":"7451c94ffc1d1b984407233e86e03cd2c142e10c","modified":1550296676447},{"_id":"themes/git_them/layout/_partial/header.ejs","hash":"fe6765fbd8aa513d578b6ff927b059ae350865f3","modified":1550298515127},{"_id":"themes/git_them/layout/_partial/intro.ejs","hash":"7fa7147871fc5b4792e25deae670c5bcafd84418","modified":1550297915735},{"_id":"themes/git_them/layout/_partial/navbar-secondary.ejs","hash":"aac14de4f63d8d9c4fde0219d1206aa1f0d7627b","modified":1534815648000},{"_id":"themes/git_them/layout/_partial/navbar.ejs","hash":"f1706d8cd9468072406345eac14f0c69c41aa393","modified":1550299108000},{"_id":"themes/git_them/layout/_partial/script.ejs","hash":"c917cc709366b5706b1112a2d25f7daf387a12a1","modified":1550289767222},{"_id":"themes/git_them/layout/_widget/disqus.ejs","hash":"ac8a5ae8517318d094381621a6ef9c3e00e60c8f","modified":1534815648000},{"_id":"themes/git_them/layout/_widget/baidutongji.ejs","hash":"f11adfa3dd5d47039b58bf9174a16ced87a10a6e","modified":1534815648000},{"_id":"themes/git_them/layout/_widget/gitalk.ejs","hash":"03547aaf44fe813f3d35613a086f567c4c0287dc","modified":1534815648000},{"_id":"themes/git_them/layout/_widget/google-analytics.ejs","hash":"21e4951dd61edd4f09056485d2e15b177895b46f","modified":1534815648000},{"_id":"themes/git_them/layout/_widget/google-custom-search.ejs","hash":"789f910476fe50827c6e9733efae44358c084360","modified":1534815648000},{"_id":"themes/git_them/source/css/_variables.styl","hash":"0a92cf3cc9eb415bbbab6e8877b6e8e74a9dcba9","modified":1534815648000},{"_id":"themes/git_them/source/css/base.styl","hash":"4f5dd37f111a8943d84f4259fbe4d01d8e7c47eb","modified":1550241426467},{"_id":"themes/git_them/source/css/calendar.styl","hash":"becd031536714de84b2eed0f3ef126c13b039b83","modified":1534815648000},{"_id":"themes/git_them/source/css/code.styl","hash":"cadef68fe242f7a2b6674ca3e230ce1f9746e08b","modified":1550298463651},{"_id":"themes/git_them/source/css/footer.styl","hash":"f50089ebf0e9b560983b09faad3cc9ced495aaed","modified":1534815648000},{"_id":"themes/git_them/source/css/main.css","hash":"79f4322bba35e45842b0f716b0729d63aa7e701d","modified":1534815648000},{"_id":"themes/git_them/source/css/navbar.styl","hash":"b3c4a7d61c4d75e51bd8ad8dc779271fcd4d0cfd","modified":1550299376750},{"_id":"themes/git_them/source/css/main.styl","hash":"f3dd225033a2c4be025b9e468ac498be67362f4a","modified":1550302860375},{"_id":"themes/git_them/source/css/header.styl","hash":"b6819022575a1c6ed6039ac7cce8803c109a57f6","modified":1534815648000},{"_id":"themes/git_them/source/css/post.styl","hash":"cc244ce559ae4591ffc5572a0ada9c8ee8bb5890","modified":1550244078474},{"_id":"themes/git_them/source/js/main.js","hash":"1cc23de812297dfef373b9bab39c85c913dc1471","modified":1550299537630}],"Category":[{"name":"ES6","_id":"cjs76ob5o0003e0jc68t9xvtj"},{"name":"js","_id":"cjs76ob67000ke0jc9nb75uwk"},{"name":"decimal","_id":"cjs76ob6l0014e0jcvho69une"},{"name":"file","_id":"cjs76ob6r001ee0jc7noxkkdi"},{"name":"flexible","_id":"cjs76ob6z001ne0jccseby8bb"},{"name":"postcss","_id":"cjs76ob75001ze0jcas9wftto"},{"name":"css","_id":"cjs76ob7b0029e0jcxuynkmsu"},{"name":"webpack","_id":"cjs76ob7f002ie0jc928xgtlv"},{"name":"hexo","_id":"cjs76ob7y003ee0jc48jah2ay"},{"name":"性能优化","_id":"cjs76ob80003ke0jceu0jxlpa"},{"name":"缓存","_id":"cjs76ob81003qe0jc8ixjfczy"},{"name":"视口","_id":"cjs76ob82003ve0jcwd131phs"}],"Data":[],"Page":[{"title":"categories","date":"2018-08-16T14:33:01.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: categories\ndate: 2018-08-16 22:33:01\ntype: \"categories\"\n---\n","updated":"2018-08-16T14:33:52.724Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjs76ob5g0000e0jcokkxjywg","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"search","date":"2018-08-16T14:33:18.000Z","type":"search","_content":"","source":"search/index.md","raw":"---\ntitle: search\ndate: 2018-08-16 22:33:18\ntype: \"search\"\n---\n","updated":"2018-08-16T14:33:52.721Z","path":"search/index.html","comments":1,"layout":"page","_id":"cjs76ob8h0055e0jcg1n5i90h","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"tags","date":"2018-08-16T14:27:04.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: tags\ndate: 2018-08-16 22:27:04\ntype: \"tags\"\n---\n","updated":"2018-08-16T14:27:24.522Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjs76ob8h0056e0jc0zxtnt6s","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Babel配置","date":"2018-11-14T14:24:43.000Z","_content":"\n\n### babel介绍\n#### 功能\n把 JavaScript 中 es2015/2016/2017/2046 的新语法转化为 es5，让低端运行环境(如浏览器和 node )能够认识并执行。\n#### 阶段\n总共分为三个阶段：解析，转换，生成。babel把功能分解到plugin里，需要配置插件。\n\n#### 插件种类\n语法插件、转义插件（比如转义箭头函数）\n\n### 配置\n#### 6.x\n##### 安装依赖\n\n```\n\"devDependencies\": {\n    \"babel-cli\": \"^6.26.0\",\n    \"babel-core\": \"^6.26.3\",\n    \"babel-plugin-transform-runtime\": \"^6.23.0\",\n    \"babel-preset-env\": \"^1.7.0\",\n    \"babel-preset-stage-2\": \"^6.24.1\"\n},\n\"dependencies\": {\n    \"babel-runtime\": \"^6.26.0\",\n    \"babel-polyfill\": \"^6.26.0\"\n}\n```\n\n##### .babelrc配置\n\n```\n{\n    \"presets\": [\n        [\n            \"env\",\n            {\n                \"modules\": false,\n                \"useBuiltIns\": true,\n                \"debug\": true,\n                \"targets\": {\n                    \"browsers\": [\n                        \"chrome 70\"\n                    ]\n                }\n            }\n        ]\n    ],\n    \"plugins\": [\n        \"babel-plugin-transform-runtime\"\n    ]\n}\n```\n#### 7.x\n##### 安装依赖\n```\n\"devDependencies\": {\n    \"@babel/cli\": \"^7.1.5\",\n    \"@babel/core\": \"^7.1.5\",\n    \"@babel/plugin-transform-runtime\": \"^7.1.0\",\n    \"@babel/preset-env\": \"^7.1.5\"\n  },\n  \"dependencies\": {\n    \"@babel/polyfill\": \"^7.0.0\",\n    \"@babel/runtime\": \"^7.1.5\",\n    \"@babel/runtime-corejs2\": \"^7.1.5\"\n  }\n```\n##### .babelrc配置\n```\n{\n    \"presets\": [\n        [\n            \"@babel/preset-env\",\n            {\n                \"targets\": {\n                },\n                \"modules\": false,\n                \"useBuiltIns\": \"entry\"\n            }\n        ]\n    ],\n    \"plugins\": [\n        [\n            \"@babel/plugin-transform-runtime\",\n            {\n                \"corejs\": 2,\n                \"helpers\": true,\n                \"regenerator\": true,\n                \"useESModules\": false\n            }\n        ]\n    ]\n}\n```\n\n##### .browserslistrc配置文件\n```\n> 1%\nnot dead\n```\n### 文档\n- [babel 6.26.3](https://babeljs.io/docs/en/6.26.3/)\n- [babel 7.x](https://babeljs.io/docs/en/index.html)\n- [browserslist 文档](https://github.com/browserslist/browserslist)\n- [一口(很长的)气了解 Babel](https://mp.weixin.qq.com/s/qetiJo47IyssYWAr455xHQ)\n### .babelrc配置\n#### preset\n- babel 提供的一组插件的集合。官方preset(env, react, flow, minify,stage-x)\n- Stage 0 - 稻草人: 只是一个想法，经过 TC39 成员提出即可。\n- Stage 1 - 提案: 初步尝试。\n- Stage 2 - 初稿: 完成初步规范。\n- Stage 3 - 候选: 完成规范和浏览器初步实现。\n- Stage 4 - 完成: 将被添加到下一年度发布。\n\n低一级的 stage 会包含所有高级 stage 的内容，例如 stage-1 会包含 stage-2, stage-3 的所有内容。\nstage-4 在下一年更新会直接放到 env 中，所以没有单独的 stage-4 可供使用。\n\n#### Plugin\n会运行在 Preset 之前。\nPlugin 会从前到后顺序执行。\nPreset 的顺序则 刚好相反(从后向前)。\n\n- preset 的逆向顺序主要是为了保证向后兼容，因为大多数用户的编写顺序是 [‘es2015’, ‘stage-0’]。这样必须先执行 stage-0 才能确保 babel 不报错。因此我们编排 preset 的时候，也要注意顺序，其实只要按照规范的时间顺序列出即可。\n\n- 简略情况下，插件和 preset 只要列出字符串格式的名字即可。但如果某个 preset 或者插件需要一些配置项(或者说参数)，就需要把自己先变成数组。第一个元素依然是字符串，表示自己的名字；第二个元素是一个对象，即配置对象。\n\n#### env\n- env 的核心目的是通过配置得知目标环境的特点，然后只做必要的转换。\n如果不写任何配置项，env 等价于 latest，也等价于 es2015 + es2016 + es2017 三个相加(不包含 stage-x 中的插件)。\n\n### 一些工具\n#### babel-cli\n命令行工具，安装后可以使用命令行编译文件。\n\n```\nbabel script.js --watch --out-file script-compiled.js\nbabel script.js --out-file script-compiled.js --source-maps\n```\n\n\n#### babel-node\nbabel-node 是 babel-cli 的一部分，作用是在 node 环境中，直接运行 es2015 的代码，而不需要额外进行转码。\n- babel-node = babel-polyfill + babel-register\n\n#### babel-register\nbabel-register 模块改写 require 命令，为它加上一个钩子。此后，每当使用 require 加载 .js、.jsx、.es 和 .es6 后缀名的文件，就会先用 babel 进行转码。\n使用时，必须首先加载 require(‘babel-register’)。\n需要注意的是，babel-register 只会对 require 命令加载的文件转码，而 不会对当前文件转码。\n另外，由于它是实时转码，所以 只适合在开发环境使用。\n\n#### babel-polyfill\n换新的 API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象。\n- babel-polyfill 主要有两个缺点：\n1. 使用 babel-polyfill 会导致打出来的包非常大\n2. babel-polyfill 会污染全局变量，给很多类的原型链上都作了修改，如果我们开发的也是一个类库供其他开发者使用，这种情况就会变得非常不可控。\n\n#### babel-runtime 和 babel-plugin-transform-runtime\n- babel-plugin-transform-runtime定义在devDependencies\n- babel-runtime定义在dependencies\n- 首先如果只使用babel每个被转化的文件都会插入一段代码 这就导致重复和浪费了。\n使用 babel-plugin-transform-runtime 定义方法改成引用，那重复定义就变成了重复引用，就不存在代码重复的问题了。\n- babel-runtime 出场了，它就是这些方法的集合处，在使用 babel-plugin-transform-runtime 的时候必须把 babel-runtime 当做依赖。\n- babel-plugin-transform-runtime 不支持 实例方法 (例如 [1,2,3].includes(1))\n\n#### babel-loader\n在构建工具（webpack）uglify之前进行处理。压缩后的代码进行 babel 处理，会非常慢。\nbabel-loader 也会读取 .babelrc 或者 package.json 中的 babel 段作为自己的配置，之后的内核处理也是相同。\n\n### Babel 7.x\n- preset 的变更：淘汰 es201x，删除 stage-x，强推 env\n- npm package 名称的变化\n1. babel-cli 变成了 @babel/cli\n2. babel-preset-env 变成了 @babel/preset-env，还可以省略 preset 而简写为 @babel/env\n3. babel-plugin-transform-arrow-functions 变成了 @babel/plugin-transform-arrow-functions\n- 不再支持低版本 node\nbabel 7.0 开始不再支持 nodejs 0.10, 0.12, 4, 5 这四个版本\n- only 和 ignore 匹配规则的变化\n在 babel 6 时，ignore 选项如果包含 .foo.js，实际上的含义 (转化为 glob) 是 ./**/.foo.js，也就是当前目录 包括子目录 的所有 foo.js 结尾的文件。这可能和开发者常规的认识有悖。\n于是在 babel 7，相同的表达式 .foo.js 只作用于当前目录，不作用于子目录。如果依然想作用于子目录的，就要按照 glob 的完整规范书写为 ./**/.foo.js 才可以。only 也是相同。\n- @babel/node 从 @babel/cli 中独立了\n和 babel 6 不同，如果要使用 @babel/node，就必须单独安装，并添加到依赖中\n#### babel-upgrade\n- 不安装到本地而是直接运行命令，npm 的新功能\n\n```\nnpx babel-upgrade --write\n```\n\n或者常规方式\n\n```\nnpm i babel-upgrade -g\nbabel-upgrade --write\n```\n\n","source":"_posts/Babel配置.md","raw":"---\ntitle: Babel配置\ndate: 2018-11-14 22:24:43\ntags: [ES6,js,Babel]\ncategories: ES6\n---\n\n\n### babel介绍\n#### 功能\n把 JavaScript 中 es2015/2016/2017/2046 的新语法转化为 es5，让低端运行环境(如浏览器和 node )能够认识并执行。\n#### 阶段\n总共分为三个阶段：解析，转换，生成。babel把功能分解到plugin里，需要配置插件。\n\n#### 插件种类\n语法插件、转义插件（比如转义箭头函数）\n\n### 配置\n#### 6.x\n##### 安装依赖\n\n```\n\"devDependencies\": {\n    \"babel-cli\": \"^6.26.0\",\n    \"babel-core\": \"^6.26.3\",\n    \"babel-plugin-transform-runtime\": \"^6.23.0\",\n    \"babel-preset-env\": \"^1.7.0\",\n    \"babel-preset-stage-2\": \"^6.24.1\"\n},\n\"dependencies\": {\n    \"babel-runtime\": \"^6.26.0\",\n    \"babel-polyfill\": \"^6.26.0\"\n}\n```\n\n##### .babelrc配置\n\n```\n{\n    \"presets\": [\n        [\n            \"env\",\n            {\n                \"modules\": false,\n                \"useBuiltIns\": true,\n                \"debug\": true,\n                \"targets\": {\n                    \"browsers\": [\n                        \"chrome 70\"\n                    ]\n                }\n            }\n        ]\n    ],\n    \"plugins\": [\n        \"babel-plugin-transform-runtime\"\n    ]\n}\n```\n#### 7.x\n##### 安装依赖\n```\n\"devDependencies\": {\n    \"@babel/cli\": \"^7.1.5\",\n    \"@babel/core\": \"^7.1.5\",\n    \"@babel/plugin-transform-runtime\": \"^7.1.0\",\n    \"@babel/preset-env\": \"^7.1.5\"\n  },\n  \"dependencies\": {\n    \"@babel/polyfill\": \"^7.0.0\",\n    \"@babel/runtime\": \"^7.1.5\",\n    \"@babel/runtime-corejs2\": \"^7.1.5\"\n  }\n```\n##### .babelrc配置\n```\n{\n    \"presets\": [\n        [\n            \"@babel/preset-env\",\n            {\n                \"targets\": {\n                },\n                \"modules\": false,\n                \"useBuiltIns\": \"entry\"\n            }\n        ]\n    ],\n    \"plugins\": [\n        [\n            \"@babel/plugin-transform-runtime\",\n            {\n                \"corejs\": 2,\n                \"helpers\": true,\n                \"regenerator\": true,\n                \"useESModules\": false\n            }\n        ]\n    ]\n}\n```\n\n##### .browserslistrc配置文件\n```\n> 1%\nnot dead\n```\n### 文档\n- [babel 6.26.3](https://babeljs.io/docs/en/6.26.3/)\n- [babel 7.x](https://babeljs.io/docs/en/index.html)\n- [browserslist 文档](https://github.com/browserslist/browserslist)\n- [一口(很长的)气了解 Babel](https://mp.weixin.qq.com/s/qetiJo47IyssYWAr455xHQ)\n### .babelrc配置\n#### preset\n- babel 提供的一组插件的集合。官方preset(env, react, flow, minify,stage-x)\n- Stage 0 - 稻草人: 只是一个想法，经过 TC39 成员提出即可。\n- Stage 1 - 提案: 初步尝试。\n- Stage 2 - 初稿: 完成初步规范。\n- Stage 3 - 候选: 完成规范和浏览器初步实现。\n- Stage 4 - 完成: 将被添加到下一年度发布。\n\n低一级的 stage 会包含所有高级 stage 的内容，例如 stage-1 会包含 stage-2, stage-3 的所有内容。\nstage-4 在下一年更新会直接放到 env 中，所以没有单独的 stage-4 可供使用。\n\n#### Plugin\n会运行在 Preset 之前。\nPlugin 会从前到后顺序执行。\nPreset 的顺序则 刚好相反(从后向前)。\n\n- preset 的逆向顺序主要是为了保证向后兼容，因为大多数用户的编写顺序是 [‘es2015’, ‘stage-0’]。这样必须先执行 stage-0 才能确保 babel 不报错。因此我们编排 preset 的时候，也要注意顺序，其实只要按照规范的时间顺序列出即可。\n\n- 简略情况下，插件和 preset 只要列出字符串格式的名字即可。但如果某个 preset 或者插件需要一些配置项(或者说参数)，就需要把自己先变成数组。第一个元素依然是字符串，表示自己的名字；第二个元素是一个对象，即配置对象。\n\n#### env\n- env 的核心目的是通过配置得知目标环境的特点，然后只做必要的转换。\n如果不写任何配置项，env 等价于 latest，也等价于 es2015 + es2016 + es2017 三个相加(不包含 stage-x 中的插件)。\n\n### 一些工具\n#### babel-cli\n命令行工具，安装后可以使用命令行编译文件。\n\n```\nbabel script.js --watch --out-file script-compiled.js\nbabel script.js --out-file script-compiled.js --source-maps\n```\n\n\n#### babel-node\nbabel-node 是 babel-cli 的一部分，作用是在 node 环境中，直接运行 es2015 的代码，而不需要额外进行转码。\n- babel-node = babel-polyfill + babel-register\n\n#### babel-register\nbabel-register 模块改写 require 命令，为它加上一个钩子。此后，每当使用 require 加载 .js、.jsx、.es 和 .es6 后缀名的文件，就会先用 babel 进行转码。\n使用时，必须首先加载 require(‘babel-register’)。\n需要注意的是，babel-register 只会对 require 命令加载的文件转码，而 不会对当前文件转码。\n另外，由于它是实时转码，所以 只适合在开发环境使用。\n\n#### babel-polyfill\n换新的 API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象。\n- babel-polyfill 主要有两个缺点：\n1. 使用 babel-polyfill 会导致打出来的包非常大\n2. babel-polyfill 会污染全局变量，给很多类的原型链上都作了修改，如果我们开发的也是一个类库供其他开发者使用，这种情况就会变得非常不可控。\n\n#### babel-runtime 和 babel-plugin-transform-runtime\n- babel-plugin-transform-runtime定义在devDependencies\n- babel-runtime定义在dependencies\n- 首先如果只使用babel每个被转化的文件都会插入一段代码 这就导致重复和浪费了。\n使用 babel-plugin-transform-runtime 定义方法改成引用，那重复定义就变成了重复引用，就不存在代码重复的问题了。\n- babel-runtime 出场了，它就是这些方法的集合处，在使用 babel-plugin-transform-runtime 的时候必须把 babel-runtime 当做依赖。\n- babel-plugin-transform-runtime 不支持 实例方法 (例如 [1,2,3].includes(1))\n\n#### babel-loader\n在构建工具（webpack）uglify之前进行处理。压缩后的代码进行 babel 处理，会非常慢。\nbabel-loader 也会读取 .babelrc 或者 package.json 中的 babel 段作为自己的配置，之后的内核处理也是相同。\n\n### Babel 7.x\n- preset 的变更：淘汰 es201x，删除 stage-x，强推 env\n- npm package 名称的变化\n1. babel-cli 变成了 @babel/cli\n2. babel-preset-env 变成了 @babel/preset-env，还可以省略 preset 而简写为 @babel/env\n3. babel-plugin-transform-arrow-functions 变成了 @babel/plugin-transform-arrow-functions\n- 不再支持低版本 node\nbabel 7.0 开始不再支持 nodejs 0.10, 0.12, 4, 5 这四个版本\n- only 和 ignore 匹配规则的变化\n在 babel 6 时，ignore 选项如果包含 .foo.js，实际上的含义 (转化为 glob) 是 ./**/.foo.js，也就是当前目录 包括子目录 的所有 foo.js 结尾的文件。这可能和开发者常规的认识有悖。\n于是在 babel 7，相同的表达式 .foo.js 只作用于当前目录，不作用于子目录。如果依然想作用于子目录的，就要按照 glob 的完整规范书写为 ./**/.foo.js 才可以。only 也是相同。\n- @babel/node 从 @babel/cli 中独立了\n和 babel 6 不同，如果要使用 @babel/node，就必须单独安装，并添加到依赖中\n#### babel-upgrade\n- 不安装到本地而是直接运行命令，npm 的新功能\n\n```\nnpx babel-upgrade --write\n```\n\n或者常规方式\n\n```\nnpm i babel-upgrade -g\nbabel-upgrade --write\n```\n\n","slug":"Babel配置","published":1,"updated":"2018-11-14T14:26:03.962Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob5i0001e0jc44h6xkoy","content":"<h3 id=\"babel介绍\"><a href=\"#babel介绍\" class=\"headerlink\" title=\"babel介绍\"></a>babel介绍</h3><h4 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h4><p>把 JavaScript 中 es2015/2016/2017/2046 的新语法转化为 es5，让低端运行环境(如浏览器和 node )能够认识并执行。</p>\n<h4 id=\"阶段\"><a href=\"#阶段\" class=\"headerlink\" title=\"阶段\"></a>阶段</h4><p>总共分为三个阶段：解析，转换，生成。babel把功能分解到plugin里，需要配置插件。</p>\n<h4 id=\"插件种类\"><a href=\"#插件种类\" class=\"headerlink\" title=\"插件种类\"></a>插件种类</h4><p>语法插件、转义插件（比如转义箭头函数）</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><h4 id=\"6-x\"><a href=\"#6-x\" class=\"headerlink\" title=\"6.x\"></a>6.x</h4><h5 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;babel-cli&quot;: &quot;^6.26.0&quot;,</span><br><span class=\"line\">    &quot;babel-core&quot;: &quot;^6.26.3&quot;,</span><br><span class=\"line\">    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.23.0&quot;,</span><br><span class=\"line\">    &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,</span><br><span class=\"line\">    &quot;babel-preset-stage-2&quot;: &quot;^6.24.1&quot;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;babel-runtime&quot;: &quot;^6.26.0&quot;,</span><br><span class=\"line\">    &quot;babel-polyfill&quot;: &quot;^6.26.0&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"babelrc配置\"><a href=\"#babelrc配置\" class=\"headerlink\" title=\".babelrc配置\"></a>.babelrc配置</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;presets&quot;: [</span><br><span class=\"line\">        [</span><br><span class=\"line\">            &quot;env&quot;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;modules&quot;: false,</span><br><span class=\"line\">                &quot;useBuiltIns&quot;: true,</span><br><span class=\"line\">                &quot;debug&quot;: true,</span><br><span class=\"line\">                &quot;targets&quot;: &#123;</span><br><span class=\"line\">                    &quot;browsers&quot;: [</span><br><span class=\"line\">                        &quot;chrome 70&quot;</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;plugins&quot;: [</span><br><span class=\"line\">        &quot;babel-plugin-transform-runtime&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"7-x\"><a href=\"#7-x\" class=\"headerlink\" title=\"7.x\"></a>7.x</h4><h5 id=\"安装依赖-1\"><a href=\"#安装依赖-1\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;@babel/cli&quot;: &quot;^7.1.5&quot;,</span><br><span class=\"line\">    &quot;@babel/core&quot;: &quot;^7.1.5&quot;,</span><br><span class=\"line\">    &quot;@babel/plugin-transform-runtime&quot;: &quot;^7.1.0&quot;,</span><br><span class=\"line\">    &quot;@babel/preset-env&quot;: &quot;^7.1.5&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;@babel/polyfill&quot;: &quot;^7.0.0&quot;,</span><br><span class=\"line\">    &quot;@babel/runtime&quot;: &quot;^7.1.5&quot;,</span><br><span class=\"line\">    &quot;@babel/runtime-corejs2&quot;: &quot;^7.1.5&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"babelrc配置-1\"><a href=\"#babelrc配置-1\" class=\"headerlink\" title=\".babelrc配置\"></a>.babelrc配置</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;presets&quot;: [</span><br><span class=\"line\">        [</span><br><span class=\"line\">            &quot;@babel/preset-env&quot;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;targets&quot;: &#123;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &quot;modules&quot;: false,</span><br><span class=\"line\">                &quot;useBuiltIns&quot;: &quot;entry&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;plugins&quot;: [</span><br><span class=\"line\">        [</span><br><span class=\"line\">            &quot;@babel/plugin-transform-runtime&quot;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;corejs&quot;: 2,</span><br><span class=\"line\">                &quot;helpers&quot;: true,</span><br><span class=\"line\">                &quot;regenerator&quot;: true,</span><br><span class=\"line\">                &quot;useESModules&quot;: false</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"browserslistrc配置文件\"><a href=\"#browserslistrc配置文件\" class=\"headerlink\" title=\".browserslistrc配置文件\"></a>.browserslistrc配置文件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 1%</span><br><span class=\"line\">not dead</span><br></pre></td></tr></table></figure>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><ul>\n<li><a href=\"https://babeljs.io/docs/en/6.26.3/\" target=\"_blank\" rel=\"noopener\">babel 6.26.3</a></li>\n<li><a href=\"https://babeljs.io/docs/en/index.html\" target=\"_blank\" rel=\"noopener\">babel 7.x</a></li>\n<li><a href=\"https://github.com/browserslist/browserslist\">browserslist 文档</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/qetiJo47IyssYWAr455xHQ\" target=\"_blank\" rel=\"noopener\">一口(很长的)气了解 Babel</a><h3 id=\"babelrc配置-2\"><a href=\"#babelrc配置-2\" class=\"headerlink\" title=\".babelrc配置\"></a>.babelrc配置</h3><h4 id=\"preset\"><a href=\"#preset\" class=\"headerlink\" title=\"preset\"></a>preset</h4></li>\n<li>babel 提供的一组插件的集合。官方preset(env, react, flow, minify,stage-x)</li>\n<li>Stage 0 - 稻草人: 只是一个想法，经过 TC39 成员提出即可。</li>\n<li>Stage 1 - 提案: 初步尝试。</li>\n<li>Stage 2 - 初稿: 完成初步规范。</li>\n<li>Stage 3 - 候选: 完成规范和浏览器初步实现。</li>\n<li>Stage 4 - 完成: 将被添加到下一年度发布。</li>\n</ul>\n<p>低一级的 stage 会包含所有高级 stage 的内容，例如 stage-1 会包含 stage-2, stage-3 的所有内容。<br>stage-4 在下一年更新会直接放到 env 中，所以没有单独的 stage-4 可供使用。</p>\n<h4 id=\"Plugin\"><a href=\"#Plugin\" class=\"headerlink\" title=\"Plugin\"></a>Plugin</h4><p>会运行在 Preset 之前。<br>Plugin 会从前到后顺序执行。<br>Preset 的顺序则 刚好相反(从后向前)。</p>\n<ul>\n<li><p>preset 的逆向顺序主要是为了保证向后兼容，因为大多数用户的编写顺序是 [‘es2015’, ‘stage-0’]。这样必须先执行 stage-0 才能确保 babel 不报错。因此我们编排 preset 的时候，也要注意顺序，其实只要按照规范的时间顺序列出即可。</p>\n</li>\n<li><p>简略情况下，插件和 preset 只要列出字符串格式的名字即可。但如果某个 preset 或者插件需要一些配置项(或者说参数)，就需要把自己先变成数组。第一个元素依然是字符串，表示自己的名字；第二个元素是一个对象，即配置对象。</p>\n</li>\n</ul>\n<h4 id=\"env\"><a href=\"#env\" class=\"headerlink\" title=\"env\"></a>env</h4><ul>\n<li>env 的核心目的是通过配置得知目标环境的特点，然后只做必要的转换。<br>如果不写任何配置项，env 等价于 latest，也等价于 es2015 + es2016 + es2017 三个相加(不包含 stage-x 中的插件)。</li>\n</ul>\n<h3 id=\"一些工具\"><a href=\"#一些工具\" class=\"headerlink\" title=\"一些工具\"></a>一些工具</h3><h4 id=\"babel-cli\"><a href=\"#babel-cli\" class=\"headerlink\" title=\"babel-cli\"></a>babel-cli</h4><p>命令行工具，安装后可以使用命令行编译文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">babel script.js --watch --out-file script-compiled.js</span><br><span class=\"line\">babel script.js --out-file script-compiled.js --source-maps</span><br></pre></td></tr></table></figure>\n<h4 id=\"babel-node\"><a href=\"#babel-node\" class=\"headerlink\" title=\"babel-node\"></a>babel-node</h4><p>babel-node 是 babel-cli 的一部分，作用是在 node 环境中，直接运行 es2015 的代码，而不需要额外进行转码。</p>\n<ul>\n<li>babel-node = babel-polyfill + babel-register</li>\n</ul>\n<h4 id=\"babel-register\"><a href=\"#babel-register\" class=\"headerlink\" title=\"babel-register\"></a>babel-register</h4><p>babel-register 模块改写 require 命令，为它加上一个钩子。此后，每当使用 require 加载 .js、.jsx、.es 和 .es6 后缀名的文件，就会先用 babel 进行转码。<br>使用时，必须首先加载 require(‘babel-register’)。<br>需要注意的是，babel-register 只会对 require 命令加载的文件转码，而 不会对当前文件转码。<br>另外，由于它是实时转码，所以 只适合在开发环境使用。</p>\n<h4 id=\"babel-polyfill\"><a href=\"#babel-polyfill\" class=\"headerlink\" title=\"babel-polyfill\"></a>babel-polyfill</h4><p>换新的 API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象。</p>\n<ul>\n<li>babel-polyfill 主要有两个缺点：</li>\n</ul>\n<ol>\n<li>使用 babel-polyfill 会导致打出来的包非常大</li>\n<li>babel-polyfill 会污染全局变量，给很多类的原型链上都作了修改，如果我们开发的也是一个类库供其他开发者使用，这种情况就会变得非常不可控。</li>\n</ol>\n<h4 id=\"babel-runtime-和-babel-plugin-transform-runtime\"><a href=\"#babel-runtime-和-babel-plugin-transform-runtime\" class=\"headerlink\" title=\"babel-runtime 和 babel-plugin-transform-runtime\"></a>babel-runtime 和 babel-plugin-transform-runtime</h4><ul>\n<li>babel-plugin-transform-runtime定义在devDependencies</li>\n<li>babel-runtime定义在dependencies</li>\n<li>首先如果只使用babel每个被转化的文件都会插入一段代码 这就导致重复和浪费了。<br>使用 babel-plugin-transform-runtime 定义方法改成引用，那重复定义就变成了重复引用，就不存在代码重复的问题了。</li>\n<li>babel-runtime 出场了，它就是这些方法的集合处，在使用 babel-plugin-transform-runtime 的时候必须把 babel-runtime 当做依赖。</li>\n<li>babel-plugin-transform-runtime 不支持 实例方法 (例如 [1,2,3].includes(1))</li>\n</ul>\n<h4 id=\"babel-loader\"><a href=\"#babel-loader\" class=\"headerlink\" title=\"babel-loader\"></a>babel-loader</h4><p>在构建工具（webpack）uglify之前进行处理。压缩后的代码进行 babel 处理，会非常慢。<br>babel-loader 也会读取 .babelrc 或者 package.json 中的 babel 段作为自己的配置，之后的内核处理也是相同。</p>\n<h3 id=\"Babel-7-x\"><a href=\"#Babel-7-x\" class=\"headerlink\" title=\"Babel 7.x\"></a>Babel 7.x</h3><ul>\n<li>preset 的变更：淘汰 es201x，删除 stage-x，强推 env</li>\n<li>npm package 名称的变化</li>\n</ul>\n<ol>\n<li>babel-cli 变成了 @babel/cli</li>\n<li>babel-preset-env 变成了 @babel/preset-env，还可以省略 preset 而简写为 @babel/env</li>\n<li>babel-plugin-transform-arrow-functions 变成了 @babel/plugin-transform-arrow-functions</li>\n</ol>\n<ul>\n<li>不再支持低版本 node<br>babel 7.0 开始不再支持 nodejs 0.10, 0.12, 4, 5 这四个版本</li>\n<li>only 和 ignore 匹配规则的变化<br>在 babel 6 时，ignore 选项如果包含 .foo.js，实际上的含义 (转化为 glob) 是 ./<strong>/.foo.js，也就是当前目录 包括子目录 的所有 foo.js 结尾的文件。这可能和开发者常规的认识有悖。<br>于是在 babel 7，相同的表达式 .foo.js 只作用于当前目录，不作用于子目录。如果依然想作用于子目录的，就要按照 glob 的完整规范书写为 ./</strong>/.foo.js 才可以。only 也是相同。</li>\n<li>@babel/node 从 @babel/cli 中独立了<br>和 babel 6 不同，如果要使用 @babel/node，就必须单独安装，并添加到依赖中<h4 id=\"babel-upgrade\"><a href=\"#babel-upgrade\" class=\"headerlink\" title=\"babel-upgrade\"></a>babel-upgrade</h4></li>\n<li>不安装到本地而是直接运行命令，npm 的新功能</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx babel-upgrade --write</span><br></pre></td></tr></table></figure>\n<p>或者常规方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i babel-upgrade -g</span><br><span class=\"line\">babel-upgrade --write</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"babel介绍\"><a href=\"#babel介绍\" class=\"headerlink\" title=\"babel介绍\"></a>babel介绍</h3><h4 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h4><p>把 JavaScript 中 es2015/2016/2017/2046 的新语法转化为 es5，让低端运行环境(如浏览器和 node )能够认识并执行。</p>\n<h4 id=\"阶段\"><a href=\"#阶段\" class=\"headerlink\" title=\"阶段\"></a>阶段</h4><p>总共分为三个阶段：解析，转换，生成。babel把功能分解到plugin里，需要配置插件。</p>\n<h4 id=\"插件种类\"><a href=\"#插件种类\" class=\"headerlink\" title=\"插件种类\"></a>插件种类</h4><p>语法插件、转义插件（比如转义箭头函数）</p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><h4 id=\"6-x\"><a href=\"#6-x\" class=\"headerlink\" title=\"6.x\"></a>6.x</h4><h5 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;babel-cli&quot;: &quot;^6.26.0&quot;,</span><br><span class=\"line\">    &quot;babel-core&quot;: &quot;^6.26.3&quot;,</span><br><span class=\"line\">    &quot;babel-plugin-transform-runtime&quot;: &quot;^6.23.0&quot;,</span><br><span class=\"line\">    &quot;babel-preset-env&quot;: &quot;^1.7.0&quot;,</span><br><span class=\"line\">    &quot;babel-preset-stage-2&quot;: &quot;^6.24.1&quot;</span><br><span class=\"line\">&#125;,</span><br><span class=\"line\">&quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;babel-runtime&quot;: &quot;^6.26.0&quot;,</span><br><span class=\"line\">    &quot;babel-polyfill&quot;: &quot;^6.26.0&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"babelrc配置\"><a href=\"#babelrc配置\" class=\"headerlink\" title=\".babelrc配置\"></a>.babelrc配置</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;presets&quot;: [</span><br><span class=\"line\">        [</span><br><span class=\"line\">            &quot;env&quot;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;modules&quot;: false,</span><br><span class=\"line\">                &quot;useBuiltIns&quot;: true,</span><br><span class=\"line\">                &quot;debug&quot;: true,</span><br><span class=\"line\">                &quot;targets&quot;: &#123;</span><br><span class=\"line\">                    &quot;browsers&quot;: [</span><br><span class=\"line\">                        &quot;chrome 70&quot;</span><br><span class=\"line\">                    ]</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;plugins&quot;: [</span><br><span class=\"line\">        &quot;babel-plugin-transform-runtime&quot;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"7-x\"><a href=\"#7-x\" class=\"headerlink\" title=\"7.x\"></a>7.x</h4><h5 id=\"安装依赖-1\"><a href=\"#安装依赖-1\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;devDependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;@babel/cli&quot;: &quot;^7.1.5&quot;,</span><br><span class=\"line\">    &quot;@babel/core&quot;: &quot;^7.1.5&quot;,</span><br><span class=\"line\">    &quot;@babel/plugin-transform-runtime&quot;: &quot;^7.1.0&quot;,</span><br><span class=\"line\">    &quot;@babel/preset-env&quot;: &quot;^7.1.5&quot;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  &quot;dependencies&quot;: &#123;</span><br><span class=\"line\">    &quot;@babel/polyfill&quot;: &quot;^7.0.0&quot;,</span><br><span class=\"line\">    &quot;@babel/runtime&quot;: &quot;^7.1.5&quot;,</span><br><span class=\"line\">    &quot;@babel/runtime-corejs2&quot;: &quot;^7.1.5&quot;</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"babelrc配置-1\"><a href=\"#babelrc配置-1\" class=\"headerlink\" title=\".babelrc配置\"></a>.babelrc配置</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    &quot;presets&quot;: [</span><br><span class=\"line\">        [</span><br><span class=\"line\">            &quot;@babel/preset-env&quot;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;targets&quot;: &#123;</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                &quot;modules&quot;: false,</span><br><span class=\"line\">                &quot;useBuiltIns&quot;: &quot;entry&quot;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &quot;plugins&quot;: [</span><br><span class=\"line\">        [</span><br><span class=\"line\">            &quot;@babel/plugin-transform-runtime&quot;,</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                &quot;corejs&quot;: 2,</span><br><span class=\"line\">                &quot;helpers&quot;: true,</span><br><span class=\"line\">                &quot;regenerator&quot;: true,</span><br><span class=\"line\">                &quot;useESModules&quot;: false</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h5 id=\"browserslistrc配置文件\"><a href=\"#browserslistrc配置文件\" class=\"headerlink\" title=\".browserslistrc配置文件\"></a>.browserslistrc配置文件</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&gt; 1%</span><br><span class=\"line\">not dead</span><br></pre></td></tr></table></figure>\n<h3 id=\"文档\"><a href=\"#文档\" class=\"headerlink\" title=\"文档\"></a>文档</h3><ul>\n<li><a href=\"https://babeljs.io/docs/en/6.26.3/\" target=\"_blank\" rel=\"noopener\">babel 6.26.3</a></li>\n<li><a href=\"https://babeljs.io/docs/en/index.html\" target=\"_blank\" rel=\"noopener\">babel 7.x</a></li>\n<li><a href=\"https://github.com/browserslist/browserslist\">browserslist 文档</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/qetiJo47IyssYWAr455xHQ\" target=\"_blank\" rel=\"noopener\">一口(很长的)气了解 Babel</a><h3 id=\"babelrc配置-2\"><a href=\"#babelrc配置-2\" class=\"headerlink\" title=\".babelrc配置\"></a>.babelrc配置</h3><h4 id=\"preset\"><a href=\"#preset\" class=\"headerlink\" title=\"preset\"></a>preset</h4></li>\n<li>babel 提供的一组插件的集合。官方preset(env, react, flow, minify,stage-x)</li>\n<li>Stage 0 - 稻草人: 只是一个想法，经过 TC39 成员提出即可。</li>\n<li>Stage 1 - 提案: 初步尝试。</li>\n<li>Stage 2 - 初稿: 完成初步规范。</li>\n<li>Stage 3 - 候选: 完成规范和浏览器初步实现。</li>\n<li>Stage 4 - 完成: 将被添加到下一年度发布。</li>\n</ul>\n<p>低一级的 stage 会包含所有高级 stage 的内容，例如 stage-1 会包含 stage-2, stage-3 的所有内容。<br>stage-4 在下一年更新会直接放到 env 中，所以没有单独的 stage-4 可供使用。</p>\n<h4 id=\"Plugin\"><a href=\"#Plugin\" class=\"headerlink\" title=\"Plugin\"></a>Plugin</h4><p>会运行在 Preset 之前。<br>Plugin 会从前到后顺序执行。<br>Preset 的顺序则 刚好相反(从后向前)。</p>\n<ul>\n<li><p>preset 的逆向顺序主要是为了保证向后兼容，因为大多数用户的编写顺序是 [‘es2015’, ‘stage-0’]。这样必须先执行 stage-0 才能确保 babel 不报错。因此我们编排 preset 的时候，也要注意顺序，其实只要按照规范的时间顺序列出即可。</p>\n</li>\n<li><p>简略情况下，插件和 preset 只要列出字符串格式的名字即可。但如果某个 preset 或者插件需要一些配置项(或者说参数)，就需要把自己先变成数组。第一个元素依然是字符串，表示自己的名字；第二个元素是一个对象，即配置对象。</p>\n</li>\n</ul>\n<h4 id=\"env\"><a href=\"#env\" class=\"headerlink\" title=\"env\"></a>env</h4><ul>\n<li>env 的核心目的是通过配置得知目标环境的特点，然后只做必要的转换。<br>如果不写任何配置项，env 等价于 latest，也等价于 es2015 + es2016 + es2017 三个相加(不包含 stage-x 中的插件)。</li>\n</ul>\n<h3 id=\"一些工具\"><a href=\"#一些工具\" class=\"headerlink\" title=\"一些工具\"></a>一些工具</h3><h4 id=\"babel-cli\"><a href=\"#babel-cli\" class=\"headerlink\" title=\"babel-cli\"></a>babel-cli</h4><p>命令行工具，安装后可以使用命令行编译文件。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">babel script.js --watch --out-file script-compiled.js</span><br><span class=\"line\">babel script.js --out-file script-compiled.js --source-maps</span><br></pre></td></tr></table></figure>\n<h4 id=\"babel-node\"><a href=\"#babel-node\" class=\"headerlink\" title=\"babel-node\"></a>babel-node</h4><p>babel-node 是 babel-cli 的一部分，作用是在 node 环境中，直接运行 es2015 的代码，而不需要额外进行转码。</p>\n<ul>\n<li>babel-node = babel-polyfill + babel-register</li>\n</ul>\n<h4 id=\"babel-register\"><a href=\"#babel-register\" class=\"headerlink\" title=\"babel-register\"></a>babel-register</h4><p>babel-register 模块改写 require 命令，为它加上一个钩子。此后，每当使用 require 加载 .js、.jsx、.es 和 .es6 后缀名的文件，就会先用 babel 进行转码。<br>使用时，必须首先加载 require(‘babel-register’)。<br>需要注意的是，babel-register 只会对 require 命令加载的文件转码，而 不会对当前文件转码。<br>另外，由于它是实时转码，所以 只适合在开发环境使用。</p>\n<h4 id=\"babel-polyfill\"><a href=\"#babel-polyfill\" class=\"headerlink\" title=\"babel-polyfill\"></a>babel-polyfill</h4><p>换新的 API，比如 Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise 等全局对象。</p>\n<ul>\n<li>babel-polyfill 主要有两个缺点：</li>\n</ul>\n<ol>\n<li>使用 babel-polyfill 会导致打出来的包非常大</li>\n<li>babel-polyfill 会污染全局变量，给很多类的原型链上都作了修改，如果我们开发的也是一个类库供其他开发者使用，这种情况就会变得非常不可控。</li>\n</ol>\n<h4 id=\"babel-runtime-和-babel-plugin-transform-runtime\"><a href=\"#babel-runtime-和-babel-plugin-transform-runtime\" class=\"headerlink\" title=\"babel-runtime 和 babel-plugin-transform-runtime\"></a>babel-runtime 和 babel-plugin-transform-runtime</h4><ul>\n<li>babel-plugin-transform-runtime定义在devDependencies</li>\n<li>babel-runtime定义在dependencies</li>\n<li>首先如果只使用babel每个被转化的文件都会插入一段代码 这就导致重复和浪费了。<br>使用 babel-plugin-transform-runtime 定义方法改成引用，那重复定义就变成了重复引用，就不存在代码重复的问题了。</li>\n<li>babel-runtime 出场了，它就是这些方法的集合处，在使用 babel-plugin-transform-runtime 的时候必须把 babel-runtime 当做依赖。</li>\n<li>babel-plugin-transform-runtime 不支持 实例方法 (例如 [1,2,3].includes(1))</li>\n</ul>\n<h4 id=\"babel-loader\"><a href=\"#babel-loader\" class=\"headerlink\" title=\"babel-loader\"></a>babel-loader</h4><p>在构建工具（webpack）uglify之前进行处理。压缩后的代码进行 babel 处理，会非常慢。<br>babel-loader 也会读取 .babelrc 或者 package.json 中的 babel 段作为自己的配置，之后的内核处理也是相同。</p>\n<h3 id=\"Babel-7-x\"><a href=\"#Babel-7-x\" class=\"headerlink\" title=\"Babel 7.x\"></a>Babel 7.x</h3><ul>\n<li>preset 的变更：淘汰 es201x，删除 stage-x，强推 env</li>\n<li>npm package 名称的变化</li>\n</ul>\n<ol>\n<li>babel-cli 变成了 @babel/cli</li>\n<li>babel-preset-env 变成了 @babel/preset-env，还可以省略 preset 而简写为 @babel/env</li>\n<li>babel-plugin-transform-arrow-functions 变成了 @babel/plugin-transform-arrow-functions</li>\n</ol>\n<ul>\n<li>不再支持低版本 node<br>babel 7.0 开始不再支持 nodejs 0.10, 0.12, 4, 5 这四个版本</li>\n<li>only 和 ignore 匹配规则的变化<br>在 babel 6 时，ignore 选项如果包含 .foo.js，实际上的含义 (转化为 glob) 是 ./<strong>/.foo.js，也就是当前目录 包括子目录 的所有 foo.js 结尾的文件。这可能和开发者常规的认识有悖。<br>于是在 babel 7，相同的表达式 .foo.js 只作用于当前目录，不作用于子目录。如果依然想作用于子目录的，就要按照 glob 的完整规范书写为 ./</strong>/.foo.js 才可以。only 也是相同。</li>\n<li>@babel/node 从 @babel/cli 中独立了<br>和 babel 6 不同，如果要使用 @babel/node，就必须单独安装，并添加到依赖中<h4 id=\"babel-upgrade\"><a href=\"#babel-upgrade\" class=\"headerlink\" title=\"babel-upgrade\"></a>babel-upgrade</h4></li>\n<li>不安装到本地而是直接运行命令，npm 的新功能</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npx babel-upgrade --write</span><br></pre></td></tr></table></figure>\n<p>或者常规方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm i babel-upgrade -g</span><br><span class=\"line\">babel-upgrade --write</span><br></pre></td></tr></table></figure>\n"},{"title":"ES6-Set&Map","date":"2018-08-22T00:29:44.000Z","_content":"\n\n如果开发者想使用非数值型索引，就会使用数组对象创建数据结构，这是Set&Map早期实现\n## 对象属性的限制\n* 1、map[5]与map['5']是同一个\n* 2、let k1 = {},k2 = {};map[k1]与map[k2]是同一个，因为对象会被转换为默认的字符换表达式\n* 3、map['count'] = 1,检查map.count是否存在很困难\n* 4、in运算符会检索对象原型，只有当原型为null时这个方法才比较稳妥\n\n## Set集合\n* 1、不会对所存储的值进行强制的类型转换，数字5和字符串'5'可作为两个元素存在（内部使用Object.is()检测），但是-0和+0被认为相等\n* 2、如果多次调用add()传入相同的参数，后续的调用会被忽略\n* 3、通过has()方法检测是否含有某个值\n* 4、使用delete()移除元素\n* 5、使用clear()清空Set集合\n\n```\nlet set = new Set([1,1,1,2,2,3])//使用含重复元素的数组初始化Set集合\nconsole.log(set.size)//3\nset.add(5)\nset.add('5')\nset.add(5)//被忽略\nconsole.log(set.has(5))//true\nconsole.log(set.has(6))//false\n\nset.delete(5)\nconsole.log(set.has(5))//false\nset.clear()\nconsole.log(set.size)//0\n```\n\n### set的forEach方法\nset的forEach方法（回调参数：1、下一次索引位置，2、与第一次相同的值（为了和数组forEach参数统一），3、Set集合本身）\n\n```\nlet set2 = new Set([1,2,3])\nset2.forEach(function (val,k,set) {\n    console.log(val)\n    console.log(k)\n    console.log(set===set2)//true\n},this)//如果不是箭头函数，可以从这里传入this\n```\n\n\n不能通过访问数组元素那样直接通过索引访问Set集合元素，需要转换成数组\n```\nlet set3 = new Set([1,1,1,2,2,3,3])\nlet arr = [...set]//复制数组并且创建一个无重复元素的新数组\n```\n### Weak Set\n* 只存储对象的弱引用，并且不可以存储原始值，如果集合中弱引用是对象的唯一引用，则回收释放相应内存\n* 两种Set的主要区别：\n* 1、WeakSet实例中，如果传入非对象参数会报错\n* 2、WeakSet对象不可迭代，不能用for-of循环\n* 3、WeakSet不暴露任何迭代器（keys()\\values()）不能通过程序检测其中内容\n* 4、WeakSet不支持forEach方法\n* 5、WeakSize不支持size属性\n\n```\nlet wset4 = new WeakSet()\nlet k = {}\nwset4.add(k)\nconsole.log(wset4.has(k))//true\nwset4.delete(k)\nconsole.log(wset4.has(k))//false\n```\n\n## Map集合\n* Map类型是一种存储许多键值对的有序列表\n* 其中键名和对应的值支持所有类型，键名的等价性判断是通过Object.is()判断的\n* 添加set(),获取get()\n\n\n```\nlet map = new Map()\nmap.set('aaa','123')\nconsole.log(map.get('aaa'))//123\nconsole.log(map.get(111))//undefined（不存在）\n\n//map总可以使用对象作为键名,对象键名不会强制转换为其他类型，所以这两个键名独立存在\nlet key1 = {},key2 = {}\nmap.set(key1,5)\nmap.set(key2,6)\nconsole.log(map.get(key1))//5\nconsole.log(map.get(key2))//6\n```\n\n* has()判断键名是否存在\n* delete()删除\n* clear()清空\n* Map集合中的size属性和Set中的类似，为集合中键值对的数量\n\n### Map的初始化方法\n\n```\nlet map1 = new Map([['name',1],['age',2]])\nconsole.log(map1.has('name'))\n```\n\n\n### Map集合的forEach\nMap集合的forEach方法，三个参数，1、下一次索引位置2、值对应的键名3、Map集合本身 (可以指定forEach的第二个参数作为回调的this)\n\n```\nmap1.forEach((value,key,ownerMap)=>{\n    console.log(value)\n    console.log(key)\n    console.log(ownerMap === map1)\n})\n```\n\n### Weak Map\n* 最大用途是保存Web页面中的DOM元素\n* ES6中Weak Map是一种存储许多键值对的无序列表，列表的键名必须是非null类型的对象\n* has()\\delete()\n* 不支持键名枚举、不支持clear()方法\n\n\n```\nlet wmap = new WeakMap()\n\nlet element = document.getElementById('aaa')\nwmap.set(element,'123')//element不能为null\nconsole.log(wmap.get(element))\n```\n\n### 私有对象数据\n* 尽管Weak Map大多被用来存储DOM元素，但也有其他用处,ES5一般使用_C下划线属性作为私有属性，但是没有任何标准规定如何使用，也会被更改\n\n\n```\n//ES5处理私有变量,缺点无法获知对象何时被摧毁，obj中的数据永远不会消失\nvar Person = (function () {\n    var obj = {}\n    var idNum = 0\n    function Person(name) {\n        Object.defineProperty(this,'_id',{value: idNum++})\n        obj[this._id] = {\n            name: name\n        }\n    }\n    Person.prototype.getName = function () {\n        return obj[this._id].name\n    }\n    return Person\n})()\nconsole.log(new Person(111).getName())\n```\n\n\n```\n//使用WeakMap解决此问题,只要对象被摧毁，相关信息也会摧毁\nlet WPerson = (function () {\n    let wmap = new WeakMap()\n    function Person(name) {\n        wmap.set(this,{name: name})\n    }\n    Person.prototype.getName = function () {\n        return wmap.get(this).name\n    }\n    return Person\n})()\nconsole.log(new WPerson(222).getName())\n```\n\n\n如果只使用对象作为键名，那么WeakMap是最好的选择，可以有效避免内存泄漏问题\n","source":"_posts/ES6-Set&Map.md","raw":"---\ntitle: ES6-Set&Map\ndate: 2018-08-22 08:29:44\ntags: [ES6,js]\ncategories: ES6\n---\n\n\n如果开发者想使用非数值型索引，就会使用数组对象创建数据结构，这是Set&Map早期实现\n## 对象属性的限制\n* 1、map[5]与map['5']是同一个\n* 2、let k1 = {},k2 = {};map[k1]与map[k2]是同一个，因为对象会被转换为默认的字符换表达式\n* 3、map['count'] = 1,检查map.count是否存在很困难\n* 4、in运算符会检索对象原型，只有当原型为null时这个方法才比较稳妥\n\n## Set集合\n* 1、不会对所存储的值进行强制的类型转换，数字5和字符串'5'可作为两个元素存在（内部使用Object.is()检测），但是-0和+0被认为相等\n* 2、如果多次调用add()传入相同的参数，后续的调用会被忽略\n* 3、通过has()方法检测是否含有某个值\n* 4、使用delete()移除元素\n* 5、使用clear()清空Set集合\n\n```\nlet set = new Set([1,1,1,2,2,3])//使用含重复元素的数组初始化Set集合\nconsole.log(set.size)//3\nset.add(5)\nset.add('5')\nset.add(5)//被忽略\nconsole.log(set.has(5))//true\nconsole.log(set.has(6))//false\n\nset.delete(5)\nconsole.log(set.has(5))//false\nset.clear()\nconsole.log(set.size)//0\n```\n\n### set的forEach方法\nset的forEach方法（回调参数：1、下一次索引位置，2、与第一次相同的值（为了和数组forEach参数统一），3、Set集合本身）\n\n```\nlet set2 = new Set([1,2,3])\nset2.forEach(function (val,k,set) {\n    console.log(val)\n    console.log(k)\n    console.log(set===set2)//true\n},this)//如果不是箭头函数，可以从这里传入this\n```\n\n\n不能通过访问数组元素那样直接通过索引访问Set集合元素，需要转换成数组\n```\nlet set3 = new Set([1,1,1,2,2,3,3])\nlet arr = [...set]//复制数组并且创建一个无重复元素的新数组\n```\n### Weak Set\n* 只存储对象的弱引用，并且不可以存储原始值，如果集合中弱引用是对象的唯一引用，则回收释放相应内存\n* 两种Set的主要区别：\n* 1、WeakSet实例中，如果传入非对象参数会报错\n* 2、WeakSet对象不可迭代，不能用for-of循环\n* 3、WeakSet不暴露任何迭代器（keys()\\values()）不能通过程序检测其中内容\n* 4、WeakSet不支持forEach方法\n* 5、WeakSize不支持size属性\n\n```\nlet wset4 = new WeakSet()\nlet k = {}\nwset4.add(k)\nconsole.log(wset4.has(k))//true\nwset4.delete(k)\nconsole.log(wset4.has(k))//false\n```\n\n## Map集合\n* Map类型是一种存储许多键值对的有序列表\n* 其中键名和对应的值支持所有类型，键名的等价性判断是通过Object.is()判断的\n* 添加set(),获取get()\n\n\n```\nlet map = new Map()\nmap.set('aaa','123')\nconsole.log(map.get('aaa'))//123\nconsole.log(map.get(111))//undefined（不存在）\n\n//map总可以使用对象作为键名,对象键名不会强制转换为其他类型，所以这两个键名独立存在\nlet key1 = {},key2 = {}\nmap.set(key1,5)\nmap.set(key2,6)\nconsole.log(map.get(key1))//5\nconsole.log(map.get(key2))//6\n```\n\n* has()判断键名是否存在\n* delete()删除\n* clear()清空\n* Map集合中的size属性和Set中的类似，为集合中键值对的数量\n\n### Map的初始化方法\n\n```\nlet map1 = new Map([['name',1],['age',2]])\nconsole.log(map1.has('name'))\n```\n\n\n### Map集合的forEach\nMap集合的forEach方法，三个参数，1、下一次索引位置2、值对应的键名3、Map集合本身 (可以指定forEach的第二个参数作为回调的this)\n\n```\nmap1.forEach((value,key,ownerMap)=>{\n    console.log(value)\n    console.log(key)\n    console.log(ownerMap === map1)\n})\n```\n\n### Weak Map\n* 最大用途是保存Web页面中的DOM元素\n* ES6中Weak Map是一种存储许多键值对的无序列表，列表的键名必须是非null类型的对象\n* has()\\delete()\n* 不支持键名枚举、不支持clear()方法\n\n\n```\nlet wmap = new WeakMap()\n\nlet element = document.getElementById('aaa')\nwmap.set(element,'123')//element不能为null\nconsole.log(wmap.get(element))\n```\n\n### 私有对象数据\n* 尽管Weak Map大多被用来存储DOM元素，但也有其他用处,ES5一般使用_C下划线属性作为私有属性，但是没有任何标准规定如何使用，也会被更改\n\n\n```\n//ES5处理私有变量,缺点无法获知对象何时被摧毁，obj中的数据永远不会消失\nvar Person = (function () {\n    var obj = {}\n    var idNum = 0\n    function Person(name) {\n        Object.defineProperty(this,'_id',{value: idNum++})\n        obj[this._id] = {\n            name: name\n        }\n    }\n    Person.prototype.getName = function () {\n        return obj[this._id].name\n    }\n    return Person\n})()\nconsole.log(new Person(111).getName())\n```\n\n\n```\n//使用WeakMap解决此问题,只要对象被摧毁，相关信息也会摧毁\nlet WPerson = (function () {\n    let wmap = new WeakMap()\n    function Person(name) {\n        wmap.set(this,{name: name})\n    }\n    Person.prototype.getName = function () {\n        return wmap.get(this).name\n    }\n    return Person\n})()\nconsole.log(new WPerson(222).getName())\n```\n\n\n如果只使用对象作为键名，那么WeakMap是最好的选择，可以有效避免内存泄漏问题\n","slug":"ES6-Set&Map","published":1,"updated":"2018-11-14T08:24:48.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob5m0002e0jcsucih7ex","content":"<p>如果开发者想使用非数值型索引，就会使用数组对象创建数据结构，这是Set&amp;Map早期实现</p>\n<h2 id=\"对象属性的限制\"><a href=\"#对象属性的限制\" class=\"headerlink\" title=\"对象属性的限制\"></a>对象属性的限制</h2><ul>\n<li>1、map[5]与map[‘5’]是同一个</li>\n<li>2、let k1 = {},k2 = {};map[k1]与map[k2]是同一个，因为对象会被转换为默认的字符换表达式</li>\n<li>3、map[‘count’] = 1,检查map.count是否存在很困难</li>\n<li>4、in运算符会检索对象原型，只有当原型为null时这个方法才比较稳妥</li>\n</ul>\n<h2 id=\"Set集合\"><a href=\"#Set集合\" class=\"headerlink\" title=\"Set集合\"></a>Set集合</h2><ul>\n<li>1、不会对所存储的值进行强制的类型转换，数字5和字符串’5’可作为两个元素存在（内部使用Object.is()检测），但是-0和+0被认为相等</li>\n<li>2、如果多次调用add()传入相同的参数，后续的调用会被忽略</li>\n<li>3、通过has()方法检测是否含有某个值</li>\n<li>4、使用delete()移除元素</li>\n<li>5、使用clear()清空Set集合</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set = new Set([1,1,1,2,2,3])//使用含重复元素的数组初始化Set集合</span><br><span class=\"line\">console.log(set.size)//3</span><br><span class=\"line\">set.add(5)</span><br><span class=\"line\">set.add(&apos;5&apos;)</span><br><span class=\"line\">set.add(5)//被忽略</span><br><span class=\"line\">console.log(set.has(5))//true</span><br><span class=\"line\">console.log(set.has(6))//false</span><br><span class=\"line\"></span><br><span class=\"line\">set.delete(5)</span><br><span class=\"line\">console.log(set.has(5))//false</span><br><span class=\"line\">set.clear()</span><br><span class=\"line\">console.log(set.size)//0</span><br></pre></td></tr></table></figure>\n<h3 id=\"set的forEach方法\"><a href=\"#set的forEach方法\" class=\"headerlink\" title=\"set的forEach方法\"></a>set的forEach方法</h3><p>set的forEach方法（回调参数：1、下一次索引位置，2、与第一次相同的值（为了和数组forEach参数统一），3、Set集合本身）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set2 = new Set([1,2,3])</span><br><span class=\"line\">set2.forEach(function (val,k,set) &#123;</span><br><span class=\"line\">    console.log(val)</span><br><span class=\"line\">    console.log(k)</span><br><span class=\"line\">    console.log(set===set2)//true</span><br><span class=\"line\">&#125;,this)//如果不是箭头函数，可以从这里传入this</span><br></pre></td></tr></table></figure>\n<p>不能通过访问数组元素那样直接通过索引访问Set集合元素，需要转换成数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set3 = new Set([1,1,1,2,2,3,3])</span><br><span class=\"line\">let arr = [...set]//复制数组并且创建一个无重复元素的新数组</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Weak-Set\"><a href=\"#Weak-Set\" class=\"headerlink\" title=\"Weak Set\"></a>Weak Set</h3><ul>\n<li>只存储对象的弱引用，并且不可以存储原始值，如果集合中弱引用是对象的唯一引用，则回收释放相应内存</li>\n<li>两种Set的主要区别：</li>\n<li>1、WeakSet实例中，如果传入非对象参数会报错</li>\n<li>2、WeakSet对象不可迭代，不能用for-of循环</li>\n<li>3、WeakSet不暴露任何迭代器（keys()\\values()）不能通过程序检测其中内容</li>\n<li>4、WeakSet不支持forEach方法</li>\n<li>5、WeakSize不支持size属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let wset4 = new WeakSet()</span><br><span class=\"line\">let k = &#123;&#125;</span><br><span class=\"line\">wset4.add(k)</span><br><span class=\"line\">console.log(wset4.has(k))//true</span><br><span class=\"line\">wset4.delete(k)</span><br><span class=\"line\">console.log(wset4.has(k))//false</span><br></pre></td></tr></table></figure>\n<h2 id=\"Map集合\"><a href=\"#Map集合\" class=\"headerlink\" title=\"Map集合\"></a>Map集合</h2><ul>\n<li>Map类型是一种存储许多键值对的有序列表</li>\n<li>其中键名和对应的值支持所有类型，键名的等价性判断是通过Object.is()判断的</li>\n<li>添加set(),获取get()</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map()</span><br><span class=\"line\">map.set(&apos;aaa&apos;,&apos;123&apos;)</span><br><span class=\"line\">console.log(map.get(&apos;aaa&apos;))//123</span><br><span class=\"line\">console.log(map.get(111))//undefined（不存在）</span><br><span class=\"line\"></span><br><span class=\"line\">//map总可以使用对象作为键名,对象键名不会强制转换为其他类型，所以这两个键名独立存在</span><br><span class=\"line\">let key1 = &#123;&#125;,key2 = &#123;&#125;</span><br><span class=\"line\">map.set(key1,5)</span><br><span class=\"line\">map.set(key2,6)</span><br><span class=\"line\">console.log(map.get(key1))//5</span><br><span class=\"line\">console.log(map.get(key2))//6</span><br></pre></td></tr></table></figure>\n<ul>\n<li>has()判断键名是否存在</li>\n<li>delete()删除</li>\n<li>clear()清空</li>\n<li>Map集合中的size属性和Set中的类似，为集合中键值对的数量</li>\n</ul>\n<h3 id=\"Map的初始化方法\"><a href=\"#Map的初始化方法\" class=\"headerlink\" title=\"Map的初始化方法\"></a>Map的初始化方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map1 = new Map([[&apos;name&apos;,1],[&apos;age&apos;,2]])</span><br><span class=\"line\">console.log(map1.has(&apos;name&apos;))</span><br></pre></td></tr></table></figure>\n<h3 id=\"Map集合的forEach\"><a href=\"#Map集合的forEach\" class=\"headerlink\" title=\"Map集合的forEach\"></a>Map集合的forEach</h3><p>Map集合的forEach方法，三个参数，1、下一次索引位置2、值对应的键名3、Map集合本身 (可以指定forEach的第二个参数作为回调的this)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map1.forEach((value,key,ownerMap)=&gt;&#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">    console.log(key)</span><br><span class=\"line\">    console.log(ownerMap === map1)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Weak-Map\"><a href=\"#Weak-Map\" class=\"headerlink\" title=\"Weak Map\"></a>Weak Map</h3><ul>\n<li>最大用途是保存Web页面中的DOM元素</li>\n<li>ES6中Weak Map是一种存储许多键值对的无序列表，列表的键名必须是非null类型的对象</li>\n<li>has()\\delete()</li>\n<li>不支持键名枚举、不支持clear()方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let wmap = new WeakMap()</span><br><span class=\"line\"></span><br><span class=\"line\">let element = document.getElementById(&apos;aaa&apos;)</span><br><span class=\"line\">wmap.set(element,&apos;123&apos;)//element不能为null</span><br><span class=\"line\">console.log(wmap.get(element))</span><br></pre></td></tr></table></figure>\n<h3 id=\"私有对象数据\"><a href=\"#私有对象数据\" class=\"headerlink\" title=\"私有对象数据\"></a>私有对象数据</h3><ul>\n<li>尽管Weak Map大多被用来存储DOM元素，但也有其他用处,ES5一般使用_C下划线属性作为私有属性，但是没有任何标准规定如何使用，也会被更改</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ES5处理私有变量,缺点无法获知对象何时被摧毁，obj中的数据永远不会消失</span><br><span class=\"line\">var Person = (function () &#123;</span><br><span class=\"line\">    var obj = &#123;&#125;</span><br><span class=\"line\">    var idNum = 0</span><br><span class=\"line\">    function Person(name) &#123;</span><br><span class=\"line\">        Object.defineProperty(this,&apos;_id&apos;,&#123;value: idNum++&#125;)</span><br><span class=\"line\">        obj[this._id] = &#123;</span><br><span class=\"line\">            name: name</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Person.prototype.getName = function () &#123;</span><br><span class=\"line\">        return obj[this._id].name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Person</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">console.log(new Person(111).getName())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用WeakMap解决此问题,只要对象被摧毁，相关信息也会摧毁</span><br><span class=\"line\">let WPerson = (function () &#123;</span><br><span class=\"line\">    let wmap = new WeakMap()</span><br><span class=\"line\">    function Person(name) &#123;</span><br><span class=\"line\">        wmap.set(this,&#123;name: name&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Person.prototype.getName = function () &#123;</span><br><span class=\"line\">        return wmap.get(this).name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Person</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">console.log(new WPerson(222).getName())</span><br></pre></td></tr></table></figure>\n<p>如果只使用对象作为键名，那么WeakMap是最好的选择，可以有效避免内存泄漏问题</p>\n","site":{"data":{}},"excerpt":"","more":"<p>如果开发者想使用非数值型索引，就会使用数组对象创建数据结构，这是Set&amp;Map早期实现</p>\n<h2 id=\"对象属性的限制\"><a href=\"#对象属性的限制\" class=\"headerlink\" title=\"对象属性的限制\"></a>对象属性的限制</h2><ul>\n<li>1、map[5]与map[‘5’]是同一个</li>\n<li>2、let k1 = {},k2 = {};map[k1]与map[k2]是同一个，因为对象会被转换为默认的字符换表达式</li>\n<li>3、map[‘count’] = 1,检查map.count是否存在很困难</li>\n<li>4、in运算符会检索对象原型，只有当原型为null时这个方法才比较稳妥</li>\n</ul>\n<h2 id=\"Set集合\"><a href=\"#Set集合\" class=\"headerlink\" title=\"Set集合\"></a>Set集合</h2><ul>\n<li>1、不会对所存储的值进行强制的类型转换，数字5和字符串’5’可作为两个元素存在（内部使用Object.is()检测），但是-0和+0被认为相等</li>\n<li>2、如果多次调用add()传入相同的参数，后续的调用会被忽略</li>\n<li>3、通过has()方法检测是否含有某个值</li>\n<li>4、使用delete()移除元素</li>\n<li>5、使用clear()清空Set集合</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set = new Set([1,1,1,2,2,3])//使用含重复元素的数组初始化Set集合</span><br><span class=\"line\">console.log(set.size)//3</span><br><span class=\"line\">set.add(5)</span><br><span class=\"line\">set.add(&apos;5&apos;)</span><br><span class=\"line\">set.add(5)//被忽略</span><br><span class=\"line\">console.log(set.has(5))//true</span><br><span class=\"line\">console.log(set.has(6))//false</span><br><span class=\"line\"></span><br><span class=\"line\">set.delete(5)</span><br><span class=\"line\">console.log(set.has(5))//false</span><br><span class=\"line\">set.clear()</span><br><span class=\"line\">console.log(set.size)//0</span><br></pre></td></tr></table></figure>\n<h3 id=\"set的forEach方法\"><a href=\"#set的forEach方法\" class=\"headerlink\" title=\"set的forEach方法\"></a>set的forEach方法</h3><p>set的forEach方法（回调参数：1、下一次索引位置，2、与第一次相同的值（为了和数组forEach参数统一），3、Set集合本身）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set2 = new Set([1,2,3])</span><br><span class=\"line\">set2.forEach(function (val,k,set) &#123;</span><br><span class=\"line\">    console.log(val)</span><br><span class=\"line\">    console.log(k)</span><br><span class=\"line\">    console.log(set===set2)//true</span><br><span class=\"line\">&#125;,this)//如果不是箭头函数，可以从这里传入this</span><br></pre></td></tr></table></figure>\n<p>不能通过访问数组元素那样直接通过索引访问Set集合元素，需要转换成数组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set3 = new Set([1,1,1,2,2,3,3])</span><br><span class=\"line\">let arr = [...set]//复制数组并且创建一个无重复元素的新数组</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"Weak-Set\"><a href=\"#Weak-Set\" class=\"headerlink\" title=\"Weak Set\"></a>Weak Set</h3><ul>\n<li>只存储对象的弱引用，并且不可以存储原始值，如果集合中弱引用是对象的唯一引用，则回收释放相应内存</li>\n<li>两种Set的主要区别：</li>\n<li>1、WeakSet实例中，如果传入非对象参数会报错</li>\n<li>2、WeakSet对象不可迭代，不能用for-of循环</li>\n<li>3、WeakSet不暴露任何迭代器（keys()\\values()）不能通过程序检测其中内容</li>\n<li>4、WeakSet不支持forEach方法</li>\n<li>5、WeakSize不支持size属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let wset4 = new WeakSet()</span><br><span class=\"line\">let k = &#123;&#125;</span><br><span class=\"line\">wset4.add(k)</span><br><span class=\"line\">console.log(wset4.has(k))//true</span><br><span class=\"line\">wset4.delete(k)</span><br><span class=\"line\">console.log(wset4.has(k))//false</span><br></pre></td></tr></table></figure>\n<h2 id=\"Map集合\"><a href=\"#Map集合\" class=\"headerlink\" title=\"Map集合\"></a>Map集合</h2><ul>\n<li>Map类型是一种存储许多键值对的有序列表</li>\n<li>其中键名和对应的值支持所有类型，键名的等价性判断是通过Object.is()判断的</li>\n<li>添加set(),获取get()</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map()</span><br><span class=\"line\">map.set(&apos;aaa&apos;,&apos;123&apos;)</span><br><span class=\"line\">console.log(map.get(&apos;aaa&apos;))//123</span><br><span class=\"line\">console.log(map.get(111))//undefined（不存在）</span><br><span class=\"line\"></span><br><span class=\"line\">//map总可以使用对象作为键名,对象键名不会强制转换为其他类型，所以这两个键名独立存在</span><br><span class=\"line\">let key1 = &#123;&#125;,key2 = &#123;&#125;</span><br><span class=\"line\">map.set(key1,5)</span><br><span class=\"line\">map.set(key2,6)</span><br><span class=\"line\">console.log(map.get(key1))//5</span><br><span class=\"line\">console.log(map.get(key2))//6</span><br></pre></td></tr></table></figure>\n<ul>\n<li>has()判断键名是否存在</li>\n<li>delete()删除</li>\n<li>clear()清空</li>\n<li>Map集合中的size属性和Set中的类似，为集合中键值对的数量</li>\n</ul>\n<h3 id=\"Map的初始化方法\"><a href=\"#Map的初始化方法\" class=\"headerlink\" title=\"Map的初始化方法\"></a>Map的初始化方法</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map1 = new Map([[&apos;name&apos;,1],[&apos;age&apos;,2]])</span><br><span class=\"line\">console.log(map1.has(&apos;name&apos;))</span><br></pre></td></tr></table></figure>\n<h3 id=\"Map集合的forEach\"><a href=\"#Map集合的forEach\" class=\"headerlink\" title=\"Map集合的forEach\"></a>Map集合的forEach</h3><p>Map集合的forEach方法，三个参数，1、下一次索引位置2、值对应的键名3、Map集合本身 (可以指定forEach的第二个参数作为回调的this)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">map1.forEach((value,key,ownerMap)=&gt;&#123;</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">    console.log(key)</span><br><span class=\"line\">    console.log(ownerMap === map1)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h3 id=\"Weak-Map\"><a href=\"#Weak-Map\" class=\"headerlink\" title=\"Weak Map\"></a>Weak Map</h3><ul>\n<li>最大用途是保存Web页面中的DOM元素</li>\n<li>ES6中Weak Map是一种存储许多键值对的无序列表，列表的键名必须是非null类型的对象</li>\n<li>has()\\delete()</li>\n<li>不支持键名枚举、不支持clear()方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let wmap = new WeakMap()</span><br><span class=\"line\"></span><br><span class=\"line\">let element = document.getElementById(&apos;aaa&apos;)</span><br><span class=\"line\">wmap.set(element,&apos;123&apos;)//element不能为null</span><br><span class=\"line\">console.log(wmap.get(element))</span><br></pre></td></tr></table></figure>\n<h3 id=\"私有对象数据\"><a href=\"#私有对象数据\" class=\"headerlink\" title=\"私有对象数据\"></a>私有对象数据</h3><ul>\n<li>尽管Weak Map大多被用来存储DOM元素，但也有其他用处,ES5一般使用_C下划线属性作为私有属性，但是没有任何标准规定如何使用，也会被更改</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//ES5处理私有变量,缺点无法获知对象何时被摧毁，obj中的数据永远不会消失</span><br><span class=\"line\">var Person = (function () &#123;</span><br><span class=\"line\">    var obj = &#123;&#125;</span><br><span class=\"line\">    var idNum = 0</span><br><span class=\"line\">    function Person(name) &#123;</span><br><span class=\"line\">        Object.defineProperty(this,&apos;_id&apos;,&#123;value: idNum++&#125;)</span><br><span class=\"line\">        obj[this._id] = &#123;</span><br><span class=\"line\">            name: name</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Person.prototype.getName = function () &#123;</span><br><span class=\"line\">        return obj[this._id].name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Person</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">console.log(new Person(111).getName())</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//使用WeakMap解决此问题,只要对象被摧毁，相关信息也会摧毁</span><br><span class=\"line\">let WPerson = (function () &#123;</span><br><span class=\"line\">    let wmap = new WeakMap()</span><br><span class=\"line\">    function Person(name) &#123;</span><br><span class=\"line\">        wmap.set(this,&#123;name: name&#125;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Person.prototype.getName = function () &#123;</span><br><span class=\"line\">        return wmap.get(this).name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return Person</span><br><span class=\"line\">&#125;)()</span><br><span class=\"line\">console.log(new WPerson(222).getName())</span><br></pre></td></tr></table></figure>\n<p>如果只使用对象作为键名，那么WeakMap是最好的选择，可以有效避免内存泄漏问题</p>\n"},{"title":"ES6-Symbol","date":"2019-02-13T00:46:38.000Z","_content":"\n#### ES6引入了第六种原始类型Symbol\n#### 私有名称\n- 为了创建非字符串属性名称设计的，Symbol出现之前一直通过属性名称来访问所有属性，全部通过一个字符串来访问。\n#### 创建Symbol\n```\nlet name = Symbol()\nlet obj = {}\nobj[name] = 'yxc'\n```\n- 由于Symbol是原始值，因此调用new Symbol()会报错，\n- Symbol函数接收一个可选参数，让你添加文本描述，建议每次创建都添加。\n```\nlet name = Symbol('name')\n```\n- Symbol的描述被存储在内部的[[Description]]属性中，只有当调用Symbol的toString()方法时才会读取这个属性。\n#### 检测Symbol\n- 使用typeof\n```\nlet name = Symbol('name')\nname.toString()//\"Symbol(name)\"\ntypeof name//\"symbol\"\n```\n#### Symbol的使用\n- 所有使用可计算属性名的地方都可以使用Symbol\n```\nlet name = Symbol('name')\nlet obj = {\n    [name]: 'yxc'\n}\n```\n- 用于Object.defineProperty()\\Object.defineProperties()方法中\n```\nlet name = Symbol('name')\nlet obj = {}\nObject.defineProperty(obj,name,{writable:false})\n```\n#### Symbol共享体系\n- ES6创建了一个可以随时访问的全局Symbol注册表，如果想创建一个可共享Symbol，使用Symbol.for()方法\n```\nlet id = Symbol.for('id')\nlet id2 = Symbol.for('id')\nconsole.log(id===id2)//true\n```\n- 使用Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的关键字\n```\nlet id = Symbol.for('id')\nconsole.log(Symbol.keyFor(id))//id\n```\n- Symbol全局注册表是一个类似全局作用域的共享环境，其他第三方库也有可能使用。\n#### Symbol与强制类型转换\n- 其他类型没有与Symbol逻辑等价的值，因此Symbol使用不是很灵活，尤其不能将Symbol强制转换为字符串和数字类型\n- 将Symbol强制转换为字符串会被错\n```\nlet name = Symbol('name')\nlet a = name + ''//VM1175:1 Uncaught TypeError: Cannot convert a Symbol value to a string\n```\n- Symbol与JS中的非空值类似，其等价布尔值为true\n```\nlet name = Symbol('name')\nlet a = name/1//VM1299:2 Uncaught TypeError: Cannot convert a Symbol value to a number\n```\n#### Symbol属性的检索\n- 为了保持ES5函数原有功能，Object.keys(),Object.getOwnPropertyNames()都不支持Symbol属性，ES6添加Object.getOwnPropertySymbols()返回包含所有Symbol属性的数组。\n```\nlet name = Symbol('name')\nlet obj = {\n    [name]: 'yxc'\n}\nconsole.log(Object.getOwnPropertySymbols(obj))//[Symbol(name)]\n```\n#### well-known Symbol\n- 对象可以从原型链中继承Symbol属性，ES6通过一些well-known Symbol预定义这些属性\n1. Symbol.hasInstance方法\n- 用于确认对象是否为函数的实例，该方法在Function.prototype中定义，所有函数都继承了instanceof属性的默认行为\n```\nlet obj = []\nconsole.log(obj instanceof Array)//true\nArray[Symbol.hasInstance](obj)//true\n```\n#### MDN\n- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol#\n","source":"_posts/ES6-Symbol.md","raw":"---\ntitle: ES6-Symbol\ndate: 2019-02-13 08:46:38\ntags: [ES6,js]\ncategories: ES6\n---\n\n#### ES6引入了第六种原始类型Symbol\n#### 私有名称\n- 为了创建非字符串属性名称设计的，Symbol出现之前一直通过属性名称来访问所有属性，全部通过一个字符串来访问。\n#### 创建Symbol\n```\nlet name = Symbol()\nlet obj = {}\nobj[name] = 'yxc'\n```\n- 由于Symbol是原始值，因此调用new Symbol()会报错，\n- Symbol函数接收一个可选参数，让你添加文本描述，建议每次创建都添加。\n```\nlet name = Symbol('name')\n```\n- Symbol的描述被存储在内部的[[Description]]属性中，只有当调用Symbol的toString()方法时才会读取这个属性。\n#### 检测Symbol\n- 使用typeof\n```\nlet name = Symbol('name')\nname.toString()//\"Symbol(name)\"\ntypeof name//\"symbol\"\n```\n#### Symbol的使用\n- 所有使用可计算属性名的地方都可以使用Symbol\n```\nlet name = Symbol('name')\nlet obj = {\n    [name]: 'yxc'\n}\n```\n- 用于Object.defineProperty()\\Object.defineProperties()方法中\n```\nlet name = Symbol('name')\nlet obj = {}\nObject.defineProperty(obj,name,{writable:false})\n```\n#### Symbol共享体系\n- ES6创建了一个可以随时访问的全局Symbol注册表，如果想创建一个可共享Symbol，使用Symbol.for()方法\n```\nlet id = Symbol.for('id')\nlet id2 = Symbol.for('id')\nconsole.log(id===id2)//true\n```\n- 使用Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的关键字\n```\nlet id = Symbol.for('id')\nconsole.log(Symbol.keyFor(id))//id\n```\n- Symbol全局注册表是一个类似全局作用域的共享环境，其他第三方库也有可能使用。\n#### Symbol与强制类型转换\n- 其他类型没有与Symbol逻辑等价的值，因此Symbol使用不是很灵活，尤其不能将Symbol强制转换为字符串和数字类型\n- 将Symbol强制转换为字符串会被错\n```\nlet name = Symbol('name')\nlet a = name + ''//VM1175:1 Uncaught TypeError: Cannot convert a Symbol value to a string\n```\n- Symbol与JS中的非空值类似，其等价布尔值为true\n```\nlet name = Symbol('name')\nlet a = name/1//VM1299:2 Uncaught TypeError: Cannot convert a Symbol value to a number\n```\n#### Symbol属性的检索\n- 为了保持ES5函数原有功能，Object.keys(),Object.getOwnPropertyNames()都不支持Symbol属性，ES6添加Object.getOwnPropertySymbols()返回包含所有Symbol属性的数组。\n```\nlet name = Symbol('name')\nlet obj = {\n    [name]: 'yxc'\n}\nconsole.log(Object.getOwnPropertySymbols(obj))//[Symbol(name)]\n```\n#### well-known Symbol\n- 对象可以从原型链中继承Symbol属性，ES6通过一些well-known Symbol预定义这些属性\n1. Symbol.hasInstance方法\n- 用于确认对象是否为函数的实例，该方法在Function.prototype中定义，所有函数都继承了instanceof属性的默认行为\n```\nlet obj = []\nconsole.log(obj instanceof Array)//true\nArray[Symbol.hasInstance](obj)//true\n```\n#### MDN\n- https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol#\n","slug":"ES6-Symbol","published":1,"updated":"2019-02-13T00:47:12.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob5r0005e0jcfzoe92kv","content":"<h4 id=\"ES6引入了第六种原始类型Symbol\"><a href=\"#ES6引入了第六种原始类型Symbol\" class=\"headerlink\" title=\"ES6引入了第六种原始类型Symbol\"></a>ES6引入了第六种原始类型Symbol</h4><h4 id=\"私有名称\"><a href=\"#私有名称\" class=\"headerlink\" title=\"私有名称\"></a>私有名称</h4><ul>\n<li><p>为了创建非字符串属性名称设计的，Symbol出现之前一直通过属性名称来访问所有属性，全部通过一个字符串来访问。</p>\n<h4 id=\"创建Symbol\"><a href=\"#创建Symbol\" class=\"headerlink\" title=\"创建Symbol\"></a>创建Symbol</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol()</span><br><span class=\"line\">let obj = &#123;&#125;</span><br><span class=\"line\">obj[name] = &apos;yxc&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>由于Symbol是原始值，因此调用new Symbol()会报错，</p>\n</li>\n<li><p>Symbol函数接收一个可选参数，让你添加文本描述，建议每次创建都添加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol(&apos;name&apos;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Symbol的描述被存储在内部的[[Description]]属性中，只有当调用Symbol的toString()方法时才会读取这个属性。</p>\n<h4 id=\"检测Symbol\"><a href=\"#检测Symbol\" class=\"headerlink\" title=\"检测Symbol\"></a>检测Symbol</h4></li>\n<li>使用typeof<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol(&apos;name&apos;)</span><br><span class=\"line\">name.toString()//&quot;Symbol(name)&quot;</span><br><span class=\"line\">typeof name//&quot;symbol&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Symbol的使用\"><a href=\"#Symbol的使用\" class=\"headerlink\" title=\"Symbol的使用\"></a>Symbol的使用</h4><ul>\n<li><p>所有使用可计算属性名的地方都可以使用Symbol</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol(&apos;name&apos;)</span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    [name]: &apos;yxc&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用于Object.defineProperty()\\Object.defineProperties()方法中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol(&apos;name&apos;)</span><br><span class=\"line\">let obj = &#123;&#125;</span><br><span class=\"line\">Object.defineProperty(obj,name,&#123;writable:false&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Symbol共享体系\"><a href=\"#Symbol共享体系\" class=\"headerlink\" title=\"Symbol共享体系\"></a>Symbol共享体系</h4><ul>\n<li><p>ES6创建了一个可以随时访问的全局Symbol注册表，如果想创建一个可共享Symbol，使用Symbol.for()方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let id = Symbol.for(&apos;id&apos;)</span><br><span class=\"line\">let id2 = Symbol.for(&apos;id&apos;)</span><br><span class=\"line\">console.log(id===id2)//true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的关键字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let id = Symbol.for(&apos;id&apos;)</span><br><span class=\"line\">console.log(Symbol.keyFor(id))//id</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Symbol全局注册表是一个类似全局作用域的共享环境，其他第三方库也有可能使用。</p>\n<h4 id=\"Symbol与强制类型转换\"><a href=\"#Symbol与强制类型转换\" class=\"headerlink\" title=\"Symbol与强制类型转换\"></a>Symbol与强制类型转换</h4></li>\n<li>其他类型没有与Symbol逻辑等价的值，因此Symbol使用不是很灵活，尤其不能将Symbol强制转换为字符串和数字类型</li>\n<li><p>将Symbol强制转换为字符串会被错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol(&apos;name&apos;)</span><br><span class=\"line\">let a = name + &apos;&apos;//VM1175:1 Uncaught TypeError: Cannot convert a Symbol value to a string</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Symbol与JS中的非空值类似，其等价布尔值为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol(&apos;name&apos;)</span><br><span class=\"line\">let a = name/1//VM1299:2 Uncaught TypeError: Cannot convert a Symbol value to a number</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Symbol属性的检索\"><a href=\"#Symbol属性的检索\" class=\"headerlink\" title=\"Symbol属性的检索\"></a>Symbol属性的检索</h4><ul>\n<li>为了保持ES5函数原有功能，Object.keys(),Object.getOwnPropertyNames()都不支持Symbol属性，ES6添加Object.getOwnPropertySymbols()返回包含所有Symbol属性的数组。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol(&apos;name&apos;)</span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    [name]: &apos;yxc&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Object.getOwnPropertySymbols(obj))//[Symbol(name)]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"well-known-Symbol\"><a href=\"#well-known-Symbol\" class=\"headerlink\" title=\"well-known Symbol\"></a>well-known Symbol</h4><ul>\n<li>对象可以从原型链中继承Symbol属性，ES6通过一些well-known Symbol预定义这些属性</li>\n</ul>\n<ol>\n<li>Symbol.hasInstance方法</li>\n</ol>\n<ul>\n<li>用于确认对象是否为函数的实例，该方法在Function.prototype中定义，所有函数都继承了instanceof属性的默认行为<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = []</span><br><span class=\"line\">console.log(obj instanceof Array)//true</span><br><span class=\"line\">Array[Symbol.hasInstance](obj)//true</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"MDN\"><a href=\"#MDN\" class=\"headerlink\" title=\"MDN\"></a>MDN</h4><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol#\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol#</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"ES6引入了第六种原始类型Symbol\"><a href=\"#ES6引入了第六种原始类型Symbol\" class=\"headerlink\" title=\"ES6引入了第六种原始类型Symbol\"></a>ES6引入了第六种原始类型Symbol</h4><h4 id=\"私有名称\"><a href=\"#私有名称\" class=\"headerlink\" title=\"私有名称\"></a>私有名称</h4><ul>\n<li><p>为了创建非字符串属性名称设计的，Symbol出现之前一直通过属性名称来访问所有属性，全部通过一个字符串来访问。</p>\n<h4 id=\"创建Symbol\"><a href=\"#创建Symbol\" class=\"headerlink\" title=\"创建Symbol\"></a>创建Symbol</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol()</span><br><span class=\"line\">let obj = &#123;&#125;</span><br><span class=\"line\">obj[name] = &apos;yxc&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>由于Symbol是原始值，因此调用new Symbol()会报错，</p>\n</li>\n<li><p>Symbol函数接收一个可选参数，让你添加文本描述，建议每次创建都添加。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol(&apos;name&apos;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Symbol的描述被存储在内部的[[Description]]属性中，只有当调用Symbol的toString()方法时才会读取这个属性。</p>\n<h4 id=\"检测Symbol\"><a href=\"#检测Symbol\" class=\"headerlink\" title=\"检测Symbol\"></a>检测Symbol</h4></li>\n<li>使用typeof<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol(&apos;name&apos;)</span><br><span class=\"line\">name.toString()//&quot;Symbol(name)&quot;</span><br><span class=\"line\">typeof name//&quot;symbol&quot;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Symbol的使用\"><a href=\"#Symbol的使用\" class=\"headerlink\" title=\"Symbol的使用\"></a>Symbol的使用</h4><ul>\n<li><p>所有使用可计算属性名的地方都可以使用Symbol</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol(&apos;name&apos;)</span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    [name]: &apos;yxc&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>用于Object.defineProperty()\\Object.defineProperties()方法中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol(&apos;name&apos;)</span><br><span class=\"line\">let obj = &#123;&#125;</span><br><span class=\"line\">Object.defineProperty(obj,name,&#123;writable:false&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Symbol共享体系\"><a href=\"#Symbol共享体系\" class=\"headerlink\" title=\"Symbol共享体系\"></a>Symbol共享体系</h4><ul>\n<li><p>ES6创建了一个可以随时访问的全局Symbol注册表，如果想创建一个可共享Symbol，使用Symbol.for()方法</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let id = Symbol.for(&apos;id&apos;)</span><br><span class=\"line\">let id2 = Symbol.for(&apos;id&apos;)</span><br><span class=\"line\">console.log(id===id2)//true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用Symbol.keyFor()方法在Symbol全局注册表中检索与Symbol有关的关键字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let id = Symbol.for(&apos;id&apos;)</span><br><span class=\"line\">console.log(Symbol.keyFor(id))//id</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Symbol全局注册表是一个类似全局作用域的共享环境，其他第三方库也有可能使用。</p>\n<h4 id=\"Symbol与强制类型转换\"><a href=\"#Symbol与强制类型转换\" class=\"headerlink\" title=\"Symbol与强制类型转换\"></a>Symbol与强制类型转换</h4></li>\n<li>其他类型没有与Symbol逻辑等价的值，因此Symbol使用不是很灵活，尤其不能将Symbol强制转换为字符串和数字类型</li>\n<li><p>将Symbol强制转换为字符串会被错</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol(&apos;name&apos;)</span><br><span class=\"line\">let a = name + &apos;&apos;//VM1175:1 Uncaught TypeError: Cannot convert a Symbol value to a string</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Symbol与JS中的非空值类似，其等价布尔值为true</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol(&apos;name&apos;)</span><br><span class=\"line\">let a = name/1//VM1299:2 Uncaught TypeError: Cannot convert a Symbol value to a number</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Symbol属性的检索\"><a href=\"#Symbol属性的检索\" class=\"headerlink\" title=\"Symbol属性的检索\"></a>Symbol属性的检索</h4><ul>\n<li>为了保持ES5函数原有功能，Object.keys(),Object.getOwnPropertyNames()都不支持Symbol属性，ES6添加Object.getOwnPropertySymbols()返回包含所有Symbol属性的数组。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = Symbol(&apos;name&apos;)</span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    [name]: &apos;yxc&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(Object.getOwnPropertySymbols(obj))//[Symbol(name)]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"well-known-Symbol\"><a href=\"#well-known-Symbol\" class=\"headerlink\" title=\"well-known Symbol\"></a>well-known Symbol</h4><ul>\n<li>对象可以从原型链中继承Symbol属性，ES6通过一些well-known Symbol预定义这些属性</li>\n</ul>\n<ol>\n<li>Symbol.hasInstance方法</li>\n</ol>\n<ul>\n<li>用于确认对象是否为函数的实例，该方法在Function.prototype中定义，所有函数都继承了instanceof属性的默认行为<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = []</span><br><span class=\"line\">console.log(obj instanceof Array)//true</span><br><span class=\"line\">Array[Symbol.hasInstance](obj)//true</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"MDN\"><a href=\"#MDN\" class=\"headerlink\" title=\"MDN\"></a>MDN</h4><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol#\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol#</a></li>\n</ul>\n"},{"title":"ES6-async&await","date":"2018-12-10T04:16:25.000Z","_content":"1. async 做一件什么事情?\n- 带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象\n- 如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装\n- 如果async关键字函数显式地返回promise，那就以你返回的promise为准\n- 在语义上要理解，async表示函数内部有异步操作\n- 另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错\n2. await 在等什么？\n- await等的是右侧「表达式」的结果\n```\nasync function async1() {\n    console.log( 'async1 start' )\n    await async2()\n    console.log( 'async1 end' )\n}\nasync function async2() {\n    console.log( 'async2' )\n}\nasync1()\nconsole.log( 'script start' )\n//async1 start\n//async2\n//script start\n//async1 end\n```\n3. await 等到之后，做了一件什么事情？\n- 如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果\n- 如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果\n#### 来自\n1. https://segmentfault.com/a/1190000007535316\n2. https://segmentfault.com/a/1190000017224799\n","source":"_posts/ES6-async-await.md","raw":"---\ntitle: ES6-async&await\ndate: 2018-12-10 12:16:25\ntags: [js,async&await]\ncategories: js\n---\n1. async 做一件什么事情?\n- 带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象\n- 如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装\n- 如果async关键字函数显式地返回promise，那就以你返回的promise为准\n- 在语义上要理解，async表示函数内部有异步操作\n- 另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错\n2. await 在等什么？\n- await等的是右侧「表达式」的结果\n```\nasync function async1() {\n    console.log( 'async1 start' )\n    await async2()\n    console.log( 'async1 end' )\n}\nasync function async2() {\n    console.log( 'async2' )\n}\nasync1()\nconsole.log( 'script start' )\n//async1 start\n//async2\n//script start\n//async1 end\n```\n3. await 等到之后，做了一件什么事情？\n- 如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果\n- 如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果\n#### 来自\n1. https://segmentfault.com/a/1190000007535316\n2. https://segmentfault.com/a/1190000017224799\n","slug":"ES6-async-await","published":1,"updated":"2019-01-02T12:18:04.295Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob5t0006e0jcpjpenub7","content":"<ol>\n<li>async 做一件什么事情?</li>\n</ol>\n<ul>\n<li>带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象</li>\n<li>如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装</li>\n<li>如果async关键字函数显式地返回promise，那就以你返回的promise为准</li>\n<li>在语义上要理解，async表示函数内部有异步操作</li>\n<li>另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错</li>\n</ul>\n<ol start=\"2\">\n<li>await 在等什么？</li>\n</ol>\n<ul>\n<li>await等的是右侧「表达式」的结果<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">    console.log( &apos;async1 start&apos; )</span><br><span class=\"line\">    await async2()</span><br><span class=\"line\">    console.log( &apos;async1 end&apos; )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function async2() &#123;</span><br><span class=\"line\">    console.log( &apos;async2&apos; )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async1()</span><br><span class=\"line\">console.log( &apos;script start&apos; )</span><br><span class=\"line\">//async1 start</span><br><span class=\"line\">//async2</span><br><span class=\"line\">//script start</span><br><span class=\"line\">//async1 end</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"3\">\n<li>await 等到之后，做了一件什么事情？</li>\n</ol>\n<ul>\n<li>如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果</li>\n<li>如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果<h4 id=\"来自\"><a href=\"#来自\" class=\"headerlink\" title=\"来自\"></a>来自</h4></li>\n</ul>\n<ol>\n<li><a href=\"https://segmentfault.com/a/1190000007535316\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000007535316</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017224799\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000017224799</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li>async 做一件什么事情?</li>\n</ol>\n<ul>\n<li>带 async 关键字的函数，它使得你的函数的返回值必定是 promise 对象</li>\n<li>如果async关键字函数返回的不是promise，会自动用Promise.resolve()包装</li>\n<li>如果async关键字函数显式地返回promise，那就以你返回的promise为准</li>\n<li>在语义上要理解，async表示函数内部有异步操作</li>\n<li>另外注意，一般 await 关键字要在 async 关键字函数的内部，await 写在外面会报错</li>\n</ul>\n<ol start=\"2\">\n<li>await 在等什么？</li>\n</ol>\n<ul>\n<li>await等的是右侧「表达式」的结果<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">    console.log( &apos;async1 start&apos; )</span><br><span class=\"line\">    await async2()</span><br><span class=\"line\">    console.log( &apos;async1 end&apos; )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async function async2() &#123;</span><br><span class=\"line\">    console.log( &apos;async2&apos; )</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">async1()</span><br><span class=\"line\">console.log( &apos;script start&apos; )</span><br><span class=\"line\">//async1 start</span><br><span class=\"line\">//async2</span><br><span class=\"line\">//script start</span><br><span class=\"line\">//async1 end</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"3\">\n<li>await 等到之后，做了一件什么事情？</li>\n</ol>\n<ul>\n<li>如果不是 promise , await会阻塞后面的代码，先执行async外面的同步代码，同步代码执行完，再回到async内部，把这个非promise的东西，作为 await表达式的结果</li>\n<li>如果它等到的是一个 promise 对象，await 也会暂停async后面的代码，先执行async外面的同步代码，等着 Promise 对象 fulfilled，然后把 resolve 的参数作为 await 表达式的运算结果<h4 id=\"来自\"><a href=\"#来自\" class=\"headerlink\" title=\"来自\"></a>来自</h4></li>\n</ul>\n<ol>\n<li><a href=\"https://segmentfault.com/a/1190000007535316\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000007535316</a></li>\n<li><a href=\"https://segmentfault.com/a/1190000017224799\" target=\"_blank\" rel=\"noopener\">https://segmentfault.com/a/1190000017224799</a></li>\n</ol>\n"},{"title":"ES6-代理(Proxy)与反射(Reflection)","date":"2019-02-15T00:50:44.000Z","_content":"\n### 简介\n\n- 代理Proxy是一种可以拦截并修改底层javascript引擎操作的包装器，在新语言中通过它暴露内部运作的对象。\n- 数组问题：ES6之前不能通过自己定义的对象模仿js数组对象的行为方式（赋值影响length属性）。\n\n### 代理和反射\n\n- 调用 new Proxy() 可以创建代替其他目标(target)对象的代理，虚化了目标，所以二者看起来功能一致。\n- 陷阱：每个陷阱复写js对象的一些内建特性\n- 创建一个简单的代理：示例中代理的所有操作都会转发给目标。\n\n```\nlet target = {}\nlet proxy = new Proxy(target,{})\nproxy.name = '123'\nconsole.log(target.name)//123\n\ntarget.age = 11\nconsole.log(proxy.age)//11\n```\n\n#### 使用set陷阱验证属性\n\n- 参数：trapTarget(代理目标)，key(写入属性字符串或者symbol)，value(写入值)，receiver(代理)\n- Reflect.set()是set陷阱对应的反射方法和默认特性，如果属性已经设置陷阱应该返回true，如果未设置返回false。即基于是否成功返回适当的值。\n\n```\nlet obj = {\n}\nlet proxyObj = new Proxy(obj,{\n    set(trapTarget,key,val,receiver){\n        return Reflect.set(trapTarget,key,val+1,receiver)\n    }\n})\nproxyObj.count = 1\nconsole.log(obj.count)//2\nobj.age = 2\nconsole.log(proxyObj.age)//2\n```\n\n#### 使用get陷阱验证对象结构\n\n```\nlet obj = {\n    name: '123'\n}\nlet proxyObj = new Proxy(obj,{\n    get(trapTarget,key,receiver){\n        if(!(key in trapTarget)){\n            throw new TypeError(`属性${key}不存在`)\n        }\n        return Reflect.get(trapTarget,key,receiver)\n    }\n})\nconsole.log(proxyObj.name)//123\nconsole.log(proxyObj.age)//Uncaught TypeError: 属性age不存在\n```\n\n#### 使用has陷阱隐藏已有属性\n\n- 用in操作符检测属性存在时，可以使用has陷阱拦截in操作符的属性返回不同的值。\n\n```\nlet obj = {\n    name: '123',\n    age: '11'\n}\nlet proxyObj = new Proxy(obj,{\n    has(trapTarget,key){\n        if(key === 'name'){\n            return false\n        }\n        return Reflect.has(trapTarget,key)\n    }\n})\nconsole.log('name' in proxyObj)//false\nconsole.log('age' in proxyObj)//true\n```\n\n#### 使用deleteProperty陷阱防止删除属性\n\n- 在严格模式下删除一个不可配置(nonconfigurable)的属性会报错，非严格模式下只会返回false\n\n```\nlet obj = {\n    name: '123',\n    age: '11'\n}\nlet proxyObj = new Proxy(obj,{\n    deleteProperty(trapTarget,key){\n        if(key === 'name'){\n            return false\n        }\n        return Reflect.deleteProperty(trapTarget,key)\n    }\n})\nconsole.log(delete proxyObj.name)//false\nconsole.log(delete proxyObj.age)//true\n```\n\n#### 原型代理陷阱\n\n- 通过代理setPrototypeOf和getPrototypeOf陷阱可以拦截Object.setPrototypeOf()和Object.getPrototypeOf()方法\n","source":"_posts/ES6-代理-Proxy-与反射-Reflection.md","raw":"---\ntitle: ES6-代理(Proxy)与反射(Reflection)\ndate: 2019-02-15 08:50:44\ntags: [ES6,js]\ncategories: ES6\n---\n\n### 简介\n\n- 代理Proxy是一种可以拦截并修改底层javascript引擎操作的包装器，在新语言中通过它暴露内部运作的对象。\n- 数组问题：ES6之前不能通过自己定义的对象模仿js数组对象的行为方式（赋值影响length属性）。\n\n### 代理和反射\n\n- 调用 new Proxy() 可以创建代替其他目标(target)对象的代理，虚化了目标，所以二者看起来功能一致。\n- 陷阱：每个陷阱复写js对象的一些内建特性\n- 创建一个简单的代理：示例中代理的所有操作都会转发给目标。\n\n```\nlet target = {}\nlet proxy = new Proxy(target,{})\nproxy.name = '123'\nconsole.log(target.name)//123\n\ntarget.age = 11\nconsole.log(proxy.age)//11\n```\n\n#### 使用set陷阱验证属性\n\n- 参数：trapTarget(代理目标)，key(写入属性字符串或者symbol)，value(写入值)，receiver(代理)\n- Reflect.set()是set陷阱对应的反射方法和默认特性，如果属性已经设置陷阱应该返回true，如果未设置返回false。即基于是否成功返回适当的值。\n\n```\nlet obj = {\n}\nlet proxyObj = new Proxy(obj,{\n    set(trapTarget,key,val,receiver){\n        return Reflect.set(trapTarget,key,val+1,receiver)\n    }\n})\nproxyObj.count = 1\nconsole.log(obj.count)//2\nobj.age = 2\nconsole.log(proxyObj.age)//2\n```\n\n#### 使用get陷阱验证对象结构\n\n```\nlet obj = {\n    name: '123'\n}\nlet proxyObj = new Proxy(obj,{\n    get(trapTarget,key,receiver){\n        if(!(key in trapTarget)){\n            throw new TypeError(`属性${key}不存在`)\n        }\n        return Reflect.get(trapTarget,key,receiver)\n    }\n})\nconsole.log(proxyObj.name)//123\nconsole.log(proxyObj.age)//Uncaught TypeError: 属性age不存在\n```\n\n#### 使用has陷阱隐藏已有属性\n\n- 用in操作符检测属性存在时，可以使用has陷阱拦截in操作符的属性返回不同的值。\n\n```\nlet obj = {\n    name: '123',\n    age: '11'\n}\nlet proxyObj = new Proxy(obj,{\n    has(trapTarget,key){\n        if(key === 'name'){\n            return false\n        }\n        return Reflect.has(trapTarget,key)\n    }\n})\nconsole.log('name' in proxyObj)//false\nconsole.log('age' in proxyObj)//true\n```\n\n#### 使用deleteProperty陷阱防止删除属性\n\n- 在严格模式下删除一个不可配置(nonconfigurable)的属性会报错，非严格模式下只会返回false\n\n```\nlet obj = {\n    name: '123',\n    age: '11'\n}\nlet proxyObj = new Proxy(obj,{\n    deleteProperty(trapTarget,key){\n        if(key === 'name'){\n            return false\n        }\n        return Reflect.deleteProperty(trapTarget,key)\n    }\n})\nconsole.log(delete proxyObj.name)//false\nconsole.log(delete proxyObj.age)//true\n```\n\n#### 原型代理陷阱\n\n- 通过代理setPrototypeOf和getPrototypeOf陷阱可以拦截Object.setPrototypeOf()和Object.getPrototypeOf()方法\n","slug":"ES6-代理-Proxy-与反射-Reflection","published":1,"updated":"2019-02-16T06:30:27.940Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob5u0007e0jcbh4wx8vn","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>代理Proxy是一种可以拦截并修改底层javascript引擎操作的包装器，在新语言中通过它暴露内部运作的对象。</li>\n<li>数组问题：ES6之前不能通过自己定义的对象模仿js数组对象的行为方式（赋值影响length属性）。</li>\n</ul>\n<h3 id=\"代理和反射\"><a href=\"#代理和反射\" class=\"headerlink\" title=\"代理和反射\"></a>代理和反射</h3><ul>\n<li>调用 new Proxy() 可以创建代替其他目标(target)对象的代理，虚化了目标，所以二者看起来功能一致。</li>\n<li>陷阱：每个陷阱复写js对象的一些内建特性</li>\n<li>创建一个简单的代理：示例中代理的所有操作都会转发给目标。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let target = &#123;&#125;</span><br><span class=\"line\">let proxy = new Proxy(target,&#123;&#125;)</span><br><span class=\"line\">proxy.name = &apos;123&apos;</span><br><span class=\"line\">console.log(target.name)//123</span><br><span class=\"line\"></span><br><span class=\"line\">target.age = 11</span><br><span class=\"line\">console.log(proxy.age)//11</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用set陷阱验证属性\"><a href=\"#使用set陷阱验证属性\" class=\"headerlink\" title=\"使用set陷阱验证属性\"></a>使用set陷阱验证属性</h4><ul>\n<li>参数：trapTarget(代理目标)，key(写入属性字符串或者symbol)，value(写入值)，receiver(代理)</li>\n<li>Reflect.set()是set陷阱对应的反射方法和默认特性，如果属性已经设置陷阱应该返回true，如果未设置返回false。即基于是否成功返回适当的值。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj = new Proxy(obj,&#123;</span><br><span class=\"line\">    set(trapTarget,key,val,receiver)&#123;</span><br><span class=\"line\">        return Reflect.set(trapTarget,key,val+1,receiver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">proxyObj.count = 1</span><br><span class=\"line\">console.log(obj.count)//2</span><br><span class=\"line\">obj.age = 2</span><br><span class=\"line\">console.log(proxyObj.age)//2</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用get陷阱验证对象结构\"><a href=\"#使用get陷阱验证对象结构\" class=\"headerlink\" title=\"使用get陷阱验证对象结构\"></a>使用get陷阱验证对象结构</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    name: &apos;123&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj = new Proxy(obj,&#123;</span><br><span class=\"line\">    get(trapTarget,key,receiver)&#123;</span><br><span class=\"line\">        if(!(key in trapTarget))&#123;</span><br><span class=\"line\">            throw new TypeError(`属性$&#123;key&#125;不存在`)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Reflect.get(trapTarget,key,receiver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(proxyObj.name)//123</span><br><span class=\"line\">console.log(proxyObj.age)//Uncaught TypeError: 属性age不存在</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用has陷阱隐藏已有属性\"><a href=\"#使用has陷阱隐藏已有属性\" class=\"headerlink\" title=\"使用has陷阱隐藏已有属性\"></a>使用has陷阱隐藏已有属性</h4><ul>\n<li>用in操作符检测属性存在时，可以使用has陷阱拦截in操作符的属性返回不同的值。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    name: &apos;123&apos;,</span><br><span class=\"line\">    age: &apos;11&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj = new Proxy(obj,&#123;</span><br><span class=\"line\">    has(trapTarget,key)&#123;</span><br><span class=\"line\">        if(key === &apos;name&apos;)&#123;</span><br><span class=\"line\">            return false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Reflect.has(trapTarget,key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(&apos;name&apos; in proxyObj)//false</span><br><span class=\"line\">console.log(&apos;age&apos; in proxyObj)//true</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用deleteProperty陷阱防止删除属性\"><a href=\"#使用deleteProperty陷阱防止删除属性\" class=\"headerlink\" title=\"使用deleteProperty陷阱防止删除属性\"></a>使用deleteProperty陷阱防止删除属性</h4><ul>\n<li>在严格模式下删除一个不可配置(nonconfigurable)的属性会报错，非严格模式下只会返回false</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    name: &apos;123&apos;,</span><br><span class=\"line\">    age: &apos;11&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj = new Proxy(obj,&#123;</span><br><span class=\"line\">    deleteProperty(trapTarget,key)&#123;</span><br><span class=\"line\">        if(key === &apos;name&apos;)&#123;</span><br><span class=\"line\">            return false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Reflect.deleteProperty(trapTarget,key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(delete proxyObj.name)//false</span><br><span class=\"line\">console.log(delete proxyObj.age)//true</span><br></pre></td></tr></table></figure>\n<h4 id=\"原型代理陷阱\"><a href=\"#原型代理陷阱\" class=\"headerlink\" title=\"原型代理陷阱\"></a>原型代理陷阱</h4><ul>\n<li>通过代理setPrototypeOf和getPrototypeOf陷阱可以拦截Object.setPrototypeOf()和Object.getPrototypeOf()方法</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>代理Proxy是一种可以拦截并修改底层javascript引擎操作的包装器，在新语言中通过它暴露内部运作的对象。</li>\n<li>数组问题：ES6之前不能通过自己定义的对象模仿js数组对象的行为方式（赋值影响length属性）。</li>\n</ul>\n<h3 id=\"代理和反射\"><a href=\"#代理和反射\" class=\"headerlink\" title=\"代理和反射\"></a>代理和反射</h3><ul>\n<li>调用 new Proxy() 可以创建代替其他目标(target)对象的代理，虚化了目标，所以二者看起来功能一致。</li>\n<li>陷阱：每个陷阱复写js对象的一些内建特性</li>\n<li>创建一个简单的代理：示例中代理的所有操作都会转发给目标。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let target = &#123;&#125;</span><br><span class=\"line\">let proxy = new Proxy(target,&#123;&#125;)</span><br><span class=\"line\">proxy.name = &apos;123&apos;</span><br><span class=\"line\">console.log(target.name)//123</span><br><span class=\"line\"></span><br><span class=\"line\">target.age = 11</span><br><span class=\"line\">console.log(proxy.age)//11</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用set陷阱验证属性\"><a href=\"#使用set陷阱验证属性\" class=\"headerlink\" title=\"使用set陷阱验证属性\"></a>使用set陷阱验证属性</h4><ul>\n<li>参数：trapTarget(代理目标)，key(写入属性字符串或者symbol)，value(写入值)，receiver(代理)</li>\n<li>Reflect.set()是set陷阱对应的反射方法和默认特性，如果属性已经设置陷阱应该返回true，如果未设置返回false。即基于是否成功返回适当的值。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj = new Proxy(obj,&#123;</span><br><span class=\"line\">    set(trapTarget,key,val,receiver)&#123;</span><br><span class=\"line\">        return Reflect.set(trapTarget,key,val+1,receiver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">proxyObj.count = 1</span><br><span class=\"line\">console.log(obj.count)//2</span><br><span class=\"line\">obj.age = 2</span><br><span class=\"line\">console.log(proxyObj.age)//2</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用get陷阱验证对象结构\"><a href=\"#使用get陷阱验证对象结构\" class=\"headerlink\" title=\"使用get陷阱验证对象结构\"></a>使用get陷阱验证对象结构</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    name: &apos;123&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj = new Proxy(obj,&#123;</span><br><span class=\"line\">    get(trapTarget,key,receiver)&#123;</span><br><span class=\"line\">        if(!(key in trapTarget))&#123;</span><br><span class=\"line\">            throw new TypeError(`属性$&#123;key&#125;不存在`)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Reflect.get(trapTarget,key,receiver)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(proxyObj.name)//123</span><br><span class=\"line\">console.log(proxyObj.age)//Uncaught TypeError: 属性age不存在</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用has陷阱隐藏已有属性\"><a href=\"#使用has陷阱隐藏已有属性\" class=\"headerlink\" title=\"使用has陷阱隐藏已有属性\"></a>使用has陷阱隐藏已有属性</h4><ul>\n<li>用in操作符检测属性存在时，可以使用has陷阱拦截in操作符的属性返回不同的值。</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    name: &apos;123&apos;,</span><br><span class=\"line\">    age: &apos;11&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj = new Proxy(obj,&#123;</span><br><span class=\"line\">    has(trapTarget,key)&#123;</span><br><span class=\"line\">        if(key === &apos;name&apos;)&#123;</span><br><span class=\"line\">            return false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Reflect.has(trapTarget,key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(&apos;name&apos; in proxyObj)//false</span><br><span class=\"line\">console.log(&apos;age&apos; in proxyObj)//true</span><br></pre></td></tr></table></figure>\n<h4 id=\"使用deleteProperty陷阱防止删除属性\"><a href=\"#使用deleteProperty陷阱防止删除属性\" class=\"headerlink\" title=\"使用deleteProperty陷阱防止删除属性\"></a>使用deleteProperty陷阱防止删除属性</h4><ul>\n<li>在严格模式下删除一个不可配置(nonconfigurable)的属性会报错，非严格模式下只会返回false</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    name: &apos;123&apos;,</span><br><span class=\"line\">    age: &apos;11&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let proxyObj = new Proxy(obj,&#123;</span><br><span class=\"line\">    deleteProperty(trapTarget,key)&#123;</span><br><span class=\"line\">        if(key === &apos;name&apos;)&#123;</span><br><span class=\"line\">            return false</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return Reflect.deleteProperty(trapTarget,key)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(delete proxyObj.name)//false</span><br><span class=\"line\">console.log(delete proxyObj.age)//true</span><br></pre></td></tr></table></figure>\n<h4 id=\"原型代理陷阱\"><a href=\"#原型代理陷阱\" class=\"headerlink\" title=\"原型代理陷阱\"></a>原型代理陷阱</h4><ul>\n<li>通过代理setPrototypeOf和getPrototypeOf陷阱可以拦截Object.setPrototypeOf()和Object.getPrototypeOf()方法</li>\n</ul>\n"},{"title":"ES6-promise","date":"2018-08-22T00:29:26.000Z","_content":"\n\n### 简介\n#### 异步编程\n- Promise可以完成其他语言中类似Future和Deferred功能\n\n- 异步编程的背景知识：\nJS引擎是基于单线程(single-threaded)事件循环概念构建的，同一时刻只允许一个代码块在执行，代码块放在一个任务队列(job queue)中，\n每当一个代码块准备执行，就会被添加到任务队列，JS引擎执行完一段代码后，事件循环会执行队列中的下一个任务，队列中的任务会从第一个执行到\n最后一个。\n- eventLoop：https://crazyaguai.github.io/2018/10/20/js-eventLoop/\n#### 事件模型\n- 事件模型,适用于响应用户交互和完成类似的低频功能，但是对于复杂的需求不是很灵活\n\n```\nlet btn = document.querySelector('.button')\n    btn.onclick = function (event) {\n}\n```\n\n#### 回调模式\n- 回调模式，如果嵌套了太多回调，会陷入回调地狱\n\n### Promise\n#### Promise基础知识\n- Promise相当于异步操作的占位符，让函数返回一个Promise\nPromise生命周期：\n- 先处于进行中(pending)状态，此时操作未完成，它也是未处理(unsettled)的，一旦异步操作结束，Promise变为已处理(settled)状态\n- 之后会进入Fulfilled(完成)或者Rejected(未成功)状态\n- 内部属性[[PromiseState]]被用来表示三种状态pending\\fufilled\\rejected\n\n- Promise有then()方法接收两个参数，fufilled状态调用的函数、rejected状态调用的函数\n\n- 如果有一个对象实现了then()方法，那么称之为thenable对象，所有Promise都是thenable对象。但并非所有thenable对象都是promise\n\n- Promise还有一个chache()方法用来接收错误，如果不给Promise添加拒绝处理程序，那么所有错误将被忽略，所以一定要添加\n\n- 每次调用then()\\cache()方法时都会创建一个任务，当promise被解决时，这些任务都会加入到一个为Promise定制的独立队列中\n\n#### 创建未完成的Promise\n\n```\nfunction Fun() {\n    return new Promise((resolve,reject)=>{\n        resolve()\n    })\n}\nFun().then(res=>{\n}).catch(err=>{\n})\n```\n\n\n- Promise执行器会立即执行，之后才会执行后续流程的代码\n\n```\nfunction Fun1() {\n    return new Promise((resolve,reject)=>{\n        //这里会立即执行function Fun1() {\n        console.log(1)\n        resolve(3)\n    })\n}\nFun1().then(res=>{\n    //这里会被添加到任务对列中并异步执行\n    //完成处理程序和拒绝处理程序总被添加到任务对列的末尾\n    console.log(res)\n})\nconsole.log(2)\n//1 2 3\n```\n#### 创建已处理的Promise\n- Promise.resolve(),接收参数返回一个完成状态的Promise,不会有任何编排过程\n\n```\nlet promise = Promise.resolve(1)\npromise.then(res=>{\n    console.log(res)\n})\npromise.then(res=>{\n    console.log(res)\n})\n//1 1\n```\n\n#### 创建拒绝状态的Promise\n- Promise.reject('error'),创建拒绝状态的Promise\n```\nlet promise = Promise.reject(1)\npromise.catch(res=>{\n    console.log(res)\n})\npromise.catch(res=>{\n    console.log(res)\n})\n//1 1\n```\n\n#### 非Promise的Thenable对象\n- 非Promise的Thenable对象，如果传入一个非Promise的Thenable对象，则这些方法会创建一个新的Promise并在then()函数中调用\n```\nlet thenable = {\n    then(resolve,reject){\n        setTimeout(()=>{\n            resolve('thenable')\n        },1000)\n    }\n}\nlet p1 = Promise.resolve(thenable)\np1.then(res=>{\n    console.log(res)\n})\n```\n### 相关应用\n#### Thenable对象\n - 可以使用Promise.resolve()或者Promise.reject()处理非Promise的Thenable对象，\n - ES6之前许多库使用了thenable对象，所以如果想兼容之前已有的库，需要将Thenable对象转换为正式的Promise对象，\n - 如果不确定某个对象是否为Promise对象，那么可以根据预期的结果将其传入Promise.resolve()或Promise.reject()，如果是Promise则不会有任何变化\n```\nvar original = Promise.resolve('我在第二行');\nvar cast = Promise.resolve(original);\ncast.then(function(value) {\n    console.log('value: ' + value);\n});\nconsole.log('original === cast ? ' + (original === cast));\n//打印顺序如下，这里有一个同步异步先后执行的区别\n//original === cast ? true\n//value: 我在第二行\n```\n- Resolve一个thenable对象\n```\nvar p1 = Promise.resolve({\n    then: function (onFulfill, onReject) {\n        onFulfill(\"fulfilled!\");\n    }\n});\nconsole.log(p1 instanceof Promise) // true, 这是一个Promise对象\n\np1.then(function (v) {\n    console.log(v); // 输出\"fulfilled!\"\n}, function (e) {\n    // 不会被调用\n});\n```\n-  Thenable在callback之前抛出异常\n```\n// Promise rejects\nvar thenable = {\n    then: function (resolve) {\n        throw new TypeError(\"Throwing\");\n        resolve(\"Resolving\");\n    }\n};\n\nvar p2 = Promise.resolve(thenable);\np2.then(function (v) {\n    // 不会被调用\n}, function (e) {\n    console.log(e); // TypeError: Throwing\n});\n```\n- Thenable在callback之后抛出异常\n```\n// Promise resolves\nvar thenable = {\n    then: function (resolve) {\n        resolve(\"Resolving\");\n        throw new TypeError(\"Throwing\");\n    }\n};\n\nvar p3 = Promise.resolve(thenable);\np3.then(function (v) {\n    console.log(v); // 输出\"Resolving\"\n}, function (e) {\n    // 不会被调用\n});\n```\n\n#### 执行器错误\n- 如果执行器内部抛出一个错误，那么Promise的拒绝程序就会被调用\n```\nlet p3 = new Promise(function (resolve,reject) {\n    throw new Error('Explosion')\n    //等价于\n    // try{\n    //     throw new Error('Explosion')\n    // }catch (e) {\n    //     reject(e)\n    // }\n})\np3.catch(function (error) {\n    console.log(error.message)\n})\n```\n\n#### 全局的Promise错误处理\n- NodeJS中：\n1. unhandledRejection在一个事件中当Promise被拒绝，并且没有提供拒绝处理程序时该事件被触发\n2. rejectionHandled在一个事件循环后，当Promise被拒绝时，若拒绝处理程序被调用，触发该事件\n\n```\n//拒绝原因以及被拒绝的promise作为参数被传入unhandleRejection事件处理程序\nlet rejected\nprocess.on('unhandleRejection', function (reason, promise) {\n    console.log(reason.message)\n    console.log(rejected === promise)\n})\nrejected = Promise.reject(\nthrow new Error('Explosion')\n)\n\n//rejectionHandle事件在拒绝处理程序最后被调用时触发，如果在创建rejected之后直接添加拒绝处理程序，那个rejectionHandle事件不会被触发\nlet rejected\nprocess.on('rejectionHandle', function (promise) {\n    console.log(rejected === promise)\n})\nrejected = Promise.reject(new Error('Explosion'))\nsetTimeout(() => {\n    rejected.catch(err => {\n        console.log(err.message)\n    })\n}, 1000)\n\n//通过rejectionHandle和事件unhandleRejection将潜在未处理的拒绝存储为一个列表\n\nlet possiblyUnhandleRejections = new Map()\n//如果一个拒绝没有被处理，则添加到map集合中\nprocess.on('unhandledRejection', function (reason, promise) {\n    possiblyUnhandleRejections.set(promise, reason)\n})\n\n//如果被处理了，移除promise\nprocess.on('rejectionHandled', function (promise) {\n    possiblyUnhandleRejections.delete(promise)\n})\n\n//循环未处理的Promise\nsetInterval(function () {\n    possiblyUnhandleRejections.forEach(function (reason, promise) {\n        //做一些处理\n    })\n    possiblyUnhandleRejections.clear()\n}, 6000)\n```\n\n#### 浏览器环境的拒绝处理\n- unhandledrejection:当一个Promise被拒绝并且没有提供拒绝处理时触发\n- rejectionhandled:在一个事件循环后,当Promise被拒绝时，若拒绝处理程序被调用，则触发该事件\n```\n//用DOM0级标记法onunhandledrejection和onrejectionhandled\n\nlet possiblyUnhandleRejections = new Map()\n//如果一个拒绝没有被处理，添加到map中\nwindow.onunhandledrejection = function (event) {\n    possiblyUnhandleRejections.set(event.promise, event.reason)\n}\n//如果出发了拒绝方法，从map中删除\nwindow.onrejectionhandled = function (event) {\n    possiblyUnhandleRejections.delete(event.promise)\n}\n//循环遍历处理\nsetInterval(() => {\n    possiblyUnhandleRejections.forEach((promise, reason) => {\n        console.log('111111')\n        console.log(promise)\n        console.log(reason)\n    })\n    possiblyUnhandleRejections.clear()\n}, 3000)\nlet p5 = Promise.reject('111')\n```\n\n#### 串联Promise\n- 每次调用then()、cache()方法，实际上创建并且返回了另一个Promise，当只有第一个Promise完成或者被拒绝后，第二个才会被解决\n```\nlet p7 = new Promise((resolve, reject) => {\n    resolve(1)\n})\np7.then((res) => {\n    console.log(res)//1\n}).then(res => {\n    console.log('Finished')\n}).catch(err => {\n    //这里可以处理公共的错误\n})\n```\n\n- 务必在Promise的结尾有一个处理拒绝的程序，以便能够正确处理所有的错误\n\n#### Promise的链返回值\n- Promise中返回一个值可以沿着这条链传递数据\n- 如果返回的是Promise对象，那么要看返回的Promise怎么处理\n- 响应多个Promise\n#### Promise.all()\n- 只有迭代中所有Promise都解决后才被解决\n- 如果有一个被拒绝，那么返回的Promise就立即被拒绝\n\n#### Promise.race()\n- 只要有一个被解决返回，Promise就被解决\n\n#### 自Promise继承\n- 定义自己的Promise来扩展内建Promise功能\n- 由于MyPromise.resolve()和MyPromise.reject()通过Symbol.species属性决定返回Promise类型，所以无论传什么值，都会返回MyPromise实例\n```\nclass MyPromise extends Promise{\n    success(resolve,reject){\n        return this.then(resolve,reject)\n    }\n    failure(reject){\n        return this.cache(reject)\n    }\n}\n\nlet mPromise = new MyPromise(function (resolve,reject) {\n    resolve('1')\n})\nmPromise.success(res=>{\n\n}).failure(err=>{\n\n})\n```\n\n#### Promise的异步执行\n\n- 对已完成的promise执行then,此时会执行then的操作\n```\nconst promise = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('111')\n    },1000)\n})\nsetTimeout(()=>{\n    promise.then(res=>{\n        console.log(res)\n    })\n},3000)\n```\n\n\n- then里面不返回新的promise\n```\nnew Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('2222')\n    },1000)\n}).then((res)=>{\n    (function f() {\n        return new Promise(resolve=>{\n            setTimeout(()=>{\n                resolve('333')\n            },1000)\n        })\n    }())\n    console.log(res)\n    return false\n}).then(res=>{\n    console.log(res)\n})\n```\n\n- then的嵌套\n- 需要返回一个新的promise实例才可以等resolve之后回调\n\n- 错误处理,catch也会返回promise实例，后面的then和catch也会执行\n```\nnew Promise((resolve, reject) => {\n    // reject('123')\n    // throw new Error('1111')\n}).then(res => {\n}).catch(err => {\n    console.log(err)\n})\n```\n\n- promise.all 与 map 连用\n```\nlet arr = [1,2,3]\nPromise.all(arr.map(item=>{\n    return new Promise(resolve=>{\n        resolve('1111')\n    })\n})).then(all=>{\n    console.log(all)\n})\n```\n\n- promise实现队列，使用.then返回新的promise实例\n```\nlet arr = [1,2,3,4]\nfunction queue(arr) {\n    let promise = Promise.resolve()\n    arr.forEach(item=>{\n        promise = promise.then(res=>{\n            console.log(res)\n            return new Promise(resolve=>{\n                 // 在这里处理相关逻辑\n                resolve(item)\n            })\n        })\n    })\n    return promise\n}\nqueue(arr).then(res=>{\n    console.log(res)\n})\n```\n- promise.resolve\n```\nPromise.resolve().then(res=>{\n    return Promise.resolve('123')\n}).then(res=>{\n    console.log(res)\n    return Promise.resolve(new Promise(resolve=>{\n        setTimeout(()=>{\n            resolve('456')\n        },1000)\n    })).then(res=>{\n        console.log(res)\n        Promise.resolve({\n            then(){\n                console.log('7890')\n            }\n        })\n    })\n})\n```\n","source":"_posts/ES6-promise.md","raw":"---\ntitle: ES6-promise\ndate: 2018-08-22 08:29:26\ntags: [ES6,js]\ncategories: ES6\n---\n\n\n### 简介\n#### 异步编程\n- Promise可以完成其他语言中类似Future和Deferred功能\n\n- 异步编程的背景知识：\nJS引擎是基于单线程(single-threaded)事件循环概念构建的，同一时刻只允许一个代码块在执行，代码块放在一个任务队列(job queue)中，\n每当一个代码块准备执行，就会被添加到任务队列，JS引擎执行完一段代码后，事件循环会执行队列中的下一个任务，队列中的任务会从第一个执行到\n最后一个。\n- eventLoop：https://crazyaguai.github.io/2018/10/20/js-eventLoop/\n#### 事件模型\n- 事件模型,适用于响应用户交互和完成类似的低频功能，但是对于复杂的需求不是很灵活\n\n```\nlet btn = document.querySelector('.button')\n    btn.onclick = function (event) {\n}\n```\n\n#### 回调模式\n- 回调模式，如果嵌套了太多回调，会陷入回调地狱\n\n### Promise\n#### Promise基础知识\n- Promise相当于异步操作的占位符，让函数返回一个Promise\nPromise生命周期：\n- 先处于进行中(pending)状态，此时操作未完成，它也是未处理(unsettled)的，一旦异步操作结束，Promise变为已处理(settled)状态\n- 之后会进入Fulfilled(完成)或者Rejected(未成功)状态\n- 内部属性[[PromiseState]]被用来表示三种状态pending\\fufilled\\rejected\n\n- Promise有then()方法接收两个参数，fufilled状态调用的函数、rejected状态调用的函数\n\n- 如果有一个对象实现了then()方法，那么称之为thenable对象，所有Promise都是thenable对象。但并非所有thenable对象都是promise\n\n- Promise还有一个chache()方法用来接收错误，如果不给Promise添加拒绝处理程序，那么所有错误将被忽略，所以一定要添加\n\n- 每次调用then()\\cache()方法时都会创建一个任务，当promise被解决时，这些任务都会加入到一个为Promise定制的独立队列中\n\n#### 创建未完成的Promise\n\n```\nfunction Fun() {\n    return new Promise((resolve,reject)=>{\n        resolve()\n    })\n}\nFun().then(res=>{\n}).catch(err=>{\n})\n```\n\n\n- Promise执行器会立即执行，之后才会执行后续流程的代码\n\n```\nfunction Fun1() {\n    return new Promise((resolve,reject)=>{\n        //这里会立即执行function Fun1() {\n        console.log(1)\n        resolve(3)\n    })\n}\nFun1().then(res=>{\n    //这里会被添加到任务对列中并异步执行\n    //完成处理程序和拒绝处理程序总被添加到任务对列的末尾\n    console.log(res)\n})\nconsole.log(2)\n//1 2 3\n```\n#### 创建已处理的Promise\n- Promise.resolve(),接收参数返回一个完成状态的Promise,不会有任何编排过程\n\n```\nlet promise = Promise.resolve(1)\npromise.then(res=>{\n    console.log(res)\n})\npromise.then(res=>{\n    console.log(res)\n})\n//1 1\n```\n\n#### 创建拒绝状态的Promise\n- Promise.reject('error'),创建拒绝状态的Promise\n```\nlet promise = Promise.reject(1)\npromise.catch(res=>{\n    console.log(res)\n})\npromise.catch(res=>{\n    console.log(res)\n})\n//1 1\n```\n\n#### 非Promise的Thenable对象\n- 非Promise的Thenable对象，如果传入一个非Promise的Thenable对象，则这些方法会创建一个新的Promise并在then()函数中调用\n```\nlet thenable = {\n    then(resolve,reject){\n        setTimeout(()=>{\n            resolve('thenable')\n        },1000)\n    }\n}\nlet p1 = Promise.resolve(thenable)\np1.then(res=>{\n    console.log(res)\n})\n```\n### 相关应用\n#### Thenable对象\n - 可以使用Promise.resolve()或者Promise.reject()处理非Promise的Thenable对象，\n - ES6之前许多库使用了thenable对象，所以如果想兼容之前已有的库，需要将Thenable对象转换为正式的Promise对象，\n - 如果不确定某个对象是否为Promise对象，那么可以根据预期的结果将其传入Promise.resolve()或Promise.reject()，如果是Promise则不会有任何变化\n```\nvar original = Promise.resolve('我在第二行');\nvar cast = Promise.resolve(original);\ncast.then(function(value) {\n    console.log('value: ' + value);\n});\nconsole.log('original === cast ? ' + (original === cast));\n//打印顺序如下，这里有一个同步异步先后执行的区别\n//original === cast ? true\n//value: 我在第二行\n```\n- Resolve一个thenable对象\n```\nvar p1 = Promise.resolve({\n    then: function (onFulfill, onReject) {\n        onFulfill(\"fulfilled!\");\n    }\n});\nconsole.log(p1 instanceof Promise) // true, 这是一个Promise对象\n\np1.then(function (v) {\n    console.log(v); // 输出\"fulfilled!\"\n}, function (e) {\n    // 不会被调用\n});\n```\n-  Thenable在callback之前抛出异常\n```\n// Promise rejects\nvar thenable = {\n    then: function (resolve) {\n        throw new TypeError(\"Throwing\");\n        resolve(\"Resolving\");\n    }\n};\n\nvar p2 = Promise.resolve(thenable);\np2.then(function (v) {\n    // 不会被调用\n}, function (e) {\n    console.log(e); // TypeError: Throwing\n});\n```\n- Thenable在callback之后抛出异常\n```\n// Promise resolves\nvar thenable = {\n    then: function (resolve) {\n        resolve(\"Resolving\");\n        throw new TypeError(\"Throwing\");\n    }\n};\n\nvar p3 = Promise.resolve(thenable);\np3.then(function (v) {\n    console.log(v); // 输出\"Resolving\"\n}, function (e) {\n    // 不会被调用\n});\n```\n\n#### 执行器错误\n- 如果执行器内部抛出一个错误，那么Promise的拒绝程序就会被调用\n```\nlet p3 = new Promise(function (resolve,reject) {\n    throw new Error('Explosion')\n    //等价于\n    // try{\n    //     throw new Error('Explosion')\n    // }catch (e) {\n    //     reject(e)\n    // }\n})\np3.catch(function (error) {\n    console.log(error.message)\n})\n```\n\n#### 全局的Promise错误处理\n- NodeJS中：\n1. unhandledRejection在一个事件中当Promise被拒绝，并且没有提供拒绝处理程序时该事件被触发\n2. rejectionHandled在一个事件循环后，当Promise被拒绝时，若拒绝处理程序被调用，触发该事件\n\n```\n//拒绝原因以及被拒绝的promise作为参数被传入unhandleRejection事件处理程序\nlet rejected\nprocess.on('unhandleRejection', function (reason, promise) {\n    console.log(reason.message)\n    console.log(rejected === promise)\n})\nrejected = Promise.reject(\nthrow new Error('Explosion')\n)\n\n//rejectionHandle事件在拒绝处理程序最后被调用时触发，如果在创建rejected之后直接添加拒绝处理程序，那个rejectionHandle事件不会被触发\nlet rejected\nprocess.on('rejectionHandle', function (promise) {\n    console.log(rejected === promise)\n})\nrejected = Promise.reject(new Error('Explosion'))\nsetTimeout(() => {\n    rejected.catch(err => {\n        console.log(err.message)\n    })\n}, 1000)\n\n//通过rejectionHandle和事件unhandleRejection将潜在未处理的拒绝存储为一个列表\n\nlet possiblyUnhandleRejections = new Map()\n//如果一个拒绝没有被处理，则添加到map集合中\nprocess.on('unhandledRejection', function (reason, promise) {\n    possiblyUnhandleRejections.set(promise, reason)\n})\n\n//如果被处理了，移除promise\nprocess.on('rejectionHandled', function (promise) {\n    possiblyUnhandleRejections.delete(promise)\n})\n\n//循环未处理的Promise\nsetInterval(function () {\n    possiblyUnhandleRejections.forEach(function (reason, promise) {\n        //做一些处理\n    })\n    possiblyUnhandleRejections.clear()\n}, 6000)\n```\n\n#### 浏览器环境的拒绝处理\n- unhandledrejection:当一个Promise被拒绝并且没有提供拒绝处理时触发\n- rejectionhandled:在一个事件循环后,当Promise被拒绝时，若拒绝处理程序被调用，则触发该事件\n```\n//用DOM0级标记法onunhandledrejection和onrejectionhandled\n\nlet possiblyUnhandleRejections = new Map()\n//如果一个拒绝没有被处理，添加到map中\nwindow.onunhandledrejection = function (event) {\n    possiblyUnhandleRejections.set(event.promise, event.reason)\n}\n//如果出发了拒绝方法，从map中删除\nwindow.onrejectionhandled = function (event) {\n    possiblyUnhandleRejections.delete(event.promise)\n}\n//循环遍历处理\nsetInterval(() => {\n    possiblyUnhandleRejections.forEach((promise, reason) => {\n        console.log('111111')\n        console.log(promise)\n        console.log(reason)\n    })\n    possiblyUnhandleRejections.clear()\n}, 3000)\nlet p5 = Promise.reject('111')\n```\n\n#### 串联Promise\n- 每次调用then()、cache()方法，实际上创建并且返回了另一个Promise，当只有第一个Promise完成或者被拒绝后，第二个才会被解决\n```\nlet p7 = new Promise((resolve, reject) => {\n    resolve(1)\n})\np7.then((res) => {\n    console.log(res)//1\n}).then(res => {\n    console.log('Finished')\n}).catch(err => {\n    //这里可以处理公共的错误\n})\n```\n\n- 务必在Promise的结尾有一个处理拒绝的程序，以便能够正确处理所有的错误\n\n#### Promise的链返回值\n- Promise中返回一个值可以沿着这条链传递数据\n- 如果返回的是Promise对象，那么要看返回的Promise怎么处理\n- 响应多个Promise\n#### Promise.all()\n- 只有迭代中所有Promise都解决后才被解决\n- 如果有一个被拒绝，那么返回的Promise就立即被拒绝\n\n#### Promise.race()\n- 只要有一个被解决返回，Promise就被解决\n\n#### 自Promise继承\n- 定义自己的Promise来扩展内建Promise功能\n- 由于MyPromise.resolve()和MyPromise.reject()通过Symbol.species属性决定返回Promise类型，所以无论传什么值，都会返回MyPromise实例\n```\nclass MyPromise extends Promise{\n    success(resolve,reject){\n        return this.then(resolve,reject)\n    }\n    failure(reject){\n        return this.cache(reject)\n    }\n}\n\nlet mPromise = new MyPromise(function (resolve,reject) {\n    resolve('1')\n})\nmPromise.success(res=>{\n\n}).failure(err=>{\n\n})\n```\n\n#### Promise的异步执行\n\n- 对已完成的promise执行then,此时会执行then的操作\n```\nconst promise = new Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('111')\n    },1000)\n})\nsetTimeout(()=>{\n    promise.then(res=>{\n        console.log(res)\n    })\n},3000)\n```\n\n\n- then里面不返回新的promise\n```\nnew Promise((resolve,reject)=>{\n    setTimeout(()=>{\n        resolve('2222')\n    },1000)\n}).then((res)=>{\n    (function f() {\n        return new Promise(resolve=>{\n            setTimeout(()=>{\n                resolve('333')\n            },1000)\n        })\n    }())\n    console.log(res)\n    return false\n}).then(res=>{\n    console.log(res)\n})\n```\n\n- then的嵌套\n- 需要返回一个新的promise实例才可以等resolve之后回调\n\n- 错误处理,catch也会返回promise实例，后面的then和catch也会执行\n```\nnew Promise((resolve, reject) => {\n    // reject('123')\n    // throw new Error('1111')\n}).then(res => {\n}).catch(err => {\n    console.log(err)\n})\n```\n\n- promise.all 与 map 连用\n```\nlet arr = [1,2,3]\nPromise.all(arr.map(item=>{\n    return new Promise(resolve=>{\n        resolve('1111')\n    })\n})).then(all=>{\n    console.log(all)\n})\n```\n\n- promise实现队列，使用.then返回新的promise实例\n```\nlet arr = [1,2,3,4]\nfunction queue(arr) {\n    let promise = Promise.resolve()\n    arr.forEach(item=>{\n        promise = promise.then(res=>{\n            console.log(res)\n            return new Promise(resolve=>{\n                 // 在这里处理相关逻辑\n                resolve(item)\n            })\n        })\n    })\n    return promise\n}\nqueue(arr).then(res=>{\n    console.log(res)\n})\n```\n- promise.resolve\n```\nPromise.resolve().then(res=>{\n    return Promise.resolve('123')\n}).then(res=>{\n    console.log(res)\n    return Promise.resolve(new Promise(resolve=>{\n        setTimeout(()=>{\n            resolve('456')\n        },1000)\n    })).then(res=>{\n        console.log(res)\n        Promise.resolve({\n            then(){\n                console.log('7890')\n            }\n        })\n    })\n})\n```\n","slug":"ES6-promise","published":1,"updated":"2019-02-13T08:50:32.638Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob5x000ae0jcp2bpmumw","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><h4 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h4><ul>\n<li><p>Promise可以完成其他语言中类似Future和Deferred功能</p>\n</li>\n<li><p>异步编程的背景知识：<br>JS引擎是基于单线程(single-threaded)事件循环概念构建的，同一时刻只允许一个代码块在执行，代码块放在一个任务队列(job queue)中，<br>每当一个代码块准备执行，就会被添加到任务队列，JS引擎执行完一段代码后，事件循环会执行队列中的下一个任务，队列中的任务会从第一个执行到<br>最后一个。</p>\n</li>\n<li>eventLoop：<a href=\"https://crazyaguai.github.io/2018/10/20/js-eventLoop/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2018/10/20/js-eventLoop/</a><h4 id=\"事件模型\"><a href=\"#事件模型\" class=\"headerlink\" title=\"事件模型\"></a>事件模型</h4></li>\n<li>事件模型,适用于响应用户交互和完成类似的低频功能，但是对于复杂的需求不是很灵活</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let btn = document.querySelector(&apos;.button&apos;)</span><br><span class=\"line\">    btn.onclick = function (event) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"回调模式\"><a href=\"#回调模式\" class=\"headerlink\" title=\"回调模式\"></a>回调模式</h4><ul>\n<li>回调模式，如果嵌套了太多回调，会陷入回调地狱</li>\n</ul>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><h4 id=\"Promise基础知识\"><a href=\"#Promise基础知识\" class=\"headerlink\" title=\"Promise基础知识\"></a>Promise基础知识</h4><ul>\n<li>Promise相当于异步操作的占位符，让函数返回一个Promise<br>Promise生命周期：</li>\n<li>先处于进行中(pending)状态，此时操作未完成，它也是未处理(unsettled)的，一旦异步操作结束，Promise变为已处理(settled)状态</li>\n<li>之后会进入Fulfilled(完成)或者Rejected(未成功)状态</li>\n<li><p>内部属性[[PromiseState]]被用来表示三种状态pending\\fufilled\\rejected</p>\n</li>\n<li><p>Promise有then()方法接收两个参数，fufilled状态调用的函数、rejected状态调用的函数</p>\n</li>\n<li><p>如果有一个对象实现了then()方法，那么称之为thenable对象，所有Promise都是thenable对象。但并非所有thenable对象都是promise</p>\n</li>\n<li><p>Promise还有一个chache()方法用来接收错误，如果不给Promise添加拒绝处理程序，那么所有错误将被忽略，所以一定要添加</p>\n</li>\n<li><p>每次调用then()\\cache()方法时都会创建一个任务，当promise被解决时，这些任务都会加入到一个为Promise定制的独立队列中</p>\n</li>\n</ul>\n<h4 id=\"创建未完成的Promise\"><a href=\"#创建未完成的Promise\" class=\"headerlink\" title=\"创建未完成的Promise\"></a>创建未完成的Promise</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fun() &#123;</span><br><span class=\"line\">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun().then(res=&gt;&#123;</span><br><span class=\"line\">&#125;).catch(err=&gt;&#123;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Promise执行器会立即执行，之后才会执行后续流程的代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fun1() &#123;</span><br><span class=\"line\">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">        //这里会立即执行function Fun1() &#123;</span><br><span class=\"line\">        console.log(1)</span><br><span class=\"line\">        resolve(3)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun1().then(res=&gt;&#123;</span><br><span class=\"line\">    //这里会被添加到任务对列中并异步执行</span><br><span class=\"line\">    //完成处理程序和拒绝处理程序总被添加到任务对列的末尾</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(2)</span><br><span class=\"line\">//1 2 3</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建已处理的Promise\"><a href=\"#创建已处理的Promise\" class=\"headerlink\" title=\"创建已处理的Promise\"></a>创建已处理的Promise</h4><ul>\n<li>Promise.resolve(),接收参数返回一个完成状态的Promise,不会有任何编排过程</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let promise = Promise.resolve(1)</span><br><span class=\"line\">promise.then(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//1 1</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建拒绝状态的Promise\"><a href=\"#创建拒绝状态的Promise\" class=\"headerlink\" title=\"创建拒绝状态的Promise\"></a>创建拒绝状态的Promise</h4><ul>\n<li>Promise.reject(‘error’),创建拒绝状态的Promise<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let promise = Promise.reject(1)</span><br><span class=\"line\">promise.catch(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.catch(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//1 1</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"非Promise的Thenable对象\"><a href=\"#非Promise的Thenable对象\" class=\"headerlink\" title=\"非Promise的Thenable对象\"></a>非Promise的Thenable对象</h4><ul>\n<li>非Promise的Thenable对象，如果传入一个非Promise的Thenable对象，则这些方法会创建一个新的Promise并在then()函数中调用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let thenable = &#123;</span><br><span class=\"line\">    then(resolve,reject)&#123;</span><br><span class=\"line\">        setTimeout(()=&gt;&#123;</span><br><span class=\"line\">            resolve(&apos;thenable&apos;)</span><br><span class=\"line\">        &#125;,1000)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p1 = Promise.resolve(thenable)</span><br><span class=\"line\">p1.then(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"相关应用\"><a href=\"#相关应用\" class=\"headerlink\" title=\"相关应用\"></a>相关应用</h3><h4 id=\"Thenable对象\"><a href=\"#Thenable对象\" class=\"headerlink\" title=\"Thenable对象\"></a>Thenable对象</h4><ul>\n<li>可以使用Promise.resolve()或者Promise.reject()处理非Promise的Thenable对象，</li>\n<li>ES6之前许多库使用了thenable对象，所以如果想兼容之前已有的库，需要将Thenable对象转换为正式的Promise对象，</li>\n<li>如果不确定某个对象是否为Promise对象，那么可以根据预期的结果将其传入Promise.resolve()或Promise.reject()，如果是Promise则不会有任何变化<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var original = Promise.resolve(&apos;我在第二行&apos;);</span><br><span class=\"line\">var cast = Promise.resolve(original);</span><br><span class=\"line\">cast.then(function(value) &#123;</span><br><span class=\"line\">    console.log(&apos;value: &apos; + value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&apos;original === cast ? &apos; + (original === cast));</span><br><span class=\"line\">//打印顺序如下，这里有一个同步异步先后执行的区别</span><br><span class=\"line\">//original === cast ? true</span><br><span class=\"line\">//value: 我在第二行</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>Resolve一个thenable对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 = Promise.resolve(&#123;</span><br><span class=\"line\">    then: function (onFulfill, onReject) &#123;</span><br><span class=\"line\">        onFulfill(&quot;fulfilled!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(p1 instanceof Promise) // true, 这是一个Promise对象</span><br><span class=\"line\"></span><br><span class=\"line\">p1.then(function (v) &#123;</span><br><span class=\"line\">    console.log(v); // 输出&quot;fulfilled!&quot;</span><br><span class=\"line\">&#125;, function (e) &#123;</span><br><span class=\"line\">    // 不会被调用</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Thenable在callback之前抛出异常</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Promise rejects</span><br><span class=\"line\">var thenable = &#123;</span><br><span class=\"line\">    then: function (resolve) &#123;</span><br><span class=\"line\">        throw new TypeError(&quot;Throwing&quot;);</span><br><span class=\"line\">        resolve(&quot;Resolving&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p2 = Promise.resolve(thenable);</span><br><span class=\"line\">p2.then(function (v) &#123;</span><br><span class=\"line\">    // 不会被调用</span><br><span class=\"line\">&#125;, function (e) &#123;</span><br><span class=\"line\">    console.log(e); // TypeError: Throwing</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Thenable在callback之后抛出异常</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Promise resolves</span><br><span class=\"line\">var thenable = &#123;</span><br><span class=\"line\">    then: function (resolve) &#123;</span><br><span class=\"line\">        resolve(&quot;Resolving&quot;);</span><br><span class=\"line\">        throw new TypeError(&quot;Throwing&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p3 = Promise.resolve(thenable);</span><br><span class=\"line\">p3.then(function (v) &#123;</span><br><span class=\"line\">    console.log(v); // 输出&quot;Resolving&quot;</span><br><span class=\"line\">&#125;, function (e) &#123;</span><br><span class=\"line\">    // 不会被调用</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"执行器错误\"><a href=\"#执行器错误\" class=\"headerlink\" title=\"执行器错误\"></a>执行器错误</h4><ul>\n<li>如果执行器内部抛出一个错误，那么Promise的拒绝程序就会被调用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p3 = new Promise(function (resolve,reject) &#123;</span><br><span class=\"line\">    throw new Error(&apos;Explosion&apos;)</span><br><span class=\"line\">    //等价于</span><br><span class=\"line\">    // try&#123;</span><br><span class=\"line\">    //     throw new Error(&apos;Explosion&apos;)</span><br><span class=\"line\">    // &#125;catch (e) &#123;</span><br><span class=\"line\">    //     reject(e)</span><br><span class=\"line\">    // &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p3.catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error.message)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"全局的Promise错误处理\"><a href=\"#全局的Promise错误处理\" class=\"headerlink\" title=\"全局的Promise错误处理\"></a>全局的Promise错误处理</h4><ul>\n<li>NodeJS中：</li>\n</ul>\n<ol>\n<li>unhandledRejection在一个事件中当Promise被拒绝，并且没有提供拒绝处理程序时该事件被触发</li>\n<li>rejectionHandled在一个事件循环后，当Promise被拒绝时，若拒绝处理程序被调用，触发该事件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//拒绝原因以及被拒绝的promise作为参数被传入unhandleRejection事件处理程序</span><br><span class=\"line\">let rejected</span><br><span class=\"line\">process.on(&apos;unhandleRejection&apos;, function (reason, promise) &#123;</span><br><span class=\"line\">    console.log(reason.message)</span><br><span class=\"line\">    console.log(rejected === promise)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">rejected = Promise.reject(</span><br><span class=\"line\">throw new Error(&apos;Explosion&apos;)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">//rejectionHandle事件在拒绝处理程序最后被调用时触发，如果在创建rejected之后直接添加拒绝处理程序，那个rejectionHandle事件不会被触发</span><br><span class=\"line\">let rejected</span><br><span class=\"line\">process.on(&apos;rejectionHandle&apos;, function (promise) &#123;</span><br><span class=\"line\">    console.log(rejected === promise)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">rejected = Promise.reject(new Error(&apos;Explosion&apos;))</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    rejected.catch(err =&gt; &#123;</span><br><span class=\"line\">        console.log(err.message)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;, 1000)</span><br><span class=\"line\"></span><br><span class=\"line\">//通过rejectionHandle和事件unhandleRejection将潜在未处理的拒绝存储为一个列表</span><br><span class=\"line\"></span><br><span class=\"line\">let possiblyUnhandleRejections = new Map()</span><br><span class=\"line\">//如果一个拒绝没有被处理，则添加到map集合中</span><br><span class=\"line\">process.on(&apos;unhandledRejection&apos;, function (reason, promise) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.set(promise, reason)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">//如果被处理了，移除promise</span><br><span class=\"line\">process.on(&apos;rejectionHandled&apos;, function (promise) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.delete(promise)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">//循环未处理的Promise</span><br><span class=\"line\">setInterval(function () &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.forEach(function (reason, promise) &#123;</span><br><span class=\"line\">        //做一些处理</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    possiblyUnhandleRejections.clear()</span><br><span class=\"line\">&#125;, 6000)</span><br></pre></td></tr></table></figure>\n<h4 id=\"浏览器环境的拒绝处理\"><a href=\"#浏览器环境的拒绝处理\" class=\"headerlink\" title=\"浏览器环境的拒绝处理\"></a>浏览器环境的拒绝处理</h4><ul>\n<li>unhandledrejection:当一个Promise被拒绝并且没有提供拒绝处理时触发</li>\n<li>rejectionhandled:在一个事件循环后,当Promise被拒绝时，若拒绝处理程序被调用，则触发该事件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//用DOM0级标记法onunhandledrejection和onrejectionhandled</span><br><span class=\"line\"></span><br><span class=\"line\">let possiblyUnhandleRejections = new Map()</span><br><span class=\"line\">//如果一个拒绝没有被处理，添加到map中</span><br><span class=\"line\">window.onunhandledrejection = function (event) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.set(event.promise, event.reason)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//如果出发了拒绝方法，从map中删除</span><br><span class=\"line\">window.onrejectionhandled = function (event) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.delete(event.promise)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//循环遍历处理</span><br><span class=\"line\">setInterval(() =&gt; &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.forEach((promise, reason) =&gt; &#123;</span><br><span class=\"line\">        console.log(&apos;111111&apos;)</span><br><span class=\"line\">        console.log(promise)</span><br><span class=\"line\">        console.log(reason)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    possiblyUnhandleRejections.clear()</span><br><span class=\"line\">&#125;, 3000)</span><br><span class=\"line\">let p5 = Promise.reject(&apos;111&apos;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"串联Promise\"><a href=\"#串联Promise\" class=\"headerlink\" title=\"串联Promise\"></a>串联Promise</h4><ul>\n<li><p>每次调用then()、cache()方法，实际上创建并且返回了另一个Promise，当只有第一个Promise完成或者被拒绝后，第二个才会被解决</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p7 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    resolve(1)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p7.then((res) =&gt; &#123;</span><br><span class=\"line\">    console.log(res)//1</span><br><span class=\"line\">&#125;).then(res =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;Finished&apos;)</span><br><span class=\"line\">&#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">    //这里可以处理公共的错误</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>务必在Promise的结尾有一个处理拒绝的程序，以便能够正确处理所有的错误</p>\n</li>\n</ul>\n<h4 id=\"Promise的链返回值\"><a href=\"#Promise的链返回值\" class=\"headerlink\" title=\"Promise的链返回值\"></a>Promise的链返回值</h4><ul>\n<li>Promise中返回一个值可以沿着这条链传递数据</li>\n<li>如果返回的是Promise对象，那么要看返回的Promise怎么处理</li>\n<li>响应多个Promise<h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4></li>\n<li>只有迭代中所有Promise都解决后才被解决</li>\n<li>如果有一个被拒绝，那么返回的Promise就立即被拒绝</li>\n</ul>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><ul>\n<li>只要有一个被解决返回，Promise就被解决</li>\n</ul>\n<h4 id=\"自Promise继承\"><a href=\"#自Promise继承\" class=\"headerlink\" title=\"自Promise继承\"></a>自Promise继承</h4><ul>\n<li>定义自己的Promise来扩展内建Promise功能</li>\n<li>由于MyPromise.resolve()和MyPromise.reject()通过Symbol.species属性决定返回Promise类型，所以无论传什么值，都会返回MyPromise实例<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyPromise extends Promise&#123;</span><br><span class=\"line\">    success(resolve,reject)&#123;</span><br><span class=\"line\">        return this.then(resolve,reject)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    failure(reject)&#123;</span><br><span class=\"line\">        return this.cache(reject)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let mPromise = new MyPromise(function (resolve,reject) &#123;</span><br><span class=\"line\">    resolve(&apos;1&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">mPromise.success(res=&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;).failure(err=&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Promise的异步执行\"><a href=\"#Promise的异步执行\" class=\"headerlink\" title=\"Promise的异步执行\"></a>Promise的异步执行</h4><ul>\n<li><p>对已完成的promise执行then,此时会执行then的操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        resolve(&apos;111&apos;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">setTimeout(()=&gt;&#123;</span><br><span class=\"line\">    promise.then(res=&gt;&#123;</span><br><span class=\"line\">        console.log(res)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;,3000)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>then里面不返回新的promise</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        resolve(&apos;2222&apos;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;).then((res)=&gt;&#123;</span><br><span class=\"line\">    (function f() &#123;</span><br><span class=\"line\">        return new Promise(resolve=&gt;&#123;</span><br><span class=\"line\">            setTimeout(()=&gt;&#123;</span><br><span class=\"line\">                resolve(&apos;333&apos;)</span><br><span class=\"line\">            &#125;,1000)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;())</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">    return false</span><br><span class=\"line\">&#125;).then(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>then的嵌套</p>\n</li>\n<li><p>需要返回一个新的promise实例才可以等resolve之后回调</p>\n</li>\n<li><p>错误处理,catch也会返回promise实例，后面的then和catch也会执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    // reject(&apos;123&apos;)</span><br><span class=\"line\">    // throw new Error(&apos;1111&apos;)</span><br><span class=\"line\">&#125;).then(res =&gt; &#123;</span><br><span class=\"line\">&#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">    console.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>promise.all 与 map 连用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,2,3]</span><br><span class=\"line\">Promise.all(arr.map(item=&gt;&#123;</span><br><span class=\"line\">    return new Promise(resolve=&gt;&#123;</span><br><span class=\"line\">        resolve(&apos;1111&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)).then(all=&gt;&#123;</span><br><span class=\"line\">    console.log(all)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>promise实现队列，使用.then返回新的promise实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,2,3,4]</span><br><span class=\"line\">function queue(arr) &#123;</span><br><span class=\"line\">    let promise = Promise.resolve()</span><br><span class=\"line\">    arr.forEach(item=&gt;&#123;</span><br><span class=\"line\">        promise = promise.then(res=&gt;&#123;</span><br><span class=\"line\">            console.log(res)</span><br><span class=\"line\">            return new Promise(resolve=&gt;&#123;</span><br><span class=\"line\">                 // 在这里处理相关逻辑</span><br><span class=\"line\">                resolve(item)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return promise</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">queue(arr).then(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>promise.resolve</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve().then(res=&gt;&#123;</span><br><span class=\"line\">    return Promise.resolve(&apos;123&apos;)</span><br><span class=\"line\">&#125;).then(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">    return Promise.resolve(new Promise(resolve=&gt;&#123;</span><br><span class=\"line\">        setTimeout(()=&gt;&#123;</span><br><span class=\"line\">            resolve(&apos;456&apos;)</span><br><span class=\"line\">        &#125;,1000)</span><br><span class=\"line\">    &#125;)).then(res=&gt;&#123;</span><br><span class=\"line\">        console.log(res)</span><br><span class=\"line\">        Promise.resolve(&#123;</span><br><span class=\"line\">            then()&#123;</span><br><span class=\"line\">                console.log(&apos;7890&apos;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><h4 id=\"异步编程\"><a href=\"#异步编程\" class=\"headerlink\" title=\"异步编程\"></a>异步编程</h4><ul>\n<li><p>Promise可以完成其他语言中类似Future和Deferred功能</p>\n</li>\n<li><p>异步编程的背景知识：<br>JS引擎是基于单线程(single-threaded)事件循环概念构建的，同一时刻只允许一个代码块在执行，代码块放在一个任务队列(job queue)中，<br>每当一个代码块准备执行，就会被添加到任务队列，JS引擎执行完一段代码后，事件循环会执行队列中的下一个任务，队列中的任务会从第一个执行到<br>最后一个。</p>\n</li>\n<li>eventLoop：<a href=\"https://crazyaguai.github.io/2018/10/20/js-eventLoop/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2018/10/20/js-eventLoop/</a><h4 id=\"事件模型\"><a href=\"#事件模型\" class=\"headerlink\" title=\"事件模型\"></a>事件模型</h4></li>\n<li>事件模型,适用于响应用户交互和完成类似的低频功能，但是对于复杂的需求不是很灵活</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let btn = document.querySelector(&apos;.button&apos;)</span><br><span class=\"line\">    btn.onclick = function (event) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"回调模式\"><a href=\"#回调模式\" class=\"headerlink\" title=\"回调模式\"></a>回调模式</h4><ul>\n<li>回调模式，如果嵌套了太多回调，会陷入回调地狱</li>\n</ul>\n<h3 id=\"Promise\"><a href=\"#Promise\" class=\"headerlink\" title=\"Promise\"></a>Promise</h3><h4 id=\"Promise基础知识\"><a href=\"#Promise基础知识\" class=\"headerlink\" title=\"Promise基础知识\"></a>Promise基础知识</h4><ul>\n<li>Promise相当于异步操作的占位符，让函数返回一个Promise<br>Promise生命周期：</li>\n<li>先处于进行中(pending)状态，此时操作未完成，它也是未处理(unsettled)的，一旦异步操作结束，Promise变为已处理(settled)状态</li>\n<li>之后会进入Fulfilled(完成)或者Rejected(未成功)状态</li>\n<li><p>内部属性[[PromiseState]]被用来表示三种状态pending\\fufilled\\rejected</p>\n</li>\n<li><p>Promise有then()方法接收两个参数，fufilled状态调用的函数、rejected状态调用的函数</p>\n</li>\n<li><p>如果有一个对象实现了then()方法，那么称之为thenable对象，所有Promise都是thenable对象。但并非所有thenable对象都是promise</p>\n</li>\n<li><p>Promise还有一个chache()方法用来接收错误，如果不给Promise添加拒绝处理程序，那么所有错误将被忽略，所以一定要添加</p>\n</li>\n<li><p>每次调用then()\\cache()方法时都会创建一个任务，当promise被解决时，这些任务都会加入到一个为Promise定制的独立队列中</p>\n</li>\n</ul>\n<h4 id=\"创建未完成的Promise\"><a href=\"#创建未完成的Promise\" class=\"headerlink\" title=\"创建未完成的Promise\"></a>创建未完成的Promise</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fun() &#123;</span><br><span class=\"line\">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">        resolve()</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun().then(res=&gt;&#123;</span><br><span class=\"line\">&#125;).catch(err=&gt;&#123;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Promise执行器会立即执行，之后才会执行后续流程的代码</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fun1() &#123;</span><br><span class=\"line\">    return new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">        //这里会立即执行function Fun1() &#123;</span><br><span class=\"line\">        console.log(1)</span><br><span class=\"line\">        resolve(3)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun1().then(res=&gt;&#123;</span><br><span class=\"line\">    //这里会被添加到任务对列中并异步执行</span><br><span class=\"line\">    //完成处理程序和拒绝处理程序总被添加到任务对列的末尾</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(2)</span><br><span class=\"line\">//1 2 3</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建已处理的Promise\"><a href=\"#创建已处理的Promise\" class=\"headerlink\" title=\"创建已处理的Promise\"></a>创建已处理的Promise</h4><ul>\n<li>Promise.resolve(),接收参数返回一个完成状态的Promise,不会有任何编排过程</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let promise = Promise.resolve(1)</span><br><span class=\"line\">promise.then(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.then(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//1 1</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建拒绝状态的Promise\"><a href=\"#创建拒绝状态的Promise\" class=\"headerlink\" title=\"创建拒绝状态的Promise\"></a>创建拒绝状态的Promise</h4><ul>\n<li>Promise.reject(‘error’),创建拒绝状态的Promise<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let promise = Promise.reject(1)</span><br><span class=\"line\">promise.catch(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">promise.catch(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">//1 1</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"非Promise的Thenable对象\"><a href=\"#非Promise的Thenable对象\" class=\"headerlink\" title=\"非Promise的Thenable对象\"></a>非Promise的Thenable对象</h4><ul>\n<li>非Promise的Thenable对象，如果传入一个非Promise的Thenable对象，则这些方法会创建一个新的Promise并在then()函数中调用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let thenable = &#123;</span><br><span class=\"line\">    then(resolve,reject)&#123;</span><br><span class=\"line\">        setTimeout(()=&gt;&#123;</span><br><span class=\"line\">            resolve(&apos;thenable&apos;)</span><br><span class=\"line\">        &#125;,1000)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let p1 = Promise.resolve(thenable)</span><br><span class=\"line\">p1.then(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"相关应用\"><a href=\"#相关应用\" class=\"headerlink\" title=\"相关应用\"></a>相关应用</h3><h4 id=\"Thenable对象\"><a href=\"#Thenable对象\" class=\"headerlink\" title=\"Thenable对象\"></a>Thenable对象</h4><ul>\n<li>可以使用Promise.resolve()或者Promise.reject()处理非Promise的Thenable对象，</li>\n<li>ES6之前许多库使用了thenable对象，所以如果想兼容之前已有的库，需要将Thenable对象转换为正式的Promise对象，</li>\n<li>如果不确定某个对象是否为Promise对象，那么可以根据预期的结果将其传入Promise.resolve()或Promise.reject()，如果是Promise则不会有任何变化<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var original = Promise.resolve(&apos;我在第二行&apos;);</span><br><span class=\"line\">var cast = Promise.resolve(original);</span><br><span class=\"line\">cast.then(function(value) &#123;</span><br><span class=\"line\">    console.log(&apos;value: &apos; + value);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(&apos;original === cast ? &apos; + (original === cast));</span><br><span class=\"line\">//打印顺序如下，这里有一个同步异步先后执行的区别</span><br><span class=\"line\">//original === cast ? true</span><br><span class=\"line\">//value: 我在第二行</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li><p>Resolve一个thenable对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var p1 = Promise.resolve(&#123;</span><br><span class=\"line\">    then: function (onFulfill, onReject) &#123;</span><br><span class=\"line\">        onFulfill(&quot;fulfilled!&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">console.log(p1 instanceof Promise) // true, 这是一个Promise对象</span><br><span class=\"line\"></span><br><span class=\"line\">p1.then(function (v) &#123;</span><br><span class=\"line\">    console.log(v); // 输出&quot;fulfilled!&quot;</span><br><span class=\"line\">&#125;, function (e) &#123;</span><br><span class=\"line\">    // 不会被调用</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Thenable在callback之前抛出异常</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Promise rejects</span><br><span class=\"line\">var thenable = &#123;</span><br><span class=\"line\">    then: function (resolve) &#123;</span><br><span class=\"line\">        throw new TypeError(&quot;Throwing&quot;);</span><br><span class=\"line\">        resolve(&quot;Resolving&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p2 = Promise.resolve(thenable);</span><br><span class=\"line\">p2.then(function (v) &#123;</span><br><span class=\"line\">    // 不会被调用</span><br><span class=\"line\">&#125;, function (e) &#123;</span><br><span class=\"line\">    console.log(e); // TypeError: Throwing</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Thenable在callback之后抛出异常</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Promise resolves</span><br><span class=\"line\">var thenable = &#123;</span><br><span class=\"line\">    then: function (resolve) &#123;</span><br><span class=\"line\">        resolve(&quot;Resolving&quot;);</span><br><span class=\"line\">        throw new TypeError(&quot;Throwing&quot;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var p3 = Promise.resolve(thenable);</span><br><span class=\"line\">p3.then(function (v) &#123;</span><br><span class=\"line\">    console.log(v); // 输出&quot;Resolving&quot;</span><br><span class=\"line\">&#125;, function (e) &#123;</span><br><span class=\"line\">    // 不会被调用</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"执行器错误\"><a href=\"#执行器错误\" class=\"headerlink\" title=\"执行器错误\"></a>执行器错误</h4><ul>\n<li>如果执行器内部抛出一个错误，那么Promise的拒绝程序就会被调用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p3 = new Promise(function (resolve,reject) &#123;</span><br><span class=\"line\">    throw new Error(&apos;Explosion&apos;)</span><br><span class=\"line\">    //等价于</span><br><span class=\"line\">    // try&#123;</span><br><span class=\"line\">    //     throw new Error(&apos;Explosion&apos;)</span><br><span class=\"line\">    // &#125;catch (e) &#123;</span><br><span class=\"line\">    //     reject(e)</span><br><span class=\"line\">    // &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p3.catch(function (error) &#123;</span><br><span class=\"line\">    console.log(error.message)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"全局的Promise错误处理\"><a href=\"#全局的Promise错误处理\" class=\"headerlink\" title=\"全局的Promise错误处理\"></a>全局的Promise错误处理</h4><ul>\n<li>NodeJS中：</li>\n</ul>\n<ol>\n<li>unhandledRejection在一个事件中当Promise被拒绝，并且没有提供拒绝处理程序时该事件被触发</li>\n<li>rejectionHandled在一个事件循环后，当Promise被拒绝时，若拒绝处理程序被调用，触发该事件</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//拒绝原因以及被拒绝的promise作为参数被传入unhandleRejection事件处理程序</span><br><span class=\"line\">let rejected</span><br><span class=\"line\">process.on(&apos;unhandleRejection&apos;, function (reason, promise) &#123;</span><br><span class=\"line\">    console.log(reason.message)</span><br><span class=\"line\">    console.log(rejected === promise)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">rejected = Promise.reject(</span><br><span class=\"line\">throw new Error(&apos;Explosion&apos;)</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">//rejectionHandle事件在拒绝处理程序最后被调用时触发，如果在创建rejected之后直接添加拒绝处理程序，那个rejectionHandle事件不会被触发</span><br><span class=\"line\">let rejected</span><br><span class=\"line\">process.on(&apos;rejectionHandle&apos;, function (promise) &#123;</span><br><span class=\"line\">    console.log(rejected === promise)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">rejected = Promise.reject(new Error(&apos;Explosion&apos;))</span><br><span class=\"line\">setTimeout(() =&gt; &#123;</span><br><span class=\"line\">    rejected.catch(err =&gt; &#123;</span><br><span class=\"line\">        console.log(err.message)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;, 1000)</span><br><span class=\"line\"></span><br><span class=\"line\">//通过rejectionHandle和事件unhandleRejection将潜在未处理的拒绝存储为一个列表</span><br><span class=\"line\"></span><br><span class=\"line\">let possiblyUnhandleRejections = new Map()</span><br><span class=\"line\">//如果一个拒绝没有被处理，则添加到map集合中</span><br><span class=\"line\">process.on(&apos;unhandledRejection&apos;, function (reason, promise) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.set(promise, reason)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">//如果被处理了，移除promise</span><br><span class=\"line\">process.on(&apos;rejectionHandled&apos;, function (promise) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.delete(promise)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">//循环未处理的Promise</span><br><span class=\"line\">setInterval(function () &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.forEach(function (reason, promise) &#123;</span><br><span class=\"line\">        //做一些处理</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    possiblyUnhandleRejections.clear()</span><br><span class=\"line\">&#125;, 6000)</span><br></pre></td></tr></table></figure>\n<h4 id=\"浏览器环境的拒绝处理\"><a href=\"#浏览器环境的拒绝处理\" class=\"headerlink\" title=\"浏览器环境的拒绝处理\"></a>浏览器环境的拒绝处理</h4><ul>\n<li>unhandledrejection:当一个Promise被拒绝并且没有提供拒绝处理时触发</li>\n<li>rejectionhandled:在一个事件循环后,当Promise被拒绝时，若拒绝处理程序被调用，则触发该事件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//用DOM0级标记法onunhandledrejection和onrejectionhandled</span><br><span class=\"line\"></span><br><span class=\"line\">let possiblyUnhandleRejections = new Map()</span><br><span class=\"line\">//如果一个拒绝没有被处理，添加到map中</span><br><span class=\"line\">window.onunhandledrejection = function (event) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.set(event.promise, event.reason)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//如果出发了拒绝方法，从map中删除</span><br><span class=\"line\">window.onrejectionhandled = function (event) &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.delete(event.promise)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//循环遍历处理</span><br><span class=\"line\">setInterval(() =&gt; &#123;</span><br><span class=\"line\">    possiblyUnhandleRejections.forEach((promise, reason) =&gt; &#123;</span><br><span class=\"line\">        console.log(&apos;111111&apos;)</span><br><span class=\"line\">        console.log(promise)</span><br><span class=\"line\">        console.log(reason)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    possiblyUnhandleRejections.clear()</span><br><span class=\"line\">&#125;, 3000)</span><br><span class=\"line\">let p5 = Promise.reject(&apos;111&apos;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"串联Promise\"><a href=\"#串联Promise\" class=\"headerlink\" title=\"串联Promise\"></a>串联Promise</h4><ul>\n<li><p>每次调用then()、cache()方法，实际上创建并且返回了另一个Promise，当只有第一个Promise完成或者被拒绝后，第二个才会被解决</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let p7 = new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    resolve(1)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">p7.then((res) =&gt; &#123;</span><br><span class=\"line\">    console.log(res)//1</span><br><span class=\"line\">&#125;).then(res =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;Finished&apos;)</span><br><span class=\"line\">&#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">    //这里可以处理公共的错误</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>务必在Promise的结尾有一个处理拒绝的程序，以便能够正确处理所有的错误</p>\n</li>\n</ul>\n<h4 id=\"Promise的链返回值\"><a href=\"#Promise的链返回值\" class=\"headerlink\" title=\"Promise的链返回值\"></a>Promise的链返回值</h4><ul>\n<li>Promise中返回一个值可以沿着这条链传递数据</li>\n<li>如果返回的是Promise对象，那么要看返回的Promise怎么处理</li>\n<li>响应多个Promise<h4 id=\"Promise-all\"><a href=\"#Promise-all\" class=\"headerlink\" title=\"Promise.all()\"></a>Promise.all()</h4></li>\n<li>只有迭代中所有Promise都解决后才被解决</li>\n<li>如果有一个被拒绝，那么返回的Promise就立即被拒绝</li>\n</ul>\n<h4 id=\"Promise-race\"><a href=\"#Promise-race\" class=\"headerlink\" title=\"Promise.race()\"></a>Promise.race()</h4><ul>\n<li>只要有一个被解决返回，Promise就被解决</li>\n</ul>\n<h4 id=\"自Promise继承\"><a href=\"#自Promise继承\" class=\"headerlink\" title=\"自Promise继承\"></a>自Promise继承</h4><ul>\n<li>定义自己的Promise来扩展内建Promise功能</li>\n<li>由于MyPromise.resolve()和MyPromise.reject()通过Symbol.species属性决定返回Promise类型，所以无论传什么值，都会返回MyPromise实例<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyPromise extends Promise&#123;</span><br><span class=\"line\">    success(resolve,reject)&#123;</span><br><span class=\"line\">        return this.then(resolve,reject)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    failure(reject)&#123;</span><br><span class=\"line\">        return this.cache(reject)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">let mPromise = new MyPromise(function (resolve,reject) &#123;</span><br><span class=\"line\">    resolve(&apos;1&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">mPromise.success(res=&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;).failure(err=&gt;&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"Promise的异步执行\"><a href=\"#Promise的异步执行\" class=\"headerlink\" title=\"Promise的异步执行\"></a>Promise的异步执行</h4><ul>\n<li><p>对已完成的promise执行then,此时会执行then的操作</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const promise = new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        resolve(&apos;111&apos;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">setTimeout(()=&gt;&#123;</span><br><span class=\"line\">    promise.then(res=&gt;&#123;</span><br><span class=\"line\">        console.log(res)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;,3000)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>then里面不返回新的promise</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve,reject)=&gt;&#123;</span><br><span class=\"line\">    setTimeout(()=&gt;&#123;</span><br><span class=\"line\">        resolve(&apos;2222&apos;)</span><br><span class=\"line\">    &#125;,1000)</span><br><span class=\"line\">&#125;).then((res)=&gt;&#123;</span><br><span class=\"line\">    (function f() &#123;</span><br><span class=\"line\">        return new Promise(resolve=&gt;&#123;</span><br><span class=\"line\">            setTimeout(()=&gt;&#123;</span><br><span class=\"line\">                resolve(&apos;333&apos;)</span><br><span class=\"line\">            &#125;,1000)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;())</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">    return false</span><br><span class=\"line\">&#125;).then(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>then的嵌套</p>\n</li>\n<li><p>需要返回一个新的promise实例才可以等resolve之后回调</p>\n</li>\n<li><p>错误处理,catch也会返回promise实例，后面的then和catch也会执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new Promise((resolve, reject) =&gt; &#123;</span><br><span class=\"line\">    // reject(&apos;123&apos;)</span><br><span class=\"line\">    // throw new Error(&apos;1111&apos;)</span><br><span class=\"line\">&#125;).then(res =&gt; &#123;</span><br><span class=\"line\">&#125;).catch(err =&gt; &#123;</span><br><span class=\"line\">    console.log(err)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>promise.all 与 map 连用</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,2,3]</span><br><span class=\"line\">Promise.all(arr.map(item=&gt;&#123;</span><br><span class=\"line\">    return new Promise(resolve=&gt;&#123;</span><br><span class=\"line\">        resolve(&apos;1111&apos;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)).then(all=&gt;&#123;</span><br><span class=\"line\">    console.log(all)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>promise实现队列，使用.then返回新的promise实例</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,2,3,4]</span><br><span class=\"line\">function queue(arr) &#123;</span><br><span class=\"line\">    let promise = Promise.resolve()</span><br><span class=\"line\">    arr.forEach(item=&gt;&#123;</span><br><span class=\"line\">        promise = promise.then(res=&gt;&#123;</span><br><span class=\"line\">            console.log(res)</span><br><span class=\"line\">            return new Promise(resolve=&gt;&#123;</span><br><span class=\"line\">                 // 在这里处理相关逻辑</span><br><span class=\"line\">                resolve(item)</span><br><span class=\"line\">            &#125;)</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">    return promise</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">queue(arr).then(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>promise.resolve</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Promise.resolve().then(res=&gt;&#123;</span><br><span class=\"line\">    return Promise.resolve(&apos;123&apos;)</span><br><span class=\"line\">&#125;).then(res=&gt;&#123;</span><br><span class=\"line\">    console.log(res)</span><br><span class=\"line\">    return Promise.resolve(new Promise(resolve=&gt;&#123;</span><br><span class=\"line\">        setTimeout(()=&gt;&#123;</span><br><span class=\"line\">            resolve(&apos;456&apos;)</span><br><span class=\"line\">        &#125;,1000)</span><br><span class=\"line\">    &#125;)).then(res=&gt;&#123;</span><br><span class=\"line\">        console.log(res)</span><br><span class=\"line\">        Promise.resolve(&#123;</span><br><span class=\"line\">            then()&#123;</span><br><span class=\"line\">                console.log(&apos;7890&apos;)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"ES6-扩展对象属性","date":"2018-08-21T00:10:13.000Z","_content":"\n### 简介\n- ES6通过多种方式加强对象的使用，通过简单的语法扩展，提供更多操作对象以及对象交互方法。\n\n### 初始值的简写\n```\nlet a = 1;\nlet obj = {\n    a\n}\n```\n### 对象方法的简写\n- 注意简写方法可以使用super关键字\n```\nlet obj = {\n    a(){\n    }\n}\n```\n### 可计算属性名\n\n```\nlet firstName = 'first name'\nlet name = 'name'\nlet person = {\n    [firstName]: 'yang',\n    ['last'+name]: 'xiao'\n}\nconsole.log(person[firstName])//yang\nconsole.log(person['first name'])//yang\nconsole.log(person['last'+name])//xiao\n```\n\n\n### 新增对象方法\n\n### Object.is()\n- 以下几项比较特殊，其他比较与===相同\n```\nconsole.log(Object.is(+0,-0))//false\nconsole.log(Object.is(NaN,NaN))//true\nconsole.log(Object.is(0,''))//false\n```\n\n### Object.assign()\n- 混合（Mixin）模式，接受一个接收对象和任意数量的源对象\n1. 对于对象属性是浅复制\n2. 不能将访问器属性复制到接收对象，只是调用get\n```\nlet obj = {}\nObject.assign(obj,{a:1},{a:2},{b:[1,2,3]},{get c(){\n        return 'c'\n    }})\nconsole.log(obj)//{a:2,b:[1,2,3],c:'c'}\n```\n\n### 自有属性的枚举顺序\n1. 所有数字按照升序排序\n2. 所有字母按照被加入对象的顺序排序\n3. symbol类型按照被加入顺序排序\n4. for-in循环不适用，因为浏览器厂商不一样\n\n### 增强对象原型\n- 对原型进行了改进\n\n#### Object.setPrototypeOf()\n- 改变对象的原型，改变对象内部专属[[Prototype]]，接收两个参数，**被改变原型的对象**，以及**替代原型的对象**\n\n#### 简化原型访问的super\n1. super相当于指针，指向Object.getPrototypeOf(this)的值\n2. 必须在简写方法时使用super\n```\nlet person = {\n    Fun(){\n        return 'hello'\n    }\n}\nlet dog = {\n    Fun(){\n        return 'wangwangwang'\n    }\n}\nlet friend = {\n\n    //必须在简写时使用super\n    Fun(){\n        //ES6写法\n        return super.Fun() + ' world'\n\n        //ES5写法\n        // return Object.getPrototypeOf(this).Fun.call(this) + ' world'\n    }\n}\n\nObject.setPrototypeOf(friend,person)\nconsole.log(friend.Fun())//hello world\nObject.setPrototypeOf(friend,dog)\nconsole.log(friend.Fun())//wangwangwang world\n```\n\n\n#### [[HomeObject]]属性\n- 正式的方法定义内部存在[[HomeObject]]属性\n```\nlet obj = {\n    //是方法有[[HomeObject]]属性指向obj\n    //super的使用就是通过[[HomeObject]]来确定后续执行，因此必须为简写方法\n    Fun(){\n    },\n    //不是方法没有[[HomeObject]]属性\n    Fun1:function () {\n    }\n}\n```\n","source":"_posts/ES6-扩展对象属性.md","raw":"---\ntitle: ES6-扩展对象属性\ndate: 2018-08-21 08:10:13\ntags: [ES6,js]\ncategories: ES6\n---\n\n### 简介\n- ES6通过多种方式加强对象的使用，通过简单的语法扩展，提供更多操作对象以及对象交互方法。\n\n### 初始值的简写\n```\nlet a = 1;\nlet obj = {\n    a\n}\n```\n### 对象方法的简写\n- 注意简写方法可以使用super关键字\n```\nlet obj = {\n    a(){\n    }\n}\n```\n### 可计算属性名\n\n```\nlet firstName = 'first name'\nlet name = 'name'\nlet person = {\n    [firstName]: 'yang',\n    ['last'+name]: 'xiao'\n}\nconsole.log(person[firstName])//yang\nconsole.log(person['first name'])//yang\nconsole.log(person['last'+name])//xiao\n```\n\n\n### 新增对象方法\n\n### Object.is()\n- 以下几项比较特殊，其他比较与===相同\n```\nconsole.log(Object.is(+0,-0))//false\nconsole.log(Object.is(NaN,NaN))//true\nconsole.log(Object.is(0,''))//false\n```\n\n### Object.assign()\n- 混合（Mixin）模式，接受一个接收对象和任意数量的源对象\n1. 对于对象属性是浅复制\n2. 不能将访问器属性复制到接收对象，只是调用get\n```\nlet obj = {}\nObject.assign(obj,{a:1},{a:2},{b:[1,2,3]},{get c(){\n        return 'c'\n    }})\nconsole.log(obj)//{a:2,b:[1,2,3],c:'c'}\n```\n\n### 自有属性的枚举顺序\n1. 所有数字按照升序排序\n2. 所有字母按照被加入对象的顺序排序\n3. symbol类型按照被加入顺序排序\n4. for-in循环不适用，因为浏览器厂商不一样\n\n### 增强对象原型\n- 对原型进行了改进\n\n#### Object.setPrototypeOf()\n- 改变对象的原型，改变对象内部专属[[Prototype]]，接收两个参数，**被改变原型的对象**，以及**替代原型的对象**\n\n#### 简化原型访问的super\n1. super相当于指针，指向Object.getPrototypeOf(this)的值\n2. 必须在简写方法时使用super\n```\nlet person = {\n    Fun(){\n        return 'hello'\n    }\n}\nlet dog = {\n    Fun(){\n        return 'wangwangwang'\n    }\n}\nlet friend = {\n\n    //必须在简写时使用super\n    Fun(){\n        //ES6写法\n        return super.Fun() + ' world'\n\n        //ES5写法\n        // return Object.getPrototypeOf(this).Fun.call(this) + ' world'\n    }\n}\n\nObject.setPrototypeOf(friend,person)\nconsole.log(friend.Fun())//hello world\nObject.setPrototypeOf(friend,dog)\nconsole.log(friend.Fun())//wangwangwang world\n```\n\n\n#### [[HomeObject]]属性\n- 正式的方法定义内部存在[[HomeObject]]属性\n```\nlet obj = {\n    //是方法有[[HomeObject]]属性指向obj\n    //super的使用就是通过[[HomeObject]]来确定后续执行，因此必须为简写方法\n    Fun(){\n    },\n    //不是方法没有[[HomeObject]]属性\n    Fun1:function () {\n    }\n}\n```\n","slug":"ES6-扩展对象属性","published":1,"updated":"2019-02-13T10:20:16.675Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob5z000be0jc7eqa6hbh","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>ES6通过多种方式加强对象的使用，通过简单的语法扩展，提供更多操作对象以及对象交互方法。</li>\n</ul>\n<h3 id=\"初始值的简写\"><a href=\"#初始值的简写\" class=\"headerlink\" title=\"初始值的简写\"></a>初始值的简写</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = 1;</span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    a</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象方法的简写\"><a href=\"#对象方法的简写\" class=\"headerlink\" title=\"对象方法的简写\"></a>对象方法的简写</h3><ul>\n<li>注意简写方法可以使用super关键字<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    a()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"可计算属性名\"><a href=\"#可计算属性名\" class=\"headerlink\" title=\"可计算属性名\"></a>可计算属性名</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let firstName = &apos;first name&apos;</span><br><span class=\"line\">let name = &apos;name&apos;</span><br><span class=\"line\">let person = &#123;</span><br><span class=\"line\">    [firstName]: &apos;yang&apos;,</span><br><span class=\"line\">    [&apos;last&apos;+name]: &apos;xiao&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(person[firstName])//yang</span><br><span class=\"line\">console.log(person[&apos;first name&apos;])//yang</span><br><span class=\"line\">console.log(person[&apos;last&apos;+name])//xiao</span><br></pre></td></tr></table></figure>\n<h3 id=\"新增对象方法\"><a href=\"#新增对象方法\" class=\"headerlink\" title=\"新增对象方法\"></a>新增对象方法</h3><h3 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is()\"></a>Object.is()</h3><ul>\n<li>以下几项比较特殊，其他比较与===相同<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Object.is(+0,-0))//false</span><br><span class=\"line\">console.log(Object.is(NaN,NaN))//true</span><br><span class=\"line\">console.log(Object.is(0,&apos;&apos;))//false</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h3><ul>\n<li>混合（Mixin）模式，接受一个接收对象和任意数量的源对象</li>\n</ul>\n<ol>\n<li>对于对象属性是浅复制</li>\n<li>不能将访问器属性复制到接收对象，只是调用get<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;&#125;</span><br><span class=\"line\">Object.assign(obj,&#123;a:1&#125;,&#123;a:2&#125;,&#123;b:[1,2,3]&#125;,&#123;get c()&#123;</span><br><span class=\"line\">        return &apos;c&apos;</span><br><span class=\"line\">    &#125;&#125;)</span><br><span class=\"line\">console.log(obj)//&#123;a:2,b:[1,2,3],c:&apos;c&apos;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"自有属性的枚举顺序\"><a href=\"#自有属性的枚举顺序\" class=\"headerlink\" title=\"自有属性的枚举顺序\"></a>自有属性的枚举顺序</h3><ol>\n<li>所有数字按照升序排序</li>\n<li>所有字母按照被加入对象的顺序排序</li>\n<li>symbol类型按照被加入顺序排序</li>\n<li>for-in循环不适用，因为浏览器厂商不一样</li>\n</ol>\n<h3 id=\"增强对象原型\"><a href=\"#增强对象原型\" class=\"headerlink\" title=\"增强对象原型\"></a>增强对象原型</h3><ul>\n<li>对原型进行了改进</li>\n</ul>\n<h4 id=\"Object-setPrototypeOf\"><a href=\"#Object-setPrototypeOf\" class=\"headerlink\" title=\"Object.setPrototypeOf()\"></a>Object.setPrototypeOf()</h4><ul>\n<li>改变对象的原型，改变对象内部专属[[Prototype]]，接收两个参数，<strong>被改变原型的对象</strong>，以及<strong>替代原型的对象</strong></li>\n</ul>\n<h4 id=\"简化原型访问的super\"><a href=\"#简化原型访问的super\" class=\"headerlink\" title=\"简化原型访问的super\"></a>简化原型访问的super</h4><ol>\n<li>super相当于指针，指向Object.getPrototypeOf(this)的值</li>\n<li>必须在简写方法时使用super<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let person = &#123;</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        return &apos;hello&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let dog = &#123;</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        return &apos;wangwangwang&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let friend = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //必须在简写时使用super</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        //ES6写法</span><br><span class=\"line\">        return super.Fun() + &apos; world&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">        //ES5写法</span><br><span class=\"line\">        // return Object.getPrototypeOf(this).Fun.call(this) + &apos; world&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.setPrototypeOf(friend,person)</span><br><span class=\"line\">console.log(friend.Fun())//hello world</span><br><span class=\"line\">Object.setPrototypeOf(friend,dog)</span><br><span class=\"line\">console.log(friend.Fun())//wangwangwang world</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"HomeObject-属性\"><a href=\"#HomeObject-属性\" class=\"headerlink\" title=\"[[HomeObject]]属性\"></a>[[HomeObject]]属性</h4><ul>\n<li>正式的方法定义内部存在[[HomeObject]]属性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    //是方法有[[HomeObject]]属性指向obj</span><br><span class=\"line\">    //super的使用就是通过[[HomeObject]]来确定后续执行，因此必须为简写方法</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //不是方法没有[[HomeObject]]属性</span><br><span class=\"line\">    Fun1:function () &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>ES6通过多种方式加强对象的使用，通过简单的语法扩展，提供更多操作对象以及对象交互方法。</li>\n</ul>\n<h3 id=\"初始值的简写\"><a href=\"#初始值的简写\" class=\"headerlink\" title=\"初始值的简写\"></a>初始值的简写</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = 1;</span><br><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    a</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象方法的简写\"><a href=\"#对象方法的简写\" class=\"headerlink\" title=\"对象方法的简写\"></a>对象方法的简写</h3><ul>\n<li>注意简写方法可以使用super关键字<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    a()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"可计算属性名\"><a href=\"#可计算属性名\" class=\"headerlink\" title=\"可计算属性名\"></a>可计算属性名</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let firstName = &apos;first name&apos;</span><br><span class=\"line\">let name = &apos;name&apos;</span><br><span class=\"line\">let person = &#123;</span><br><span class=\"line\">    [firstName]: &apos;yang&apos;,</span><br><span class=\"line\">    [&apos;last&apos;+name]: &apos;xiao&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(person[firstName])//yang</span><br><span class=\"line\">console.log(person[&apos;first name&apos;])//yang</span><br><span class=\"line\">console.log(person[&apos;last&apos;+name])//xiao</span><br></pre></td></tr></table></figure>\n<h3 id=\"新增对象方法\"><a href=\"#新增对象方法\" class=\"headerlink\" title=\"新增对象方法\"></a>新增对象方法</h3><h3 id=\"Object-is\"><a href=\"#Object-is\" class=\"headerlink\" title=\"Object.is()\"></a>Object.is()</h3><ul>\n<li>以下几项比较特殊，其他比较与===相同<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(Object.is(+0,-0))//false</span><br><span class=\"line\">console.log(Object.is(NaN,NaN))//true</span><br><span class=\"line\">console.log(Object.is(0,&apos;&apos;))//false</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Object-assign\"><a href=\"#Object-assign\" class=\"headerlink\" title=\"Object.assign()\"></a>Object.assign()</h3><ul>\n<li>混合（Mixin）模式，接受一个接收对象和任意数量的源对象</li>\n</ul>\n<ol>\n<li>对于对象属性是浅复制</li>\n<li>不能将访问器属性复制到接收对象，只是调用get<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;&#125;</span><br><span class=\"line\">Object.assign(obj,&#123;a:1&#125;,&#123;a:2&#125;,&#123;b:[1,2,3]&#125;,&#123;get c()&#123;</span><br><span class=\"line\">        return &apos;c&apos;</span><br><span class=\"line\">    &#125;&#125;)</span><br><span class=\"line\">console.log(obj)//&#123;a:2,b:[1,2,3],c:&apos;c&apos;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"自有属性的枚举顺序\"><a href=\"#自有属性的枚举顺序\" class=\"headerlink\" title=\"自有属性的枚举顺序\"></a>自有属性的枚举顺序</h3><ol>\n<li>所有数字按照升序排序</li>\n<li>所有字母按照被加入对象的顺序排序</li>\n<li>symbol类型按照被加入顺序排序</li>\n<li>for-in循环不适用，因为浏览器厂商不一样</li>\n</ol>\n<h3 id=\"增强对象原型\"><a href=\"#增强对象原型\" class=\"headerlink\" title=\"增强对象原型\"></a>增强对象原型</h3><ul>\n<li>对原型进行了改进</li>\n</ul>\n<h4 id=\"Object-setPrototypeOf\"><a href=\"#Object-setPrototypeOf\" class=\"headerlink\" title=\"Object.setPrototypeOf()\"></a>Object.setPrototypeOf()</h4><ul>\n<li>改变对象的原型，改变对象内部专属[[Prototype]]，接收两个参数，<strong>被改变原型的对象</strong>，以及<strong>替代原型的对象</strong></li>\n</ul>\n<h4 id=\"简化原型访问的super\"><a href=\"#简化原型访问的super\" class=\"headerlink\" title=\"简化原型访问的super\"></a>简化原型访问的super</h4><ol>\n<li>super相当于指针，指向Object.getPrototypeOf(this)的值</li>\n<li>必须在简写方法时使用super<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let person = &#123;</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        return &apos;hello&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let dog = &#123;</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        return &apos;wangwangwang&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let friend = &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //必须在简写时使用super</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        //ES6写法</span><br><span class=\"line\">        return super.Fun() + &apos; world&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">        //ES5写法</span><br><span class=\"line\">        // return Object.getPrototypeOf(this).Fun.call(this) + &apos; world&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">Object.setPrototypeOf(friend,person)</span><br><span class=\"line\">console.log(friend.Fun())//hello world</span><br><span class=\"line\">Object.setPrototypeOf(friend,dog)</span><br><span class=\"line\">console.log(friend.Fun())//wangwangwang world</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"HomeObject-属性\"><a href=\"#HomeObject-属性\" class=\"headerlink\" title=\"[[HomeObject]]属性\"></a>[[HomeObject]]属性</h4><ul>\n<li>正式的方法定义内部存在[[HomeObject]]属性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    //是方法有[[HomeObject]]属性指向obj</span><br><span class=\"line\">    //super的使用就是通过[[HomeObject]]来确定后续执行，因此必须为简写方法</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //不是方法没有[[HomeObject]]属性</span><br><span class=\"line\">    Fun1:function () &#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"ES6-改进数组功能","date":"2018-11-10T02:30:30.000Z","_content":"\n## 常用数组方法\n#### 检测数组\n\n```\nlet arr1 = [1,2,3]\nconsole.log(Array.isArray(arr1))//true\n```\n\n#### 转换方法\n\n```\nconsole.log(arr1.valueOf())//[1,2,3]\nconsole.log(arr1.toString())//1,2,3\nconsole.log(arr1.toLocaleString())//1,2,3（每一项调用的是toLocalString()方法）\nconsole.log(arr1.join('#'))//1#2#3\n```\n\n#### 栈方法\n\n```\nlet arr2 = [1,2,3]\narr2.push(4)\nconsole.log(arr2)//[1,2,3,4]\narr2.pop(4)\nconsole.log(arr2)//[1,2,3]\n```\n\n#### 对列方法\n\n```\nlet arr3 = [1,2,3]\narr3.unshift(0)//[0,1,2,3,4]\nconsole.log(arr3)\narr3.shift()\nconsole.log(arr3)\n```\n\n#### 排序方法\n\n```\nlet arr4 = [3,2,1]\narr4.reverse()//反转数组顺序\nconsole.log(arr4)\narr4.sort((a,b)=>{\n    return a - b\n})//由小到大\nconsole.log(arr4)\narr4.sort((a,b)=>{\n    return b - a\n})//由大到小\nconsole.log(arr4)\n\nlet arr5 = [1,2,'10']\nconsole.log(arr5.sort())//[1,'10',2]sort默认先toString()再排序\n```\n\n#### 操作方法\n\n```\nlet a1 = [1]\nlet a2 = [2]\nlet a3 = a1.concat(a2)\nconsole.log(a1)//[1]\nconsole.log(a2)//[2]\nconsole.log(a3)//[1,2]\n\nlet aa1 = [1,2,3,4,5]\nlet aa2 = aa1.slice(1,4)//slice()左闭右开\nlet aa3 = aa1.slice(1)\nconsole.log(aa1)//[1,2,3,4,5]\nconsole.log(aa2)//[2,3,4]\nconsole.log(aa3)//[2,3,4,5]\n```\n\n#### 删除、插入、替换\n删除splice(1,2)\\插入splice(2,0,'a','b')\\替换splice(1,2,3,4)\n\n```\nlet sa1 = [1,2,3,4,5]\nlet sa2 = sa1.splice(1,2,'a','b')//从1位置开始，删除两项，并添加'a'\\'b'两项\nconsole.log(sa1)\nconsole.log(sa2)//返回删除的数组\n```\n\n#### 位置方法\n\n```\nlet la = [1,2,3,2,1]\nconsole.log(la.indexOf(2))//1\nconsole.log(la.lastIndexOf(2))//3\n```\n\n#### 迭代方法\n- every()对数组中每一项进行运行给定函数，如果都返回true，则返回true\n- filter()对数组中每一项进行运行给定函数，如果都返回true，则返回true项组成的数组\n- forEach()对数组中每一项执行给定函数，没有返回值\n- map()对数组中每一项执行给定函数，返回每次函数调用结果返回的数组\n\n```\nlet ma = [1,2,3]\nlet ma1 = ma.map((item,index,arr)=>{\n    return 2\n})\nconsole.log(ma)//[1,2,3]\nconsole.log(ma1)//[2,2,2]\n```\n\n#### some()\n\n#### 归并方法reduce(),reduceRight()\n\n```\nlet ra = [1,2,3]\nlet res = ra.reduce((pre,cur,index,arr)=>{\n    return pre+cur\n})\nconsole.log(ra)\nconsole.log(res)\n```\n\n## ES6方法\n-  ES6标准继续改进数组，添加了许多新功能，比如创建数组新方法、几个实用的方法、创建定型数组\n#### Array.of()\n- Array构造函数传入参数问题\n\n```\nlet arr = new Array(2)\nconsole.log(arr)//[undefined,undefined]\narr = new Array('2')\nconsole.log(arr)//['2']\narr = new Array(1,2)\nconsole.log(arr)//[1,2]\narr = new Array(2,'2')\nconsole.log(arr)//[2,'2']\n```\n\n- Array.of()方法总会创建一个包含所有参数的数组\n\n```\nlet arr1 = Array.of(1,2,3)\nconsole.log(arr1)//[1,2,3]\n```\n\n- 注意：Array.of()不使用Sympol.species属性返回确定的类型，而是使用of()方法中this()的值来返回数据类型\n\n#### Array.from()\n- js不支持直接将非数组对象转换为真实数组，如arguments，如果把它当做数组使用必须先转换该对象的类型\n- es5中的转换方法\n\n```\nfunction makeArray(arrayLike) {\n    var res = []\n    for(var i = 0;i<arrayLike.length;i++){\n        res.push(arrayLike[i])\n    }\n    //或者\n    // res = Array.prototype.slice().call(arrayLike)\n    return res\n}\n(function f(a,b,c) {\n    var arr = makeArray(arguments)\n    console.log(arr)//[1,2,3]\n})(1,2,3)\n```\n\n- Array.from()用来将对象转化为数组，可以接受可迭代对象或类数组对象作为第一个参数，第二个参数可以提供一个映射关系，将每一个值转换为其他形式，第三个参数用来表示映射函数this的值\n\n```\nfunction f1(a,b,c) {\n    let arr = Array.from(arguments,function (item) {\n        return item+this.a\n    },{a:1})\n    console.log(arr)//[3,4,5]\n}\nf1(2,3,4)\n```\n\n- 转换可迭代对象，如果一个对象即是类数组又是可迭代对象，那么会根据迭代器来决定转换哪个值\n\n```\nlet nums = {\n    *[Symbol.iterator](){\n        yield 1;\n        yield 2;\n        yield 3;\n    }\n}\nlet i_arr = Array.from(nums)\nconsole.log(i_arr)//[1,2,3]\n```\n\n#### find()\\findIndex()\n- find()返回找到的值、findIndex()返回找到值的位置，接收两个参数，一个是回调函数、一个是可选参数\n\n```\nlet n = [1,2,3,4,5]\nconsole.log(n.find(item=>item>2))//3\nconsole.log(n.findIndex(item=>item>2))//2\n```\n\n- 如果在数组中查找根据某个条件匹配的元素，使用find()，如果只是匹配某个元素值使用indexOf()\n\n#### fill()\n- fill()可以用指定的值填充一致多个数组元素\n\n```\nlet f_arr = [1,2,3,4]\nf_arr.fill(1)\nconsole.log(f_arr)//[1,1,1,1]\nf_arr.fill(0,1,3)\nconsole.log(f_arr)//[1,0,0,1]左闭右开\n```\n\n#### copyWithin()\n- copyWithin()从数组中复制元素的值\n\n```\nlet c_arr = [1,2,3,4,5]\nc_arr.copyWithin(2,0)\n```\n\n- console.log(c_arr)//[1,2,1,2,3]从索引2开始粘贴值，从索引0开始复制并持续到没有更多可复制的值\n\n#### 定型数组\n- 用于处理数值类型数据专用的数组\n- [定型数组](http://www.shaoqun.com/a/318331.html)\n\n#### Array.prototype.includes()\n- ES7语法\n\n```\nlet val = [1,2,3]\nconsole.log(val.includes(1))//true\n```\n","source":"_posts/ES6-改进数组功能.md","raw":"---\ntitle: ES6-改进数组功能\ndate: 2018-11-10 10:30:30\ntags: [ES6,js,Array]\ncategories: ES6\n---\n\n## 常用数组方法\n#### 检测数组\n\n```\nlet arr1 = [1,2,3]\nconsole.log(Array.isArray(arr1))//true\n```\n\n#### 转换方法\n\n```\nconsole.log(arr1.valueOf())//[1,2,3]\nconsole.log(arr1.toString())//1,2,3\nconsole.log(arr1.toLocaleString())//1,2,3（每一项调用的是toLocalString()方法）\nconsole.log(arr1.join('#'))//1#2#3\n```\n\n#### 栈方法\n\n```\nlet arr2 = [1,2,3]\narr2.push(4)\nconsole.log(arr2)//[1,2,3,4]\narr2.pop(4)\nconsole.log(arr2)//[1,2,3]\n```\n\n#### 对列方法\n\n```\nlet arr3 = [1,2,3]\narr3.unshift(0)//[0,1,2,3,4]\nconsole.log(arr3)\narr3.shift()\nconsole.log(arr3)\n```\n\n#### 排序方法\n\n```\nlet arr4 = [3,2,1]\narr4.reverse()//反转数组顺序\nconsole.log(arr4)\narr4.sort((a,b)=>{\n    return a - b\n})//由小到大\nconsole.log(arr4)\narr4.sort((a,b)=>{\n    return b - a\n})//由大到小\nconsole.log(arr4)\n\nlet arr5 = [1,2,'10']\nconsole.log(arr5.sort())//[1,'10',2]sort默认先toString()再排序\n```\n\n#### 操作方法\n\n```\nlet a1 = [1]\nlet a2 = [2]\nlet a3 = a1.concat(a2)\nconsole.log(a1)//[1]\nconsole.log(a2)//[2]\nconsole.log(a3)//[1,2]\n\nlet aa1 = [1,2,3,4,5]\nlet aa2 = aa1.slice(1,4)//slice()左闭右开\nlet aa3 = aa1.slice(1)\nconsole.log(aa1)//[1,2,3,4,5]\nconsole.log(aa2)//[2,3,4]\nconsole.log(aa3)//[2,3,4,5]\n```\n\n#### 删除、插入、替换\n删除splice(1,2)\\插入splice(2,0,'a','b')\\替换splice(1,2,3,4)\n\n```\nlet sa1 = [1,2,3,4,5]\nlet sa2 = sa1.splice(1,2,'a','b')//从1位置开始，删除两项，并添加'a'\\'b'两项\nconsole.log(sa1)\nconsole.log(sa2)//返回删除的数组\n```\n\n#### 位置方法\n\n```\nlet la = [1,2,3,2,1]\nconsole.log(la.indexOf(2))//1\nconsole.log(la.lastIndexOf(2))//3\n```\n\n#### 迭代方法\n- every()对数组中每一项进行运行给定函数，如果都返回true，则返回true\n- filter()对数组中每一项进行运行给定函数，如果都返回true，则返回true项组成的数组\n- forEach()对数组中每一项执行给定函数，没有返回值\n- map()对数组中每一项执行给定函数，返回每次函数调用结果返回的数组\n\n```\nlet ma = [1,2,3]\nlet ma1 = ma.map((item,index,arr)=>{\n    return 2\n})\nconsole.log(ma)//[1,2,3]\nconsole.log(ma1)//[2,2,2]\n```\n\n#### some()\n\n#### 归并方法reduce(),reduceRight()\n\n```\nlet ra = [1,2,3]\nlet res = ra.reduce((pre,cur,index,arr)=>{\n    return pre+cur\n})\nconsole.log(ra)\nconsole.log(res)\n```\n\n## ES6方法\n-  ES6标准继续改进数组，添加了许多新功能，比如创建数组新方法、几个实用的方法、创建定型数组\n#### Array.of()\n- Array构造函数传入参数问题\n\n```\nlet arr = new Array(2)\nconsole.log(arr)//[undefined,undefined]\narr = new Array('2')\nconsole.log(arr)//['2']\narr = new Array(1,2)\nconsole.log(arr)//[1,2]\narr = new Array(2,'2')\nconsole.log(arr)//[2,'2']\n```\n\n- Array.of()方法总会创建一个包含所有参数的数组\n\n```\nlet arr1 = Array.of(1,2,3)\nconsole.log(arr1)//[1,2,3]\n```\n\n- 注意：Array.of()不使用Sympol.species属性返回确定的类型，而是使用of()方法中this()的值来返回数据类型\n\n#### Array.from()\n- js不支持直接将非数组对象转换为真实数组，如arguments，如果把它当做数组使用必须先转换该对象的类型\n- es5中的转换方法\n\n```\nfunction makeArray(arrayLike) {\n    var res = []\n    for(var i = 0;i<arrayLike.length;i++){\n        res.push(arrayLike[i])\n    }\n    //或者\n    // res = Array.prototype.slice().call(arrayLike)\n    return res\n}\n(function f(a,b,c) {\n    var arr = makeArray(arguments)\n    console.log(arr)//[1,2,3]\n})(1,2,3)\n```\n\n- Array.from()用来将对象转化为数组，可以接受可迭代对象或类数组对象作为第一个参数，第二个参数可以提供一个映射关系，将每一个值转换为其他形式，第三个参数用来表示映射函数this的值\n\n```\nfunction f1(a,b,c) {\n    let arr = Array.from(arguments,function (item) {\n        return item+this.a\n    },{a:1})\n    console.log(arr)//[3,4,5]\n}\nf1(2,3,4)\n```\n\n- 转换可迭代对象，如果一个对象即是类数组又是可迭代对象，那么会根据迭代器来决定转换哪个值\n\n```\nlet nums = {\n    *[Symbol.iterator](){\n        yield 1;\n        yield 2;\n        yield 3;\n    }\n}\nlet i_arr = Array.from(nums)\nconsole.log(i_arr)//[1,2,3]\n```\n\n#### find()\\findIndex()\n- find()返回找到的值、findIndex()返回找到值的位置，接收两个参数，一个是回调函数、一个是可选参数\n\n```\nlet n = [1,2,3,4,5]\nconsole.log(n.find(item=>item>2))//3\nconsole.log(n.findIndex(item=>item>2))//2\n```\n\n- 如果在数组中查找根据某个条件匹配的元素，使用find()，如果只是匹配某个元素值使用indexOf()\n\n#### fill()\n- fill()可以用指定的值填充一致多个数组元素\n\n```\nlet f_arr = [1,2,3,4]\nf_arr.fill(1)\nconsole.log(f_arr)//[1,1,1,1]\nf_arr.fill(0,1,3)\nconsole.log(f_arr)//[1,0,0,1]左闭右开\n```\n\n#### copyWithin()\n- copyWithin()从数组中复制元素的值\n\n```\nlet c_arr = [1,2,3,4,5]\nc_arr.copyWithin(2,0)\n```\n\n- console.log(c_arr)//[1,2,1,2,3]从索引2开始粘贴值，从索引0开始复制并持续到没有更多可复制的值\n\n#### 定型数组\n- 用于处理数值类型数据专用的数组\n- [定型数组](http://www.shaoqun.com/a/318331.html)\n\n#### Array.prototype.includes()\n- ES7语法\n\n```\nlet val = [1,2,3]\nconsole.log(val.includes(1))//true\n```\n","slug":"ES6-改进数组功能","published":1,"updated":"2019-02-15T14:14:14.897Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob62000ge0jctjlj01x5","content":"<h2 id=\"常用数组方法\"><a href=\"#常用数组方法\" class=\"headerlink\" title=\"常用数组方法\"></a>常用数组方法</h2><h4 id=\"检测数组\"><a href=\"#检测数组\" class=\"headerlink\" title=\"检测数组\"></a>检测数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 = [1,2,3]</span><br><span class=\"line\">console.log(Array.isArray(arr1))//true</span><br></pre></td></tr></table></figure>\n<h4 id=\"转换方法\"><a href=\"#转换方法\" class=\"headerlink\" title=\"转换方法\"></a>转换方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(arr1.valueOf())//[1,2,3]</span><br><span class=\"line\">console.log(arr1.toString())//1,2,3</span><br><span class=\"line\">console.log(arr1.toLocaleString())//1,2,3（每一项调用的是toLocalString()方法）</span><br><span class=\"line\">console.log(arr1.join(&apos;#&apos;))//1#2#3</span><br></pre></td></tr></table></figure>\n<h4 id=\"栈方法\"><a href=\"#栈方法\" class=\"headerlink\" title=\"栈方法\"></a>栈方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr2 = [1,2,3]</span><br><span class=\"line\">arr2.push(4)</span><br><span class=\"line\">console.log(arr2)//[1,2,3,4]</span><br><span class=\"line\">arr2.pop(4)</span><br><span class=\"line\">console.log(arr2)//[1,2,3]</span><br></pre></td></tr></table></figure>\n<h4 id=\"对列方法\"><a href=\"#对列方法\" class=\"headerlink\" title=\"对列方法\"></a>对列方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr3 = [1,2,3]</span><br><span class=\"line\">arr3.unshift(0)//[0,1,2,3,4]</span><br><span class=\"line\">console.log(arr3)</span><br><span class=\"line\">arr3.shift()</span><br><span class=\"line\">console.log(arr3)</span><br></pre></td></tr></table></figure>\n<h4 id=\"排序方法\"><a href=\"#排序方法\" class=\"headerlink\" title=\"排序方法\"></a>排序方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr4 = [3,2,1]</span><br><span class=\"line\">arr4.reverse()//反转数组顺序</span><br><span class=\"line\">console.log(arr4)</span><br><span class=\"line\">arr4.sort((a,b)=&gt;&#123;</span><br><span class=\"line\">    return a - b</span><br><span class=\"line\">&#125;)//由小到大</span><br><span class=\"line\">console.log(arr4)</span><br><span class=\"line\">arr4.sort((a,b)=&gt;&#123;</span><br><span class=\"line\">    return b - a</span><br><span class=\"line\">&#125;)//由大到小</span><br><span class=\"line\">console.log(arr4)</span><br><span class=\"line\"></span><br><span class=\"line\">let arr5 = [1,2,&apos;10&apos;]</span><br><span class=\"line\">console.log(arr5.sort())//[1,&apos;10&apos;,2]sort默认先toString()再排序</span><br></pre></td></tr></table></figure>\n<h4 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a1 = [1]</span><br><span class=\"line\">let a2 = [2]</span><br><span class=\"line\">let a3 = a1.concat(a2)</span><br><span class=\"line\">console.log(a1)//[1]</span><br><span class=\"line\">console.log(a2)//[2]</span><br><span class=\"line\">console.log(a3)//[1,2]</span><br><span class=\"line\"></span><br><span class=\"line\">let aa1 = [1,2,3,4,5]</span><br><span class=\"line\">let aa2 = aa1.slice(1,4)//slice()左闭右开</span><br><span class=\"line\">let aa3 = aa1.slice(1)</span><br><span class=\"line\">console.log(aa1)//[1,2,3,4,5]</span><br><span class=\"line\">console.log(aa2)//[2,3,4]</span><br><span class=\"line\">console.log(aa3)//[2,3,4,5]</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除、插入、替换\"><a href=\"#删除、插入、替换\" class=\"headerlink\" title=\"删除、插入、替换\"></a>删除、插入、替换</h4><p>删除splice(1,2)\\插入splice(2,0,’a’,’b’)\\替换splice(1,2,3,4)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let sa1 = [1,2,3,4,5]</span><br><span class=\"line\">let sa2 = sa1.splice(1,2,&apos;a&apos;,&apos;b&apos;)//从1位置开始，删除两项，并添加&apos;a&apos;\\&apos;b&apos;两项</span><br><span class=\"line\">console.log(sa1)</span><br><span class=\"line\">console.log(sa2)//返回删除的数组</span><br></pre></td></tr></table></figure>\n<h4 id=\"位置方法\"><a href=\"#位置方法\" class=\"headerlink\" title=\"位置方法\"></a>位置方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let la = [1,2,3,2,1]</span><br><span class=\"line\">console.log(la.indexOf(2))//1</span><br><span class=\"line\">console.log(la.lastIndexOf(2))//3</span><br></pre></td></tr></table></figure>\n<h4 id=\"迭代方法\"><a href=\"#迭代方法\" class=\"headerlink\" title=\"迭代方法\"></a>迭代方法</h4><ul>\n<li>every()对数组中每一项进行运行给定函数，如果都返回true，则返回true</li>\n<li>filter()对数组中每一项进行运行给定函数，如果都返回true，则返回true项组成的数组</li>\n<li>forEach()对数组中每一项执行给定函数，没有返回值</li>\n<li>map()对数组中每一项执行给定函数，返回每次函数调用结果返回的数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ma = [1,2,3]</span><br><span class=\"line\">let ma1 = ma.map((item,index,arr)=&gt;&#123;</span><br><span class=\"line\">    return 2</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(ma)//[1,2,3]</span><br><span class=\"line\">console.log(ma1)//[2,2,2]</span><br></pre></td></tr></table></figure>\n<h4 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some()\"></a>some()</h4><h4 id=\"归并方法reduce-reduceRight\"><a href=\"#归并方法reduce-reduceRight\" class=\"headerlink\" title=\"归并方法reduce(),reduceRight()\"></a>归并方法reduce(),reduceRight()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ra = [1,2,3]</span><br><span class=\"line\">let res = ra.reduce((pre,cur,index,arr)=&gt;&#123;</span><br><span class=\"line\">    return pre+cur</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(ra)</span><br><span class=\"line\">console.log(res)</span><br></pre></td></tr></table></figure>\n<h2 id=\"ES6方法\"><a href=\"#ES6方法\" class=\"headerlink\" title=\"ES6方法\"></a>ES6方法</h2><ul>\n<li>ES6标准继续改进数组，添加了许多新功能，比如创建数组新方法、几个实用的方法、创建定型数组<h4 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h4></li>\n<li>Array构造函数传入参数问题</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = new Array(2)</span><br><span class=\"line\">console.log(arr)//[undefined,undefined]</span><br><span class=\"line\">arr = new Array(&apos;2&apos;)</span><br><span class=\"line\">console.log(arr)//[&apos;2&apos;]</span><br><span class=\"line\">arr = new Array(1,2)</span><br><span class=\"line\">console.log(arr)//[1,2]</span><br><span class=\"line\">arr = new Array(2,&apos;2&apos;)</span><br><span class=\"line\">console.log(arr)//[2,&apos;2&apos;]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Array.of()方法总会创建一个包含所有参数的数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 = Array.of(1,2,3)</span><br><span class=\"line\">console.log(arr1)//[1,2,3]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意：Array.of()不使用Sympol.species属性返回确定的类型，而是使用of()方法中this()的值来返回数据类型</li>\n</ul>\n<h4 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h4><ul>\n<li>js不支持直接将非数组对象转换为真实数组，如arguments，如果把它当做数组使用必须先转换该对象的类型</li>\n<li>es5中的转换方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function makeArray(arrayLike) &#123;</span><br><span class=\"line\">    var res = []</span><br><span class=\"line\">    for(var i = 0;i&lt;arrayLike.length;i++)&#123;</span><br><span class=\"line\">        res.push(arrayLike[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //或者</span><br><span class=\"line\">    // res = Array.prototype.slice().call(arrayLike)</span><br><span class=\"line\">    return res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(function f(a,b,c) &#123;</span><br><span class=\"line\">    var arr = makeArray(arguments)</span><br><span class=\"line\">    console.log(arr)//[1,2,3]</span><br><span class=\"line\">&#125;)(1,2,3)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Array.from()用来将对象转化为数组，可以接受可迭代对象或类数组对象作为第一个参数，第二个参数可以提供一个映射关系，将每一个值转换为其他形式，第三个参数用来表示映射函数this的值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1(a,b,c) &#123;</span><br><span class=\"line\">    let arr = Array.from(arguments,function (item) &#123;</span><br><span class=\"line\">        return item+this.a</span><br><span class=\"line\">    &#125;,&#123;a:1&#125;)</span><br><span class=\"line\">    console.log(arr)//[3,4,5]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f1(2,3,4)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>转换可迭代对象，如果一个对象即是类数组又是可迭代对象，那么会根据迭代器来决定转换哪个值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let nums = &#123;</span><br><span class=\"line\">    *[Symbol.iterator]()&#123;</span><br><span class=\"line\">        yield 1;</span><br><span class=\"line\">        yield 2;</span><br><span class=\"line\">        yield 3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let i_arr = Array.from(nums)</span><br><span class=\"line\">console.log(i_arr)//[1,2,3]</span><br></pre></td></tr></table></figure>\n<h4 id=\"find-findIndex\"><a href=\"#find-findIndex\" class=\"headerlink\" title=\"find()\\findIndex()\"></a>find()\\findIndex()</h4><ul>\n<li>find()返回找到的值、findIndex()返回找到值的位置，接收两个参数，一个是回调函数、一个是可选参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let n = [1,2,3,4,5]</span><br><span class=\"line\">console.log(n.find(item=&gt;item&gt;2))//3</span><br><span class=\"line\">console.log(n.findIndex(item=&gt;item&gt;2))//2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果在数组中查找根据某个条件匹配的元素，使用find()，如果只是匹配某个元素值使用indexOf()</li>\n</ul>\n<h4 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill()\"></a>fill()</h4><ul>\n<li>fill()可以用指定的值填充一致多个数组元素</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let f_arr = [1,2,3,4]</span><br><span class=\"line\">f_arr.fill(1)</span><br><span class=\"line\">console.log(f_arr)//[1,1,1,1]</span><br><span class=\"line\">f_arr.fill(0,1,3)</span><br><span class=\"line\">console.log(f_arr)//[1,0,0,1]左闭右开</span><br></pre></td></tr></table></figure>\n<h4 id=\"copyWithin\"><a href=\"#copyWithin\" class=\"headerlink\" title=\"copyWithin()\"></a>copyWithin()</h4><ul>\n<li>copyWithin()从数组中复制元素的值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let c_arr = [1,2,3,4,5]</span><br><span class=\"line\">c_arr.copyWithin(2,0)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>console.log(c_arr)//[1,2,1,2,3]从索引2开始粘贴值，从索引0开始复制并持续到没有更多可复制的值</li>\n</ul>\n<h4 id=\"定型数组\"><a href=\"#定型数组\" class=\"headerlink\" title=\"定型数组\"></a>定型数组</h4><ul>\n<li>用于处理数值类型数据专用的数组</li>\n<li><a href=\"http://www.shaoqun.com/a/318331.html\" target=\"_blank\" rel=\"noopener\">定型数组</a></li>\n</ul>\n<h4 id=\"Array-prototype-includes\"><a href=\"#Array-prototype-includes\" class=\"headerlink\" title=\"Array.prototype.includes()\"></a>Array.prototype.includes()</h4><ul>\n<li>ES7语法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let val = [1,2,3]</span><br><span class=\"line\">console.log(val.includes(1))//true</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"常用数组方法\"><a href=\"#常用数组方法\" class=\"headerlink\" title=\"常用数组方法\"></a>常用数组方法</h2><h4 id=\"检测数组\"><a href=\"#检测数组\" class=\"headerlink\" title=\"检测数组\"></a>检测数组</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 = [1,2,3]</span><br><span class=\"line\">console.log(Array.isArray(arr1))//true</span><br></pre></td></tr></table></figure>\n<h4 id=\"转换方法\"><a href=\"#转换方法\" class=\"headerlink\" title=\"转换方法\"></a>转换方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(arr1.valueOf())//[1,2,3]</span><br><span class=\"line\">console.log(arr1.toString())//1,2,3</span><br><span class=\"line\">console.log(arr1.toLocaleString())//1,2,3（每一项调用的是toLocalString()方法）</span><br><span class=\"line\">console.log(arr1.join(&apos;#&apos;))//1#2#3</span><br></pre></td></tr></table></figure>\n<h4 id=\"栈方法\"><a href=\"#栈方法\" class=\"headerlink\" title=\"栈方法\"></a>栈方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr2 = [1,2,3]</span><br><span class=\"line\">arr2.push(4)</span><br><span class=\"line\">console.log(arr2)//[1,2,3,4]</span><br><span class=\"line\">arr2.pop(4)</span><br><span class=\"line\">console.log(arr2)//[1,2,3]</span><br></pre></td></tr></table></figure>\n<h4 id=\"对列方法\"><a href=\"#对列方法\" class=\"headerlink\" title=\"对列方法\"></a>对列方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr3 = [1,2,3]</span><br><span class=\"line\">arr3.unshift(0)//[0,1,2,3,4]</span><br><span class=\"line\">console.log(arr3)</span><br><span class=\"line\">arr3.shift()</span><br><span class=\"line\">console.log(arr3)</span><br></pre></td></tr></table></figure>\n<h4 id=\"排序方法\"><a href=\"#排序方法\" class=\"headerlink\" title=\"排序方法\"></a>排序方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr4 = [3,2,1]</span><br><span class=\"line\">arr4.reverse()//反转数组顺序</span><br><span class=\"line\">console.log(arr4)</span><br><span class=\"line\">arr4.sort((a,b)=&gt;&#123;</span><br><span class=\"line\">    return a - b</span><br><span class=\"line\">&#125;)//由小到大</span><br><span class=\"line\">console.log(arr4)</span><br><span class=\"line\">arr4.sort((a,b)=&gt;&#123;</span><br><span class=\"line\">    return b - a</span><br><span class=\"line\">&#125;)//由大到小</span><br><span class=\"line\">console.log(arr4)</span><br><span class=\"line\"></span><br><span class=\"line\">let arr5 = [1,2,&apos;10&apos;]</span><br><span class=\"line\">console.log(arr5.sort())//[1,&apos;10&apos;,2]sort默认先toString()再排序</span><br></pre></td></tr></table></figure>\n<h4 id=\"操作方法\"><a href=\"#操作方法\" class=\"headerlink\" title=\"操作方法\"></a>操作方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a1 = [1]</span><br><span class=\"line\">let a2 = [2]</span><br><span class=\"line\">let a3 = a1.concat(a2)</span><br><span class=\"line\">console.log(a1)//[1]</span><br><span class=\"line\">console.log(a2)//[2]</span><br><span class=\"line\">console.log(a3)//[1,2]</span><br><span class=\"line\"></span><br><span class=\"line\">let aa1 = [1,2,3,4,5]</span><br><span class=\"line\">let aa2 = aa1.slice(1,4)//slice()左闭右开</span><br><span class=\"line\">let aa3 = aa1.slice(1)</span><br><span class=\"line\">console.log(aa1)//[1,2,3,4,5]</span><br><span class=\"line\">console.log(aa2)//[2,3,4]</span><br><span class=\"line\">console.log(aa3)//[2,3,4,5]</span><br></pre></td></tr></table></figure>\n<h4 id=\"删除、插入、替换\"><a href=\"#删除、插入、替换\" class=\"headerlink\" title=\"删除、插入、替换\"></a>删除、插入、替换</h4><p>删除splice(1,2)\\插入splice(2,0,’a’,’b’)\\替换splice(1,2,3,4)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let sa1 = [1,2,3,4,5]</span><br><span class=\"line\">let sa2 = sa1.splice(1,2,&apos;a&apos;,&apos;b&apos;)//从1位置开始，删除两项，并添加&apos;a&apos;\\&apos;b&apos;两项</span><br><span class=\"line\">console.log(sa1)</span><br><span class=\"line\">console.log(sa2)//返回删除的数组</span><br></pre></td></tr></table></figure>\n<h4 id=\"位置方法\"><a href=\"#位置方法\" class=\"headerlink\" title=\"位置方法\"></a>位置方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let la = [1,2,3,2,1]</span><br><span class=\"line\">console.log(la.indexOf(2))//1</span><br><span class=\"line\">console.log(la.lastIndexOf(2))//3</span><br></pre></td></tr></table></figure>\n<h4 id=\"迭代方法\"><a href=\"#迭代方法\" class=\"headerlink\" title=\"迭代方法\"></a>迭代方法</h4><ul>\n<li>every()对数组中每一项进行运行给定函数，如果都返回true，则返回true</li>\n<li>filter()对数组中每一项进行运行给定函数，如果都返回true，则返回true项组成的数组</li>\n<li>forEach()对数组中每一项执行给定函数，没有返回值</li>\n<li>map()对数组中每一项执行给定函数，返回每次函数调用结果返回的数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ma = [1,2,3]</span><br><span class=\"line\">let ma1 = ma.map((item,index,arr)=&gt;&#123;</span><br><span class=\"line\">    return 2</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(ma)//[1,2,3]</span><br><span class=\"line\">console.log(ma1)//[2,2,2]</span><br></pre></td></tr></table></figure>\n<h4 id=\"some\"><a href=\"#some\" class=\"headerlink\" title=\"some()\"></a>some()</h4><h4 id=\"归并方法reduce-reduceRight\"><a href=\"#归并方法reduce-reduceRight\" class=\"headerlink\" title=\"归并方法reduce(),reduceRight()\"></a>归并方法reduce(),reduceRight()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let ra = [1,2,3]</span><br><span class=\"line\">let res = ra.reduce((pre,cur,index,arr)=&gt;&#123;</span><br><span class=\"line\">    return pre+cur</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">console.log(ra)</span><br><span class=\"line\">console.log(res)</span><br></pre></td></tr></table></figure>\n<h2 id=\"ES6方法\"><a href=\"#ES6方法\" class=\"headerlink\" title=\"ES6方法\"></a>ES6方法</h2><ul>\n<li>ES6标准继续改进数组，添加了许多新功能，比如创建数组新方法、几个实用的方法、创建定型数组<h4 id=\"Array-of\"><a href=\"#Array-of\" class=\"headerlink\" title=\"Array.of()\"></a>Array.of()</h4></li>\n<li>Array构造函数传入参数问题</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = new Array(2)</span><br><span class=\"line\">console.log(arr)//[undefined,undefined]</span><br><span class=\"line\">arr = new Array(&apos;2&apos;)</span><br><span class=\"line\">console.log(arr)//[&apos;2&apos;]</span><br><span class=\"line\">arr = new Array(1,2)</span><br><span class=\"line\">console.log(arr)//[1,2]</span><br><span class=\"line\">arr = new Array(2,&apos;2&apos;)</span><br><span class=\"line\">console.log(arr)//[2,&apos;2&apos;]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Array.of()方法总会创建一个包含所有参数的数组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr1 = Array.of(1,2,3)</span><br><span class=\"line\">console.log(arr1)//[1,2,3]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>注意：Array.of()不使用Sympol.species属性返回确定的类型，而是使用of()方法中this()的值来返回数据类型</li>\n</ul>\n<h4 id=\"Array-from\"><a href=\"#Array-from\" class=\"headerlink\" title=\"Array.from()\"></a>Array.from()</h4><ul>\n<li>js不支持直接将非数组对象转换为真实数组，如arguments，如果把它当做数组使用必须先转换该对象的类型</li>\n<li>es5中的转换方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function makeArray(arrayLike) &#123;</span><br><span class=\"line\">    var res = []</span><br><span class=\"line\">    for(var i = 0;i&lt;arrayLike.length;i++)&#123;</span><br><span class=\"line\">        res.push(arrayLike[i])</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //或者</span><br><span class=\"line\">    // res = Array.prototype.slice().call(arrayLike)</span><br><span class=\"line\">    return res</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">(function f(a,b,c) &#123;</span><br><span class=\"line\">    var arr = makeArray(arguments)</span><br><span class=\"line\">    console.log(arr)//[1,2,3]</span><br><span class=\"line\">&#125;)(1,2,3)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Array.from()用来将对象转化为数组，可以接受可迭代对象或类数组对象作为第一个参数，第二个参数可以提供一个映射关系，将每一个值转换为其他形式，第三个参数用来表示映射函数this的值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1(a,b,c) &#123;</span><br><span class=\"line\">    let arr = Array.from(arguments,function (item) &#123;</span><br><span class=\"line\">        return item+this.a</span><br><span class=\"line\">    &#125;,&#123;a:1&#125;)</span><br><span class=\"line\">    console.log(arr)//[3,4,5]</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f1(2,3,4)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>转换可迭代对象，如果一个对象即是类数组又是可迭代对象，那么会根据迭代器来决定转换哪个值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let nums = &#123;</span><br><span class=\"line\">    *[Symbol.iterator]()&#123;</span><br><span class=\"line\">        yield 1;</span><br><span class=\"line\">        yield 2;</span><br><span class=\"line\">        yield 3;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let i_arr = Array.from(nums)</span><br><span class=\"line\">console.log(i_arr)//[1,2,3]</span><br></pre></td></tr></table></figure>\n<h4 id=\"find-findIndex\"><a href=\"#find-findIndex\" class=\"headerlink\" title=\"find()\\findIndex()\"></a>find()\\findIndex()</h4><ul>\n<li>find()返回找到的值、findIndex()返回找到值的位置，接收两个参数，一个是回调函数、一个是可选参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let n = [1,2,3,4,5]</span><br><span class=\"line\">console.log(n.find(item=&gt;item&gt;2))//3</span><br><span class=\"line\">console.log(n.findIndex(item=&gt;item&gt;2))//2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>如果在数组中查找根据某个条件匹配的元素，使用find()，如果只是匹配某个元素值使用indexOf()</li>\n</ul>\n<h4 id=\"fill\"><a href=\"#fill\" class=\"headerlink\" title=\"fill()\"></a>fill()</h4><ul>\n<li>fill()可以用指定的值填充一致多个数组元素</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let f_arr = [1,2,3,4]</span><br><span class=\"line\">f_arr.fill(1)</span><br><span class=\"line\">console.log(f_arr)//[1,1,1,1]</span><br><span class=\"line\">f_arr.fill(0,1,3)</span><br><span class=\"line\">console.log(f_arr)//[1,0,0,1]左闭右开</span><br></pre></td></tr></table></figure>\n<h4 id=\"copyWithin\"><a href=\"#copyWithin\" class=\"headerlink\" title=\"copyWithin()\"></a>copyWithin()</h4><ul>\n<li>copyWithin()从数组中复制元素的值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let c_arr = [1,2,3,4,5]</span><br><span class=\"line\">c_arr.copyWithin(2,0)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>console.log(c_arr)//[1,2,1,2,3]从索引2开始粘贴值，从索引0开始复制并持续到没有更多可复制的值</li>\n</ul>\n<h4 id=\"定型数组\"><a href=\"#定型数组\" class=\"headerlink\" title=\"定型数组\"></a>定型数组</h4><ul>\n<li>用于处理数值类型数据专用的数组</li>\n<li><a href=\"http://www.shaoqun.com/a/318331.html\" target=\"_blank\" rel=\"noopener\">定型数组</a></li>\n</ul>\n<h4 id=\"Array-prototype-includes\"><a href=\"#Array-prototype-includes\" class=\"headerlink\" title=\"Array.prototype.includes()\"></a>Array.prototype.includes()</h4><ul>\n<li>ES7语法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let val = [1,2,3]</span><br><span class=\"line\">console.log(val.includes(1))//true</span><br></pre></td></tr></table></figure>\n"},{"title":"ES6-函数","date":"2018-08-21T00:31:24.000Z","_content":"\n\nES6在ES5的基础上做了大量改进，使编程更加灵活，更少出错。\n\n## 参数默认值\n\n- ES5非严格模式下，命名参数的变化会体现在arguments对象中\n```\nfunction a(b,c) {\n    console.log(b === arguments[0])//true\n    console.log(c === arguments[1])//true\n    b = 3\n    c = 3\n    //会同步\n    console.log(b === arguments[0])//true\n    console.log(c === arguments[1])//true\n}\na(1,1)\n```\n- ES5严格模式下取消了对于arguments对象的同步行为\n```\nfunction a(b,c) {\n    'use strict'\n    console.log(b === arguments[0])//true\n    console.log(c === arguments[1])//true\n    b = 3\n    c = 3\n    //不会同步\n    console.log(b === arguments[0])//false\n    console.log(c === arguments[1])//false\n}\na(1,1)\n```\n\n```\nfunction defaultParam(a,b=1) {\n}\n```\n默认参数对arguments的影响（在ES6中如果一个函数使用了默认值，无论是否显示定义严格模式，arguments与ES5严格模式保持一致）\n\n```\nfunction Fun(a,b=1) {\n    console.log(arguments)//不传b参数时，没有arguments[1]\n    console.log(a === arguments[0])//true\n    console.log(b === arguments[1])//false\n    a = 2\n    b = 2\n    //不会同步\n    console.log(a === arguments[0])//false\n    console.log(b === arguments[1])//false\n}\nFun(1)\n```\n\n## 默认参数表达式\n- 注意如果忘记写小括号，则传入默认函数的引用\n\n```\nlet num = 1\nfunction Funa() {\n    return num++\n}\nfunction Fun(a,b=Funa()) {\n    console.log(b)\n}\nFun(1)//1\nFun(1)//2\n```\n\n\n- 可以使用先定义的参数作为后定义参数的默认值(但是反过来的话会产生临时死区TDZ)\n\n```\nfunction add(first,second = first) {\n    return first+second\n}\nadd(1)\n```\n\n- 参数的默认值不能访问函数体内声明的变量（参数和函数体的作用域相互独立）\n\n## 处理无命名参数\n### 不定参数\n* 使用限制：1、每个函数只能声明一个不定参数 2、不定参数必需放在所有参数的末尾\n* 不定参数对arguments的影响：无论是否使用不定参数，arguments对象总是包含所有传入的参数\n\n```\nfunction pick(object,...keys) {\n    console.log(arguments)\n    let result = Object.create(null)\n    for(let i = 0,len = keys.length; i<len ;i++){\n        result[keys[i]] = object[keys[i]]\n    }\n    return result\n}\npick({a:1,b:2},...['a','b'])\n```\n- 对象的setter只能包含一个参数\n```\nlet obj = {\n    set name(...arrs){\n\n    }\n}\n//报错：Uncaught SyntaxError: Setter function argument must not be a rest parameter\n```\n\n\n### Function构造函数增强\n\n```\nlet Funaa = new Function('a=1','...nums','console.log(a+nums[0])')//11(字符串)\nFunaa(1,[1])\n```\n### 展开运算符\n指定数组，打散后作为参数传入函数\n\n```\nlet numArr= [1,2,3]\nMath.max(...numArr,0)//在后边在传入参数，可以控制最小值\nMath.max.apply(null,numArr)//等同于这个，但是apply需要手动绑定this\n```\n\n## name属性\n* 1、函数表达式的属性名字比函数赋值的变量权重高\n* 2、getter函数名字有get\n* 3、调用bind生成函数名字有bound\n\n```\nfunction name2() {\n}\nlet name1 = name2\nconsole.log(name1.name)//name2\nconsole.log(name2.name)//name2\nlet person = {\n    get firstName(){\n        return '1234'\n    }\n}\nconsole.log(person.firstName.name)//get firstName\nlet name3 = name2.bind(null)\nconsole.log(name3.name)//bound name2\n```\n\n## 明确函数的多用途\n- ES5中判断函数被调用的方法，但是通过Person.call()或者Person.apply()方法调用就无法判断\n```\nfunction Person(name) {\n    if(this instanceof Person){\n        this.name = name\n    }else {\n        throw new Error('必须通过new关键字调用person')\n    }\n}\n```\n* 1、函数有[[Call]]和[[Construct]]方法，分表表示直接调用和new构造\n* 2、元属性new.target（判断函数是否通过new关键字调用）\n\n```\nfunction bbb() {\n    if(new.target === bbb){\n        this.a = 1\n    }else {\n        console.log('error')\n    }\n}\nbbb()//error\nnew bbb()\n```\n\n## 块级函数\n- ES5中处理块级函数，ES5严格模式中代码块内声明函数会报错\n```\n'use strict'\nif(true){\n    //抛出错误\n    function a() {\n\n    }\n}\n```\n* ES6严格模式下块级函数（代码中块级函数会被提升至块的顶部，而使用let声明的变量不会）\n\n```\nif(true){\n    console.log(typeof a)//function\n    function a() {\n\n    }\n    console.log(typeof b)//报错\n    let b = function () {\n\n    }\n}\n```\n- ES6非严格模式下，函数提升至外围函数或全局作用域的顶部\n```\nif(true){\n    function a() {\n\n    }\n}\nconsole.log(typeof a)//function\n```\n## 箭头函数\n* 1、没有this\\super\\arguments\\ner.target绑定，箭头函数中的这些由外层最近一个非箭头函数决定\n* 2、不能通过new关键字调用\n* 3、没有原型\n* 4、不可改变this指向\n* 5、不支持arguments对象\n* 6、不支持重复命名参数\n\n```\nlet reflec = val=>val//直接返回val\n\nlet refObj = ()=>({a:1})//直接返回object\n\nlet bbbb = ((val)=>{return val})(1)//立即执行\n\nlet nullRef = ()=>{}\ntypeof nullRef//function\n```\n### 多个箭头的函数与科里化\n```\nvar a = b => c => d => {\n    console.log(b)\n    console.log(c)\n    console.log(d)\n}\n\n    // 等价于\nvar a = function (b) {\n    return function (c) {\n        return function (d) {\n            console.log(b)\n            console.log(c)\n            console.log(d)\n        }\n\n    }\n}\n```\n\n## 尾调用优化\n尾调用指的是函数作为另一个函数的最后一条语句被执行\n\nES6缩减了严格模式下尾调用栈的大小，如果满足以下条件，尾调用不在创建新栈，而是清除并重用当前栈。\n\n需要同时满足：\n* 1、尾调用不访问当前函数的变量\n* 2、在函数内部，尾调用是最后一条语句\n* 3、尾调用的结果作为函数的返回值\n适用于递归函数\n\n```\nfunction factorial(n,p=1) {\n    if(n<=1){\n        return 1\n    }else {\n        let result = n*p\n        return factorial(n-1,result)\n    }\n}\n```\n","source":"_posts/ES6-函数.md","raw":"---\ntitle: ES6-函数\ndate: 2018-08-21 08:31:24\ntags: [ES6,js]\ncategories: ES6\n---\n\n\nES6在ES5的基础上做了大量改进，使编程更加灵活，更少出错。\n\n## 参数默认值\n\n- ES5非严格模式下，命名参数的变化会体现在arguments对象中\n```\nfunction a(b,c) {\n    console.log(b === arguments[0])//true\n    console.log(c === arguments[1])//true\n    b = 3\n    c = 3\n    //会同步\n    console.log(b === arguments[0])//true\n    console.log(c === arguments[1])//true\n}\na(1,1)\n```\n- ES5严格模式下取消了对于arguments对象的同步行为\n```\nfunction a(b,c) {\n    'use strict'\n    console.log(b === arguments[0])//true\n    console.log(c === arguments[1])//true\n    b = 3\n    c = 3\n    //不会同步\n    console.log(b === arguments[0])//false\n    console.log(c === arguments[1])//false\n}\na(1,1)\n```\n\n```\nfunction defaultParam(a,b=1) {\n}\n```\n默认参数对arguments的影响（在ES6中如果一个函数使用了默认值，无论是否显示定义严格模式，arguments与ES5严格模式保持一致）\n\n```\nfunction Fun(a,b=1) {\n    console.log(arguments)//不传b参数时，没有arguments[1]\n    console.log(a === arguments[0])//true\n    console.log(b === arguments[1])//false\n    a = 2\n    b = 2\n    //不会同步\n    console.log(a === arguments[0])//false\n    console.log(b === arguments[1])//false\n}\nFun(1)\n```\n\n## 默认参数表达式\n- 注意如果忘记写小括号，则传入默认函数的引用\n\n```\nlet num = 1\nfunction Funa() {\n    return num++\n}\nfunction Fun(a,b=Funa()) {\n    console.log(b)\n}\nFun(1)//1\nFun(1)//2\n```\n\n\n- 可以使用先定义的参数作为后定义参数的默认值(但是反过来的话会产生临时死区TDZ)\n\n```\nfunction add(first,second = first) {\n    return first+second\n}\nadd(1)\n```\n\n- 参数的默认值不能访问函数体内声明的变量（参数和函数体的作用域相互独立）\n\n## 处理无命名参数\n### 不定参数\n* 使用限制：1、每个函数只能声明一个不定参数 2、不定参数必需放在所有参数的末尾\n* 不定参数对arguments的影响：无论是否使用不定参数，arguments对象总是包含所有传入的参数\n\n```\nfunction pick(object,...keys) {\n    console.log(arguments)\n    let result = Object.create(null)\n    for(let i = 0,len = keys.length; i<len ;i++){\n        result[keys[i]] = object[keys[i]]\n    }\n    return result\n}\npick({a:1,b:2},...['a','b'])\n```\n- 对象的setter只能包含一个参数\n```\nlet obj = {\n    set name(...arrs){\n\n    }\n}\n//报错：Uncaught SyntaxError: Setter function argument must not be a rest parameter\n```\n\n\n### Function构造函数增强\n\n```\nlet Funaa = new Function('a=1','...nums','console.log(a+nums[0])')//11(字符串)\nFunaa(1,[1])\n```\n### 展开运算符\n指定数组，打散后作为参数传入函数\n\n```\nlet numArr= [1,2,3]\nMath.max(...numArr,0)//在后边在传入参数，可以控制最小值\nMath.max.apply(null,numArr)//等同于这个，但是apply需要手动绑定this\n```\n\n## name属性\n* 1、函数表达式的属性名字比函数赋值的变量权重高\n* 2、getter函数名字有get\n* 3、调用bind生成函数名字有bound\n\n```\nfunction name2() {\n}\nlet name1 = name2\nconsole.log(name1.name)//name2\nconsole.log(name2.name)//name2\nlet person = {\n    get firstName(){\n        return '1234'\n    }\n}\nconsole.log(person.firstName.name)//get firstName\nlet name3 = name2.bind(null)\nconsole.log(name3.name)//bound name2\n```\n\n## 明确函数的多用途\n- ES5中判断函数被调用的方法，但是通过Person.call()或者Person.apply()方法调用就无法判断\n```\nfunction Person(name) {\n    if(this instanceof Person){\n        this.name = name\n    }else {\n        throw new Error('必须通过new关键字调用person')\n    }\n}\n```\n* 1、函数有[[Call]]和[[Construct]]方法，分表表示直接调用和new构造\n* 2、元属性new.target（判断函数是否通过new关键字调用）\n\n```\nfunction bbb() {\n    if(new.target === bbb){\n        this.a = 1\n    }else {\n        console.log('error')\n    }\n}\nbbb()//error\nnew bbb()\n```\n\n## 块级函数\n- ES5中处理块级函数，ES5严格模式中代码块内声明函数会报错\n```\n'use strict'\nif(true){\n    //抛出错误\n    function a() {\n\n    }\n}\n```\n* ES6严格模式下块级函数（代码中块级函数会被提升至块的顶部，而使用let声明的变量不会）\n\n```\nif(true){\n    console.log(typeof a)//function\n    function a() {\n\n    }\n    console.log(typeof b)//报错\n    let b = function () {\n\n    }\n}\n```\n- ES6非严格模式下，函数提升至外围函数或全局作用域的顶部\n```\nif(true){\n    function a() {\n\n    }\n}\nconsole.log(typeof a)//function\n```\n## 箭头函数\n* 1、没有this\\super\\arguments\\ner.target绑定，箭头函数中的这些由外层最近一个非箭头函数决定\n* 2、不能通过new关键字调用\n* 3、没有原型\n* 4、不可改变this指向\n* 5、不支持arguments对象\n* 6、不支持重复命名参数\n\n```\nlet reflec = val=>val//直接返回val\n\nlet refObj = ()=>({a:1})//直接返回object\n\nlet bbbb = ((val)=>{return val})(1)//立即执行\n\nlet nullRef = ()=>{}\ntypeof nullRef//function\n```\n### 多个箭头的函数与科里化\n```\nvar a = b => c => d => {\n    console.log(b)\n    console.log(c)\n    console.log(d)\n}\n\n    // 等价于\nvar a = function (b) {\n    return function (c) {\n        return function (d) {\n            console.log(b)\n            console.log(c)\n            console.log(d)\n        }\n\n    }\n}\n```\n\n## 尾调用优化\n尾调用指的是函数作为另一个函数的最后一条语句被执行\n\nES6缩减了严格模式下尾调用栈的大小，如果满足以下条件，尾调用不在创建新栈，而是清除并重用当前栈。\n\n需要同时满足：\n* 1、尾调用不访问当前函数的变量\n* 2、在函数内部，尾调用是最后一条语句\n* 3、尾调用的结果作为函数的返回值\n适用于递归函数\n\n```\nfunction factorial(n,p=1) {\n    if(n<=1){\n        return 1\n    }else {\n        let result = n*p\n        return factorial(n-1,result)\n    }\n}\n```\n","slug":"ES6-函数","published":1,"updated":"2019-01-08T13:46:05.639Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob66000je0jcfu5lhax7","content":"<p>ES6在ES5的基础上做了大量改进，使编程更加灵活，更少出错。</p>\n<h2 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h2><ul>\n<li><p>ES5非严格模式下，命名参数的变化会体现在arguments对象中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a(b,c) &#123;</span><br><span class=\"line\">    console.log(b === arguments[0])//true</span><br><span class=\"line\">    console.log(c === arguments[1])//true</span><br><span class=\"line\">    b = 3</span><br><span class=\"line\">    c = 3</span><br><span class=\"line\">    //会同步</span><br><span class=\"line\">    console.log(b === arguments[0])//true</span><br><span class=\"line\">    console.log(c === arguments[1])//true</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(1,1)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ES5严格模式下取消了对于arguments对象的同步行为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a(b,c) &#123;</span><br><span class=\"line\">    &apos;use strict&apos;</span><br><span class=\"line\">    console.log(b === arguments[0])//true</span><br><span class=\"line\">    console.log(c === arguments[1])//true</span><br><span class=\"line\">    b = 3</span><br><span class=\"line\">    c = 3</span><br><span class=\"line\">    //不会同步</span><br><span class=\"line\">    console.log(b === arguments[0])//false</span><br><span class=\"line\">    console.log(c === arguments[1])//false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(1,1)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function defaultParam(a,b=1) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认参数对arguments的影响（在ES6中如果一个函数使用了默认值，无论是否显示定义严格模式，arguments与ES5严格模式保持一致）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fun(a,b=1) &#123;</span><br><span class=\"line\">    console.log(arguments)//不传b参数时，没有arguments[1]</span><br><span class=\"line\">    console.log(a === arguments[0])//true</span><br><span class=\"line\">    console.log(b === arguments[1])//false</span><br><span class=\"line\">    a = 2</span><br><span class=\"line\">    b = 2</span><br><span class=\"line\">    //不会同步</span><br><span class=\"line\">    console.log(a === arguments[0])//false</span><br><span class=\"line\">    console.log(b === arguments[1])//false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun(1)</span><br></pre></td></tr></table></figure>\n<h2 id=\"默认参数表达式\"><a href=\"#默认参数表达式\" class=\"headerlink\" title=\"默认参数表达式\"></a>默认参数表达式</h2><ul>\n<li>注意如果忘记写小括号，则传入默认函数的引用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let num = 1</span><br><span class=\"line\">function Funa() &#123;</span><br><span class=\"line\">    return num++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Fun(a,b=Funa()) &#123;</span><br><span class=\"line\">    console.log(b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun(1)//1</span><br><span class=\"line\">Fun(1)//2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>可以使用先定义的参数作为后定义参数的默认值(但是反过来的话会产生临时死区TDZ)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(first,second = first) &#123;</span><br><span class=\"line\">    return first+second</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(1)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>参数的默认值不能访问函数体内声明的变量（参数和函数体的作用域相互独立）</li>\n</ul>\n<h2 id=\"处理无命名参数\"><a href=\"#处理无命名参数\" class=\"headerlink\" title=\"处理无命名参数\"></a>处理无命名参数</h2><h3 id=\"不定参数\"><a href=\"#不定参数\" class=\"headerlink\" title=\"不定参数\"></a>不定参数</h3><ul>\n<li>使用限制：1、每个函数只能声明一个不定参数 2、不定参数必需放在所有参数的末尾</li>\n<li>不定参数对arguments的影响：无论是否使用不定参数，arguments对象总是包含所有传入的参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function pick(object,...keys) &#123;</span><br><span class=\"line\">    console.log(arguments)</span><br><span class=\"line\">    let result = Object.create(null)</span><br><span class=\"line\">    for(let i = 0,len = keys.length; i&lt;len ;i++)&#123;</span><br><span class=\"line\">        result[keys[i]] = object[keys[i]]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">pick(&#123;a:1,b:2&#125;,...[&apos;a&apos;,&apos;b&apos;])</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对象的setter只能包含一个参数<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    set name(...arrs)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//报错：Uncaught SyntaxError: Setter function argument must not be a rest parameter</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Function构造函数增强\"><a href=\"#Function构造函数增强\" class=\"headerlink\" title=\"Function构造函数增强\"></a>Function构造函数增强</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let Funaa = new Function(&apos;a=1&apos;,&apos;...nums&apos;,&apos;console.log(a+nums[0])&apos;)//11(字符串)</span><br><span class=\"line\">Funaa(1,[1])</span><br></pre></td></tr></table></figure>\n<h3 id=\"展开运算符\"><a href=\"#展开运算符\" class=\"headerlink\" title=\"展开运算符\"></a>展开运算符</h3><p>指定数组，打散后作为参数传入函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let numArr= [1,2,3]</span><br><span class=\"line\">Math.max(...numArr,0)//在后边在传入参数，可以控制最小值</span><br><span class=\"line\">Math.max.apply(null,numArr)//等同于这个，但是apply需要手动绑定this</span><br></pre></td></tr></table></figure>\n<h2 id=\"name属性\"><a href=\"#name属性\" class=\"headerlink\" title=\"name属性\"></a>name属性</h2><ul>\n<li>1、函数表达式的属性名字比函数赋值的变量权重高</li>\n<li>2、getter函数名字有get</li>\n<li>3、调用bind生成函数名字有bound</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function name2() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let name1 = name2</span><br><span class=\"line\">console.log(name1.name)//name2</span><br><span class=\"line\">console.log(name2.name)//name2</span><br><span class=\"line\">let person = &#123;</span><br><span class=\"line\">    get firstName()&#123;</span><br><span class=\"line\">        return &apos;1234&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(person.firstName.name)//get firstName</span><br><span class=\"line\">let name3 = name2.bind(null)</span><br><span class=\"line\">console.log(name3.name)//bound name2</span><br></pre></td></tr></table></figure>\n<h2 id=\"明确函数的多用途\"><a href=\"#明确函数的多用途\" class=\"headerlink\" title=\"明确函数的多用途\"></a>明确函数的多用途</h2><ul>\n<li>ES5中判断函数被调用的方法，但是通过Person.call()或者Person.apply()方法调用就无法判断<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name) &#123;</span><br><span class=\"line\">    if(this instanceof Person)&#123;</span><br><span class=\"line\">        this.name = name</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        throw new Error(&apos;必须通过new关键字调用person&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>1、函数有[[Call]]和[[Construct]]方法，分表表示直接调用和new构造</li>\n<li>2、元属性new.target（判断函数是否通过new关键字调用）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bbb() &#123;</span><br><span class=\"line\">    if(new.target === bbb)&#123;</span><br><span class=\"line\">        this.a = 1</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        console.log(&apos;error&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bbb()//error</span><br><span class=\"line\">new bbb()</span><br></pre></td></tr></table></figure>\n<h2 id=\"块级函数\"><a href=\"#块级函数\" class=\"headerlink\" title=\"块级函数\"></a>块级函数</h2><ul>\n<li>ES5中处理块级函数，ES5严格模式中代码块内声明函数会报错<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;</span><br><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    //抛出错误</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>ES6严格模式下块级函数（代码中块级函数会被提升至块的顶部，而使用let声明的变量不会）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    console.log(typeof a)//function</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(typeof b)//报错</span><br><span class=\"line\">    let b = function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ES6非严格模式下，函数提升至外围函数或全局作用域的顶部<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(typeof a)//function</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><ul>\n<li>1、没有this\\super\\arguments\\ner.target绑定，箭头函数中的这些由外层最近一个非箭头函数决定</li>\n<li>2、不能通过new关键字调用</li>\n<li>3、没有原型</li>\n<li>4、不可改变this指向</li>\n<li>5、不支持arguments对象</li>\n<li>6、不支持重复命名参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reflec = val=&gt;val//直接返回val</span><br><span class=\"line\"></span><br><span class=\"line\">let refObj = ()=&gt;(&#123;a:1&#125;)//直接返回object</span><br><span class=\"line\"></span><br><span class=\"line\">let bbbb = ((val)=&gt;&#123;return val&#125;)(1)//立即执行</span><br><span class=\"line\"></span><br><span class=\"line\">let nullRef = ()=&gt;&#123;&#125;</span><br><span class=\"line\">typeof nullRef//function</span><br></pre></td></tr></table></figure>\n<h3 id=\"多个箭头的函数与科里化\"><a href=\"#多个箭头的函数与科里化\" class=\"headerlink\" title=\"多个箭头的函数与科里化\"></a>多个箭头的函数与科里化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = b =&gt; c =&gt; d =&gt; &#123;</span><br><span class=\"line\">    console.log(b)</span><br><span class=\"line\">    console.log(c)</span><br><span class=\"line\">    console.log(d)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 等价于</span><br><span class=\"line\">var a = function (b) &#123;</span><br><span class=\"line\">    return function (c) &#123;</span><br><span class=\"line\">        return function (d) &#123;</span><br><span class=\"line\">            console.log(b)</span><br><span class=\"line\">            console.log(c)</span><br><span class=\"line\">            console.log(d)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h2><p>尾调用指的是函数作为另一个函数的最后一条语句被执行</p>\n<p>ES6缩减了严格模式下尾调用栈的大小，如果满足以下条件，尾调用不在创建新栈，而是清除并重用当前栈。</p>\n<p>需要同时满足：</p>\n<ul>\n<li>1、尾调用不访问当前函数的变量</li>\n<li>2、在函数内部，尾调用是最后一条语句</li>\n<li>3、尾调用的结果作为函数的返回值<br>适用于递归函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factorial(n,p=1) &#123;</span><br><span class=\"line\">    if(n&lt;=1)&#123;</span><br><span class=\"line\">        return 1</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        let result = n*p</span><br><span class=\"line\">        return factorial(n-1,result)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>ES6在ES5的基础上做了大量改进，使编程更加灵活，更少出错。</p>\n<h2 id=\"参数默认值\"><a href=\"#参数默认值\" class=\"headerlink\" title=\"参数默认值\"></a>参数默认值</h2><ul>\n<li><p>ES5非严格模式下，命名参数的变化会体现在arguments对象中</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a(b,c) &#123;</span><br><span class=\"line\">    console.log(b === arguments[0])//true</span><br><span class=\"line\">    console.log(c === arguments[1])//true</span><br><span class=\"line\">    b = 3</span><br><span class=\"line\">    c = 3</span><br><span class=\"line\">    //会同步</span><br><span class=\"line\">    console.log(b === arguments[0])//true</span><br><span class=\"line\">    console.log(c === arguments[1])//true</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(1,1)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>ES5严格模式下取消了对于arguments对象的同步行为</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a(b,c) &#123;</span><br><span class=\"line\">    &apos;use strict&apos;</span><br><span class=\"line\">    console.log(b === arguments[0])//true</span><br><span class=\"line\">    console.log(c === arguments[1])//true</span><br><span class=\"line\">    b = 3</span><br><span class=\"line\">    c = 3</span><br><span class=\"line\">    //不会同步</span><br><span class=\"line\">    console.log(b === arguments[0])//false</span><br><span class=\"line\">    console.log(c === arguments[1])//false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(1,1)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function defaultParam(a,b=1) &#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>默认参数对arguments的影响（在ES6中如果一个函数使用了默认值，无论是否显示定义严格模式，arguments与ES5严格模式保持一致）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Fun(a,b=1) &#123;</span><br><span class=\"line\">    console.log(arguments)//不传b参数时，没有arguments[1]</span><br><span class=\"line\">    console.log(a === arguments[0])//true</span><br><span class=\"line\">    console.log(b === arguments[1])//false</span><br><span class=\"line\">    a = 2</span><br><span class=\"line\">    b = 2</span><br><span class=\"line\">    //不会同步</span><br><span class=\"line\">    console.log(a === arguments[0])//false</span><br><span class=\"line\">    console.log(b === arguments[1])//false</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun(1)</span><br></pre></td></tr></table></figure>\n<h2 id=\"默认参数表达式\"><a href=\"#默认参数表达式\" class=\"headerlink\" title=\"默认参数表达式\"></a>默认参数表达式</h2><ul>\n<li>注意如果忘记写小括号，则传入默认函数的引用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let num = 1</span><br><span class=\"line\">function Funa() &#123;</span><br><span class=\"line\">    return num++</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Fun(a,b=Funa()) &#123;</span><br><span class=\"line\">    console.log(b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun(1)//1</span><br><span class=\"line\">Fun(1)//2</span><br></pre></td></tr></table></figure>\n<ul>\n<li>可以使用先定义的参数作为后定义参数的默认值(但是反过来的话会产生临时死区TDZ)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function add(first,second = first) &#123;</span><br><span class=\"line\">    return first+second</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">add(1)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>参数的默认值不能访问函数体内声明的变量（参数和函数体的作用域相互独立）</li>\n</ul>\n<h2 id=\"处理无命名参数\"><a href=\"#处理无命名参数\" class=\"headerlink\" title=\"处理无命名参数\"></a>处理无命名参数</h2><h3 id=\"不定参数\"><a href=\"#不定参数\" class=\"headerlink\" title=\"不定参数\"></a>不定参数</h3><ul>\n<li>使用限制：1、每个函数只能声明一个不定参数 2、不定参数必需放在所有参数的末尾</li>\n<li>不定参数对arguments的影响：无论是否使用不定参数，arguments对象总是包含所有传入的参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function pick(object,...keys) &#123;</span><br><span class=\"line\">    console.log(arguments)</span><br><span class=\"line\">    let result = Object.create(null)</span><br><span class=\"line\">    for(let i = 0,len = keys.length; i&lt;len ;i++)&#123;</span><br><span class=\"line\">        result[keys[i]] = object[keys[i]]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    return result</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">pick(&#123;a:1,b:2&#125;,...[&apos;a&apos;,&apos;b&apos;])</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对象的setter只能包含一个参数<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    set name(...arrs)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//报错：Uncaught SyntaxError: Setter function argument must not be a rest parameter</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Function构造函数增强\"><a href=\"#Function构造函数增强\" class=\"headerlink\" title=\"Function构造函数增强\"></a>Function构造函数增强</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let Funaa = new Function(&apos;a=1&apos;,&apos;...nums&apos;,&apos;console.log(a+nums[0])&apos;)//11(字符串)</span><br><span class=\"line\">Funaa(1,[1])</span><br></pre></td></tr></table></figure>\n<h3 id=\"展开运算符\"><a href=\"#展开运算符\" class=\"headerlink\" title=\"展开运算符\"></a>展开运算符</h3><p>指定数组，打散后作为参数传入函数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let numArr= [1,2,3]</span><br><span class=\"line\">Math.max(...numArr,0)//在后边在传入参数，可以控制最小值</span><br><span class=\"line\">Math.max.apply(null,numArr)//等同于这个，但是apply需要手动绑定this</span><br></pre></td></tr></table></figure>\n<h2 id=\"name属性\"><a href=\"#name属性\" class=\"headerlink\" title=\"name属性\"></a>name属性</h2><ul>\n<li>1、函数表达式的属性名字比函数赋值的变量权重高</li>\n<li>2、getter函数名字有get</li>\n<li>3、调用bind生成函数名字有bound</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function name2() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let name1 = name2</span><br><span class=\"line\">console.log(name1.name)//name2</span><br><span class=\"line\">console.log(name2.name)//name2</span><br><span class=\"line\">let person = &#123;</span><br><span class=\"line\">    get firstName()&#123;</span><br><span class=\"line\">        return &apos;1234&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(person.firstName.name)//get firstName</span><br><span class=\"line\">let name3 = name2.bind(null)</span><br><span class=\"line\">console.log(name3.name)//bound name2</span><br></pre></td></tr></table></figure>\n<h2 id=\"明确函数的多用途\"><a href=\"#明确函数的多用途\" class=\"headerlink\" title=\"明确函数的多用途\"></a>明确函数的多用途</h2><ul>\n<li>ES5中判断函数被调用的方法，但是通过Person.call()或者Person.apply()方法调用就无法判断<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function Person(name) &#123;</span><br><span class=\"line\">    if(this instanceof Person)&#123;</span><br><span class=\"line\">        this.name = name</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        throw new Error(&apos;必须通过new关键字调用person&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>1、函数有[[Call]]和[[Construct]]方法，分表表示直接调用和new构造</li>\n<li>2、元属性new.target（判断函数是否通过new关键字调用）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bbb() &#123;</span><br><span class=\"line\">    if(new.target === bbb)&#123;</span><br><span class=\"line\">        this.a = 1</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        console.log(&apos;error&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">bbb()//error</span><br><span class=\"line\">new bbb()</span><br></pre></td></tr></table></figure>\n<h2 id=\"块级函数\"><a href=\"#块级函数\" class=\"headerlink\" title=\"块级函数\"></a>块级函数</h2><ul>\n<li>ES5中处理块级函数，ES5严格模式中代码块内声明函数会报错<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;use strict&apos;</span><br><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    //抛出错误</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ul>\n<li>ES6严格模式下块级函数（代码中块级函数会被提升至块的顶部，而使用let声明的变量不会）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    console.log(typeof a)//function</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    console.log(typeof b)//报错</span><br><span class=\"line\">    let b = function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ES6非严格模式下，函数提升至外围函数或全局作用域的顶部<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(typeof a)//function</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h2><ul>\n<li>1、没有this\\super\\arguments\\ner.target绑定，箭头函数中的这些由外层最近一个非箭头函数决定</li>\n<li>2、不能通过new关键字调用</li>\n<li>3、没有原型</li>\n<li>4、不可改变this指向</li>\n<li>5、不支持arguments对象</li>\n<li>6、不支持重复命名参数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reflec = val=&gt;val//直接返回val</span><br><span class=\"line\"></span><br><span class=\"line\">let refObj = ()=&gt;(&#123;a:1&#125;)//直接返回object</span><br><span class=\"line\"></span><br><span class=\"line\">let bbbb = ((val)=&gt;&#123;return val&#125;)(1)//立即执行</span><br><span class=\"line\"></span><br><span class=\"line\">let nullRef = ()=&gt;&#123;&#125;</span><br><span class=\"line\">typeof nullRef//function</span><br></pre></td></tr></table></figure>\n<h3 id=\"多个箭头的函数与科里化\"><a href=\"#多个箭头的函数与科里化\" class=\"headerlink\" title=\"多个箭头的函数与科里化\"></a>多个箭头的函数与科里化</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = b =&gt; c =&gt; d =&gt; &#123;</span><br><span class=\"line\">    console.log(b)</span><br><span class=\"line\">    console.log(c)</span><br><span class=\"line\">    console.log(d)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // 等价于</span><br><span class=\"line\">var a = function (b) &#123;</span><br><span class=\"line\">    return function (c) &#123;</span><br><span class=\"line\">        return function (d) &#123;</span><br><span class=\"line\">            console.log(b)</span><br><span class=\"line\">            console.log(c)</span><br><span class=\"line\">            console.log(d)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"尾调用优化\"><a href=\"#尾调用优化\" class=\"headerlink\" title=\"尾调用优化\"></a>尾调用优化</h2><p>尾调用指的是函数作为另一个函数的最后一条语句被执行</p>\n<p>ES6缩减了严格模式下尾调用栈的大小，如果满足以下条件，尾调用不在创建新栈，而是清除并重用当前栈。</p>\n<p>需要同时满足：</p>\n<ul>\n<li>1、尾调用不访问当前函数的变量</li>\n<li>2、在函数内部，尾调用是最后一条语句</li>\n<li>3、尾调用的结果作为函数的返回值<br>适用于递归函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function factorial(n,p=1) &#123;</span><br><span class=\"line\">    if(n&lt;=1)&#123;</span><br><span class=\"line\">        return 1</span><br><span class=\"line\">    &#125;else &#123;</span><br><span class=\"line\">        let result = n*p</span><br><span class=\"line\">        return factorial(n-1,result)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"ES6-模块化","date":"2019-02-11T00:40:50.000Z","_content":"\n### 简介\n\n - ES6之前，在应用的每一个js定义中都共享一个全局作用域，会引起命名冲突和安全问题。\n - ES6为了解决作用域问题，引入了模块。\n - 模块是自动运行在严格模式下的js代码，在模块顶部创建的变量不会被加到全局作用域中，这个变量仅在模块的顶级作用域存在，模块可以导入导出。\n - 在模块的顶部，this的值是undefined，模块不支持HTML风格代码注释。\n\n### 基本语法\n\n#### 导出\n\n```\nexport var a = 1\nexport function b(){}\nexport class c(){}\n```\n\n- 使用default关键字可以导出匿名函数或者类\n\n#### 导入\n\n```\nimport {a,b,c} from 'a.js'\n```\n\n- 导入整个模块\n\n```\nimport * as A from 'a.js'\n```\n\n- 不管import语句在一个模块执行多少次，只会执行一次\n\n```\n//a.js只会执行一次\nimport {a} from 'a.js'\nimport {b} from 'a.js'\nimport {c} from 'a.js'\n```\n\n- export和import限制必须在其他语句和函数之外使用\n\n```\nif(true){\n    export var a = 1//语法错误\n}\n```\n\n```\n//不能在一条语句中使用import\nfunction fun(){\n    import {a} from 'a.js'\n}\n```\n\n- ES6的import语句为函数、变量、类创建的是只读绑定，而不是像正常变量一样简单引用原始绑定\n\n```\nexport var a = 1\n\nimport {a} from 'a.js'\na = 2//抛出错误\n```\n\n- 导入重命名\n\n```\nimport {a as A} from 'a.js'\n```\n\n#### 模块的默认值\n\n```\nexport default a\nexport {a as default}\n```\n```\n//导入默认值和其他值\nimport a,{b,c} from 'a.js'\n```\n\n#### 无绑定导入\n\n- 某些模块可能不导出任何东西，只是修改全局作用域中的对象\n- 无绑定导入可以用来创建polyfill和shim\n\n```\nimport './a.js'\n```\n","source":"_posts/ES6-模块化.md","raw":"---\ntitle: ES6-模块化\ndate: 2019-02-11 08:40:50\ntags: [ES6,js]\ncategories: ES6\n---\n\n### 简介\n\n - ES6之前，在应用的每一个js定义中都共享一个全局作用域，会引起命名冲突和安全问题。\n - ES6为了解决作用域问题，引入了模块。\n - 模块是自动运行在严格模式下的js代码，在模块顶部创建的变量不会被加到全局作用域中，这个变量仅在模块的顶级作用域存在，模块可以导入导出。\n - 在模块的顶部，this的值是undefined，模块不支持HTML风格代码注释。\n\n### 基本语法\n\n#### 导出\n\n```\nexport var a = 1\nexport function b(){}\nexport class c(){}\n```\n\n- 使用default关键字可以导出匿名函数或者类\n\n#### 导入\n\n```\nimport {a,b,c} from 'a.js'\n```\n\n- 导入整个模块\n\n```\nimport * as A from 'a.js'\n```\n\n- 不管import语句在一个模块执行多少次，只会执行一次\n\n```\n//a.js只会执行一次\nimport {a} from 'a.js'\nimport {b} from 'a.js'\nimport {c} from 'a.js'\n```\n\n- export和import限制必须在其他语句和函数之外使用\n\n```\nif(true){\n    export var a = 1//语法错误\n}\n```\n\n```\n//不能在一条语句中使用import\nfunction fun(){\n    import {a} from 'a.js'\n}\n```\n\n- ES6的import语句为函数、变量、类创建的是只读绑定，而不是像正常变量一样简单引用原始绑定\n\n```\nexport var a = 1\n\nimport {a} from 'a.js'\na = 2//抛出错误\n```\n\n- 导入重命名\n\n```\nimport {a as A} from 'a.js'\n```\n\n#### 模块的默认值\n\n```\nexport default a\nexport {a as default}\n```\n```\n//导入默认值和其他值\nimport a,{b,c} from 'a.js'\n```\n\n#### 无绑定导入\n\n- 某些模块可能不导出任何东西，只是修改全局作用域中的对象\n- 无绑定导入可以用来创建polyfill和shim\n\n```\nimport './a.js'\n```\n","slug":"ES6-模块化","published":1,"updated":"2019-02-16T06:11:41.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob6a000oe0jcxyxf84o9","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>ES6之前，在应用的每一个js定义中都共享一个全局作用域，会引起命名冲突和安全问题。</li>\n<li>ES6为了解决作用域问题，引入了模块。</li>\n<li>模块是自动运行在严格模式下的js代码，在模块顶部创建的变量不会被加到全局作用域中，这个变量仅在模块的顶级作用域存在，模块可以导入导出。</li>\n<li>在模块的顶部，this的值是undefined，模块不支持HTML风格代码注释。</li>\n</ul>\n<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><h4 id=\"导出\"><a href=\"#导出\" class=\"headerlink\" title=\"导出\"></a>导出</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export var a = 1</span><br><span class=\"line\">export function b()&#123;&#125;</span><br><span class=\"line\">export class c()&#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用default关键字可以导出匿名函数或者类</li>\n</ul>\n<h4 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;a,b,c&#125; from &apos;a.js&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>导入整个模块</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as A from &apos;a.js&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>不管import语句在一个模块执行多少次，只会执行一次</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//a.js只会执行一次</span><br><span class=\"line\">import &#123;a&#125; from &apos;a.js&apos;</span><br><span class=\"line\">import &#123;b&#125; from &apos;a.js&apos;</span><br><span class=\"line\">import &#123;c&#125; from &apos;a.js&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>export和import限制必须在其他语句和函数之外使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    export var a = 1//语法错误</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//不能在一条语句中使用import</span><br><span class=\"line\">function fun()&#123;</span><br><span class=\"line\">    import &#123;a&#125; from &apos;a.js&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ES6的import语句为函数、变量、类创建的是只读绑定，而不是像正常变量一样简单引用原始绑定</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export var a = 1</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;a&#125; from &apos;a.js&apos;</span><br><span class=\"line\">a = 2//抛出错误</span><br></pre></td></tr></table></figure>\n<ul>\n<li>导入重命名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;a as A&#125; from &apos;a.js&apos;</span><br></pre></td></tr></table></figure>\n<h4 id=\"模块的默认值\"><a href=\"#模块的默认值\" class=\"headerlink\" title=\"模块的默认值\"></a>模块的默认值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default a</span><br><span class=\"line\">export &#123;a as default&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//导入默认值和其他值</span><br><span class=\"line\">import a,&#123;b,c&#125; from &apos;a.js&apos;</span><br></pre></td></tr></table></figure>\n<h4 id=\"无绑定导入\"><a href=\"#无绑定导入\" class=\"headerlink\" title=\"无绑定导入\"></a>无绑定导入</h4><ul>\n<li>某些模块可能不导出任何东西，只是修改全局作用域中的对象</li>\n<li>无绑定导入可以用来创建polyfill和shim</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &apos;./a.js&apos;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li>ES6之前，在应用的每一个js定义中都共享一个全局作用域，会引起命名冲突和安全问题。</li>\n<li>ES6为了解决作用域问题，引入了模块。</li>\n<li>模块是自动运行在严格模式下的js代码，在模块顶部创建的变量不会被加到全局作用域中，这个变量仅在模块的顶级作用域存在，模块可以导入导出。</li>\n<li>在模块的顶部，this的值是undefined，模块不支持HTML风格代码注释。</li>\n</ul>\n<h3 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h3><h4 id=\"导出\"><a href=\"#导出\" class=\"headerlink\" title=\"导出\"></a>导出</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export var a = 1</span><br><span class=\"line\">export function b()&#123;&#125;</span><br><span class=\"line\">export class c()&#123;&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用default关键字可以导出匿名函数或者类</li>\n</ul>\n<h4 id=\"导入\"><a href=\"#导入\" class=\"headerlink\" title=\"导入\"></a>导入</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;a,b,c&#125; from &apos;a.js&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>导入整个模块</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import * as A from &apos;a.js&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>不管import语句在一个模块执行多少次，只会执行一次</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//a.js只会执行一次</span><br><span class=\"line\">import &#123;a&#125; from &apos;a.js&apos;</span><br><span class=\"line\">import &#123;b&#125; from &apos;a.js&apos;</span><br><span class=\"line\">import &#123;c&#125; from &apos;a.js&apos;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>export和import限制必须在其他语句和函数之外使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if(true)&#123;</span><br><span class=\"line\">    export var a = 1//语法错误</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//不能在一条语句中使用import</span><br><span class=\"line\">function fun()&#123;</span><br><span class=\"line\">    import &#123;a&#125; from &apos;a.js&apos;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>ES6的import语句为函数、变量、类创建的是只读绑定，而不是像正常变量一样简单引用原始绑定</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export var a = 1</span><br><span class=\"line\"></span><br><span class=\"line\">import &#123;a&#125; from &apos;a.js&apos;</span><br><span class=\"line\">a = 2//抛出错误</span><br></pre></td></tr></table></figure>\n<ul>\n<li>导入重命名</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &#123;a as A&#125; from &apos;a.js&apos;</span><br></pre></td></tr></table></figure>\n<h4 id=\"模块的默认值\"><a href=\"#模块的默认值\" class=\"headerlink\" title=\"模块的默认值\"></a>模块的默认值</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">export default a</span><br><span class=\"line\">export &#123;a as default&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//导入默认值和其他值</span><br><span class=\"line\">import a,&#123;b,c&#125; from &apos;a.js&apos;</span><br></pre></td></tr></table></figure>\n<h4 id=\"无绑定导入\"><a href=\"#无绑定导入\" class=\"headerlink\" title=\"无绑定导入\"></a>无绑定导入</h4><ul>\n<li>某些模块可能不导出任何东西，只是修改全局作用域中的对象</li>\n<li>无绑定导入可以用来创建polyfill和shim</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import &apos;./a.js&apos;</span><br></pre></td></tr></table></figure>\n"},{"title":"ES6-解构","date":"2017-08-17T12:00:00.000Z","_content":"\n对象和数组是JS里面常用的两种数据结构，ES6中添加了简化任务的新特性：结构，是一种打破数据结构，拆分成更小部分的过程。\n\n# 解构对象\n\n```\nlet obj = {\n    a: 1,b: 2\n}\nlet {a,b} = obj//注意右侧要初始化程序\nconsole.log(a)//1\nconsole.log(b)//2\n```\n\n\n### 解构赋值\n```\nlet a = 1,b = 1,obj = {a:2,b:2};//这里的;一定要加上，否则报错\n({a,b} = obj)//注意这里的括号要加上\nconsole.log(a)//2\nconsole.log(b)//2\n```\n\n### 如果值为null或者undefined会导致程序抛出错误\n```\nlet {a,b} = null\n//报错:VM222:1 Uncaught TypeError: Cannot destructure property `a` of 'undefined' or 'null'.\n```\n\n### 默认值\n```\nlet obj = {\n    a: 2\n}\nlet {a ,b = 1} = obj\nconsole.log(a)//2\nconsole.log(b)//1\n```\n\n### 非同名局部变量赋值\n```\nlet obj = {\n    type: '1'\n}\nlet {type: localType} = obj\nconsole.log(localType)//'1'\n```\n\n\n### 嵌套对象解构\n```\nlet obj = {\n    a: {\n        s: 4\n    }\n}\nlet {a: {s}} = obj//此时a不是绑定，只代表在对象中的检索属性位置\nconsole.log(s)//4\n```\n\n\n# 数组解构\n\n```\nlet arr = [1,2]\nlet [a,b] = arr\nconsole.log(a,b)//1  2\n```\n\n\n### 数组解构赋值\n```\nlet arr2 = [3,4];//这个;符号必须要加\n[a,b] = arr2\nconsole.log(a,b)//3  4\n```\n\n\n### 特殊用法，交换变量位置\n```\nlet m = 1,n=2;\n[m,n] = [n,m]\n```\n\n\n### 默认值\n```\nlet arr = [1]\nlet [a,b=1] = arr\nconsole.log(a,b)//1  1\n```\n\n\n### 嵌套解构\n```\nlet arr = [1,[1,2,3]]\nlet [h,[g]] = arr\nconsole.log(h,g)//1  1\n```\n\n\n### 不定元素（不定元素一定要放在最后）\n```\nlet arr = [1,2,3,4,5]\nlet [a,...b] = arr\nconsole.log(b)//[2,3,4,5]\n```\n\n### 不定元素可以解决数组克隆功能\n```\nlet arr = [1,2,3]\nlet arr1 = arr.concat()//ES5做法\nlet [...arr2] = arr//不定元素\n```\n\n\n# 混合解构\n```\nlet obj = {\n    a: [1, 2, 3],\n    b: 2\n};\nlet {\n    a: [c],\n        b\n} = obj\nconsole.log(c,b)\n```\n\n# 解构参数\n\n```\nconst defaultParams = {\n    a: 1,b:2\n}\nfunction Fun({a,b}=defaultParams) {\n    console.log(a)\n    console.log(b)\n}\nFun({a:3,b:4})\n```\n","source":"_posts/ES6-解构.md","raw":"---\ntitle: ES6-解构\ndate: 2017-08-17 20:00:00\ntags: [ES6,js]\ncategories: ES6\n---\n\n对象和数组是JS里面常用的两种数据结构，ES6中添加了简化任务的新特性：结构，是一种打破数据结构，拆分成更小部分的过程。\n\n# 解构对象\n\n```\nlet obj = {\n    a: 1,b: 2\n}\nlet {a,b} = obj//注意右侧要初始化程序\nconsole.log(a)//1\nconsole.log(b)//2\n```\n\n\n### 解构赋值\n```\nlet a = 1,b = 1,obj = {a:2,b:2};//这里的;一定要加上，否则报错\n({a,b} = obj)//注意这里的括号要加上\nconsole.log(a)//2\nconsole.log(b)//2\n```\n\n### 如果值为null或者undefined会导致程序抛出错误\n```\nlet {a,b} = null\n//报错:VM222:1 Uncaught TypeError: Cannot destructure property `a` of 'undefined' or 'null'.\n```\n\n### 默认值\n```\nlet obj = {\n    a: 2\n}\nlet {a ,b = 1} = obj\nconsole.log(a)//2\nconsole.log(b)//1\n```\n\n### 非同名局部变量赋值\n```\nlet obj = {\n    type: '1'\n}\nlet {type: localType} = obj\nconsole.log(localType)//'1'\n```\n\n\n### 嵌套对象解构\n```\nlet obj = {\n    a: {\n        s: 4\n    }\n}\nlet {a: {s}} = obj//此时a不是绑定，只代表在对象中的检索属性位置\nconsole.log(s)//4\n```\n\n\n# 数组解构\n\n```\nlet arr = [1,2]\nlet [a,b] = arr\nconsole.log(a,b)//1  2\n```\n\n\n### 数组解构赋值\n```\nlet arr2 = [3,4];//这个;符号必须要加\n[a,b] = arr2\nconsole.log(a,b)//3  4\n```\n\n\n### 特殊用法，交换变量位置\n```\nlet m = 1,n=2;\n[m,n] = [n,m]\n```\n\n\n### 默认值\n```\nlet arr = [1]\nlet [a,b=1] = arr\nconsole.log(a,b)//1  1\n```\n\n\n### 嵌套解构\n```\nlet arr = [1,[1,2,3]]\nlet [h,[g]] = arr\nconsole.log(h,g)//1  1\n```\n\n\n### 不定元素（不定元素一定要放在最后）\n```\nlet arr = [1,2,3,4,5]\nlet [a,...b] = arr\nconsole.log(b)//[2,3,4,5]\n```\n\n### 不定元素可以解决数组克隆功能\n```\nlet arr = [1,2,3]\nlet arr1 = arr.concat()//ES5做法\nlet [...arr2] = arr//不定元素\n```\n\n\n# 混合解构\n```\nlet obj = {\n    a: [1, 2, 3],\n    b: 2\n};\nlet {\n    a: [c],\n        b\n} = obj\nconsole.log(c,b)\n```\n\n# 解构参数\n\n```\nconst defaultParams = {\n    a: 1,b:2\n}\nfunction Fun({a,b}=defaultParams) {\n    console.log(a)\n    console.log(b)\n}\nFun({a:3,b:4})\n```\n","slug":"ES6-解构","published":1,"updated":"2018-09-28T03:09:57.807Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob6d000re0jcpvg66g2s","content":"<p>对象和数组是JS里面常用的两种数据结构，ES6中添加了简化任务的新特性：结构，是一种打破数据结构，拆分成更小部分的过程。</p>\n<h1 id=\"解构对象\"><a href=\"#解构对象\" class=\"headerlink\" title=\"解构对象\"></a>解构对象</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    a: 1,b: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;a,b&#125; = obj//注意右侧要初始化程序</span><br><span class=\"line\">console.log(a)//1</span><br><span class=\"line\">console.log(b)//2</span><br></pre></td></tr></table></figure>\n<h3 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = 1,b = 1,obj = &#123;a:2,b:2&#125;;//这里的;一定要加上，否则报错</span><br><span class=\"line\">(&#123;a,b&#125; = obj)//注意这里的括号要加上</span><br><span class=\"line\">console.log(a)//2</span><br><span class=\"line\">console.log(b)//2</span><br></pre></td></tr></table></figure>\n<h3 id=\"如果值为null或者undefined会导致程序抛出错误\"><a href=\"#如果值为null或者undefined会导致程序抛出错误\" class=\"headerlink\" title=\"如果值为null或者undefined会导致程序抛出错误\"></a>如果值为null或者undefined会导致程序抛出错误</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;a,b&#125; = null</span><br><span class=\"line\">//报错:VM222:1 Uncaught TypeError: Cannot destructure property `a` of &apos;undefined&apos; or &apos;null&apos;.</span><br></pre></td></tr></table></figure>\n<h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    a: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;a ,b = 1&#125; = obj</span><br><span class=\"line\">console.log(a)//2</span><br><span class=\"line\">console.log(b)//1</span><br></pre></td></tr></table></figure>\n<h3 id=\"非同名局部变量赋值\"><a href=\"#非同名局部变量赋值\" class=\"headerlink\" title=\"非同名局部变量赋值\"></a>非同名局部变量赋值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    type: &apos;1&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;type: localType&#125; = obj</span><br><span class=\"line\">console.log(localType)//&apos;1&apos;</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌套对象解构\"><a href=\"#嵌套对象解构\" class=\"headerlink\" title=\"嵌套对象解构\"></a>嵌套对象解构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    a: &#123;</span><br><span class=\"line\">        s: 4</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;a: &#123;s&#125;&#125; = obj//此时a不是绑定，只代表在对象中的检索属性位置</span><br><span class=\"line\">console.log(s)//4</span><br></pre></td></tr></table></figure>\n<h1 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,2]</span><br><span class=\"line\">let [a,b] = arr</span><br><span class=\"line\">console.log(a,b)//1  2</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组解构赋值\"><a href=\"#数组解构赋值\" class=\"headerlink\" title=\"数组解构赋值\"></a>数组解构赋值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr2 = [3,4];//这个;符号必须要加</span><br><span class=\"line\">[a,b] = arr2</span><br><span class=\"line\">console.log(a,b)//3  4</span><br></pre></td></tr></table></figure>\n<h3 id=\"特殊用法，交换变量位置\"><a href=\"#特殊用法，交换变量位置\" class=\"headerlink\" title=\"特殊用法，交换变量位置\"></a>特殊用法，交换变量位置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let m = 1,n=2;</span><br><span class=\"line\">[m,n] = [n,m]</span><br></pre></td></tr></table></figure>\n<h3 id=\"默认值-1\"><a href=\"#默认值-1\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1]</span><br><span class=\"line\">let [a,b=1] = arr</span><br><span class=\"line\">console.log(a,b)//1  1</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌套解构\"><a href=\"#嵌套解构\" class=\"headerlink\" title=\"嵌套解构\"></a>嵌套解构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,[1,2,3]]</span><br><span class=\"line\">let [h,[g]] = arr</span><br><span class=\"line\">console.log(h,g)//1  1</span><br></pre></td></tr></table></figure>\n<h3 id=\"不定元素（不定元素一定要放在最后）\"><a href=\"#不定元素（不定元素一定要放在最后）\" class=\"headerlink\" title=\"不定元素（不定元素一定要放在最后）\"></a>不定元素（不定元素一定要放在最后）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,2,3,4,5]</span><br><span class=\"line\">let [a,...b] = arr</span><br><span class=\"line\">console.log(b)//[2,3,4,5]</span><br></pre></td></tr></table></figure>\n<h3 id=\"不定元素可以解决数组克隆功能\"><a href=\"#不定元素可以解决数组克隆功能\" class=\"headerlink\" title=\"不定元素可以解决数组克隆功能\"></a>不定元素可以解决数组克隆功能</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,2,3]</span><br><span class=\"line\">let arr1 = arr.concat()//ES5做法</span><br><span class=\"line\">let [...arr2] = arr//不定元素</span><br></pre></td></tr></table></figure>\n<h1 id=\"混合解构\"><a href=\"#混合解构\" class=\"headerlink\" title=\"混合解构\"></a>混合解构</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    a: [1, 2, 3],</span><br><span class=\"line\">    b: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let &#123;</span><br><span class=\"line\">    a: [c],</span><br><span class=\"line\">        b</span><br><span class=\"line\">&#125; = obj</span><br><span class=\"line\">console.log(c,b)</span><br></pre></td></tr></table></figure>\n<h1 id=\"解构参数\"><a href=\"#解构参数\" class=\"headerlink\" title=\"解构参数\"></a>解构参数</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const defaultParams = &#123;</span><br><span class=\"line\">    a: 1,b:2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Fun(&#123;a,b&#125;=defaultParams) &#123;</span><br><span class=\"line\">    console.log(a)</span><br><span class=\"line\">    console.log(b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun(&#123;a:3,b:4&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>对象和数组是JS里面常用的两种数据结构，ES6中添加了简化任务的新特性：结构，是一种打破数据结构，拆分成更小部分的过程。</p>\n<h1 id=\"解构对象\"><a href=\"#解构对象\" class=\"headerlink\" title=\"解构对象\"></a>解构对象</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    a: 1,b: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;a,b&#125; = obj//注意右侧要初始化程序</span><br><span class=\"line\">console.log(a)//1</span><br><span class=\"line\">console.log(b)//2</span><br></pre></td></tr></table></figure>\n<h3 id=\"解构赋值\"><a href=\"#解构赋值\" class=\"headerlink\" title=\"解构赋值\"></a>解构赋值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let a = 1,b = 1,obj = &#123;a:2,b:2&#125;;//这里的;一定要加上，否则报错</span><br><span class=\"line\">(&#123;a,b&#125; = obj)//注意这里的括号要加上</span><br><span class=\"line\">console.log(a)//2</span><br><span class=\"line\">console.log(b)//2</span><br></pre></td></tr></table></figure>\n<h3 id=\"如果值为null或者undefined会导致程序抛出错误\"><a href=\"#如果值为null或者undefined会导致程序抛出错误\" class=\"headerlink\" title=\"如果值为null或者undefined会导致程序抛出错误\"></a>如果值为null或者undefined会导致程序抛出错误</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let &#123;a,b&#125; = null</span><br><span class=\"line\">//报错:VM222:1 Uncaught TypeError: Cannot destructure property `a` of &apos;undefined&apos; or &apos;null&apos;.</span><br></pre></td></tr></table></figure>\n<h3 id=\"默认值\"><a href=\"#默认值\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    a: 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;a ,b = 1&#125; = obj</span><br><span class=\"line\">console.log(a)//2</span><br><span class=\"line\">console.log(b)//1</span><br></pre></td></tr></table></figure>\n<h3 id=\"非同名局部变量赋值\"><a href=\"#非同名局部变量赋值\" class=\"headerlink\" title=\"非同名局部变量赋值\"></a>非同名局部变量赋值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    type: &apos;1&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;type: localType&#125; = obj</span><br><span class=\"line\">console.log(localType)//&apos;1&apos;</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌套对象解构\"><a href=\"#嵌套对象解构\" class=\"headerlink\" title=\"嵌套对象解构\"></a>嵌套对象解构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    a: &#123;</span><br><span class=\"line\">        s: 4</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let &#123;a: &#123;s&#125;&#125; = obj//此时a不是绑定，只代表在对象中的检索属性位置</span><br><span class=\"line\">console.log(s)//4</span><br></pre></td></tr></table></figure>\n<h1 id=\"数组解构\"><a href=\"#数组解构\" class=\"headerlink\" title=\"数组解构\"></a>数组解构</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,2]</span><br><span class=\"line\">let [a,b] = arr</span><br><span class=\"line\">console.log(a,b)//1  2</span><br></pre></td></tr></table></figure>\n<h3 id=\"数组解构赋值\"><a href=\"#数组解构赋值\" class=\"headerlink\" title=\"数组解构赋值\"></a>数组解构赋值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr2 = [3,4];//这个;符号必须要加</span><br><span class=\"line\">[a,b] = arr2</span><br><span class=\"line\">console.log(a,b)//3  4</span><br></pre></td></tr></table></figure>\n<h3 id=\"特殊用法，交换变量位置\"><a href=\"#特殊用法，交换变量位置\" class=\"headerlink\" title=\"特殊用法，交换变量位置\"></a>特殊用法，交换变量位置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let m = 1,n=2;</span><br><span class=\"line\">[m,n] = [n,m]</span><br></pre></td></tr></table></figure>\n<h3 id=\"默认值-1\"><a href=\"#默认值-1\" class=\"headerlink\" title=\"默认值\"></a>默认值</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1]</span><br><span class=\"line\">let [a,b=1] = arr</span><br><span class=\"line\">console.log(a,b)//1  1</span><br></pre></td></tr></table></figure>\n<h3 id=\"嵌套解构\"><a href=\"#嵌套解构\" class=\"headerlink\" title=\"嵌套解构\"></a>嵌套解构</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,[1,2,3]]</span><br><span class=\"line\">let [h,[g]] = arr</span><br><span class=\"line\">console.log(h,g)//1  1</span><br></pre></td></tr></table></figure>\n<h3 id=\"不定元素（不定元素一定要放在最后）\"><a href=\"#不定元素（不定元素一定要放在最后）\" class=\"headerlink\" title=\"不定元素（不定元素一定要放在最后）\"></a>不定元素（不定元素一定要放在最后）</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,2,3,4,5]</span><br><span class=\"line\">let [a,...b] = arr</span><br><span class=\"line\">console.log(b)//[2,3,4,5]</span><br></pre></td></tr></table></figure>\n<h3 id=\"不定元素可以解决数组克隆功能\"><a href=\"#不定元素可以解决数组克隆功能\" class=\"headerlink\" title=\"不定元素可以解决数组克隆功能\"></a>不定元素可以解决数组克隆功能</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,2,3]</span><br><span class=\"line\">let arr1 = arr.concat()//ES5做法</span><br><span class=\"line\">let [...arr2] = arr//不定元素</span><br></pre></td></tr></table></figure>\n<h1 id=\"混合解构\"><a href=\"#混合解构\" class=\"headerlink\" title=\"混合解构\"></a>混合解构</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    a: [1, 2, 3],</span><br><span class=\"line\">    b: 2</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\">let &#123;</span><br><span class=\"line\">    a: [c],</span><br><span class=\"line\">        b</span><br><span class=\"line\">&#125; = obj</span><br><span class=\"line\">console.log(c,b)</span><br></pre></td></tr></table></figure>\n<h1 id=\"解构参数\"><a href=\"#解构参数\" class=\"headerlink\" title=\"解构参数\"></a>解构参数</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const defaultParams = &#123;</span><br><span class=\"line\">    a: 1,b:2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function Fun(&#123;a,b&#125;=defaultParams) &#123;</span><br><span class=\"line\">    console.log(a)</span><br><span class=\"line\">    console.log(b)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Fun(&#123;a:3,b:4&#125;)</span><br></pre></td></tr></table></figure>\n"},{"title":"ES6-迭代器iterator&生成器generator","date":"2018-08-22T00:29:09.000Z","_content":"\n### 简介\n* 通过程序化的方式使用迭代器对象返回集合中的元素，可以极大地简化数据操作，例如：for...of循环、展开运算符（...）、异步编程。\n\n* 循环存在的问题(如果多个循环要追踪多个变量，代码复杂度大大增加)\n\n```\nlet arr = [1,2,3]\nfor(let i = 0;i<arr.length;i++){\n    console.log(arr[i])\n}\n```\n\n### 迭代器（iterator）\n* 是一个特殊的对象，为专门的迭代程序设计了接口，都有一个next()方法\n* 每次调用next()返回一个对象有两个属性value和done,{value:'',done:''}\n* 每一次调用next()都会返回下一次的值，如果没有值的话，返回{value:undefined,done:true}\n\n```\nfunction createIterator(items) {\n    var i = 0\n    return {\n        next: function () {\n            var done = (i>=items.length)\n            var value = !done ? items[i++] : undefined\n            return {\n                done: done,\n                value: value\n            }\n        }\n    }\n}\nvar iterator = createIterator([1,2])\nconsole.log(iterator.next())//{done:false,value:1}\nconsole.log(iterator.next())\nconsole.log(iterator.next())//{done:true,value:undefined}\n```\n\n### 生成器（generator）\n* 生成器是一种返回迭代器的函数，通过function关键字后的*号来表示，函数中会用到新的关键字yield\n* *号可以紧挨function也可以有个空格\n* 生成器中当每执行一条yield之后会自动停止执行，继续调用next()才会继续执行\n* 注意：yield只可以在生成器函数内部调用，在其他地方调用会出现语法错误，即使是在生成器内部函数里面调用\n\n```\nfunction *Fun() {\n    yield 1\n    yield 2\n}\nlet iterator1 = Fun()\nconsole.log(iterator1.next())\nconsole.log(iterator1.next())\nconsole.log(iterator1.next())\n\n//生成器函数表达式\nlet Fun1 = function *() {\n    yield 1\n    yield 2\n}\n```\n\n#### 生成器对象方法\n生成器对象方法（生成器本身是函数，可以添加到对象中）\n\n```\nlet obj = {\n    createIterator: function *() {\n        yield 1\n    },\n    *Fun(){//ES6函数写法创建\n\n    }\n}\n```\n\n#### 可迭代对象与for...of循环\n* 可迭代对象与for...of循环\n* 可迭代对象具有Symbol.iterator属性，通过指定的函数可以返回一个作用于附属对象的迭代器\n* ES6中所有对象合集（数组、Set、Map、字符串）都是可迭代对象，都有默认的可迭代器\n* for...of循环就是用到可迭代对象的这些功能，每执行一次都会调用可迭代对象的next()方法\n* 通过调用Symbol.iterator方法来获得迭代器\n\n\n```\n//默认的迭代器，通过Symbol.iterator来访问对象默认的迭代器\nlet arr1 = [1,2]\nlet iterator2 = arr1[Symbol.iterator]()\nconsole.log(iterator2.next())\nconsole.log(iterator2.next())\nconsole.log(iterator2.next())\n\n//可以使用Symbol.iterator检测是否为可迭代对象\nfunction checkItertor(obj){\n    return typeof obj[Symbol.iterator] === 'function'\n}\nconsole.log(checkItertor([1,2]))//true\nconsole.log(checkItertor(1))//false\n```\n\n#### 创建可迭代对象\n* 创建可迭代对象，开发者定义的对象都是不可迭代的，如果给对象Symbol.iterator属性添加一个生成器可变为可迭代对象\n* 先创建一个生成器，并赋值给Symbol.iterator属性来创建默认的迭代器\n\n```\nlet collection = {\n    items: [],\n    *[Symbol.iterator](){\n        for(let item of this.items){\n            yield item\n        }\n    }\n}\ncollection.items.push(1)\ncollection.items.push(2)\nfor(let item of collection){\n    console.log(item)\n}\n```\n\n### 内建迭代器\n * entries(),多个键值对\n * values(),集合的值\n * keys(),所有的键名(数组打印出来的都是数字类型的索引)\n * 默认的迭代器\n * 数组、Set是values\n * Map是entries()\n * 注意：WeakMap与WeakSet没有内建迭代器，因为要管理弱引用无法确定存在的值\n\n```\nlet map = new Map([['a',1],['b',2]])\nfor(let [k,value] of map.entries()){//解构运用\n    console.log(k)\n    console.log(value)\n}\n```\n\n#### 字符串迭代器\n字符串迭代器（可以正确使用双字节字符）\n\n```\nlet msg = '123'\nfor(let s of msg){\n    console.log(s)\n}\n```\n\n\n#### NodeList迭代器\n\n```\nlet divs = document.getElementsByTagName('div')\nfor(let d of divs){\n    console.log(d)\n}\n```\n\n\n#### Set转换数组\n- 展开运算符与非数组可迭代对象(将可迭代对象转换为数组)\n```\nlet set1 = new\nSet([1,2,2,3])\nconsole.log([...set1])//[1,2,3]\n```\n\n\n### 高级迭代器功能\n\n#### 给迭代器传递参数\n* 如果给迭代器的next()方法传递参数，这个参数会替代生成器内部上一条yield语句的返回值\n* 注意：第一次调用next()时无论传什么参数都会被丢弃\n\n```\nfunction *createIterator2() {\n    let first = yield 1\n    let secoud = yield first + 1\n    yield secoud + 1\n}\nlet iterator4 = createIterator2()\nconsole.log(iterator4.next())\nconsole.log(iterator4.next(1))\nconsole.log(iterator4.next(2))\nconsole.log(iterator4.next())\n```\n\n#### 在迭代器中抛出错误\n* 通过throw()方法，当迭代器执行时可以抛出错误\n* next()和throw()像是迭代器两条指令，调用都会继续执行，但是调用throw()会抛出错误\n* 在错误之后的执行取决于内部的代码\n```\nfunction *errIterator() {\n    yield 1\n    yield 2\n    yield 3\n}\nlet iterator5 = errIterator()\nconsole.log(iterator5.next())\n// console.log(iterator5.throw(new Error('error')))\nconsole.log(iterator5.next())//不会在执行\n\n//可以在内部通过try-catch捕获错误\nfunction *errIterator1() {\n    let first = yield 1\n    let secound\n    try {//由于生成器捕获了这些错误因此会继续执行下一条语句\n        secound = yield first + 1\n    }catch (e) {\n        secound = 2\n    }\n    yield secound + 1\n}\nlet iterator6 = errIterator1()\nconsole.log(iterator6.next())\nconsole.log(iterator6.next(1))\nconsole.log(iterator6.throw(new Error('error')))\nconsole.log(iterator6.next(1))\n```\n#### 生成器的return返回语句\n* 可以通过return提前退出执行，如果return了值，则为{done:true,value:对应值}\n* 注意：展开运算符和for...of循环会直接忽略通过return返回的任何值，只要done变为true就会停止\n\n```\nfunction *returnIterator() {\n    return 1\n}\nlet iterator7 = returnIterator()\nconsole.log(iterator7.next())//{value:1,done:true}\n```\n\n\n#### 委托生成器（合并迭代器）\n\n```\nfunction *c1() {\n    yield 1\n    return 2\n}\nfunction *c2() {\n    yield 3\n    return 4\n}\nfunction *c3() {\n    let result = yield *c1()\n    yield result//如果想返回这个return值需要这个么做\n    yield *c2()\n    yield *'aaa'//会使用字符串的默认迭代器\n}\nlet iteratorC = c3()\n```\n\n\n#### 异步任务执行器\n\n```\nfunction run(taskDef) {\n\n    //创建一个无限使用的迭代器\n    let task = taskDef()\n\n    //开始执行任务\n    let result = task.next()\n\n    //循环调用使用next()函数\n    function step() {\n        if(!result.done){\n            //判断如果是函数则执行函数\n            if(typeof result.value === 'function'){\n                //执行异步函数，传入回调，再回调中继续执行next(),处理数据\n                result.value(function (err,data) {\n                    if(err){\n                        task.throw(err)\n                        return\n                    }\n                    result = task.next(data)\n                    step()\n                })\n            }else {\n                result = task.next(result.value)\n                step()\n            }\n        }\n    }\n    step()\n}\n\nfunction outFun() {\n    return function (callback) {\n        setTimeout(()=>{\n            console.log('111')\n            callback(null,'123')\n        },1000)\n    }\n}\n\nrun(function *() {\n    let res = yield outFun()\n    console.log('2222')\n})\n```\n","source":"_posts/ES6-迭代器iterator&生成器generator.md","raw":"---\ntitle: ES6-迭代器iterator&生成器generator\ndate: 2018-08-22 08:29:09\ntags: [ES6,js]\ncategories: ES6\n---\n\n### 简介\n* 通过程序化的方式使用迭代器对象返回集合中的元素，可以极大地简化数据操作，例如：for...of循环、展开运算符（...）、异步编程。\n\n* 循环存在的问题(如果多个循环要追踪多个变量，代码复杂度大大增加)\n\n```\nlet arr = [1,2,3]\nfor(let i = 0;i<arr.length;i++){\n    console.log(arr[i])\n}\n```\n\n### 迭代器（iterator）\n* 是一个特殊的对象，为专门的迭代程序设计了接口，都有一个next()方法\n* 每次调用next()返回一个对象有两个属性value和done,{value:'',done:''}\n* 每一次调用next()都会返回下一次的值，如果没有值的话，返回{value:undefined,done:true}\n\n```\nfunction createIterator(items) {\n    var i = 0\n    return {\n        next: function () {\n            var done = (i>=items.length)\n            var value = !done ? items[i++] : undefined\n            return {\n                done: done,\n                value: value\n            }\n        }\n    }\n}\nvar iterator = createIterator([1,2])\nconsole.log(iterator.next())//{done:false,value:1}\nconsole.log(iterator.next())\nconsole.log(iterator.next())//{done:true,value:undefined}\n```\n\n### 生成器（generator）\n* 生成器是一种返回迭代器的函数，通过function关键字后的*号来表示，函数中会用到新的关键字yield\n* *号可以紧挨function也可以有个空格\n* 生成器中当每执行一条yield之后会自动停止执行，继续调用next()才会继续执行\n* 注意：yield只可以在生成器函数内部调用，在其他地方调用会出现语法错误，即使是在生成器内部函数里面调用\n\n```\nfunction *Fun() {\n    yield 1\n    yield 2\n}\nlet iterator1 = Fun()\nconsole.log(iterator1.next())\nconsole.log(iterator1.next())\nconsole.log(iterator1.next())\n\n//生成器函数表达式\nlet Fun1 = function *() {\n    yield 1\n    yield 2\n}\n```\n\n#### 生成器对象方法\n生成器对象方法（生成器本身是函数，可以添加到对象中）\n\n```\nlet obj = {\n    createIterator: function *() {\n        yield 1\n    },\n    *Fun(){//ES6函数写法创建\n\n    }\n}\n```\n\n#### 可迭代对象与for...of循环\n* 可迭代对象与for...of循环\n* 可迭代对象具有Symbol.iterator属性，通过指定的函数可以返回一个作用于附属对象的迭代器\n* ES6中所有对象合集（数组、Set、Map、字符串）都是可迭代对象，都有默认的可迭代器\n* for...of循环就是用到可迭代对象的这些功能，每执行一次都会调用可迭代对象的next()方法\n* 通过调用Symbol.iterator方法来获得迭代器\n\n\n```\n//默认的迭代器，通过Symbol.iterator来访问对象默认的迭代器\nlet arr1 = [1,2]\nlet iterator2 = arr1[Symbol.iterator]()\nconsole.log(iterator2.next())\nconsole.log(iterator2.next())\nconsole.log(iterator2.next())\n\n//可以使用Symbol.iterator检测是否为可迭代对象\nfunction checkItertor(obj){\n    return typeof obj[Symbol.iterator] === 'function'\n}\nconsole.log(checkItertor([1,2]))//true\nconsole.log(checkItertor(1))//false\n```\n\n#### 创建可迭代对象\n* 创建可迭代对象，开发者定义的对象都是不可迭代的，如果给对象Symbol.iterator属性添加一个生成器可变为可迭代对象\n* 先创建一个生成器，并赋值给Symbol.iterator属性来创建默认的迭代器\n\n```\nlet collection = {\n    items: [],\n    *[Symbol.iterator](){\n        for(let item of this.items){\n            yield item\n        }\n    }\n}\ncollection.items.push(1)\ncollection.items.push(2)\nfor(let item of collection){\n    console.log(item)\n}\n```\n\n### 内建迭代器\n * entries(),多个键值对\n * values(),集合的值\n * keys(),所有的键名(数组打印出来的都是数字类型的索引)\n * 默认的迭代器\n * 数组、Set是values\n * Map是entries()\n * 注意：WeakMap与WeakSet没有内建迭代器，因为要管理弱引用无法确定存在的值\n\n```\nlet map = new Map([['a',1],['b',2]])\nfor(let [k,value] of map.entries()){//解构运用\n    console.log(k)\n    console.log(value)\n}\n```\n\n#### 字符串迭代器\n字符串迭代器（可以正确使用双字节字符）\n\n```\nlet msg = '123'\nfor(let s of msg){\n    console.log(s)\n}\n```\n\n\n#### NodeList迭代器\n\n```\nlet divs = document.getElementsByTagName('div')\nfor(let d of divs){\n    console.log(d)\n}\n```\n\n\n#### Set转换数组\n- 展开运算符与非数组可迭代对象(将可迭代对象转换为数组)\n```\nlet set1 = new\nSet([1,2,2,3])\nconsole.log([...set1])//[1,2,3]\n```\n\n\n### 高级迭代器功能\n\n#### 给迭代器传递参数\n* 如果给迭代器的next()方法传递参数，这个参数会替代生成器内部上一条yield语句的返回值\n* 注意：第一次调用next()时无论传什么参数都会被丢弃\n\n```\nfunction *createIterator2() {\n    let first = yield 1\n    let secoud = yield first + 1\n    yield secoud + 1\n}\nlet iterator4 = createIterator2()\nconsole.log(iterator4.next())\nconsole.log(iterator4.next(1))\nconsole.log(iterator4.next(2))\nconsole.log(iterator4.next())\n```\n\n#### 在迭代器中抛出错误\n* 通过throw()方法，当迭代器执行时可以抛出错误\n* next()和throw()像是迭代器两条指令，调用都会继续执行，但是调用throw()会抛出错误\n* 在错误之后的执行取决于内部的代码\n```\nfunction *errIterator() {\n    yield 1\n    yield 2\n    yield 3\n}\nlet iterator5 = errIterator()\nconsole.log(iterator5.next())\n// console.log(iterator5.throw(new Error('error')))\nconsole.log(iterator5.next())//不会在执行\n\n//可以在内部通过try-catch捕获错误\nfunction *errIterator1() {\n    let first = yield 1\n    let secound\n    try {//由于生成器捕获了这些错误因此会继续执行下一条语句\n        secound = yield first + 1\n    }catch (e) {\n        secound = 2\n    }\n    yield secound + 1\n}\nlet iterator6 = errIterator1()\nconsole.log(iterator6.next())\nconsole.log(iterator6.next(1))\nconsole.log(iterator6.throw(new Error('error')))\nconsole.log(iterator6.next(1))\n```\n#### 生成器的return返回语句\n* 可以通过return提前退出执行，如果return了值，则为{done:true,value:对应值}\n* 注意：展开运算符和for...of循环会直接忽略通过return返回的任何值，只要done变为true就会停止\n\n```\nfunction *returnIterator() {\n    return 1\n}\nlet iterator7 = returnIterator()\nconsole.log(iterator7.next())//{value:1,done:true}\n```\n\n\n#### 委托生成器（合并迭代器）\n\n```\nfunction *c1() {\n    yield 1\n    return 2\n}\nfunction *c2() {\n    yield 3\n    return 4\n}\nfunction *c3() {\n    let result = yield *c1()\n    yield result//如果想返回这个return值需要这个么做\n    yield *c2()\n    yield *'aaa'//会使用字符串的默认迭代器\n}\nlet iteratorC = c3()\n```\n\n\n#### 异步任务执行器\n\n```\nfunction run(taskDef) {\n\n    //创建一个无限使用的迭代器\n    let task = taskDef()\n\n    //开始执行任务\n    let result = task.next()\n\n    //循环调用使用next()函数\n    function step() {\n        if(!result.done){\n            //判断如果是函数则执行函数\n            if(typeof result.value === 'function'){\n                //执行异步函数，传入回调，再回调中继续执行next(),处理数据\n                result.value(function (err,data) {\n                    if(err){\n                        task.throw(err)\n                        return\n                    }\n                    result = task.next(data)\n                    step()\n                })\n            }else {\n                result = task.next(result.value)\n                step()\n            }\n        }\n    }\n    step()\n}\n\nfunction outFun() {\n    return function (callback) {\n        setTimeout(()=>{\n            console.log('111')\n            callback(null,'123')\n        },1000)\n    }\n}\n\nrun(function *() {\n    let res = yield outFun()\n    console.log('2222')\n})\n```\n","slug":"ES6-迭代器iterator&生成器generator","published":1,"updated":"2019-02-13T07:57:54.489Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob6g000ve0jcj0myw39o","content":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li><p>通过程序化的方式使用迭代器对象返回集合中的元素，可以极大地简化数据操作，例如：for…of循环、展开运算符（…）、异步编程。</p>\n</li>\n<li><p>循环存在的问题(如果多个循环要追踪多个变量，代码复杂度大大增加)</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,2,3]</span><br><span class=\"line\">for(let i = 0;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">    console.log(arr[i])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"迭代器（iterator）\"><a href=\"#迭代器（iterator）\" class=\"headerlink\" title=\"迭代器（iterator）\"></a>迭代器（iterator）</h3><ul>\n<li>是一个特殊的对象，为专门的迭代程序设计了接口，都有一个next()方法</li>\n<li>每次调用next()返回一个对象有两个属性value和done,{value:’’,done:’’}</li>\n<li>每一次调用next()都会返回下一次的值，如果没有值的话，返回{value:undefined,done:true}</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createIterator(items) &#123;</span><br><span class=\"line\">    var i = 0</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        next: function () &#123;</span><br><span class=\"line\">            var done = (i&gt;=items.length)</span><br><span class=\"line\">            var value = !done ? items[i++] : undefined</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                done: done,</span><br><span class=\"line\">                value: value</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var iterator = createIterator([1,2])</span><br><span class=\"line\">console.log(iterator.next())//&#123;done:false,value:1&#125;</span><br><span class=\"line\">console.log(iterator.next())</span><br><span class=\"line\">console.log(iterator.next())//&#123;done:true,value:undefined&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成器（generator）\"><a href=\"#生成器（generator）\" class=\"headerlink\" title=\"生成器（generator）\"></a>生成器（generator）</h3><ul>\n<li>生成器是一种返回迭代器的函数，通过function关键字后的*号来表示，函数中会用到新的关键字yield</li>\n<li>*号可以紧挨function也可以有个空格</li>\n<li>生成器中当每执行一条yield之后会自动停止执行，继续调用next()才会继续执行</li>\n<li>注意：yield只可以在生成器函数内部调用，在其他地方调用会出现语法错误，即使是在生成器内部函数里面调用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *Fun() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    yield 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator1 = Fun()</span><br><span class=\"line\">console.log(iterator1.next())</span><br><span class=\"line\">console.log(iterator1.next())</span><br><span class=\"line\">console.log(iterator1.next())</span><br><span class=\"line\"></span><br><span class=\"line\">//生成器函数表达式</span><br><span class=\"line\">let Fun1 = function *() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    yield 2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"生成器对象方法\"><a href=\"#生成器对象方法\" class=\"headerlink\" title=\"生成器对象方法\"></a>生成器对象方法</h4><p>生成器对象方法（生成器本身是函数，可以添加到对象中）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    createIterator: function *() &#123;</span><br><span class=\"line\">        yield 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    *Fun()&#123;//ES6函数写法创建</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"可迭代对象与for…of循环\"><a href=\"#可迭代对象与for…of循环\" class=\"headerlink\" title=\"可迭代对象与for…of循环\"></a>可迭代对象与for…of循环</h4><ul>\n<li>可迭代对象与for…of循环</li>\n<li>可迭代对象具有Symbol.iterator属性，通过指定的函数可以返回一个作用于附属对象的迭代器</li>\n<li>ES6中所有对象合集（数组、Set、Map、字符串）都是可迭代对象，都有默认的可迭代器</li>\n<li>for…of循环就是用到可迭代对象的这些功能，每执行一次都会调用可迭代对象的next()方法</li>\n<li>通过调用Symbol.iterator方法来获得迭代器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//默认的迭代器，通过Symbol.iterator来访问对象默认的迭代器</span><br><span class=\"line\">let arr1 = [1,2]</span><br><span class=\"line\">let iterator2 = arr1[Symbol.iterator]()</span><br><span class=\"line\">console.log(iterator2.next())</span><br><span class=\"line\">console.log(iterator2.next())</span><br><span class=\"line\">console.log(iterator2.next())</span><br><span class=\"line\"></span><br><span class=\"line\">//可以使用Symbol.iterator检测是否为可迭代对象</span><br><span class=\"line\">function checkItertor(obj)&#123;</span><br><span class=\"line\">    return typeof obj[Symbol.iterator] === &apos;function&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(checkItertor([1,2]))//true</span><br><span class=\"line\">console.log(checkItertor(1))//false</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建可迭代对象\"><a href=\"#创建可迭代对象\" class=\"headerlink\" title=\"创建可迭代对象\"></a>创建可迭代对象</h4><ul>\n<li>创建可迭代对象，开发者定义的对象都是不可迭代的，如果给对象Symbol.iterator属性添加一个生成器可变为可迭代对象</li>\n<li>先创建一个生成器，并赋值给Symbol.iterator属性来创建默认的迭代器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let collection = &#123;</span><br><span class=\"line\">    items: [],</span><br><span class=\"line\">    *[Symbol.iterator]()&#123;</span><br><span class=\"line\">        for(let item of this.items)&#123;</span><br><span class=\"line\">            yield item</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">collection.items.push(1)</span><br><span class=\"line\">collection.items.push(2)</span><br><span class=\"line\">for(let item of collection)&#123;</span><br><span class=\"line\">    console.log(item)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内建迭代器\"><a href=\"#内建迭代器\" class=\"headerlink\" title=\"内建迭代器\"></a>内建迭代器</h3><ul>\n<li>entries(),多个键值对</li>\n<li>values(),集合的值</li>\n<li>keys(),所有的键名(数组打印出来的都是数字类型的索引)</li>\n<li>默认的迭代器</li>\n<li>数组、Set是values</li>\n<li>Map是entries()</li>\n<li>注意：WeakMap与WeakSet没有内建迭代器，因为要管理弱引用无法确定存在的值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map([[&apos;a&apos;,1],[&apos;b&apos;,2]])</span><br><span class=\"line\">for(let [k,value] of map.entries())&#123;//解构运用</span><br><span class=\"line\">    console.log(k)</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串迭代器\"><a href=\"#字符串迭代器\" class=\"headerlink\" title=\"字符串迭代器\"></a>字符串迭代器</h4><p>字符串迭代器（可以正确使用双字节字符）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let msg = &apos;123&apos;</span><br><span class=\"line\">for(let s of msg)&#123;</span><br><span class=\"line\">    console.log(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"NodeList迭代器\"><a href=\"#NodeList迭代器\" class=\"headerlink\" title=\"NodeList迭代器\"></a>NodeList迭代器</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let divs = document.getElementsByTagName(&apos;div&apos;)</span><br><span class=\"line\">for(let d of divs)&#123;</span><br><span class=\"line\">    console.log(d)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Set转换数组\"><a href=\"#Set转换数组\" class=\"headerlink\" title=\"Set转换数组\"></a>Set转换数组</h4><ul>\n<li>展开运算符与非数组可迭代对象(将可迭代对象转换为数组)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set1 = new</span><br><span class=\"line\">Set([1,2,2,3])</span><br><span class=\"line\">console.log([...set1])//[1,2,3]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"高级迭代器功能\"><a href=\"#高级迭代器功能\" class=\"headerlink\" title=\"高级迭代器功能\"></a>高级迭代器功能</h3><h4 id=\"给迭代器传递参数\"><a href=\"#给迭代器传递参数\" class=\"headerlink\" title=\"给迭代器传递参数\"></a>给迭代器传递参数</h4><ul>\n<li>如果给迭代器的next()方法传递参数，这个参数会替代生成器内部上一条yield语句的返回值</li>\n<li>注意：第一次调用next()时无论传什么参数都会被丢弃</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *createIterator2() &#123;</span><br><span class=\"line\">    let first = yield 1</span><br><span class=\"line\">    let secoud = yield first + 1</span><br><span class=\"line\">    yield secoud + 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator4 = createIterator2()</span><br><span class=\"line\">console.log(iterator4.next())</span><br><span class=\"line\">console.log(iterator4.next(1))</span><br><span class=\"line\">console.log(iterator4.next(2))</span><br><span class=\"line\">console.log(iterator4.next())</span><br></pre></td></tr></table></figure>\n<h4 id=\"在迭代器中抛出错误\"><a href=\"#在迭代器中抛出错误\" class=\"headerlink\" title=\"在迭代器中抛出错误\"></a>在迭代器中抛出错误</h4><ul>\n<li>通过throw()方法，当迭代器执行时可以抛出错误</li>\n<li>next()和throw()像是迭代器两条指令，调用都会继续执行，但是调用throw()会抛出错误</li>\n<li>在错误之后的执行取决于内部的代码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *errIterator() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    yield 2</span><br><span class=\"line\">    yield 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator5 = errIterator()</span><br><span class=\"line\">console.log(iterator5.next())</span><br><span class=\"line\">// console.log(iterator5.throw(new Error(&apos;error&apos;)))</span><br><span class=\"line\">console.log(iterator5.next())//不会在执行</span><br><span class=\"line\"></span><br><span class=\"line\">//可以在内部通过try-catch捕获错误</span><br><span class=\"line\">function *errIterator1() &#123;</span><br><span class=\"line\">    let first = yield 1</span><br><span class=\"line\">    let secound</span><br><span class=\"line\">    try &#123;//由于生成器捕获了这些错误因此会继续执行下一条语句</span><br><span class=\"line\">        secound = yield first + 1</span><br><span class=\"line\">    &#125;catch (e) &#123;</span><br><span class=\"line\">        secound = 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    yield secound + 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator6 = errIterator1()</span><br><span class=\"line\">console.log(iterator6.next())</span><br><span class=\"line\">console.log(iterator6.next(1))</span><br><span class=\"line\">console.log(iterator6.throw(new Error(&apos;error&apos;)))</span><br><span class=\"line\">console.log(iterator6.next(1))</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"生成器的return返回语句\"><a href=\"#生成器的return返回语句\" class=\"headerlink\" title=\"生成器的return返回语句\"></a>生成器的return返回语句</h4><ul>\n<li>可以通过return提前退出执行，如果return了值，则为{done:true,value:对应值}</li>\n<li>注意：展开运算符和for…of循环会直接忽略通过return返回的任何值，只要done变为true就会停止</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *returnIterator() &#123;</span><br><span class=\"line\">    return 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator7 = returnIterator()</span><br><span class=\"line\">console.log(iterator7.next())//&#123;value:1,done:true&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"委托生成器（合并迭代器）\"><a href=\"#委托生成器（合并迭代器）\" class=\"headerlink\" title=\"委托生成器（合并迭代器）\"></a>委托生成器（合并迭代器）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *c1() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    return 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function *c2() &#123;</span><br><span class=\"line\">    yield 3</span><br><span class=\"line\">    return 4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function *c3() &#123;</span><br><span class=\"line\">    let result = yield *c1()</span><br><span class=\"line\">    yield result//如果想返回这个return值需要这个么做</span><br><span class=\"line\">    yield *c2()</span><br><span class=\"line\">    yield *&apos;aaa&apos;//会使用字符串的默认迭代器</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iteratorC = c3()</span><br></pre></td></tr></table></figure>\n<h4 id=\"异步任务执行器\"><a href=\"#异步任务执行器\" class=\"headerlink\" title=\"异步任务执行器\"></a>异步任务执行器</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function run(taskDef) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //创建一个无限使用的迭代器</span><br><span class=\"line\">    let task = taskDef()</span><br><span class=\"line\"></span><br><span class=\"line\">    //开始执行任务</span><br><span class=\"line\">    let result = task.next()</span><br><span class=\"line\"></span><br><span class=\"line\">    //循环调用使用next()函数</span><br><span class=\"line\">    function step() &#123;</span><br><span class=\"line\">        if(!result.done)&#123;</span><br><span class=\"line\">            //判断如果是函数则执行函数</span><br><span class=\"line\">            if(typeof result.value === &apos;function&apos;)&#123;</span><br><span class=\"line\">                //执行异步函数，传入回调，再回调中继续执行next(),处理数据</span><br><span class=\"line\">                result.value(function (err,data) &#123;</span><br><span class=\"line\">                    if(err)&#123;</span><br><span class=\"line\">                        task.throw(err)</span><br><span class=\"line\">                        return</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    result = task.next(data)</span><br><span class=\"line\">                    step()</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                result = task.next(result.value)</span><br><span class=\"line\">                step()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    step()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function outFun() &#123;</span><br><span class=\"line\">    return function (callback) &#123;</span><br><span class=\"line\">        setTimeout(()=&gt;&#123;</span><br><span class=\"line\">            console.log(&apos;111&apos;)</span><br><span class=\"line\">            callback(null,&apos;123&apos;)</span><br><span class=\"line\">        &#125;,1000)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">run(function *() &#123;</span><br><span class=\"line\">    let res = yield outFun()</span><br><span class=\"line\">    console.log(&apos;2222&apos;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h3><ul>\n<li><p>通过程序化的方式使用迭代器对象返回集合中的元素，可以极大地简化数据操作，例如：for…of循环、展开运算符（…）、异步编程。</p>\n</li>\n<li><p>循环存在的问题(如果多个循环要追踪多个变量，代码复杂度大大增加)</p>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let arr = [1,2,3]</span><br><span class=\"line\">for(let i = 0;i&lt;arr.length;i++)&#123;</span><br><span class=\"line\">    console.log(arr[i])</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"迭代器（iterator）\"><a href=\"#迭代器（iterator）\" class=\"headerlink\" title=\"迭代器（iterator）\"></a>迭代器（iterator）</h3><ul>\n<li>是一个特殊的对象，为专门的迭代程序设计了接口，都有一个next()方法</li>\n<li>每次调用next()返回一个对象有两个属性value和done,{value:’’,done:’’}</li>\n<li>每一次调用next()都会返回下一次的值，如果没有值的话，返回{value:undefined,done:true}</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function createIterator(items) &#123;</span><br><span class=\"line\">    var i = 0</span><br><span class=\"line\">    return &#123;</span><br><span class=\"line\">        next: function () &#123;</span><br><span class=\"line\">            var done = (i&gt;=items.length)</span><br><span class=\"line\">            var value = !done ? items[i++] : undefined</span><br><span class=\"line\">            return &#123;</span><br><span class=\"line\">                done: done,</span><br><span class=\"line\">                value: value</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var iterator = createIterator([1,2])</span><br><span class=\"line\">console.log(iterator.next())//&#123;done:false,value:1&#125;</span><br><span class=\"line\">console.log(iterator.next())</span><br><span class=\"line\">console.log(iterator.next())//&#123;done:true,value:undefined&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"生成器（generator）\"><a href=\"#生成器（generator）\" class=\"headerlink\" title=\"生成器（generator）\"></a>生成器（generator）</h3><ul>\n<li>生成器是一种返回迭代器的函数，通过function关键字后的*号来表示，函数中会用到新的关键字yield</li>\n<li>*号可以紧挨function也可以有个空格</li>\n<li>生成器中当每执行一条yield之后会自动停止执行，继续调用next()才会继续执行</li>\n<li>注意：yield只可以在生成器函数内部调用，在其他地方调用会出现语法错误，即使是在生成器内部函数里面调用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *Fun() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    yield 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator1 = Fun()</span><br><span class=\"line\">console.log(iterator1.next())</span><br><span class=\"line\">console.log(iterator1.next())</span><br><span class=\"line\">console.log(iterator1.next())</span><br><span class=\"line\"></span><br><span class=\"line\">//生成器函数表达式</span><br><span class=\"line\">let Fun1 = function *() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    yield 2</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"生成器对象方法\"><a href=\"#生成器对象方法\" class=\"headerlink\" title=\"生成器对象方法\"></a>生成器对象方法</h4><p>生成器对象方法（生成器本身是函数，可以添加到对象中）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let obj = &#123;</span><br><span class=\"line\">    createIterator: function *() &#123;</span><br><span class=\"line\">        yield 1</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    *Fun()&#123;//ES6函数写法创建</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"可迭代对象与for…of循环\"><a href=\"#可迭代对象与for…of循环\" class=\"headerlink\" title=\"可迭代对象与for…of循环\"></a>可迭代对象与for…of循环</h4><ul>\n<li>可迭代对象与for…of循环</li>\n<li>可迭代对象具有Symbol.iterator属性，通过指定的函数可以返回一个作用于附属对象的迭代器</li>\n<li>ES6中所有对象合集（数组、Set、Map、字符串）都是可迭代对象，都有默认的可迭代器</li>\n<li>for…of循环就是用到可迭代对象的这些功能，每执行一次都会调用可迭代对象的next()方法</li>\n<li>通过调用Symbol.iterator方法来获得迭代器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//默认的迭代器，通过Symbol.iterator来访问对象默认的迭代器</span><br><span class=\"line\">let arr1 = [1,2]</span><br><span class=\"line\">let iterator2 = arr1[Symbol.iterator]()</span><br><span class=\"line\">console.log(iterator2.next())</span><br><span class=\"line\">console.log(iterator2.next())</span><br><span class=\"line\">console.log(iterator2.next())</span><br><span class=\"line\"></span><br><span class=\"line\">//可以使用Symbol.iterator检测是否为可迭代对象</span><br><span class=\"line\">function checkItertor(obj)&#123;</span><br><span class=\"line\">    return typeof obj[Symbol.iterator] === &apos;function&apos;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">console.log(checkItertor([1,2]))//true</span><br><span class=\"line\">console.log(checkItertor(1))//false</span><br></pre></td></tr></table></figure>\n<h4 id=\"创建可迭代对象\"><a href=\"#创建可迭代对象\" class=\"headerlink\" title=\"创建可迭代对象\"></a>创建可迭代对象</h4><ul>\n<li>创建可迭代对象，开发者定义的对象都是不可迭代的，如果给对象Symbol.iterator属性添加一个生成器可变为可迭代对象</li>\n<li>先创建一个生成器，并赋值给Symbol.iterator属性来创建默认的迭代器</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let collection = &#123;</span><br><span class=\"line\">    items: [],</span><br><span class=\"line\">    *[Symbol.iterator]()&#123;</span><br><span class=\"line\">        for(let item of this.items)&#123;</span><br><span class=\"line\">            yield item</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">collection.items.push(1)</span><br><span class=\"line\">collection.items.push(2)</span><br><span class=\"line\">for(let item of collection)&#123;</span><br><span class=\"line\">    console.log(item)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内建迭代器\"><a href=\"#内建迭代器\" class=\"headerlink\" title=\"内建迭代器\"></a>内建迭代器</h3><ul>\n<li>entries(),多个键值对</li>\n<li>values(),集合的值</li>\n<li>keys(),所有的键名(数组打印出来的都是数字类型的索引)</li>\n<li>默认的迭代器</li>\n<li>数组、Set是values</li>\n<li>Map是entries()</li>\n<li>注意：WeakMap与WeakSet没有内建迭代器，因为要管理弱引用无法确定存在的值</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let map = new Map([[&apos;a&apos;,1],[&apos;b&apos;,2]])</span><br><span class=\"line\">for(let [k,value] of map.entries())&#123;//解构运用</span><br><span class=\"line\">    console.log(k)</span><br><span class=\"line\">    console.log(value)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"字符串迭代器\"><a href=\"#字符串迭代器\" class=\"headerlink\" title=\"字符串迭代器\"></a>字符串迭代器</h4><p>字符串迭代器（可以正确使用双字节字符）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let msg = &apos;123&apos;</span><br><span class=\"line\">for(let s of msg)&#123;</span><br><span class=\"line\">    console.log(s)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"NodeList迭代器\"><a href=\"#NodeList迭代器\" class=\"headerlink\" title=\"NodeList迭代器\"></a>NodeList迭代器</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let divs = document.getElementsByTagName(&apos;div&apos;)</span><br><span class=\"line\">for(let d of divs)&#123;</span><br><span class=\"line\">    console.log(d)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Set转换数组\"><a href=\"#Set转换数组\" class=\"headerlink\" title=\"Set转换数组\"></a>Set转换数组</h4><ul>\n<li>展开运算符与非数组可迭代对象(将可迭代对象转换为数组)<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let set1 = new</span><br><span class=\"line\">Set([1,2,2,3])</span><br><span class=\"line\">console.log([...set1])//[1,2,3]</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"高级迭代器功能\"><a href=\"#高级迭代器功能\" class=\"headerlink\" title=\"高级迭代器功能\"></a>高级迭代器功能</h3><h4 id=\"给迭代器传递参数\"><a href=\"#给迭代器传递参数\" class=\"headerlink\" title=\"给迭代器传递参数\"></a>给迭代器传递参数</h4><ul>\n<li>如果给迭代器的next()方法传递参数，这个参数会替代生成器内部上一条yield语句的返回值</li>\n<li>注意：第一次调用next()时无论传什么参数都会被丢弃</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *createIterator2() &#123;</span><br><span class=\"line\">    let first = yield 1</span><br><span class=\"line\">    let secoud = yield first + 1</span><br><span class=\"line\">    yield secoud + 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator4 = createIterator2()</span><br><span class=\"line\">console.log(iterator4.next())</span><br><span class=\"line\">console.log(iterator4.next(1))</span><br><span class=\"line\">console.log(iterator4.next(2))</span><br><span class=\"line\">console.log(iterator4.next())</span><br></pre></td></tr></table></figure>\n<h4 id=\"在迭代器中抛出错误\"><a href=\"#在迭代器中抛出错误\" class=\"headerlink\" title=\"在迭代器中抛出错误\"></a>在迭代器中抛出错误</h4><ul>\n<li>通过throw()方法，当迭代器执行时可以抛出错误</li>\n<li>next()和throw()像是迭代器两条指令，调用都会继续执行，但是调用throw()会抛出错误</li>\n<li>在错误之后的执行取决于内部的代码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *errIterator() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    yield 2</span><br><span class=\"line\">    yield 3</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator5 = errIterator()</span><br><span class=\"line\">console.log(iterator5.next())</span><br><span class=\"line\">// console.log(iterator5.throw(new Error(&apos;error&apos;)))</span><br><span class=\"line\">console.log(iterator5.next())//不会在执行</span><br><span class=\"line\"></span><br><span class=\"line\">//可以在内部通过try-catch捕获错误</span><br><span class=\"line\">function *errIterator1() &#123;</span><br><span class=\"line\">    let first = yield 1</span><br><span class=\"line\">    let secound</span><br><span class=\"line\">    try &#123;//由于生成器捕获了这些错误因此会继续执行下一条语句</span><br><span class=\"line\">        secound = yield first + 1</span><br><span class=\"line\">    &#125;catch (e) &#123;</span><br><span class=\"line\">        secound = 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    yield secound + 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator6 = errIterator1()</span><br><span class=\"line\">console.log(iterator6.next())</span><br><span class=\"line\">console.log(iterator6.next(1))</span><br><span class=\"line\">console.log(iterator6.throw(new Error(&apos;error&apos;)))</span><br><span class=\"line\">console.log(iterator6.next(1))</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"生成器的return返回语句\"><a href=\"#生成器的return返回语句\" class=\"headerlink\" title=\"生成器的return返回语句\"></a>生成器的return返回语句</h4><ul>\n<li>可以通过return提前退出执行，如果return了值，则为{done:true,value:对应值}</li>\n<li>注意：展开运算符和for…of循环会直接忽略通过return返回的任何值，只要done变为true就会停止</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *returnIterator() &#123;</span><br><span class=\"line\">    return 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iterator7 = returnIterator()</span><br><span class=\"line\">console.log(iterator7.next())//&#123;value:1,done:true&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"委托生成器（合并迭代器）\"><a href=\"#委托生成器（合并迭代器）\" class=\"headerlink\" title=\"委托生成器（合并迭代器）\"></a>委托生成器（合并迭代器）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function *c1() &#123;</span><br><span class=\"line\">    yield 1</span><br><span class=\"line\">    return 2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function *c2() &#123;</span><br><span class=\"line\">    yield 3</span><br><span class=\"line\">    return 4</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function *c3() &#123;</span><br><span class=\"line\">    let result = yield *c1()</span><br><span class=\"line\">    yield result//如果想返回这个return值需要这个么做</span><br><span class=\"line\">    yield *c2()</span><br><span class=\"line\">    yield *&apos;aaa&apos;//会使用字符串的默认迭代器</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let iteratorC = c3()</span><br></pre></td></tr></table></figure>\n<h4 id=\"异步任务执行器\"><a href=\"#异步任务执行器\" class=\"headerlink\" title=\"异步任务执行器\"></a>异步任务执行器</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function run(taskDef) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    //创建一个无限使用的迭代器</span><br><span class=\"line\">    let task = taskDef()</span><br><span class=\"line\"></span><br><span class=\"line\">    //开始执行任务</span><br><span class=\"line\">    let result = task.next()</span><br><span class=\"line\"></span><br><span class=\"line\">    //循环调用使用next()函数</span><br><span class=\"line\">    function step() &#123;</span><br><span class=\"line\">        if(!result.done)&#123;</span><br><span class=\"line\">            //判断如果是函数则执行函数</span><br><span class=\"line\">            if(typeof result.value === &apos;function&apos;)&#123;</span><br><span class=\"line\">                //执行异步函数，传入回调，再回调中继续执行next(),处理数据</span><br><span class=\"line\">                result.value(function (err,data) &#123;</span><br><span class=\"line\">                    if(err)&#123;</span><br><span class=\"line\">                        task.throw(err)</span><br><span class=\"line\">                        return</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                    result = task.next(data)</span><br><span class=\"line\">                    step()</span><br><span class=\"line\">                &#125;)</span><br><span class=\"line\">            &#125;else &#123;</span><br><span class=\"line\">                result = task.next(result.value)</span><br><span class=\"line\">                step()</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    step()</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">function outFun() &#123;</span><br><span class=\"line\">    return function (callback) &#123;</span><br><span class=\"line\">        setTimeout(()=&gt;&#123;</span><br><span class=\"line\">            console.log(&apos;111&apos;)</span><br><span class=\"line\">            callback(null,&apos;123&apos;)</span><br><span class=\"line\">        &#125;,1000)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">run(function *() &#123;</span><br><span class=\"line\">    let res = yield outFun()</span><br><span class=\"line\">    console.log(&apos;2222&apos;)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n"},{"title":"decimal处理数字问题","date":"2019-01-31T12:39:49.000Z","_content":"#### 简介\n数字货币交易所项目，需要处理大量小数、大数展示问题，使用decimal库处理js中的数字运算，包括大数展示为字符串、小数向上取整、小数向下取整、小数四舍五入、小数补零、加减乘除、取余运算。也可改为vue filter使用。\n#### 安装依赖\n```\nnpm install --save decimal.js-light\n```\n#### 基本配置\n```\nDecimal.set({\n    precision: 1e+9,//（计算结果）小数精度位数\n    rounding: Decimal.ROUND_HALF_UP,//小数舍去配置\n    minE: -9e15,//负指数极限（比较转换成指数后指数部分值<这个值转换为0）\n    maxE: 9e15,//正指数极限（比较转换成指数后指数部分值>这个值转换为Infinity）\n    toExpNeg: -9e15,//toString()负指数表示配置（比较转换成指数后指数部分值<=这个值用指数表示）\n    toExpPos: 9e15,//toString()正指数表示配置（比较转换成指数后指数部分值>=这个值用指数表示）\n});\n```\n#### 代码\n```\nimport Decimal from 'decimal.js-light'\n\nDecimal.set({\n    precision: 20,\n    rounding: Decimal.ROUND_HALF_UP,//默认使用四舍五入\n    toExpNeg: -9e15,\n    toExpPos: 9e15,\n});\n\nexport default {\n    //数字转换为字符串显示\n    format(num){\n        num = num ? num : 0\n        return new Decimal(num).toString()\n    },\n    //保留小数向上取整\n    formatUp(num,len){\n        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_UP).toString()\n    },\n    //保留小数向下取整\n    formatDown(num,len){\n        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_DOWN).toString()\n    },\n    //保留小数四舍五入\n    formatHalf(num,len){\n        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_HALF_UP).toString()\n    },\n    //小数舍去0\n    remove0(num){\n        num = num ? num : 0\n        return new Decimal(num).toString()\n    },\n    //小数补零\n    add0(num,len){\n        return new Decimal(num).toFixed(len,Decimal.ROUND_DOWN).toString()\n    },\n    //加\n    add(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.plus(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //减\n    minus(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.minus(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //乘\n    mult(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.times(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //除\n    div(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.dividedBy(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //取余\n    mod(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.modulo(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    }\n}\n```\n","source":"_posts/decimal处理数字问题.md","raw":"---\ntitle: decimal处理数字问题\ndate: 2019-01-31 20:39:49\ntags: [大数,js,小数]\ncategories: decimal\n---\n#### 简介\n数字货币交易所项目，需要处理大量小数、大数展示问题，使用decimal库处理js中的数字运算，包括大数展示为字符串、小数向上取整、小数向下取整、小数四舍五入、小数补零、加减乘除、取余运算。也可改为vue filter使用。\n#### 安装依赖\n```\nnpm install --save decimal.js-light\n```\n#### 基本配置\n```\nDecimal.set({\n    precision: 1e+9,//（计算结果）小数精度位数\n    rounding: Decimal.ROUND_HALF_UP,//小数舍去配置\n    minE: -9e15,//负指数极限（比较转换成指数后指数部分值<这个值转换为0）\n    maxE: 9e15,//正指数极限（比较转换成指数后指数部分值>这个值转换为Infinity）\n    toExpNeg: -9e15,//toString()负指数表示配置（比较转换成指数后指数部分值<=这个值用指数表示）\n    toExpPos: 9e15,//toString()正指数表示配置（比较转换成指数后指数部分值>=这个值用指数表示）\n});\n```\n#### 代码\n```\nimport Decimal from 'decimal.js-light'\n\nDecimal.set({\n    precision: 20,\n    rounding: Decimal.ROUND_HALF_UP,//默认使用四舍五入\n    toExpNeg: -9e15,\n    toExpPos: 9e15,\n});\n\nexport default {\n    //数字转换为字符串显示\n    format(num){\n        num = num ? num : 0\n        return new Decimal(num).toString()\n    },\n    //保留小数向上取整\n    formatUp(num,len){\n        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_UP).toString()\n    },\n    //保留小数向下取整\n    formatDown(num,len){\n        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_DOWN).toString()\n    },\n    //保留小数四舍五入\n    formatHalf(num,len){\n        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_HALF_UP).toString()\n    },\n    //小数舍去0\n    remove0(num){\n        num = num ? num : 0\n        return new Decimal(num).toString()\n    },\n    //小数补零\n    add0(num,len){\n        return new Decimal(num).toFixed(len,Decimal.ROUND_DOWN).toString()\n    },\n    //加\n    add(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.plus(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //减\n    minus(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.minus(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //乘\n    mult(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.times(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //除\n    div(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.dividedBy(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    },\n    //取余\n    mod(num1, num2, len) {\n        let a = new Decimal(num1)\n        let b = new Decimal(num2)\n        let c = a.modulo(b)\n        if(len > 0){\n            return c.toDecimalPlaces(len).toString()\n        }else{\n            return c.toString()\n        }\n    }\n}\n```\n","slug":"decimal处理数字问题","published":1,"updated":"2019-01-31T12:40:40.523Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob6h000ye0jcecm6hop3","content":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>数字货币交易所项目，需要处理大量小数、大数展示问题，使用decimal库处理js中的数字运算，包括大数展示为字符串、小数向上取整、小数向下取整、小数四舍五入、小数补零、加减乘除、取余运算。也可改为vue filter使用。</p>\n<h4 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save decimal.js-light</span><br></pre></td></tr></table></figure>\n<h4 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Decimal.set(&#123;</span><br><span class=\"line\">    precision: 1e+9,//（计算结果）小数精度位数</span><br><span class=\"line\">    rounding: Decimal.ROUND_HALF_UP,//小数舍去配置</span><br><span class=\"line\">    minE: -9e15,//负指数极限（比较转换成指数后指数部分值&lt;这个值转换为0）</span><br><span class=\"line\">    maxE: 9e15,//正指数极限（比较转换成指数后指数部分值&gt;这个值转换为Infinity）</span><br><span class=\"line\">    toExpNeg: -9e15,//toString()负指数表示配置（比较转换成指数后指数部分值&lt;=这个值用指数表示）</span><br><span class=\"line\">    toExpPos: 9e15,//toString()正指数表示配置（比较转换成指数后指数部分值&gt;=这个值用指数表示）</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Decimal from &apos;decimal.js-light&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Decimal.set(&#123;</span><br><span class=\"line\">    precision: 20,</span><br><span class=\"line\">    rounding: Decimal.ROUND_HALF_UP,//默认使用四舍五入</span><br><span class=\"line\">    toExpNeg: -9e15,</span><br><span class=\"line\">    toExpPos: 9e15,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    //数字转换为字符串显示</span><br><span class=\"line\">    format(num)&#123;</span><br><span class=\"line\">        num = num ? num : 0</span><br><span class=\"line\">        return new Decimal(num).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //保留小数向上取整</span><br><span class=\"line\">    formatUp(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_UP).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //保留小数向下取整</span><br><span class=\"line\">    formatDown(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_DOWN).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //保留小数四舍五入</span><br><span class=\"line\">    formatHalf(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_HALF_UP).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //小数舍去0</span><br><span class=\"line\">    remove0(num)&#123;</span><br><span class=\"line\">        num = num ? num : 0</span><br><span class=\"line\">        return new Decimal(num).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //小数补零</span><br><span class=\"line\">    add0(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toFixed(len,Decimal.ROUND_DOWN).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //加</span><br><span class=\"line\">    add(num1, num2, len) &#123;</span><br><span class=\"line\">        let a = new Decimal(num1)</span><br><span class=\"line\">        let b = new Decimal(num2)</span><br><span class=\"line\">        let c = a.plus(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //减</span><br><span class=\"line\">    minus(num1, num2, len) &#123;</span><br><span class=\"line\">        let a = new Decimal(num1)</span><br><span class=\"line\">        let b = new Decimal(num2)</span><br><span class=\"line\">        let c = a.minus(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //乘</span><br><span class=\"line\">    mult(num1, num2, len) &#123;</span><br><span class=\"line\">        let a = new Decimal(num1)</span><br><span class=\"line\">        let b = new Decimal(num2)</span><br><span class=\"line\">        let c = a.times(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //除</span><br><span class=\"line\">    div(num1, num2, len) &#123;</span><br><span class=\"line\">        let a = new Decimal(num1)</span><br><span class=\"line\">        let b = new Decimal(num2)</span><br><span class=\"line\">        let c = a.dividedBy(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //取余</span><br><span class=\"line\">    mod(num1, num2, len) &#123;</span><br><span class=\"line\">        let a = new Decimal(num1)</span><br><span class=\"line\">        let b = new Decimal(num2)</span><br><span class=\"line\">        let c = a.modulo(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h4><p>数字货币交易所项目，需要处理大量小数、大数展示问题，使用decimal库处理js中的数字运算，包括大数展示为字符串、小数向上取整、小数向下取整、小数四舍五入、小数补零、加减乘除、取余运算。也可改为vue filter使用。</p>\n<h4 id=\"安装依赖\"><a href=\"#安装依赖\" class=\"headerlink\" title=\"安装依赖\"></a>安装依赖</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save decimal.js-light</span><br></pre></td></tr></table></figure>\n<h4 id=\"基本配置\"><a href=\"#基本配置\" class=\"headerlink\" title=\"基本配置\"></a>基本配置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Decimal.set(&#123;</span><br><span class=\"line\">    precision: 1e+9,//（计算结果）小数精度位数</span><br><span class=\"line\">    rounding: Decimal.ROUND_HALF_UP,//小数舍去配置</span><br><span class=\"line\">    minE: -9e15,//负指数极限（比较转换成指数后指数部分值&lt;这个值转换为0）</span><br><span class=\"line\">    maxE: 9e15,//正指数极限（比较转换成指数后指数部分值&gt;这个值转换为Infinity）</span><br><span class=\"line\">    toExpNeg: -9e15,//toString()负指数表示配置（比较转换成指数后指数部分值&lt;=这个值用指数表示）</span><br><span class=\"line\">    toExpPos: 9e15,//toString()正指数表示配置（比较转换成指数后指数部分值&gt;=这个值用指数表示）</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n<h4 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import Decimal from &apos;decimal.js-light&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">Decimal.set(&#123;</span><br><span class=\"line\">    precision: 20,</span><br><span class=\"line\">    rounding: Decimal.ROUND_HALF_UP,//默认使用四舍五入</span><br><span class=\"line\">    toExpNeg: -9e15,</span><br><span class=\"line\">    toExpPos: 9e15,</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">export default &#123;</span><br><span class=\"line\">    //数字转换为字符串显示</span><br><span class=\"line\">    format(num)&#123;</span><br><span class=\"line\">        num = num ? num : 0</span><br><span class=\"line\">        return new Decimal(num).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //保留小数向上取整</span><br><span class=\"line\">    formatUp(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_UP).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //保留小数向下取整</span><br><span class=\"line\">    formatDown(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_DOWN).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //保留小数四舍五入</span><br><span class=\"line\">    formatHalf(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toDecimalPlaces(len,Decimal.ROUND_HALF_UP).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //小数舍去0</span><br><span class=\"line\">    remove0(num)&#123;</span><br><span class=\"line\">        num = num ? num : 0</span><br><span class=\"line\">        return new Decimal(num).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //小数补零</span><br><span class=\"line\">    add0(num,len)&#123;</span><br><span class=\"line\">        return new Decimal(num).toFixed(len,Decimal.ROUND_DOWN).toString()</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //加</span><br><span class=\"line\">    add(num1, num2, len) &#123;</span><br><span class=\"line\">        let a = new Decimal(num1)</span><br><span class=\"line\">        let b = new Decimal(num2)</span><br><span class=\"line\">        let c = a.plus(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //减</span><br><span class=\"line\">    minus(num1, num2, len) &#123;</span><br><span class=\"line\">        let a = new Decimal(num1)</span><br><span class=\"line\">        let b = new Decimal(num2)</span><br><span class=\"line\">        let c = a.minus(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //乘</span><br><span class=\"line\">    mult(num1, num2, len) &#123;</span><br><span class=\"line\">        let a = new Decimal(num1)</span><br><span class=\"line\">        let b = new Decimal(num2)</span><br><span class=\"line\">        let c = a.times(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //除</span><br><span class=\"line\">    div(num1, num2, len) &#123;</span><br><span class=\"line\">        let a = new Decimal(num1)</span><br><span class=\"line\">        let b = new Decimal(num2)</span><br><span class=\"line\">        let c = a.dividedBy(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //取余</span><br><span class=\"line\">    mod(num1, num2, len) &#123;</span><br><span class=\"line\">        let a = new Decimal(num1)</span><br><span class=\"line\">        let b = new Decimal(num2)</span><br><span class=\"line\">        let c = a.modulo(b)</span><br><span class=\"line\">        if(len &gt; 0)&#123;</span><br><span class=\"line\">            return c.toDecimalPlaces(len).toString()</span><br><span class=\"line\">        &#125;else&#123;</span><br><span class=\"line\">            return c.toString()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"js-eventLoop","date":"2018-10-20T12:12:52.000Z","_content":"\n### Micro-Task 与 Macro-Task\\\n- 事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。\n#### macro-task\n- setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等\n#### micro-task\n- process.nextTick、Promise、MutationObserver 等。\n### Event Loop 过程\n1. 初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。\n2. 全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。\n3. macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的，因此，一个 macro-task执行完成后，会清空 micro-task对列。\n4. 执行渲染操作，更新界面\n5. 检查是否存在 Web worker 任务，如果有，则对其进行处理 。\n### 例子\n```\nasync function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\n\nasync function async2() {\n    console.log('async2')\n}\n\nconsole.log('script start')\n\nsetTimeout(function () {\n    console.log('setTimeout')\n}, 0)\n\nasync1();\n\nnew Promise(function (resolve) {\n    console.log('promise1')\n    resolve();\n}).then(function () {\n    console.log('promise2')\n})\n\nconsole.log('script end')\n```\n执行script标签内容（script start）-> setTimeout 进入 Macro-Task 对列 -> 执行 async1（async1 start）-> 执行 async2 (async2) ->由于 await async2 进入等待 -> 执行 Promise （promise1）-> promise.then() 进入 Micro-Task 对列 -> script 执行结束（script end）->清空 Micro-Task 对列（promise2）-> await 执行（async1 end）->执行新的 Macro-Task 任务（setTimeout）\n- 注意：node环境以及babel转换或者部分浏览器执行顺序有所不同\n","source":"_posts/js-eventLoop.md","raw":"---\ntitle: js-eventLoop\ndate: 2018-10-20 20:12:52\ntags: [js]\ncategories: js\n---\n\n### Micro-Task 与 Macro-Task\\\n- 事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。\n#### macro-task\n- setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等\n#### micro-task\n- process.nextTick、Promise、MutationObserver 等。\n### Event Loop 过程\n1. 初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。\n2. 全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。\n3. macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的，因此，一个 macro-task执行完成后，会清空 micro-task对列。\n4. 执行渲染操作，更新界面\n5. 检查是否存在 Web worker 任务，如果有，则对其进行处理 。\n### 例子\n```\nasync function async1() {\n    console.log('async1 start')\n    await async2()\n    console.log('async1 end')\n}\n\nasync function async2() {\n    console.log('async2')\n}\n\nconsole.log('script start')\n\nsetTimeout(function () {\n    console.log('setTimeout')\n}, 0)\n\nasync1();\n\nnew Promise(function (resolve) {\n    console.log('promise1')\n    resolve();\n}).then(function () {\n    console.log('promise2')\n})\n\nconsole.log('script end')\n```\n执行script标签内容（script start）-> setTimeout 进入 Macro-Task 对列 -> 执行 async1（async1 start）-> 执行 async2 (async2) ->由于 await async2 进入等待 -> 执行 Promise （promise1）-> promise.then() 进入 Micro-Task 对列 -> script 执行结束（script end）->清空 Micro-Task 对列（promise2）-> await 执行（async1 end）->执行新的 Macro-Task 任务（setTimeout）\n- 注意：node环境以及babel转换或者部分浏览器执行顺序有所不同\n","slug":"js-eventLoop","published":1,"updated":"2019-01-02T12:13:51.766Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob6k0012e0jc0emmflez","content":"<h3 id=\"Micro-Task-与-Macro-Task\"><a href=\"#Micro-Task-与-Macro-Task\" class=\"headerlink\" title=\"Micro-Task 与 Macro-Task\\\"></a>Micro-Task 与 Macro-Task\\</h3><ul>\n<li>事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。<h4 id=\"macro-task\"><a href=\"#macro-task\" class=\"headerlink\" title=\"macro-task\"></a>macro-task</h4></li>\n<li>setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等<h4 id=\"micro-task\"><a href=\"#micro-task\" class=\"headerlink\" title=\"micro-task\"></a>micro-task</h4></li>\n<li>process.nextTick、Promise、MutationObserver 等。<h3 id=\"Event-Loop-过程\"><a href=\"#Event-Loop-过程\" class=\"headerlink\" title=\"Event Loop 过程\"></a>Event Loop 过程</h3></li>\n</ul>\n<ol>\n<li>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</li>\n<li>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</li>\n<li>macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的，因此，一个 macro-task执行完成后，会清空 micro-task对列。</li>\n<li>执行渲染操作，更新界面</li>\n<li>检查是否存在 Web worker 任务，如果有，则对其进行处理 。<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">    console.log(&apos;async1 start&apos;)</span><br><span class=\"line\">    await async2()</span><br><span class=\"line\">    console.log(&apos;async1 end&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">async function async2() &#123;</span><br><span class=\"line\">    console.log(&apos;async2&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;script start&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">    console.log(&apos;setTimeout&apos;)</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">async1();</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(function (resolve) &#123;</span><br><span class=\"line\">    console.log(&apos;promise1&apos;)</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function () &#123;</span><br><span class=\"line\">    console.log(&apos;promise2&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;script end&apos;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>执行script标签内容（script start）-&gt; setTimeout 进入 Macro-Task 对列 -&gt; 执行 async1（async1 start）-&gt; 执行 async2 (async2) -&gt;由于 await async2 进入等待 -&gt; 执行 Promise （promise1）-&gt; promise.then() 进入 Micro-Task 对列 -&gt; script 执行结束（script end）-&gt;清空 Micro-Task 对列（promise2）-&gt; await 执行（async1 end）-&gt;执行新的 Macro-Task 任务（setTimeout）</p>\n<ul>\n<li>注意：node环境以及babel转换或者部分浏览器执行顺序有所不同</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Micro-Task-与-Macro-Task\"><a href=\"#Micro-Task-与-Macro-Task\" class=\"headerlink\" title=\"Micro-Task 与 Macro-Task\\\"></a>Micro-Task 与 Macro-Task\\</h3><ul>\n<li>事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。<h4 id=\"macro-task\"><a href=\"#macro-task\" class=\"headerlink\" title=\"macro-task\"></a>macro-task</h4></li>\n<li>setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作、UI 渲染等<h4 id=\"micro-task\"><a href=\"#micro-task\" class=\"headerlink\" title=\"micro-task\"></a>micro-task</h4></li>\n<li>process.nextTick、Promise、MutationObserver 等。<h3 id=\"Event-Loop-过程\"><a href=\"#Event-Loop-过程\" class=\"headerlink\" title=\"Event Loop 过程\"></a>Event Loop 过程</h3></li>\n</ul>\n<ol>\n<li>初始状态：调用栈空。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。</li>\n<li>全局上下文（script 标签）被推入调用栈，同步代码执行。在执行的过程中，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。</li>\n<li>macro-task 出队时，任务是一个一个执行的；而 micro-task 出队时，任务是一队一队执行的，因此，一个 macro-task执行完成后，会清空 micro-task对列。</li>\n<li>执行渲染操作，更新界面</li>\n<li>检查是否存在 Web worker 任务，如果有，则对其进行处理 。<h3 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">async function async1() &#123;</span><br><span class=\"line\">    console.log(&apos;async1 start&apos;)</span><br><span class=\"line\">    await async2()</span><br><span class=\"line\">    console.log(&apos;async1 end&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">async function async2() &#123;</span><br><span class=\"line\">    console.log(&apos;async2&apos;)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;script start&apos;)</span><br><span class=\"line\"></span><br><span class=\"line\">setTimeout(function () &#123;</span><br><span class=\"line\">    console.log(&apos;setTimeout&apos;)</span><br><span class=\"line\">&#125;, 0)</span><br><span class=\"line\"></span><br><span class=\"line\">async1();</span><br><span class=\"line\"></span><br><span class=\"line\">new Promise(function (resolve) &#123;</span><br><span class=\"line\">    console.log(&apos;promise1&apos;)</span><br><span class=\"line\">    resolve();</span><br><span class=\"line\">&#125;).then(function () &#123;</span><br><span class=\"line\">    console.log(&apos;promise2&apos;)</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(&apos;script end&apos;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<p>执行script标签内容（script start）-&gt; setTimeout 进入 Macro-Task 对列 -&gt; 执行 async1（async1 start）-&gt; 执行 async2 (async2) -&gt;由于 await async2 进入等待 -&gt; 执行 Promise （promise1）-&gt; promise.then() 进入 Micro-Task 对列 -&gt; script 执行结束（script end）-&gt;清空 Micro-Task 对列（promise2）-&gt; await 执行（async1 end）-&gt;执行新的 Macro-Task 任务（setTimeout）</p>\n<ul>\n<li>注意：node环境以及babel转换或者部分浏览器执行顺序有所不同</li>\n</ul>\n"},{"title":"js-file相关","date":"2019-01-31T12:00:49.000Z","_content":"### Blob对象\n- Blob对象表示一个不可变、原始数据的类文件对象。\n#### 属性：\n- Blob.size\n- Blob.type\n#### 方法：\n- Blob.slice([start,[ end ,[contentType]]])，返回一个新的 Blob对象，包含指定范围数据。\n### Blob()构造函数\n- 返回一个新的 Blob 对象。\n- var aBlob = new Blob( array, options );\n#### 参数：\n- array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。\n- options：type，默认值为 \"\"，它代表了将会被放入到blob中的数组内容的MIME类型。endings，默认值为\"transparent\"，用于指定包含行结束符\\n的字符串如何被写入。\n#### js创建并下载excel\n- 步骤\n1. 创建Blob对象\n2. 转换为dataURL或者ObjectURL\n3. 使用a标签download下载\n- 示例代码\n```\n<div id=\"myTable\">\n    <style media=\"screen\">\n        table {\n            border-collapse: collapse;\n        }\n        table th{\n            height: 50px;\n            font-size: 24px;\n            font-family: '微软雅黑';\n            font-weight: 700;\n        }\n        table th {\n            border: 1px #000 solid;\n            height: 40px;\n            background: #efefef;\n        }\n        table td {\n            padding: 0 40px;\n            border: 1px #000 solid;\n            height: 40px;\n            text-align: center;\n        }\n        table td {\n            font-size: 20px;\n            font-weight: 700;\n        }\n    </style>\n    <table>\n        <tr>\n            <th colspan=\"2\">主要信息</th>\n            <th colspan=\"2\">其它信息</th>\n        </tr>\n        <tr>\n            <th>姓名</th>\n            <th>性别</th>\n            <th>年龄</th>\n            <th>注册时间</th>\n        </tr>\n        <tr>\n            <td>张三</td>\n            <td>男</td>\n            <td>18</td>\n            <td>123</td>\n        </tr>\n        <tr>\n            <td>张三</td>\n            <td>男</td>\n            <td>18</td>\n            <td>123</td>\n        </tr>\n    </table>\n</div>\n<script>\n    let table = document.getElementById('myTable').outerHTML\n    var oMyBlob = new Blob([table], {type : 'application/vnd.ms-excel'});\n\n    //方法1：使用FileReader dataURL\n    let reader = new FileReader()\n    reader.onload = function () {\n        let a = document.createElement('a')\n        a.href = reader.result\n        a.download = 'a.xls'\n        a.click()\n    }\n    reader.readAsDataURL(oMyBlob)\n\n    //方法2：使用window.URL.createObjectURL\n    let objURL = window.URL.createObjectURL(oMyBlob)\n    let a = document.createElement('a')\n    a.href = objURL\n    a.download = 'a.xls'\n    a.click()\n\n</script>\n```\n### File对象\n- File 对象是特殊类型的 Blob。\n#### 获取方式\n- <input> 元素上选择文件后返回的 FileList 对象\n```\nlet fileInput = document.getElementById('myFile')\nfileInput.addEventListener('change',()=>{\n    console.log(fileInput.files)\n})\n```\n- 由拖放操作生成的 DataTransfer 对象\n```\n//可以是个div\nvar dropbox;\ndropbox = document.getElementById(\"dropbox\");\ndropbox.addEventListener(\"dragenter\", (e)=>{\n    e.stopPropagation();\n    e.preventDefault();\n});\ndropbox.addEventListener(\"dragover\", (e)=>{\n    e.stopPropagation();\n    e.preventDefault();\n});\ndropbox.addEventListener(\"drop\", (e)=>{\n    e.stopPropagation();\n    e.preventDefault();\n\n    var dt = e.dataTransfer;\n    var files = dt.files;\n    console.log(files)\n    console.log(files)\n});\n```\n- 来自 HTMLCanvasElement 上的 mozGetAsFile() API\n#### 属性\n- File.lastModified：文件最后修改时间\n- File.lastModifiedDate：文件最后修改时间的 Date 对象\n- File.name：名称\n- File.size：大小\n- File.type：类型\n- File.webkitRelativePath：路径（非标准的）\n```\n//input需要设置 webkitdirectory 属性（只允许选择文件夹）\n<input id=\"myFile\" webkitdirectory type=\"file\">\n```\n\n### File()构造器\n#### 语法\n- var myFile = new File(bits, name[, options]);\n#### 参数\n- bits：ArrayBuffer，ArrayBufferView，Blob，或者 DOMString 对象的 Array — 或者任何这些对象的组合。这是 UTF-8 编码的文件内容。\n- name：USVString，表示文件名称，或者文件路径。\n- options：type: DOMString，表示将要放到文件中的内容的 MIME 类型。默认值为 \"\" 。lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。\n- https://developer.mozilla.org/zh-CN/docs/Web/API/File/File\n```\nvar file = new File([\"foo\"], \"foo.txt\", {\n  type: \"text/plain\",\n});\n```\n### FileReader对象\n- https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\n- 允许Web应用程序异步读取存储在用户计算机上的文件\n- FileReader()返回一个新构造的FileReader\n#### 属性：\n- FileReader.error：读取文件发生错误\n- FileReader.readyState：状态数字 EMPTY（0）、LOADING（1）、DONE（2）\n- FileReader.result：文件的内容。该属性仅在读取操作完成后才有效。\n#### 事件：\n- 继承自EventTarget，所以所有这些事件也可以通过addEventListener方法使用。\n- FileReader.onabort：中断时触发\n- FileReader.onerror：错误时触发\n- FileReader.onload：读取操作完成时触发\n- FileReader.onloadstart：\n- FileReader.onloadend：\n- FileReader.onprogress：处理progress事件。该事件在读取Blob时触发。\n#### 方法：\n- FileReader.abort()：终止操作\n- FileReader.readAsArrayBuffer()\n- FileReader.readAsBinaryString()非标准的\n- FileReader.readAsDataURL()\n- FileReader.readAsText()\n#### 例子\n- input图片展示\n```\n<input type=\"file\" id=\"inputFile\">\n<script>\n    let inputFile = document.getElementById('inputFile')\n    inputFile.addEventListener('change', () => {\n        let file = inputFile.files[0]\n        let reader = new FileReader()\n        reader.onload = function () {\n            let img = document.createElement('img')\n            img.src = reader.result\n            document.documentElement.appendChild(img)\n        }\n        reader.readAsDataURL(file)\n    })\n</script>\n```\n### ObjectURL\n- https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\n- https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\n- objectURL = URL.createObjectURL(object);表示指定的File对象或Blob对象的url\n- window.URL.revokeObjectURL(objectURL);释放一个现有的对象URL\n```\n//选择图片并转换为对象URL显示\n<input type=\"file\" id=\"file1\">\n<script>\n    let inputFile = document.getElementById('file1')\n    inputFile.addEventListener('change',()=>{\n        let file = inputFile.files[0]\n        let url = window.URL.createObjectURL(file)\n\n        let img = document.createElement('img')\n        img.src = url\n        document.documentElement.appendChild(img)\n\n        img.onload = function() {\n            window.URL.revokeObjectURL(url)\n        }\n    })\n</script>\n```\n```\n//展示pdf\n<input type=\"file\" id=\"file2\">\n<iframe src=\"\" frameborder=\"0\" id=\"view\"></iframe>\n<script>\n    let pdfInput = document.getElementById('file2')\n    pdfInput.addEventListener('change',()=>{\n        let file = pdfInput.files[0]\n        let url = window.URL.createObjectURL(file)\n        var iframe = document.getElementById('view');\n        iframe.setAttribute('src', url);\n    })\n</script>\n```\n","source":"_posts/js-file相关.md","raw":"---\ntitle: js-file相关\ndate: 2019-01-31 20:00:49\ntags: [js,文件,file]\ncategories: file\n---\n### Blob对象\n- Blob对象表示一个不可变、原始数据的类文件对象。\n#### 属性：\n- Blob.size\n- Blob.type\n#### 方法：\n- Blob.slice([start,[ end ,[contentType]]])，返回一个新的 Blob对象，包含指定范围数据。\n### Blob()构造函数\n- 返回一个新的 Blob 对象。\n- var aBlob = new Blob( array, options );\n#### 参数：\n- array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。\n- options：type，默认值为 \"\"，它代表了将会被放入到blob中的数组内容的MIME类型。endings，默认值为\"transparent\"，用于指定包含行结束符\\n的字符串如何被写入。\n#### js创建并下载excel\n- 步骤\n1. 创建Blob对象\n2. 转换为dataURL或者ObjectURL\n3. 使用a标签download下载\n- 示例代码\n```\n<div id=\"myTable\">\n    <style media=\"screen\">\n        table {\n            border-collapse: collapse;\n        }\n        table th{\n            height: 50px;\n            font-size: 24px;\n            font-family: '微软雅黑';\n            font-weight: 700;\n        }\n        table th {\n            border: 1px #000 solid;\n            height: 40px;\n            background: #efefef;\n        }\n        table td {\n            padding: 0 40px;\n            border: 1px #000 solid;\n            height: 40px;\n            text-align: center;\n        }\n        table td {\n            font-size: 20px;\n            font-weight: 700;\n        }\n    </style>\n    <table>\n        <tr>\n            <th colspan=\"2\">主要信息</th>\n            <th colspan=\"2\">其它信息</th>\n        </tr>\n        <tr>\n            <th>姓名</th>\n            <th>性别</th>\n            <th>年龄</th>\n            <th>注册时间</th>\n        </tr>\n        <tr>\n            <td>张三</td>\n            <td>男</td>\n            <td>18</td>\n            <td>123</td>\n        </tr>\n        <tr>\n            <td>张三</td>\n            <td>男</td>\n            <td>18</td>\n            <td>123</td>\n        </tr>\n    </table>\n</div>\n<script>\n    let table = document.getElementById('myTable').outerHTML\n    var oMyBlob = new Blob([table], {type : 'application/vnd.ms-excel'});\n\n    //方法1：使用FileReader dataURL\n    let reader = new FileReader()\n    reader.onload = function () {\n        let a = document.createElement('a')\n        a.href = reader.result\n        a.download = 'a.xls'\n        a.click()\n    }\n    reader.readAsDataURL(oMyBlob)\n\n    //方法2：使用window.URL.createObjectURL\n    let objURL = window.URL.createObjectURL(oMyBlob)\n    let a = document.createElement('a')\n    a.href = objURL\n    a.download = 'a.xls'\n    a.click()\n\n</script>\n```\n### File对象\n- File 对象是特殊类型的 Blob。\n#### 获取方式\n- <input> 元素上选择文件后返回的 FileList 对象\n```\nlet fileInput = document.getElementById('myFile')\nfileInput.addEventListener('change',()=>{\n    console.log(fileInput.files)\n})\n```\n- 由拖放操作生成的 DataTransfer 对象\n```\n//可以是个div\nvar dropbox;\ndropbox = document.getElementById(\"dropbox\");\ndropbox.addEventListener(\"dragenter\", (e)=>{\n    e.stopPropagation();\n    e.preventDefault();\n});\ndropbox.addEventListener(\"dragover\", (e)=>{\n    e.stopPropagation();\n    e.preventDefault();\n});\ndropbox.addEventListener(\"drop\", (e)=>{\n    e.stopPropagation();\n    e.preventDefault();\n\n    var dt = e.dataTransfer;\n    var files = dt.files;\n    console.log(files)\n    console.log(files)\n});\n```\n- 来自 HTMLCanvasElement 上的 mozGetAsFile() API\n#### 属性\n- File.lastModified：文件最后修改时间\n- File.lastModifiedDate：文件最后修改时间的 Date 对象\n- File.name：名称\n- File.size：大小\n- File.type：类型\n- File.webkitRelativePath：路径（非标准的）\n```\n//input需要设置 webkitdirectory 属性（只允许选择文件夹）\n<input id=\"myFile\" webkitdirectory type=\"file\">\n```\n\n### File()构造器\n#### 语法\n- var myFile = new File(bits, name[, options]);\n#### 参数\n- bits：ArrayBuffer，ArrayBufferView，Blob，或者 DOMString 对象的 Array — 或者任何这些对象的组合。这是 UTF-8 编码的文件内容。\n- name：USVString，表示文件名称，或者文件路径。\n- options：type: DOMString，表示将要放到文件中的内容的 MIME 类型。默认值为 \"\" 。lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。\n- https://developer.mozilla.org/zh-CN/docs/Web/API/File/File\n```\nvar file = new File([\"foo\"], \"foo.txt\", {\n  type: \"text/plain\",\n});\n```\n### FileReader对象\n- https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\n- 允许Web应用程序异步读取存储在用户计算机上的文件\n- FileReader()返回一个新构造的FileReader\n#### 属性：\n- FileReader.error：读取文件发生错误\n- FileReader.readyState：状态数字 EMPTY（0）、LOADING（1）、DONE（2）\n- FileReader.result：文件的内容。该属性仅在读取操作完成后才有效。\n#### 事件：\n- 继承自EventTarget，所以所有这些事件也可以通过addEventListener方法使用。\n- FileReader.onabort：中断时触发\n- FileReader.onerror：错误时触发\n- FileReader.onload：读取操作完成时触发\n- FileReader.onloadstart：\n- FileReader.onloadend：\n- FileReader.onprogress：处理progress事件。该事件在读取Blob时触发。\n#### 方法：\n- FileReader.abort()：终止操作\n- FileReader.readAsArrayBuffer()\n- FileReader.readAsBinaryString()非标准的\n- FileReader.readAsDataURL()\n- FileReader.readAsText()\n#### 例子\n- input图片展示\n```\n<input type=\"file\" id=\"inputFile\">\n<script>\n    let inputFile = document.getElementById('inputFile')\n    inputFile.addEventListener('change', () => {\n        let file = inputFile.files[0]\n        let reader = new FileReader()\n        reader.onload = function () {\n            let img = document.createElement('img')\n            img.src = reader.result\n            document.documentElement.appendChild(img)\n        }\n        reader.readAsDataURL(file)\n    })\n</script>\n```\n### ObjectURL\n- https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\n- https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\n- objectURL = URL.createObjectURL(object);表示指定的File对象或Blob对象的url\n- window.URL.revokeObjectURL(objectURL);释放一个现有的对象URL\n```\n//选择图片并转换为对象URL显示\n<input type=\"file\" id=\"file1\">\n<script>\n    let inputFile = document.getElementById('file1')\n    inputFile.addEventListener('change',()=>{\n        let file = inputFile.files[0]\n        let url = window.URL.createObjectURL(file)\n\n        let img = document.createElement('img')\n        img.src = url\n        document.documentElement.appendChild(img)\n\n        img.onload = function() {\n            window.URL.revokeObjectURL(url)\n        }\n    })\n</script>\n```\n```\n//展示pdf\n<input type=\"file\" id=\"file2\">\n<iframe src=\"\" frameborder=\"0\" id=\"view\"></iframe>\n<script>\n    let pdfInput = document.getElementById('file2')\n    pdfInput.addEventListener('change',()=>{\n        let file = pdfInput.files[0]\n        let url = window.URL.createObjectURL(file)\n        var iframe = document.getElementById('view');\n        iframe.setAttribute('src', url);\n    })\n</script>\n```\n","slug":"js-file相关","published":1,"updated":"2019-01-31T12:01:42.597Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob6m0016e0jcgow1kvhv","content":"<h3 id=\"Blob对象\"><a href=\"#Blob对象\" class=\"headerlink\" title=\"Blob对象\"></a>Blob对象</h3><ul>\n<li>Blob对象表示一个不可变、原始数据的类文件对象。<h4 id=\"属性：\"><a href=\"#属性：\" class=\"headerlink\" title=\"属性：\"></a>属性：</h4></li>\n<li>Blob.size</li>\n<li>Blob.type<h4 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4></li>\n<li>Blob.slice([start,[ end ,[contentType]]])，返回一个新的 Blob对象，包含指定范围数据。<h3 id=\"Blob-构造函数\"><a href=\"#Blob-构造函数\" class=\"headerlink\" title=\"Blob()构造函数\"></a>Blob()构造函数</h3></li>\n<li>返回一个新的 Blob 对象。</li>\n<li>var aBlob = new Blob( array, options );<h4 id=\"参数：\"><a href=\"#参数：\" class=\"headerlink\" title=\"参数：\"></a>参数：</h4></li>\n<li>array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。</li>\n<li>options：type，默认值为 “”，它代表了将会被放入到blob中的数组内容的MIME类型。endings，默认值为”transparent”，用于指定包含行结束符\\n的字符串如何被写入。<h4 id=\"js创建并下载excel\"><a href=\"#js创建并下载excel\" class=\"headerlink\" title=\"js创建并下载excel\"></a>js创建并下载excel</h4></li>\n<li>步骤</li>\n</ul>\n<ol>\n<li>创建Blob对象</li>\n<li>转换为dataURL或者ObjectURL</li>\n<li>使用a标签download下载</li>\n</ol>\n<ul>\n<li>示例代码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;myTable&quot;&gt;</span><br><span class=\"line\">    &lt;style media=&quot;screen&quot;&gt;</span><br><span class=\"line\">        table &#123;</span><br><span class=\"line\">            border-collapse: collapse;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table th&#123;</span><br><span class=\"line\">            height: 50px;</span><br><span class=\"line\">            font-size: 24px;</span><br><span class=\"line\">            font-family: &apos;微软雅黑&apos;;</span><br><span class=\"line\">            font-weight: 700;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table th &#123;</span><br><span class=\"line\">            border: 1px #000 solid;</span><br><span class=\"line\">            height: 40px;</span><br><span class=\"line\">            background: #efefef;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table td &#123;</span><br><span class=\"line\">            padding: 0 40px;</span><br><span class=\"line\">            border: 1px #000 solid;</span><br><span class=\"line\">            height: 40px;</span><br><span class=\"line\">            text-align: center;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table td &#123;</span><br><span class=\"line\">            font-size: 20px;</span><br><span class=\"line\">            font-weight: 700;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">    &lt;table&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;th colspan=&quot;2&quot;&gt;主要信息&lt;/th&gt;</span><br><span class=\"line\">            &lt;th colspan=&quot;2&quot;&gt;其它信息&lt;/th&gt;</span><br><span class=\"line\">        &lt;/tr&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;th&gt;姓名&lt;/th&gt;</span><br><span class=\"line\">            &lt;th&gt;性别&lt;/th&gt;</span><br><span class=\"line\">            &lt;th&gt;年龄&lt;/th&gt;</span><br><span class=\"line\">            &lt;th&gt;注册时间&lt;/th&gt;</span><br><span class=\"line\">        &lt;/tr&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;td&gt;张三&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;男&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;18&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;123&lt;/td&gt;</span><br><span class=\"line\">        &lt;/tr&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;td&gt;张三&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;男&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;18&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;123&lt;/td&gt;</span><br><span class=\"line\">        &lt;/tr&gt;</span><br><span class=\"line\">    &lt;/table&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let table = document.getElementById(&apos;myTable&apos;).outerHTML</span><br><span class=\"line\">    var oMyBlob = new Blob([table], &#123;type : &apos;application/vnd.ms-excel&apos;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //方法1：使用FileReader dataURL</span><br><span class=\"line\">    let reader = new FileReader()</span><br><span class=\"line\">    reader.onload = function () &#123;</span><br><span class=\"line\">        let a = document.createElement(&apos;a&apos;)</span><br><span class=\"line\">        a.href = reader.result</span><br><span class=\"line\">        a.download = &apos;a.xls&apos;</span><br><span class=\"line\">        a.click()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reader.readAsDataURL(oMyBlob)</span><br><span class=\"line\"></span><br><span class=\"line\">    //方法2：使用window.URL.createObjectURL</span><br><span class=\"line\">    let objURL = window.URL.createObjectURL(oMyBlob)</span><br><span class=\"line\">    let a = document.createElement(&apos;a&apos;)</span><br><span class=\"line\">    a.href = objURL</span><br><span class=\"line\">    a.download = &apos;a.xls&apos;</span><br><span class=\"line\">    a.click()</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"File对象\"><a href=\"#File对象\" class=\"headerlink\" title=\"File对象\"></a>File对象</h3><ul>\n<li>File 对象是特殊类型的 Blob。<h4 id=\"获取方式\"><a href=\"#获取方式\" class=\"headerlink\" title=\"获取方式\"></a>获取方式</h4></li>\n<li><p><input> 元素上选择文件后返回的 FileList 对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fileInput = document.getElementById(&apos;myFile&apos;)</span><br><span class=\"line\">fileInput.addEventListener(&apos;change&apos;,()=&gt;&#123;</span><br><span class=\"line\">    console.log(fileInput.files)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>由拖放操作生成的 DataTransfer 对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//可以是个div</span><br><span class=\"line\">var dropbox;</span><br><span class=\"line\">dropbox = document.getElementById(&quot;dropbox&quot;);</span><br><span class=\"line\">dropbox.addEventListener(&quot;dragenter&quot;, (e)=&gt;&#123;</span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dropbox.addEventListener(&quot;dragover&quot;, (e)=&gt;&#123;</span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dropbox.addEventListener(&quot;drop&quot;, (e)=&gt;&#123;</span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\"></span><br><span class=\"line\">    var dt = e.dataTransfer;</span><br><span class=\"line\">    var files = dt.files;</span><br><span class=\"line\">    console.log(files)</span><br><span class=\"line\">    console.log(files)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>来自 HTMLCanvasElement 上的 mozGetAsFile() API</p>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4></li>\n<li>File.lastModified：文件最后修改时间</li>\n<li>File.lastModifiedDate：文件最后修改时间的 Date 对象</li>\n<li>File.name：名称</li>\n<li>File.size：大小</li>\n<li>File.type：类型</li>\n<li>File.webkitRelativePath：路径（非标准的）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//input需要设置 webkitdirectory 属性（只允许选择文件夹）</span><br><span class=\"line\">&lt;input id=&quot;myFile&quot; webkitdirectory type=&quot;file&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"File-构造器\"><a href=\"#File-构造器\" class=\"headerlink\" title=\"File()构造器\"></a>File()构造器</h3><h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><ul>\n<li>var myFile = new File(bits, name[, options]);<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4></li>\n<li>bits：ArrayBuffer，ArrayBufferView，Blob，或者 DOMString 对象的 Array — 或者任何这些对象的组合。这是 UTF-8 编码的文件内容。</li>\n<li>name：USVString，表示文件名称，或者文件路径。</li>\n<li>options：type: DOMString，表示将要放到文件中的内容的 MIME 类型。默认值为 “” 。lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/File/File\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/File/File</a><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var file = new File([&quot;foo&quot;], &quot;foo.txt&quot;, &#123;</span><br><span class=\"line\">  type: &quot;text/plain&quot;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"FileReader对象\"><a href=\"#FileReader对象\" class=\"headerlink\" title=\"FileReader对象\"></a>FileReader对象</h3><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader</a></li>\n<li>允许Web应用程序异步读取存储在用户计算机上的文件</li>\n<li>FileReader()返回一个新构造的FileReader<h4 id=\"属性：-1\"><a href=\"#属性：-1\" class=\"headerlink\" title=\"属性：\"></a>属性：</h4></li>\n<li>FileReader.error：读取文件发生错误</li>\n<li>FileReader.readyState：状态数字 EMPTY（0）、LOADING（1）、DONE（2）</li>\n<li>FileReader.result：文件的内容。该属性仅在读取操作完成后才有效。<h4 id=\"事件：\"><a href=\"#事件：\" class=\"headerlink\" title=\"事件：\"></a>事件：</h4></li>\n<li>继承自EventTarget，所以所有这些事件也可以通过addEventListener方法使用。</li>\n<li>FileReader.onabort：中断时触发</li>\n<li>FileReader.onerror：错误时触发</li>\n<li>FileReader.onload：读取操作完成时触发</li>\n<li>FileReader.onloadstart：</li>\n<li>FileReader.onloadend：</li>\n<li>FileReader.onprogress：处理progress事件。该事件在读取Blob时触发。<h4 id=\"方法：-1\"><a href=\"#方法：-1\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4></li>\n<li>FileReader.abort()：终止操作</li>\n<li>FileReader.readAsArrayBuffer()</li>\n<li>FileReader.readAsBinaryString()非标准的</li>\n<li>FileReader.readAsDataURL()</li>\n<li>FileReader.readAsText()<h4 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h4></li>\n<li>input图片展示<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;file&quot; id=&quot;inputFile&quot;&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let inputFile = document.getElementById(&apos;inputFile&apos;)</span><br><span class=\"line\">    inputFile.addEventListener(&apos;change&apos;, () =&gt; &#123;</span><br><span class=\"line\">        let file = inputFile.files[0]</span><br><span class=\"line\">        let reader = new FileReader()</span><br><span class=\"line\">        reader.onload = function () &#123;</span><br><span class=\"line\">            let img = document.createElement(&apos;img&apos;)</span><br><span class=\"line\">            img.src = reader.result</span><br><span class=\"line\">            document.documentElement.appendChild(img)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reader.readAsDataURL(file)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"ObjectURL\"><a href=\"#ObjectURL\" class=\"headerlink\" title=\"ObjectURL\"></a>ObjectURL</h3><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL</a></li>\n<li>objectURL = URL.createObjectURL(object);表示指定的File对象或Blob对象的url</li>\n<li>window.URL.revokeObjectURL(objectURL);释放一个现有的对象URL<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//选择图片并转换为对象URL显示</span><br><span class=\"line\">&lt;input type=&quot;file&quot; id=&quot;file1&quot;&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let inputFile = document.getElementById(&apos;file1&apos;)</span><br><span class=\"line\">    inputFile.addEventListener(&apos;change&apos;,()=&gt;&#123;</span><br><span class=\"line\">        let file = inputFile.files[0]</span><br><span class=\"line\">        let url = window.URL.createObjectURL(file)</span><br><span class=\"line\"></span><br><span class=\"line\">        let img = document.createElement(&apos;img&apos;)</span><br><span class=\"line\">        img.src = url</span><br><span class=\"line\">        document.documentElement.appendChild(img)</span><br><span class=\"line\"></span><br><span class=\"line\">        img.onload = function() &#123;</span><br><span class=\"line\">            window.URL.revokeObjectURL(url)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//展示pdf</span><br><span class=\"line\">&lt;input type=&quot;file&quot; id=&quot;file2&quot;&gt;</span><br><span class=\"line\">&lt;iframe src=&quot;&quot; frameborder=&quot;0&quot; id=&quot;view&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let pdfInput = document.getElementById(&apos;file2&apos;)</span><br><span class=\"line\">    pdfInput.addEventListener(&apos;change&apos;,()=&gt;&#123;</span><br><span class=\"line\">        let file = pdfInput.files[0]</span><br><span class=\"line\">        let url = window.URL.createObjectURL(file)</span><br><span class=\"line\">        var iframe = document.getElementById(&apos;view&apos;);</span><br><span class=\"line\">        iframe.setAttribute(&apos;src&apos;, url);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"Blob对象\"><a href=\"#Blob对象\" class=\"headerlink\" title=\"Blob对象\"></a>Blob对象</h3><ul>\n<li>Blob对象表示一个不可变、原始数据的类文件对象。<h4 id=\"属性：\"><a href=\"#属性：\" class=\"headerlink\" title=\"属性：\"></a>属性：</h4></li>\n<li>Blob.size</li>\n<li>Blob.type<h4 id=\"方法：\"><a href=\"#方法：\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4></li>\n<li>Blob.slice([start,[ end ,[contentType]]])，返回一个新的 Blob对象，包含指定范围数据。<h3 id=\"Blob-构造函数\"><a href=\"#Blob-构造函数\" class=\"headerlink\" title=\"Blob()构造函数\"></a>Blob()构造函数</h3></li>\n<li>返回一个新的 Blob 对象。</li>\n<li>var aBlob = new Blob( array, options );<h4 id=\"参数：\"><a href=\"#参数：\" class=\"headerlink\" title=\"参数：\"></a>参数：</h4></li>\n<li>array 是一个由ArrayBuffer, ArrayBufferView, Blob, DOMString 等对象构成的 Array ，或者其他类似对象的混合体，它将会被放进 Blob。DOMStrings会被编码为UTF-8。</li>\n<li>options：type，默认值为 “”，它代表了将会被放入到blob中的数组内容的MIME类型。endings，默认值为”transparent”，用于指定包含行结束符\\n的字符串如何被写入。<h4 id=\"js创建并下载excel\"><a href=\"#js创建并下载excel\" class=\"headerlink\" title=\"js创建并下载excel\"></a>js创建并下载excel</h4></li>\n<li>步骤</li>\n</ul>\n<ol>\n<li>创建Blob对象</li>\n<li>转换为dataURL或者ObjectURL</li>\n<li>使用a标签download下载</li>\n</ol>\n<ul>\n<li>示例代码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;div id=&quot;myTable&quot;&gt;</span><br><span class=\"line\">    &lt;style media=&quot;screen&quot;&gt;</span><br><span class=\"line\">        table &#123;</span><br><span class=\"line\">            border-collapse: collapse;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table th&#123;</span><br><span class=\"line\">            height: 50px;</span><br><span class=\"line\">            font-size: 24px;</span><br><span class=\"line\">            font-family: &apos;微软雅黑&apos;;</span><br><span class=\"line\">            font-weight: 700;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table th &#123;</span><br><span class=\"line\">            border: 1px #000 solid;</span><br><span class=\"line\">            height: 40px;</span><br><span class=\"line\">            background: #efefef;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table td &#123;</span><br><span class=\"line\">            padding: 0 40px;</span><br><span class=\"line\">            border: 1px #000 solid;</span><br><span class=\"line\">            height: 40px;</span><br><span class=\"line\">            text-align: center;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        table td &#123;</span><br><span class=\"line\">            font-size: 20px;</span><br><span class=\"line\">            font-weight: 700;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &lt;/style&gt;</span><br><span class=\"line\">    &lt;table&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;th colspan=&quot;2&quot;&gt;主要信息&lt;/th&gt;</span><br><span class=\"line\">            &lt;th colspan=&quot;2&quot;&gt;其它信息&lt;/th&gt;</span><br><span class=\"line\">        &lt;/tr&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;th&gt;姓名&lt;/th&gt;</span><br><span class=\"line\">            &lt;th&gt;性别&lt;/th&gt;</span><br><span class=\"line\">            &lt;th&gt;年龄&lt;/th&gt;</span><br><span class=\"line\">            &lt;th&gt;注册时间&lt;/th&gt;</span><br><span class=\"line\">        &lt;/tr&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;td&gt;张三&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;男&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;18&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;123&lt;/td&gt;</span><br><span class=\"line\">        &lt;/tr&gt;</span><br><span class=\"line\">        &lt;tr&gt;</span><br><span class=\"line\">            &lt;td&gt;张三&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;男&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;18&lt;/td&gt;</span><br><span class=\"line\">            &lt;td&gt;123&lt;/td&gt;</span><br><span class=\"line\">        &lt;/tr&gt;</span><br><span class=\"line\">    &lt;/table&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let table = document.getElementById(&apos;myTable&apos;).outerHTML</span><br><span class=\"line\">    var oMyBlob = new Blob([table], &#123;type : &apos;application/vnd.ms-excel&apos;&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //方法1：使用FileReader dataURL</span><br><span class=\"line\">    let reader = new FileReader()</span><br><span class=\"line\">    reader.onload = function () &#123;</span><br><span class=\"line\">        let a = document.createElement(&apos;a&apos;)</span><br><span class=\"line\">        a.href = reader.result</span><br><span class=\"line\">        a.download = &apos;a.xls&apos;</span><br><span class=\"line\">        a.click()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    reader.readAsDataURL(oMyBlob)</span><br><span class=\"line\"></span><br><span class=\"line\">    //方法2：使用window.URL.createObjectURL</span><br><span class=\"line\">    let objURL = window.URL.createObjectURL(oMyBlob)</span><br><span class=\"line\">    let a = document.createElement(&apos;a&apos;)</span><br><span class=\"line\">    a.href = objURL</span><br><span class=\"line\">    a.download = &apos;a.xls&apos;</span><br><span class=\"line\">    a.click()</span><br><span class=\"line\"></span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"File对象\"><a href=\"#File对象\" class=\"headerlink\" title=\"File对象\"></a>File对象</h3><ul>\n<li>File 对象是特殊类型的 Blob。<h4 id=\"获取方式\"><a href=\"#获取方式\" class=\"headerlink\" title=\"获取方式\"></a>获取方式</h4></li>\n<li><p><input> 元素上选择文件后返回的 FileList 对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let fileInput = document.getElementById(&apos;myFile&apos;)</span><br><span class=\"line\">fileInput.addEventListener(&apos;change&apos;,()=&gt;&#123;</span><br><span class=\"line\">    console.log(fileInput.files)</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>由拖放操作生成的 DataTransfer 对象</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//可以是个div</span><br><span class=\"line\">var dropbox;</span><br><span class=\"line\">dropbox = document.getElementById(&quot;dropbox&quot;);</span><br><span class=\"line\">dropbox.addEventListener(&quot;dragenter&quot;, (e)=&gt;&#123;</span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dropbox.addEventListener(&quot;dragover&quot;, (e)=&gt;&#123;</span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\">dropbox.addEventListener(&quot;drop&quot;, (e)=&gt;&#123;</span><br><span class=\"line\">    e.stopPropagation();</span><br><span class=\"line\">    e.preventDefault();</span><br><span class=\"line\"></span><br><span class=\"line\">    var dt = e.dataTransfer;</span><br><span class=\"line\">    var files = dt.files;</span><br><span class=\"line\">    console.log(files)</span><br><span class=\"line\">    console.log(files)</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>来自 HTMLCanvasElement 上的 mozGetAsFile() API</p>\n<h4 id=\"属性\"><a href=\"#属性\" class=\"headerlink\" title=\"属性\"></a>属性</h4></li>\n<li>File.lastModified：文件最后修改时间</li>\n<li>File.lastModifiedDate：文件最后修改时间的 Date 对象</li>\n<li>File.name：名称</li>\n<li>File.size：大小</li>\n<li>File.type：类型</li>\n<li>File.webkitRelativePath：路径（非标准的）<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//input需要设置 webkitdirectory 属性（只允许选择文件夹）</span><br><span class=\"line\">&lt;input id=&quot;myFile&quot; webkitdirectory type=&quot;file&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"File-构造器\"><a href=\"#File-构造器\" class=\"headerlink\" title=\"File()构造器\"></a>File()构造器</h3><h4 id=\"语法\"><a href=\"#语法\" class=\"headerlink\" title=\"语法\"></a>语法</h4><ul>\n<li>var myFile = new File(bits, name[, options]);<h4 id=\"参数\"><a href=\"#参数\" class=\"headerlink\" title=\"参数\"></a>参数</h4></li>\n<li>bits：ArrayBuffer，ArrayBufferView，Blob，或者 DOMString 对象的 Array — 或者任何这些对象的组合。这是 UTF-8 编码的文件内容。</li>\n<li>name：USVString，表示文件名称，或者文件路径。</li>\n<li>options：type: DOMString，表示将要放到文件中的内容的 MIME 类型。默认值为 “” 。lastModified: 数值，表示文件最后修改时间的 Unix 时间戳（毫秒）。默认值为 Date.now()。</li>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/File/File\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/File/File</a><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var file = new File([&quot;foo&quot;], &quot;foo.txt&quot;, &#123;</span><br><span class=\"line\">  type: &quot;text/plain&quot;,</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"FileReader对象\"><a href=\"#FileReader对象\" class=\"headerlink\" title=\"FileReader对象\"></a>FileReader对象</h3><ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader</a></li>\n<li>允许Web应用程序异步读取存储在用户计算机上的文件</li>\n<li>FileReader()返回一个新构造的FileReader<h4 id=\"属性：-1\"><a href=\"#属性：-1\" class=\"headerlink\" title=\"属性：\"></a>属性：</h4></li>\n<li>FileReader.error：读取文件发生错误</li>\n<li>FileReader.readyState：状态数字 EMPTY（0）、LOADING（1）、DONE（2）</li>\n<li>FileReader.result：文件的内容。该属性仅在读取操作完成后才有效。<h4 id=\"事件：\"><a href=\"#事件：\" class=\"headerlink\" title=\"事件：\"></a>事件：</h4></li>\n<li>继承自EventTarget，所以所有这些事件也可以通过addEventListener方法使用。</li>\n<li>FileReader.onabort：中断时触发</li>\n<li>FileReader.onerror：错误时触发</li>\n<li>FileReader.onload：读取操作完成时触发</li>\n<li>FileReader.onloadstart：</li>\n<li>FileReader.onloadend：</li>\n<li>FileReader.onprogress：处理progress事件。该事件在读取Blob时触发。<h4 id=\"方法：-1\"><a href=\"#方法：-1\" class=\"headerlink\" title=\"方法：\"></a>方法：</h4></li>\n<li>FileReader.abort()：终止操作</li>\n<li>FileReader.readAsArrayBuffer()</li>\n<li>FileReader.readAsBinaryString()非标准的</li>\n<li>FileReader.readAsDataURL()</li>\n<li>FileReader.readAsText()<h4 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h4></li>\n<li>input图片展示<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;input type=&quot;file&quot; id=&quot;inputFile&quot;&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let inputFile = document.getElementById(&apos;inputFile&apos;)</span><br><span class=\"line\">    inputFile.addEventListener(&apos;change&apos;, () =&gt; &#123;</span><br><span class=\"line\">        let file = inputFile.files[0]</span><br><span class=\"line\">        let reader = new FileReader()</span><br><span class=\"line\">        reader.onload = function () &#123;</span><br><span class=\"line\">            let img = document.createElement(&apos;img&apos;)</span><br><span class=\"line\">            img.src = reader.result</span><br><span class=\"line\">            document.documentElement.appendChild(img)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reader.readAsDataURL(file)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"ObjectURL\"><a href=\"#ObjectURL\" class=\"headerlink\" title=\"ObjectURL\"></a>ObjectURL</h3><ul>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Web/API/URL/createObjectURL</a></li>\n<li><a href=\"https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/en-US/docs/Web/API/URL/revokeObjectURL</a></li>\n<li>objectURL = URL.createObjectURL(object);表示指定的File对象或Blob对象的url</li>\n<li>window.URL.revokeObjectURL(objectURL);释放一个现有的对象URL<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//选择图片并转换为对象URL显示</span><br><span class=\"line\">&lt;input type=&quot;file&quot; id=&quot;file1&quot;&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let inputFile = document.getElementById(&apos;file1&apos;)</span><br><span class=\"line\">    inputFile.addEventListener(&apos;change&apos;,()=&gt;&#123;</span><br><span class=\"line\">        let file = inputFile.files[0]</span><br><span class=\"line\">        let url = window.URL.createObjectURL(file)</span><br><span class=\"line\"></span><br><span class=\"line\">        let img = document.createElement(&apos;img&apos;)</span><br><span class=\"line\">        img.src = url</span><br><span class=\"line\">        document.documentElement.appendChild(img)</span><br><span class=\"line\"></span><br><span class=\"line\">        img.onload = function() &#123;</span><br><span class=\"line\">            window.URL.revokeObjectURL(url)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//展示pdf</span><br><span class=\"line\">&lt;input type=&quot;file&quot; id=&quot;file2&quot;&gt;</span><br><span class=\"line\">&lt;iframe src=&quot;&quot; frameborder=&quot;0&quot; id=&quot;view&quot;&gt;&lt;/iframe&gt;</span><br><span class=\"line\">&lt;script&gt;</span><br><span class=\"line\">    let pdfInput = document.getElementById(&apos;file2&apos;)</span><br><span class=\"line\">    pdfInput.addEventListener(&apos;change&apos;,()=&gt;&#123;</span><br><span class=\"line\">        let file = pdfInput.files[0]</span><br><span class=\"line\">        let url = window.URL.createObjectURL(file)</span><br><span class=\"line\">        var iframe = document.getElementById(&apos;view&apos;);</span><br><span class=\"line\">        iframe.setAttribute(&apos;src&apos;, url);</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&lt;/script&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"js-深浅拷贝","date":"2019-01-06T02:53:30.000Z","_content":"\n##### 概念\n- https://mp.weixin.qq.com/s/scz9gRJeh7PM6GJ7wvnTsA\n##### 方法1：不考虑循环情况\n```\nfunction clone(value) {\n    if (Array.isArray(value)) {\n        return value.map(clone)\n    } else if (value && typeof value === 'object') {\n        const res = {}\n        for (const key in value) {\n            res[key] = clone(value[key])\n        }\n        return res\n    } else {\n        return value\n    }\n}\n```\n##### 方法2：考虑循环嵌套情况\n```\nfunction deepCopy(obj, cache = []) {\n    // just return if obj is immutable value\n    if (obj === null || typeof obj !== 'object') {\n        return obj\n    }\n\n    // if obj is hit, it is in circular structure\n    const hit = cache.filter(c => c.original === obj)[0]\n    if (hit) {\n        return hit.copy\n    }\n\n    const copy = Array.isArray(obj) ? [] : {}\n    // put the copy into cache at first\n    // because we want to refer it in recursive deepCopy\n    cache.push({\n        original: obj,\n        copy\n    })\n\n    Object.keys(obj).forEach(key => {\n        copy[key] = deepCopy(obj[key], cache)\n    })\n\n    return copy\n}\n```\n","source":"_posts/js-深浅拷贝.md","raw":"---\ntitle: js-深浅拷贝\ndate: 2019-01-06 10:53:30\ntags: [js,深拷贝]\ncategories: js\n---\n\n##### 概念\n- https://mp.weixin.qq.com/s/scz9gRJeh7PM6GJ7wvnTsA\n##### 方法1：不考虑循环情况\n```\nfunction clone(value) {\n    if (Array.isArray(value)) {\n        return value.map(clone)\n    } else if (value && typeof value === 'object') {\n        const res = {}\n        for (const key in value) {\n            res[key] = clone(value[key])\n        }\n        return res\n    } else {\n        return value\n    }\n}\n```\n##### 方法2：考虑循环嵌套情况\n```\nfunction deepCopy(obj, cache = []) {\n    // just return if obj is immutable value\n    if (obj === null || typeof obj !== 'object') {\n        return obj\n    }\n\n    // if obj is hit, it is in circular structure\n    const hit = cache.filter(c => c.original === obj)[0]\n    if (hit) {\n        return hit.copy\n    }\n\n    const copy = Array.isArray(obj) ? [] : {}\n    // put the copy into cache at first\n    // because we want to refer it in recursive deepCopy\n    cache.push({\n        original: obj,\n        copy\n    })\n\n    Object.keys(obj).forEach(key => {\n        copy[key] = deepCopy(obj[key], cache)\n    })\n\n    return copy\n}\n```\n","slug":"js-深浅拷贝","published":1,"updated":"2019-01-06T02:56:06.974Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob6p001ae0jcltsrf5aw","content":"<h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h5><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/scz9gRJeh7PM6GJ7wvnTsA\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/scz9gRJeh7PM6GJ7wvnTsA</a><h5 id=\"方法1：不考虑循环情况\"><a href=\"#方法1：不考虑循环情况\" class=\"headerlink\" title=\"方法1：不考虑循环情况\"></a>方法1：不考虑循环情况</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function clone(value) &#123;</span><br><span class=\"line\">    if (Array.isArray(value)) &#123;</span><br><span class=\"line\">        return value.map(clone)</span><br><span class=\"line\">    &#125; else if (value &amp;&amp; typeof value === &apos;object&apos;) &#123;</span><br><span class=\"line\">        const res = &#123;&#125;</span><br><span class=\"line\">        for (const key in value) &#123;</span><br><span class=\"line\">            res[key] = clone(value[key])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"方法2：考虑循环嵌套情况\"><a href=\"#方法2：考虑循环嵌套情况\" class=\"headerlink\" title=\"方法2：考虑循环嵌套情况\"></a>方法2：考虑循环嵌套情况</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function deepCopy(obj, cache = []) &#123;</span><br><span class=\"line\">    // just return if obj is immutable value</span><br><span class=\"line\">    if (obj === null || typeof obj !== &apos;object&apos;) &#123;</span><br><span class=\"line\">        return obj</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // if obj is hit, it is in circular structure</span><br><span class=\"line\">    const hit = cache.filter(c =&gt; c.original === obj)[0]</span><br><span class=\"line\">    if (hit) &#123;</span><br><span class=\"line\">        return hit.copy</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const copy = Array.isArray(obj) ? [] : &#123;&#125;</span><br><span class=\"line\">    // put the copy into cache at first</span><br><span class=\"line\">    // because we want to refer it in recursive deepCopy</span><br><span class=\"line\">    cache.push(&#123;</span><br><span class=\"line\">        original: obj,</span><br><span class=\"line\">        copy</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class=\"line\">        copy[key] = deepCopy(obj[key], cache)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    return copy</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"概念\"><a href=\"#概念\" class=\"headerlink\" title=\"概念\"></a>概念</h5><ul>\n<li><a href=\"https://mp.weixin.qq.com/s/scz9gRJeh7PM6GJ7wvnTsA\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/scz9gRJeh7PM6GJ7wvnTsA</a><h5 id=\"方法1：不考虑循环情况\"><a href=\"#方法1：不考虑循环情况\" class=\"headerlink\" title=\"方法1：不考虑循环情况\"></a>方法1：不考虑循环情况</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function clone(value) &#123;</span><br><span class=\"line\">    if (Array.isArray(value)) &#123;</span><br><span class=\"line\">        return value.map(clone)</span><br><span class=\"line\">    &#125; else if (value &amp;&amp; typeof value === &apos;object&apos;) &#123;</span><br><span class=\"line\">        const res = &#123;&#125;</span><br><span class=\"line\">        for (const key in value) &#123;</span><br><span class=\"line\">            res[key] = clone(value[key])</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return res</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        return value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"方法2：考虑循环嵌套情况\"><a href=\"#方法2：考虑循环嵌套情况\" class=\"headerlink\" title=\"方法2：考虑循环嵌套情况\"></a>方法2：考虑循环嵌套情况</h5><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function deepCopy(obj, cache = []) &#123;</span><br><span class=\"line\">    // just return if obj is immutable value</span><br><span class=\"line\">    if (obj === null || typeof obj !== &apos;object&apos;) &#123;</span><br><span class=\"line\">        return obj</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    // if obj is hit, it is in circular structure</span><br><span class=\"line\">    const hit = cache.filter(c =&gt; c.original === obj)[0]</span><br><span class=\"line\">    if (hit) &#123;</span><br><span class=\"line\">        return hit.copy</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    const copy = Array.isArray(obj) ? [] : &#123;&#125;</span><br><span class=\"line\">    // put the copy into cache at first</span><br><span class=\"line\">    // because we want to refer it in recursive deepCopy</span><br><span class=\"line\">    cache.push(&#123;</span><br><span class=\"line\">        original: obj,</span><br><span class=\"line\">        copy</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    Object.keys(obj).forEach(key =&gt; &#123;</span><br><span class=\"line\">        copy[key] = deepCopy(obj[key], cache)</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    return copy</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"flexible布局以及1px边框解决方案","date":"2019-01-20T15:11:44.000Z","_content":"\n##### 视口概念\n- https://crazyaguai.github.io/2019/01/20/%E8%A7%86%E5%8F%A3%E6%A6%82%E5%BF%B5/\n##### flexble布局\n1. 把布局视口分为10份，设置html元素font-size大小。\n```\nvar rem = docEl.clientWidth / 10\ndocEl.style.fontSize = rem + 'px'\n```\n2. 基本宽度 = UI设计稿宽度 / 10，元素尺寸使用rem单位，即元素尺寸 = 元素设计稿尺寸 / 基本宽度，这样实现按比例自适应尺寸。\n3. 转换rem尺寸方式\n- 使用postcss插件：[postcss-plugin-px2rem](https://github.com/pigcan/postcss-plugin-px2rem)\n```\n//.postcssrc.js文件配置\nmodule.exports = {\n    \"plugins\": {\n        \"postcss-import\": {},\n        \"postcss-url\": {},\n        \"postcss-plugin-px2rem\": {\n            rootValue: 37.5,\n            propBlackList: ['border'],//border不转换\n            exclude: [/((src)|(node_modules))/],//特定文件夹不转换\n        },\n        // 浏览器兼容部分在package.json中\n        \"autoprefixer\": {}\n    }\n}\n```\n- 编写sass函数转换\n```\n@function px2em($px, $base-font-size: 37.5px) {\n    @return ($px / $base-font-size) * 1rem;\n}\n```\n4. 1px边框解决方法\n```\nfunction fix1px() {\n    var metas = document.querySelectorAll('meta')\n    metas.forEach(item=>{\n        if(item.name == 'viewport'){\n            document.getElementsByTagName('head')[0].removeChild(item)\n        }\n    })\n\n    //解决1px线问题\n    var scale = 1/dpr\n    var meta = document.createElement('meta')\n    meta.setAttribute('name', 'viewport')\n    meta.setAttribute('content', 'width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no')\n    document.getElementsByTagName('head')[0].appendChild(meta)\n}\n```\n- dpr=2时meta\n```\n<meta name=\"viewport\" content=\"width=device-width initial-scale=0.5 maximum-scale=0.5 minimum-scale=0.5 user-scalable=no\">\n```\n- 解读：首先设置width=device-width，布局视口=理想视口（此时1css像素=2物理像素），同时理想视口=视觉视口，因此布局视口=视觉视口，initial-scale=0.5，会使布局视口和视觉视口扩大为原来2倍，布局视口仍然=视觉视口，所以会在整个屏幕显示，同时1css像素=1物理像素，解决了边框问题。\n- 开发时，如果使用postcss插件，配置不转换边框，需要转换的border属性（比如用border画三角形）可以自己转换成rem尺寸。\n5. 方案代码\n```\n(function flexible(window, document) {\n    var docEl = document.documentElement\n    var dpr = window.devicePixelRatio || 1\n    // adjust body font size\n    function setBodyFontSize() {\n        if (document.body) {\n            document.body.style.fontSize = (12 * dpr) + 'px'\n        }\n        else {\n            document.addEventListener('DOMContentLoaded', setBodyFontSize)\n        }\n    }\n\n    setBodyFontSize();\n\n    // set 1rem = viewWidth / 10\n    function setRemUnit() {\n        fix1px()\n        var rem = docEl.clientWidth / 10\n        docEl.style.fontSize = rem + 'px'\n    }\n\n    setRemUnit()\n\n    // reset rem unit on page resize\n    window.addEventListener('resize', setRemUnit)\n    window.addEventListener('pageshow', function (e) {\n        if (e.persisted) {\n            setRemUnit()\n        }\n    })\n\n    // detect 0.5px supports\n    if (dpr >= 2) {\n        var fakeBody = document.createElement('body')\n        var testElement = document.createElement('div')\n        testElement.style.border = '.5px solid transparent'\n        fakeBody.appendChild(testElement)\n        docEl.appendChild(fakeBody)\n        if (testElement.offsetHeight === 1) {\n            docEl.classList.add('hairlines')\n        }\n        docEl.removeChild(fakeBody)\n    }\n\n    function fix1px() {\n        var metas = document.querySelectorAll('meta')\n        metas.forEach(item=>{\n            if(item.name == 'viewport'){\n                document.getElementsByTagName('head')[0].removeChild(item)\n            }\n        })\n\n        //解决1px线问题\n        var scale = 1/dpr\n        var meta = document.createElement('meta')\n        meta.setAttribute('name', 'viewport')\n        meta.setAttribute('content', 'width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no')\n        document.getElementsByTagName('head')[0].appendChild(meta)\n    }\n}(window, document))\n```\n","source":"_posts/flexible布局以及1px边框解决方案.md","raw":"---\ntitle: flexible布局以及1px边框解决方案\ndate: 2019-01-20 23:11:44\ntags: [flexible,h5]\ncategories: flexible\n---\n\n##### 视口概念\n- https://crazyaguai.github.io/2019/01/20/%E8%A7%86%E5%8F%A3%E6%A6%82%E5%BF%B5/\n##### flexble布局\n1. 把布局视口分为10份，设置html元素font-size大小。\n```\nvar rem = docEl.clientWidth / 10\ndocEl.style.fontSize = rem + 'px'\n```\n2. 基本宽度 = UI设计稿宽度 / 10，元素尺寸使用rem单位，即元素尺寸 = 元素设计稿尺寸 / 基本宽度，这样实现按比例自适应尺寸。\n3. 转换rem尺寸方式\n- 使用postcss插件：[postcss-plugin-px2rem](https://github.com/pigcan/postcss-plugin-px2rem)\n```\n//.postcssrc.js文件配置\nmodule.exports = {\n    \"plugins\": {\n        \"postcss-import\": {},\n        \"postcss-url\": {},\n        \"postcss-plugin-px2rem\": {\n            rootValue: 37.5,\n            propBlackList: ['border'],//border不转换\n            exclude: [/((src)|(node_modules))/],//特定文件夹不转换\n        },\n        // 浏览器兼容部分在package.json中\n        \"autoprefixer\": {}\n    }\n}\n```\n- 编写sass函数转换\n```\n@function px2em($px, $base-font-size: 37.5px) {\n    @return ($px / $base-font-size) * 1rem;\n}\n```\n4. 1px边框解决方法\n```\nfunction fix1px() {\n    var metas = document.querySelectorAll('meta')\n    metas.forEach(item=>{\n        if(item.name == 'viewport'){\n            document.getElementsByTagName('head')[0].removeChild(item)\n        }\n    })\n\n    //解决1px线问题\n    var scale = 1/dpr\n    var meta = document.createElement('meta')\n    meta.setAttribute('name', 'viewport')\n    meta.setAttribute('content', 'width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no')\n    document.getElementsByTagName('head')[0].appendChild(meta)\n}\n```\n- dpr=2时meta\n```\n<meta name=\"viewport\" content=\"width=device-width initial-scale=0.5 maximum-scale=0.5 minimum-scale=0.5 user-scalable=no\">\n```\n- 解读：首先设置width=device-width，布局视口=理想视口（此时1css像素=2物理像素），同时理想视口=视觉视口，因此布局视口=视觉视口，initial-scale=0.5，会使布局视口和视觉视口扩大为原来2倍，布局视口仍然=视觉视口，所以会在整个屏幕显示，同时1css像素=1物理像素，解决了边框问题。\n- 开发时，如果使用postcss插件，配置不转换边框，需要转换的border属性（比如用border画三角形）可以自己转换成rem尺寸。\n5. 方案代码\n```\n(function flexible(window, document) {\n    var docEl = document.documentElement\n    var dpr = window.devicePixelRatio || 1\n    // adjust body font size\n    function setBodyFontSize() {\n        if (document.body) {\n            document.body.style.fontSize = (12 * dpr) + 'px'\n        }\n        else {\n            document.addEventListener('DOMContentLoaded', setBodyFontSize)\n        }\n    }\n\n    setBodyFontSize();\n\n    // set 1rem = viewWidth / 10\n    function setRemUnit() {\n        fix1px()\n        var rem = docEl.clientWidth / 10\n        docEl.style.fontSize = rem + 'px'\n    }\n\n    setRemUnit()\n\n    // reset rem unit on page resize\n    window.addEventListener('resize', setRemUnit)\n    window.addEventListener('pageshow', function (e) {\n        if (e.persisted) {\n            setRemUnit()\n        }\n    })\n\n    // detect 0.5px supports\n    if (dpr >= 2) {\n        var fakeBody = document.createElement('body')\n        var testElement = document.createElement('div')\n        testElement.style.border = '.5px solid transparent'\n        fakeBody.appendChild(testElement)\n        docEl.appendChild(fakeBody)\n        if (testElement.offsetHeight === 1) {\n            docEl.classList.add('hairlines')\n        }\n        docEl.removeChild(fakeBody)\n    }\n\n    function fix1px() {\n        var metas = document.querySelectorAll('meta')\n        metas.forEach(item=>{\n            if(item.name == 'viewport'){\n                document.getElementsByTagName('head')[0].removeChild(item)\n            }\n        })\n\n        //解决1px线问题\n        var scale = 1/dpr\n        var meta = document.createElement('meta')\n        meta.setAttribute('name', 'viewport')\n        meta.setAttribute('content', 'width=device-width,initial-scale=' + scale + ', maximum-scale=' + scale + ', minimum-scale=' + scale + ', user-scalable=no')\n        document.getElementsByTagName('head')[0].appendChild(meta)\n    }\n}(window, document))\n```\n","slug":"flexible布局以及1px边框解决方案","published":1,"updated":"2019-01-20T15:12:49.669Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob6q001de0jctpy14fim","content":"<h5 id=\"视口概念\"><a href=\"#视口概念\" class=\"headerlink\" title=\"视口概念\"></a>视口概念</h5><ul>\n<li><a href=\"https://crazyaguai.github.io/2019/01/20/%E8%A7%86%E5%8F%A3%E6%A6%82%E5%BF%B5/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2019/01/20/%E8%A7%86%E5%8F%A3%E6%A6%82%E5%BF%B5/</a><h5 id=\"flexble布局\"><a href=\"#flexble布局\" class=\"headerlink\" title=\"flexble布局\"></a>flexble布局</h5></li>\n</ul>\n<ol>\n<li><p>把布局视口分为10份，设置html元素font-size大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var rem = docEl.clientWidth / 10</span><br><span class=\"line\">docEl.style.fontSize = rem + &apos;px&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>基本宽度 = UI设计稿宽度 / 10，元素尺寸使用rem单位，即元素尺寸 = 元素设计稿尺寸 / 基本宽度，这样实现按比例自适应尺寸。</p>\n</li>\n<li>转换rem尺寸方式</li>\n</ol>\n<ul>\n<li><p>使用postcss插件：<a href=\"https://github.com/pigcan/postcss-plugin-px2rem\">postcss-plugin-px2rem</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//.postcssrc.js文件配置</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    &quot;plugins&quot;: &#123;</span><br><span class=\"line\">        &quot;postcss-import&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-url&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-plugin-px2rem&quot;: &#123;</span><br><span class=\"line\">            rootValue: 37.5,</span><br><span class=\"line\">            propBlackList: [&apos;border&apos;],//border不转换</span><br><span class=\"line\">            exclude: [/((src)|(node_modules))/],//特定文件夹不转换</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 浏览器兼容部分在package.json中</span><br><span class=\"line\">        &quot;autoprefixer&quot;: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写sass函数转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function px2em($px, $base-font-size: 37.5px) &#123;</span><br><span class=\"line\">    @return ($px / $base-font-size) * 1rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"4\">\n<li>1px边框解决方法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fix1px() &#123;</span><br><span class=\"line\">    var metas = document.querySelectorAll(&apos;meta&apos;)</span><br><span class=\"line\">    metas.forEach(item=&gt;&#123;</span><br><span class=\"line\">        if(item.name == &apos;viewport&apos;)&#123;</span><br><span class=\"line\">            document.getElementsByTagName(&apos;head&apos;)[0].removeChild(item)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    //解决1px线问题</span><br><span class=\"line\">    var scale = 1/dpr</span><br><span class=\"line\">    var meta = document.createElement(&apos;meta&apos;)</span><br><span class=\"line\">    meta.setAttribute(&apos;name&apos;, &apos;viewport&apos;)</span><br><span class=\"line\">    meta.setAttribute(&apos;content&apos;, &apos;width=device-width,initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;, minimum-scale=&apos; + scale + &apos;, user-scalable=no&apos;)</span><br><span class=\"line\">    document.getElementsByTagName(&apos;head&apos;)[0].appendChild(meta)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li><p>dpr=2时meta</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width initial-scale=0.5 maximum-scale=0.5 minimum-scale=0.5 user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解读：首先设置width=device-width，布局视口=理想视口（此时1css像素=2物理像素），同时理想视口=视觉视口，因此布局视口=视觉视口，initial-scale=0.5，会使布局视口和视觉视口扩大为原来2倍，布局视口仍然=视觉视口，所以会在整个屏幕显示，同时1css像素=1物理像素，解决了边框问题。</p>\n</li>\n<li>开发时，如果使用postcss插件，配置不转换边框，需要转换的border属性（比如用border画三角形）可以自己转换成rem尺寸。</li>\n</ul>\n<ol start=\"5\">\n<li>方案代码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function flexible(window, document) &#123;</span><br><span class=\"line\">    var docEl = document.documentElement</span><br><span class=\"line\">    var dpr = window.devicePixelRatio || 1</span><br><span class=\"line\">    // adjust body font size</span><br><span class=\"line\">    function setBodyFontSize() &#123;</span><br><span class=\"line\">        if (document.body) &#123;</span><br><span class=\"line\">            document.body.style.fontSize = (12 * dpr) + &apos;px&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            document.addEventListener(&apos;DOMContentLoaded&apos;, setBodyFontSize)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    setBodyFontSize();</span><br><span class=\"line\"></span><br><span class=\"line\">    // set 1rem = viewWidth / 10</span><br><span class=\"line\">    function setRemUnit() &#123;</span><br><span class=\"line\">        fix1px()</span><br><span class=\"line\">        var rem = docEl.clientWidth / 10</span><br><span class=\"line\">        docEl.style.fontSize = rem + &apos;px&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    setRemUnit()</span><br><span class=\"line\"></span><br><span class=\"line\">    // reset rem unit on page resize</span><br><span class=\"line\">    window.addEventListener(&apos;resize&apos;, setRemUnit)</span><br><span class=\"line\">    window.addEventListener(&apos;pageshow&apos;, function (e) &#123;</span><br><span class=\"line\">        if (e.persisted) &#123;</span><br><span class=\"line\">            setRemUnit()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    // detect 0.5px supports</span><br><span class=\"line\">    if (dpr &gt;= 2) &#123;</span><br><span class=\"line\">        var fakeBody = document.createElement(&apos;body&apos;)</span><br><span class=\"line\">        var testElement = document.createElement(&apos;div&apos;)</span><br><span class=\"line\">        testElement.style.border = &apos;.5px solid transparent&apos;</span><br><span class=\"line\">        fakeBody.appendChild(testElement)</span><br><span class=\"line\">        docEl.appendChild(fakeBody)</span><br><span class=\"line\">        if (testElement.offsetHeight === 1) &#123;</span><br><span class=\"line\">            docEl.classList.add(&apos;hairlines&apos;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        docEl.removeChild(fakeBody)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function fix1px() &#123;</span><br><span class=\"line\">        var metas = document.querySelectorAll(&apos;meta&apos;)</span><br><span class=\"line\">        metas.forEach(item=&gt;&#123;</span><br><span class=\"line\">            if(item.name == &apos;viewport&apos;)&#123;</span><br><span class=\"line\">                document.getElementsByTagName(&apos;head&apos;)[0].removeChild(item)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        //解决1px线问题</span><br><span class=\"line\">        var scale = 1/dpr</span><br><span class=\"line\">        var meta = document.createElement(&apos;meta&apos;)</span><br><span class=\"line\">        meta.setAttribute(&apos;name&apos;, &apos;viewport&apos;)</span><br><span class=\"line\">        meta.setAttribute(&apos;content&apos;, &apos;width=device-width,initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;, minimum-scale=&apos; + scale + &apos;, user-scalable=no&apos;)</span><br><span class=\"line\">        document.getElementsByTagName(&apos;head&apos;)[0].appendChild(meta)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(window, document))</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h5 id=\"视口概念\"><a href=\"#视口概念\" class=\"headerlink\" title=\"视口概念\"></a>视口概念</h5><ul>\n<li><a href=\"https://crazyaguai.github.io/2019/01/20/%E8%A7%86%E5%8F%A3%E6%A6%82%E5%BF%B5/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2019/01/20/%E8%A7%86%E5%8F%A3%E6%A6%82%E5%BF%B5/</a><h5 id=\"flexble布局\"><a href=\"#flexble布局\" class=\"headerlink\" title=\"flexble布局\"></a>flexble布局</h5></li>\n</ul>\n<ol>\n<li><p>把布局视口分为10份，设置html元素font-size大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var rem = docEl.clientWidth / 10</span><br><span class=\"line\">docEl.style.fontSize = rem + &apos;px&apos;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>基本宽度 = UI设计稿宽度 / 10，元素尺寸使用rem单位，即元素尺寸 = 元素设计稿尺寸 / 基本宽度，这样实现按比例自适应尺寸。</p>\n</li>\n<li>转换rem尺寸方式</li>\n</ol>\n<ul>\n<li><p>使用postcss插件：<a href=\"https://github.com/pigcan/postcss-plugin-px2rem\">postcss-plugin-px2rem</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//.postcssrc.js文件配置</span><br><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    &quot;plugins&quot;: &#123;</span><br><span class=\"line\">        &quot;postcss-import&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-url&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-plugin-px2rem&quot;: &#123;</span><br><span class=\"line\">            rootValue: 37.5,</span><br><span class=\"line\">            propBlackList: [&apos;border&apos;],//border不转换</span><br><span class=\"line\">            exclude: [/((src)|(node_modules))/],//特定文件夹不转换</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        // 浏览器兼容部分在package.json中</span><br><span class=\"line\">        &quot;autoprefixer&quot;: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>编写sass函数转换</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@function px2em($px, $base-font-size: 37.5px) &#123;</span><br><span class=\"line\">    @return ($px / $base-font-size) * 1rem;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"4\">\n<li>1px边框解决方法<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function fix1px() &#123;</span><br><span class=\"line\">    var metas = document.querySelectorAll(&apos;meta&apos;)</span><br><span class=\"line\">    metas.forEach(item=&gt;&#123;</span><br><span class=\"line\">        if(item.name == &apos;viewport&apos;)&#123;</span><br><span class=\"line\">            document.getElementsByTagName(&apos;head&apos;)[0].removeChild(item)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    //解决1px线问题</span><br><span class=\"line\">    var scale = 1/dpr</span><br><span class=\"line\">    var meta = document.createElement(&apos;meta&apos;)</span><br><span class=\"line\">    meta.setAttribute(&apos;name&apos;, &apos;viewport&apos;)</span><br><span class=\"line\">    meta.setAttribute(&apos;content&apos;, &apos;width=device-width,initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;, minimum-scale=&apos; + scale + &apos;, user-scalable=no&apos;)</span><br><span class=\"line\">    document.getElementsByTagName(&apos;head&apos;)[0].appendChild(meta)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li><p>dpr=2时meta</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width initial-scale=0.5 maximum-scale=0.5 minimum-scale=0.5 user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>解读：首先设置width=device-width，布局视口=理想视口（此时1css像素=2物理像素），同时理想视口=视觉视口，因此布局视口=视觉视口，initial-scale=0.5，会使布局视口和视觉视口扩大为原来2倍，布局视口仍然=视觉视口，所以会在整个屏幕显示，同时1css像素=1物理像素，解决了边框问题。</p>\n</li>\n<li>开发时，如果使用postcss插件，配置不转换边框，需要转换的border属性（比如用border画三角形）可以自己转换成rem尺寸。</li>\n</ul>\n<ol start=\"5\">\n<li>方案代码<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function flexible(window, document) &#123;</span><br><span class=\"line\">    var docEl = document.documentElement</span><br><span class=\"line\">    var dpr = window.devicePixelRatio || 1</span><br><span class=\"line\">    // adjust body font size</span><br><span class=\"line\">    function setBodyFontSize() &#123;</span><br><span class=\"line\">        if (document.body) &#123;</span><br><span class=\"line\">            document.body.style.fontSize = (12 * dpr) + &apos;px&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        else &#123;</span><br><span class=\"line\">            document.addEventListener(&apos;DOMContentLoaded&apos;, setBodyFontSize)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    setBodyFontSize();</span><br><span class=\"line\"></span><br><span class=\"line\">    // set 1rem = viewWidth / 10</span><br><span class=\"line\">    function setRemUnit() &#123;</span><br><span class=\"line\">        fix1px()</span><br><span class=\"line\">        var rem = docEl.clientWidth / 10</span><br><span class=\"line\">        docEl.style.fontSize = rem + &apos;px&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    setRemUnit()</span><br><span class=\"line\"></span><br><span class=\"line\">    // reset rem unit on page resize</span><br><span class=\"line\">    window.addEventListener(&apos;resize&apos;, setRemUnit)</span><br><span class=\"line\">    window.addEventListener(&apos;pageshow&apos;, function (e) &#123;</span><br><span class=\"line\">        if (e.persisted) &#123;</span><br><span class=\"line\">            setRemUnit()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">    // detect 0.5px supports</span><br><span class=\"line\">    if (dpr &gt;= 2) &#123;</span><br><span class=\"line\">        var fakeBody = document.createElement(&apos;body&apos;)</span><br><span class=\"line\">        var testElement = document.createElement(&apos;div&apos;)</span><br><span class=\"line\">        testElement.style.border = &apos;.5px solid transparent&apos;</span><br><span class=\"line\">        fakeBody.appendChild(testElement)</span><br><span class=\"line\">        docEl.appendChild(fakeBody)</span><br><span class=\"line\">        if (testElement.offsetHeight === 1) &#123;</span><br><span class=\"line\">            docEl.classList.add(&apos;hairlines&apos;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        docEl.removeChild(fakeBody)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    function fix1px() &#123;</span><br><span class=\"line\">        var metas = document.querySelectorAll(&apos;meta&apos;)</span><br><span class=\"line\">        metas.forEach(item=&gt;&#123;</span><br><span class=\"line\">            if(item.name == &apos;viewport&apos;)&#123;</span><br><span class=\"line\">                document.getElementsByTagName(&apos;head&apos;)[0].removeChild(item)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;)</span><br><span class=\"line\"></span><br><span class=\"line\">        //解决1px线问题</span><br><span class=\"line\">        var scale = 1/dpr</span><br><span class=\"line\">        var meta = document.createElement(&apos;meta&apos;)</span><br><span class=\"line\">        meta.setAttribute(&apos;name&apos;, &apos;viewport&apos;)</span><br><span class=\"line\">        meta.setAttribute(&apos;content&apos;, &apos;width=device-width,initial-scale=&apos; + scale + &apos;, maximum-scale=&apos; + scale + &apos;, minimum-scale=&apos; + scale + &apos;, user-scalable=no&apos;)</span><br><span class=\"line\">        document.getElementsByTagName(&apos;head&apos;)[0].appendChild(meta)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(window, document))</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"js数据类型检测","date":"2019-01-15T07:52:17.000Z","_content":"\n#### typeof\n- 返回一个表示数据类型的字符串\n- 返回结果包括：number、boolean、string、symbol、object、undefined、function 等 7 种数据类型，**但不能判断 null、array 等**\n- 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了\"object\"。\n```\n// Numbers\ntypeof 37 === 'number';\ntypeof 3.14 === 'number';\ntypeof Math.LN2 === 'number';\ntypeof Infinity === 'number';\ntypeof NaN === 'number'; // 尽管NaN是\"Not-A-Number\"的缩写\ntypeof Number(1) === 'number'; // 但不要使用这种形式!\n\n// Strings\ntypeof \"\" === 'string';\ntypeof \"bla\" === 'string';\ntypeof (typeof 1) === 'string'; // typeof总是返回一个字符串\ntypeof String(\"abc\") === 'string'; // 但不要使用这种形式!\n\n// Booleans\ntypeof true === 'boolean';\ntypeof false === 'boolean';\ntypeof Boolean(true) === 'boolean'; // 但不要使用这种形式!\n\n// Symbols\ntypeof Symbol() === 'symbol';\ntypeof Symbol('foo') === 'symbol';\ntypeof Symbol.iterator === 'symbol';\n\n// Undefined\ntypeof undefined === 'undefined';\ntypeof declaredButUndefinedVariable === 'undefined';\ntypeof undeclaredVariable === 'undefined';\n\n// Objects\ntypeof {a:1} === 'object';\n\n// 使用Array.isArray 或者 Object.prototype.toString.call\n// 区分数组,普通对象\ntypeof [1, 2, 4] === 'object';\n\ntypeof new Date() === 'object';\n\n// 下面的容易令人迷惑，不要使用！\ntypeof new Boolean(true) === 'object';\ntypeof new Number(1) === 'object';\ntypeof new String(\"abc\") === 'object';\n\n// 函数\ntypeof function(){} === 'function';\ntypeof class C{} === 'function'\ntypeof Math.sin === 'function';\ntypeof new Function() === 'function';\n\n// null\ntypeof null === 'object';\n\n//new 操作符\nvar str = new String('String');\nvar num = new Number(100);\n\ntypeof str; // It will return 'object'\ntypeof num; // It will return 'object'\n\n// But there is a exception in case of Function constructor of Javascript\n\nvar func = new Function();\n\ntypeof func; // It will return 'function'\n```\n\n#### instanceof\n- instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性\n```\n[] instanceof Array; //true\n{} instanceof Object;//true\nnew Date() instanceof Date;//true\nnew RegExp() instanceof RegExp//true\n```\n- 对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建的是有一定的区别的\n```\nconsole.log(1 instanceof Number)//false\nconsole.log(new Number(1) instanceof Number)//true\n```\n- 类的原型继承中，我们最后检测出来的结果未必准确\n```\nvar arr = [1, 2, 3];\nconsole.log(arr instanceof Array) // true\nconsole.log(arr instanceof Object);  // true\nfunction fn(){}\nconsole.log(fn instanceof Function)// true\nconsole.log(fn instanceof Object)// true\n```\n- 不能检测 null 和 undefined\n#### ES6数组Array.isArray()\n```\nArray.isArray([]);   // true\n```\n\n#### 严格运算符 ===\n只能用于判断 null 和 undefined，因为这两种类型的值都是唯一的\n```\nvar a = null\ntypeof a // \"object\"\na === null // true\n```\n\n#### constructor\n- constructor 作用和 instanceof 非常相似。但 constructor 检测 Object 与 instanceof 不一样，**还可以处理基本数据类型的检测**。\n```\nvar aa=[1,2];\nconsole.log(aa.constructor===Array);//true\nconsole.log(aa.constructor===RegExp);//false\nconsole.log((1).constructor===Number);//true\nvar reg=/^$/;\nconsole.log(reg.constructor===RegExp);//true\nconsole.log(reg.constructor===Object);//false\n```\n- null 和 undefined 是无效的对象,不会有 constructor 存在。\n- 函数的 constructor 是不稳定的，这个主要体现在把类的原型进行重写。\n\n#### Object.prototype.toString.call()\n- 每个对象都有一个toString()方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 \"[object type]\"，其中type是对象的类型。\n- 关于 toString\n1. 本意是转换为字符串，但是某些 toString 方法不仅仅是转换为字符串\n2. 对于 Number、String，Boolean，Array，RegExp、Date、Function 原型上的 toString 方法都是把当前的数据类型转换为字符串的类型（它们的作用仅仅是用来转换为字符串的）\n3. Object 上的 toString 并不是用来转换为字符串的。\n- Object 上的 toString 它的作用是返回当前方法执行的主体（方法中的 this）所属类的详细信息。\n```\nObject.prototype.toString.call('') ;   // [object String]\nObject.prototype.toString.call(1) ;    // [object Number]\nObject.prototype.toString.call(true) ; // [object Boolean]\nObject.prototype.toString.call(undefined) ; // [object Undefined]\nObject.prototype.toString.call(null) ; // [object Null]\nObject.prototype.toString.call(new Function()) ; // [object Function]\nObject.prototype.toString.call(new Date()) ; // [object Date]\nObject.prototype.toString.call([]) ; // [object Array]\nObject.prototype.toString.call(new RegExp()) ; // [object RegExp]\nObject.prototype.toString.call(new Error()) ; // [object Error]\nObject.prototype.toString.call(document) ; // [object HTMLDocument]\nObject.prototype.toString.call(window) ; //[object global] window是全局对象global的引用\n```\n#### 整理\n- 来自https://mp.weixin.qq.com/s/l4U4lVt_sz7lqT43aTuaTA\n","source":"_posts/js数据类型检测.md","raw":"---\ntitle: js数据类型检测\ndate: 2019-01-15 15:52:17\ntags: [js,数据类型检测]\ncategories: js\n---\n\n#### typeof\n- 返回一个表示数据类型的字符串\n- 返回结果包括：number、boolean、string、symbol、object、undefined、function 等 7 种数据类型，**但不能判断 null、array 等**\n- 在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了\"object\"。\n```\n// Numbers\ntypeof 37 === 'number';\ntypeof 3.14 === 'number';\ntypeof Math.LN2 === 'number';\ntypeof Infinity === 'number';\ntypeof NaN === 'number'; // 尽管NaN是\"Not-A-Number\"的缩写\ntypeof Number(1) === 'number'; // 但不要使用这种形式!\n\n// Strings\ntypeof \"\" === 'string';\ntypeof \"bla\" === 'string';\ntypeof (typeof 1) === 'string'; // typeof总是返回一个字符串\ntypeof String(\"abc\") === 'string'; // 但不要使用这种形式!\n\n// Booleans\ntypeof true === 'boolean';\ntypeof false === 'boolean';\ntypeof Boolean(true) === 'boolean'; // 但不要使用这种形式!\n\n// Symbols\ntypeof Symbol() === 'symbol';\ntypeof Symbol('foo') === 'symbol';\ntypeof Symbol.iterator === 'symbol';\n\n// Undefined\ntypeof undefined === 'undefined';\ntypeof declaredButUndefinedVariable === 'undefined';\ntypeof undeclaredVariable === 'undefined';\n\n// Objects\ntypeof {a:1} === 'object';\n\n// 使用Array.isArray 或者 Object.prototype.toString.call\n// 区分数组,普通对象\ntypeof [1, 2, 4] === 'object';\n\ntypeof new Date() === 'object';\n\n// 下面的容易令人迷惑，不要使用！\ntypeof new Boolean(true) === 'object';\ntypeof new Number(1) === 'object';\ntypeof new String(\"abc\") === 'object';\n\n// 函数\ntypeof function(){} === 'function';\ntypeof class C{} === 'function'\ntypeof Math.sin === 'function';\ntypeof new Function() === 'function';\n\n// null\ntypeof null === 'object';\n\n//new 操作符\nvar str = new String('String');\nvar num = new Number(100);\n\ntypeof str; // It will return 'object'\ntypeof num; // It will return 'object'\n\n// But there is a exception in case of Function constructor of Javascript\n\nvar func = new Function();\n\ntypeof func; // It will return 'function'\n```\n\n#### instanceof\n- instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性\n```\n[] instanceof Array; //true\n{} instanceof Object;//true\nnew Date() instanceof Date;//true\nnew RegExp() instanceof RegExp//true\n```\n- 对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建的是有一定的区别的\n```\nconsole.log(1 instanceof Number)//false\nconsole.log(new Number(1) instanceof Number)//true\n```\n- 类的原型继承中，我们最后检测出来的结果未必准确\n```\nvar arr = [1, 2, 3];\nconsole.log(arr instanceof Array) // true\nconsole.log(arr instanceof Object);  // true\nfunction fn(){}\nconsole.log(fn instanceof Function)// true\nconsole.log(fn instanceof Object)// true\n```\n- 不能检测 null 和 undefined\n#### ES6数组Array.isArray()\n```\nArray.isArray([]);   // true\n```\n\n#### 严格运算符 ===\n只能用于判断 null 和 undefined，因为这两种类型的值都是唯一的\n```\nvar a = null\ntypeof a // \"object\"\na === null // true\n```\n\n#### constructor\n- constructor 作用和 instanceof 非常相似。但 constructor 检测 Object 与 instanceof 不一样，**还可以处理基本数据类型的检测**。\n```\nvar aa=[1,2];\nconsole.log(aa.constructor===Array);//true\nconsole.log(aa.constructor===RegExp);//false\nconsole.log((1).constructor===Number);//true\nvar reg=/^$/;\nconsole.log(reg.constructor===RegExp);//true\nconsole.log(reg.constructor===Object);//false\n```\n- null 和 undefined 是无效的对象,不会有 constructor 存在。\n- 函数的 constructor 是不稳定的，这个主要体现在把类的原型进行重写。\n\n#### Object.prototype.toString.call()\n- 每个对象都有一个toString()方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 \"[object type]\"，其中type是对象的类型。\n- 关于 toString\n1. 本意是转换为字符串，但是某些 toString 方法不仅仅是转换为字符串\n2. 对于 Number、String，Boolean，Array，RegExp、Date、Function 原型上的 toString 方法都是把当前的数据类型转换为字符串的类型（它们的作用仅仅是用来转换为字符串的）\n3. Object 上的 toString 并不是用来转换为字符串的。\n- Object 上的 toString 它的作用是返回当前方法执行的主体（方法中的 this）所属类的详细信息。\n```\nObject.prototype.toString.call('') ;   // [object String]\nObject.prototype.toString.call(1) ;    // [object Number]\nObject.prototype.toString.call(true) ; // [object Boolean]\nObject.prototype.toString.call(undefined) ; // [object Undefined]\nObject.prototype.toString.call(null) ; // [object Null]\nObject.prototype.toString.call(new Function()) ; // [object Function]\nObject.prototype.toString.call(new Date()) ; // [object Date]\nObject.prototype.toString.call([]) ; // [object Array]\nObject.prototype.toString.call(new RegExp()) ; // [object RegExp]\nObject.prototype.toString.call(new Error()) ; // [object Error]\nObject.prototype.toString.call(document) ; // [object HTMLDocument]\nObject.prototype.toString.call(window) ; //[object global] window是全局对象global的引用\n```\n#### 整理\n- 来自https://mp.weixin.qq.com/s/l4U4lVt_sz7lqT43aTuaTA\n","slug":"js数据类型检测","published":1,"updated":"2019-02-13T05:37:46.161Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob6u001ie0jcnhfso1ss","content":"<h4 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h4><ul>\n<li>返回一个表示数据类型的字符串</li>\n<li>返回结果包括：number、boolean、string、symbol、object、undefined、function 等 7 种数据类型，<strong>但不能判断 null、array 等</strong></li>\n<li>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了”object”。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Numbers</span><br><span class=\"line\">typeof 37 === &apos;number&apos;;</span><br><span class=\"line\">typeof 3.14 === &apos;number&apos;;</span><br><span class=\"line\">typeof Math.LN2 === &apos;number&apos;;</span><br><span class=\"line\">typeof Infinity === &apos;number&apos;;</span><br><span class=\"line\">typeof NaN === &apos;number&apos;; // 尽管NaN是&quot;Not-A-Number&quot;的缩写</span><br><span class=\"line\">typeof Number(1) === &apos;number&apos;; // 但不要使用这种形式!</span><br><span class=\"line\"></span><br><span class=\"line\">// Strings</span><br><span class=\"line\">typeof &quot;&quot; === &apos;string&apos;;</span><br><span class=\"line\">typeof &quot;bla&quot; === &apos;string&apos;;</span><br><span class=\"line\">typeof (typeof 1) === &apos;string&apos;; // typeof总是返回一个字符串</span><br><span class=\"line\">typeof String(&quot;abc&quot;) === &apos;string&apos;; // 但不要使用这种形式!</span><br><span class=\"line\"></span><br><span class=\"line\">// Booleans</span><br><span class=\"line\">typeof true === &apos;boolean&apos;;</span><br><span class=\"line\">typeof false === &apos;boolean&apos;;</span><br><span class=\"line\">typeof Boolean(true) === &apos;boolean&apos;; // 但不要使用这种形式!</span><br><span class=\"line\"></span><br><span class=\"line\">// Symbols</span><br><span class=\"line\">typeof Symbol() === &apos;symbol&apos;;</span><br><span class=\"line\">typeof Symbol(&apos;foo&apos;) === &apos;symbol&apos;;</span><br><span class=\"line\">typeof Symbol.iterator === &apos;symbol&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Undefined</span><br><span class=\"line\">typeof undefined === &apos;undefined&apos;;</span><br><span class=\"line\">typeof declaredButUndefinedVariable === &apos;undefined&apos;;</span><br><span class=\"line\">typeof undeclaredVariable === &apos;undefined&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Objects</span><br><span class=\"line\">typeof &#123;a:1&#125; === &apos;object&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用Array.isArray 或者 Object.prototype.toString.call</span><br><span class=\"line\">// 区分数组,普通对象</span><br><span class=\"line\">typeof [1, 2, 4] === &apos;object&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">typeof new Date() === &apos;object&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 下面的容易令人迷惑，不要使用！</span><br><span class=\"line\">typeof new Boolean(true) === &apos;object&apos;;</span><br><span class=\"line\">typeof new Number(1) === &apos;object&apos;;</span><br><span class=\"line\">typeof new String(&quot;abc&quot;) === &apos;object&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 函数</span><br><span class=\"line\">typeof function()&#123;&#125; === &apos;function&apos;;</span><br><span class=\"line\">typeof class C&#123;&#125; === &apos;function&apos;</span><br><span class=\"line\">typeof Math.sin === &apos;function&apos;;</span><br><span class=\"line\">typeof new Function() === &apos;function&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// null</span><br><span class=\"line\">typeof null === &apos;object&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">//new 操作符</span><br><span class=\"line\">var str = new String(&apos;String&apos;);</span><br><span class=\"line\">var num = new Number(100);</span><br><span class=\"line\"></span><br><span class=\"line\">typeof str; // It will return &apos;object&apos;</span><br><span class=\"line\">typeof num; // It will return &apos;object&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">// But there is a exception in case of Function constructor of Javascript</span><br><span class=\"line\"></span><br><span class=\"line\">var func = new Function();</span><br><span class=\"line\"></span><br><span class=\"line\">typeof func; // It will return &apos;function&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h4><ul>\n<li><p>instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] instanceof Array; //true</span><br><span class=\"line\">&#123;&#125; instanceof Object;//true</span><br><span class=\"line\">new Date() instanceof Date;//true</span><br><span class=\"line\">new RegExp() instanceof RegExp//true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建的是有一定的区别的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1 instanceof Number)//false</span><br><span class=\"line\">console.log(new Number(1) instanceof Number)//true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类的原型继承中，我们最后检测出来的结果未必准确</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3];</span><br><span class=\"line\">console.log(arr instanceof Array) // true</span><br><span class=\"line\">console.log(arr instanceof Object);  // true</span><br><span class=\"line\">function fn()&#123;&#125;</span><br><span class=\"line\">console.log(fn instanceof Function)// true</span><br><span class=\"line\">console.log(fn instanceof Object)// true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不能检测 null 和 undefined</p>\n<h4 id=\"ES6数组Array-isArray\"><a href=\"#ES6数组Array-isArray\" class=\"headerlink\" title=\"ES6数组Array.isArray()\"></a>ES6数组Array.isArray()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.isArray([]);   // true</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"严格运算符\"><a href=\"#严格运算符\" class=\"headerlink\" title=\"严格运算符 ===\"></a>严格运算符 ===</h4><p>只能用于判断 null 和 undefined，因为这两种类型的值都是唯一的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = null</span><br><span class=\"line\">typeof a // &quot;object&quot;</span><br><span class=\"line\">a === null // true</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h4><ul>\n<li><p>constructor 作用和 instanceof 非常相似。但 constructor 检测 Object 与 instanceof 不一样，<strong>还可以处理基本数据类型的检测</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var aa=[1,2];</span><br><span class=\"line\">console.log(aa.constructor===Array);//true</span><br><span class=\"line\">console.log(aa.constructor===RegExp);//false</span><br><span class=\"line\">console.log((1).constructor===Number);//true</span><br><span class=\"line\">var reg=/^$/;</span><br><span class=\"line\">console.log(reg.constructor===RegExp);//true</span><br><span class=\"line\">console.log(reg.constructor===Object);//false</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>null 和 undefined 是无效的对象,不会有 constructor 存在。</p>\n</li>\n<li>函数的 constructor 是不稳定的，这个主要体现在把类的原型进行重写。</li>\n</ul>\n<h4 id=\"Object-prototype-toString-call\"><a href=\"#Object-prototype-toString-call\" class=\"headerlink\" title=\"Object.prototype.toString.call()\"></a>Object.prototype.toString.call()</h4><ul>\n<li>每个对象都有一个toString()方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中type是对象的类型。</li>\n<li>关于 toString</li>\n</ul>\n<ol>\n<li>本意是转换为字符串，但是某些 toString 方法不仅仅是转换为字符串</li>\n<li>对于 Number、String，Boolean，Array，RegExp、Date、Function 原型上的 toString 方法都是把当前的数据类型转换为字符串的类型（它们的作用仅仅是用来转换为字符串的）</li>\n<li>Object 上的 toString 并不是用来转换为字符串的。</li>\n</ol>\n<ul>\n<li>Object 上的 toString 它的作用是返回当前方法执行的主体（方法中的 this）所属类的详细信息。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call(&apos;&apos;) ;   // [object String]</span><br><span class=\"line\">Object.prototype.toString.call(1) ;    // [object Number]</span><br><span class=\"line\">Object.prototype.toString.call(true) ; // [object Boolean]</span><br><span class=\"line\">Object.prototype.toString.call(undefined) ; // [object Undefined]</span><br><span class=\"line\">Object.prototype.toString.call(null) ; // [object Null]</span><br><span class=\"line\">Object.prototype.toString.call(new Function()) ; // [object Function]</span><br><span class=\"line\">Object.prototype.toString.call(new Date()) ; // [object Date]</span><br><span class=\"line\">Object.prototype.toString.call([]) ; // [object Array]</span><br><span class=\"line\">Object.prototype.toString.call(new RegExp()) ; // [object RegExp]</span><br><span class=\"line\">Object.prototype.toString.call(new Error()) ; // [object Error]</span><br><span class=\"line\">Object.prototype.toString.call(document) ; // [object HTMLDocument]</span><br><span class=\"line\">Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"整理\"><a href=\"#整理\" class=\"headerlink\" title=\"整理\"></a>整理</h4><ul>\n<li>来自<a href=\"https://mp.weixin.qq.com/s/l4U4lVt_sz7lqT43aTuaTA\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/l4U4lVt_sz7lqT43aTuaTA</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"typeof\"><a href=\"#typeof\" class=\"headerlink\" title=\"typeof\"></a>typeof</h4><ul>\n<li>返回一个表示数据类型的字符串</li>\n<li>返回结果包括：number、boolean、string、symbol、object、undefined、function 等 7 种数据类型，<strong>但不能判断 null、array 等</strong></li>\n<li>在 JavaScript 最初的实现中，JavaScript 中的值是由一个表示类型的标签和实际数据值表示的。对象的类型标签是 0。由于 null 代表的是空指针（大多数平台下值为 0x00），因此，null的类型标签也成为了 0，typeof null就错误的返回了”object”。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// Numbers</span><br><span class=\"line\">typeof 37 === &apos;number&apos;;</span><br><span class=\"line\">typeof 3.14 === &apos;number&apos;;</span><br><span class=\"line\">typeof Math.LN2 === &apos;number&apos;;</span><br><span class=\"line\">typeof Infinity === &apos;number&apos;;</span><br><span class=\"line\">typeof NaN === &apos;number&apos;; // 尽管NaN是&quot;Not-A-Number&quot;的缩写</span><br><span class=\"line\">typeof Number(1) === &apos;number&apos;; // 但不要使用这种形式!</span><br><span class=\"line\"></span><br><span class=\"line\">// Strings</span><br><span class=\"line\">typeof &quot;&quot; === &apos;string&apos;;</span><br><span class=\"line\">typeof &quot;bla&quot; === &apos;string&apos;;</span><br><span class=\"line\">typeof (typeof 1) === &apos;string&apos;; // typeof总是返回一个字符串</span><br><span class=\"line\">typeof String(&quot;abc&quot;) === &apos;string&apos;; // 但不要使用这种形式!</span><br><span class=\"line\"></span><br><span class=\"line\">// Booleans</span><br><span class=\"line\">typeof true === &apos;boolean&apos;;</span><br><span class=\"line\">typeof false === &apos;boolean&apos;;</span><br><span class=\"line\">typeof Boolean(true) === &apos;boolean&apos;; // 但不要使用这种形式!</span><br><span class=\"line\"></span><br><span class=\"line\">// Symbols</span><br><span class=\"line\">typeof Symbol() === &apos;symbol&apos;;</span><br><span class=\"line\">typeof Symbol(&apos;foo&apos;) === &apos;symbol&apos;;</span><br><span class=\"line\">typeof Symbol.iterator === &apos;symbol&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Undefined</span><br><span class=\"line\">typeof undefined === &apos;undefined&apos;;</span><br><span class=\"line\">typeof declaredButUndefinedVariable === &apos;undefined&apos;;</span><br><span class=\"line\">typeof undeclaredVariable === &apos;undefined&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// Objects</span><br><span class=\"line\">typeof &#123;a:1&#125; === &apos;object&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 使用Array.isArray 或者 Object.prototype.toString.call</span><br><span class=\"line\">// 区分数组,普通对象</span><br><span class=\"line\">typeof [1, 2, 4] === &apos;object&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">typeof new Date() === &apos;object&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 下面的容易令人迷惑，不要使用！</span><br><span class=\"line\">typeof new Boolean(true) === &apos;object&apos;;</span><br><span class=\"line\">typeof new Number(1) === &apos;object&apos;;</span><br><span class=\"line\">typeof new String(&quot;abc&quot;) === &apos;object&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// 函数</span><br><span class=\"line\">typeof function()&#123;&#125; === &apos;function&apos;;</span><br><span class=\"line\">typeof class C&#123;&#125; === &apos;function&apos;</span><br><span class=\"line\">typeof Math.sin === &apos;function&apos;;</span><br><span class=\"line\">typeof new Function() === &apos;function&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">// null</span><br><span class=\"line\">typeof null === &apos;object&apos;;</span><br><span class=\"line\"></span><br><span class=\"line\">//new 操作符</span><br><span class=\"line\">var str = new String(&apos;String&apos;);</span><br><span class=\"line\">var num = new Number(100);</span><br><span class=\"line\"></span><br><span class=\"line\">typeof str; // It will return &apos;object&apos;</span><br><span class=\"line\">typeof num; // It will return &apos;object&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">// But there is a exception in case of Function constructor of Javascript</span><br><span class=\"line\"></span><br><span class=\"line\">var func = new Function();</span><br><span class=\"line\"></span><br><span class=\"line\">typeof func; // It will return &apos;function&apos;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"instanceof\"><a href=\"#instanceof\" class=\"headerlink\" title=\"instanceof\"></a>instanceof</h4><ul>\n<li><p>instanceof 运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[] instanceof Array; //true</span><br><span class=\"line\">&#123;&#125; instanceof Object;//true</span><br><span class=\"line\">new Date() instanceof Date;//true</span><br><span class=\"line\">new RegExp() instanceof RegExp//true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>对于基本数据类型来说，字面量方式创建出来的结果和实例方式创建的是有一定的区别的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(1 instanceof Number)//false</span><br><span class=\"line\">console.log(new Number(1) instanceof Number)//true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>类的原型继承中，我们最后检测出来的结果未必准确</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var arr = [1, 2, 3];</span><br><span class=\"line\">console.log(arr instanceof Array) // true</span><br><span class=\"line\">console.log(arr instanceof Object);  // true</span><br><span class=\"line\">function fn()&#123;&#125;</span><br><span class=\"line\">console.log(fn instanceof Function)// true</span><br><span class=\"line\">console.log(fn instanceof Object)// true</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不能检测 null 和 undefined</p>\n<h4 id=\"ES6数组Array-isArray\"><a href=\"#ES6数组Array-isArray\" class=\"headerlink\" title=\"ES6数组Array.isArray()\"></a>ES6数组Array.isArray()</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Array.isArray([]);   // true</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"严格运算符\"><a href=\"#严格运算符\" class=\"headerlink\" title=\"严格运算符 ===\"></a>严格运算符 ===</h4><p>只能用于判断 null 和 undefined，因为这两种类型的值都是唯一的<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var a = null</span><br><span class=\"line\">typeof a // &quot;object&quot;</span><br><span class=\"line\">a === null // true</span><br></pre></td></tr></table></figure></p>\n<h4 id=\"constructor-NaN\"><a href=\"#constructor-NaN\" class=\"headerlink\" title=\"constructor\"></a>constructor</h4><ul>\n<li><p>constructor 作用和 instanceof 非常相似。但 constructor 检测 Object 与 instanceof 不一样，<strong>还可以处理基本数据类型的检测</strong>。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var aa=[1,2];</span><br><span class=\"line\">console.log(aa.constructor===Array);//true</span><br><span class=\"line\">console.log(aa.constructor===RegExp);//false</span><br><span class=\"line\">console.log((1).constructor===Number);//true</span><br><span class=\"line\">var reg=/^$/;</span><br><span class=\"line\">console.log(reg.constructor===RegExp);//true</span><br><span class=\"line\">console.log(reg.constructor===Object);//false</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>null 和 undefined 是无效的对象,不会有 constructor 存在。</p>\n</li>\n<li>函数的 constructor 是不稳定的，这个主要体现在把类的原型进行重写。</li>\n</ul>\n<h4 id=\"Object-prototype-toString-call\"><a href=\"#Object-prototype-toString-call\" class=\"headerlink\" title=\"Object.prototype.toString.call()\"></a>Object.prototype.toString.call()</h4><ul>\n<li>每个对象都有一个toString()方法，当该对象被表示为一个文本值时，或者一个对象以预期的字符串方式引用时自动调用。默认情况下，toString()方法被每个Object对象继承。如果此方法在自定义对象中未被覆盖，toString() 返回 “[object type]”，其中type是对象的类型。</li>\n<li>关于 toString</li>\n</ul>\n<ol>\n<li>本意是转换为字符串，但是某些 toString 方法不仅仅是转换为字符串</li>\n<li>对于 Number、String，Boolean，Array，RegExp、Date、Function 原型上的 toString 方法都是把当前的数据类型转换为字符串的类型（它们的作用仅仅是用来转换为字符串的）</li>\n<li>Object 上的 toString 并不是用来转换为字符串的。</li>\n</ol>\n<ul>\n<li>Object 上的 toString 它的作用是返回当前方法执行的主体（方法中的 this）所属类的详细信息。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Object.prototype.toString.call(&apos;&apos;) ;   // [object String]</span><br><span class=\"line\">Object.prototype.toString.call(1) ;    // [object Number]</span><br><span class=\"line\">Object.prototype.toString.call(true) ; // [object Boolean]</span><br><span class=\"line\">Object.prototype.toString.call(undefined) ; // [object Undefined]</span><br><span class=\"line\">Object.prototype.toString.call(null) ; // [object Null]</span><br><span class=\"line\">Object.prototype.toString.call(new Function()) ; // [object Function]</span><br><span class=\"line\">Object.prototype.toString.call(new Date()) ; // [object Date]</span><br><span class=\"line\">Object.prototype.toString.call([]) ; // [object Array]</span><br><span class=\"line\">Object.prototype.toString.call(new RegExp()) ; // [object RegExp]</span><br><span class=\"line\">Object.prototype.toString.call(new Error()) ; // [object Error]</span><br><span class=\"line\">Object.prototype.toString.call(document) ; // [object HTMLDocument]</span><br><span class=\"line\">Object.prototype.toString.call(window) ; //[object global] window是全局对象global的引用</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"整理\"><a href=\"#整理\" class=\"headerlink\" title=\"整理\"></a>整理</h4><ul>\n<li>来自<a href=\"https://mp.weixin.qq.com/s/l4U4lVt_sz7lqT43aTuaTA\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/l4U4lVt_sz7lqT43aTuaTA</a></li>\n</ul>\n"},{"title":"js正则表达式","date":"2018-11-21T14:24:41.000Z","_content":"\n### 修饰符\n- g全局匹配\n- i不区分大小写，默认大小写敏感\n- m匹配多行\n\n```\nlet str =\n`aA\nA\n`.replace(/a/igm,'B')\nconsole.log(str)\n// `BB\n// b`\n```\n\n\n### 元字符\n- \\t 水平制表符tab\n- \\v 垂直制表符\n- \\n 换行符\n- \\r 回车符\n- \\0 空字符\n- \\f 换页符\n- \\cX ctrl+X\n\n### 字符类\n- 使用[]创建一个字符类\n\n```\nconsole.log('1b2'.replace(/[abc]/g,'3'))//132\n```\n- 使用^符号字符类取反\n\n```\nconsole.log('1b2'.replace(/[^abc]/g,'3'))//3b3\n```\n\n\n### 范围类\n- [a-zA-Z0-9]\n- 范围类中想包含-符号[a-z-]\n\n```\nconsole.log('a-'.replace(/[a-z-]/g,'1'))//11\n```\n\n\n### 预定义的范围类\n- . 除了回车和换行符之外的所有字符--[^\\n\\r]\n- \\d 数字字符--[0-9]\n- \\D 非数字字符--[^0-9]\n- \\s 空白符--[\\t\\n\\x0B\\f\\r]\n- \\S 非空白符--[^\\t\\n\\x0B\\f\\r]\n- \\w 单词字符，字母、数字、下划线--[a-zA-Z_0-9]\n- \\W 非单词字符--[^a-zA-Z_0-9]\n\n### 边界\n- ^ 以XXX开始\n```\nconsole.log('abc'.replace(/^[abc]/,'A'))//Abc\n```\n- $ 以XXX结束\n```\nconsole.log('abc'.replace(/[abc]$/,'A'))//abA\n```\n- \\b 单词边界\n```\nconsole.log('Are you youOK'.replace(/you\\b/,'YOU'))//Are YOU youOK\n```\n- \\B 非单词边界\n```\nconsole.log('Are you youOK'.replace(/you\\B/,'YOU'))//Are you YOUOK\n```\n\n\n### 量词\n- ? 出现0次或者一次（最多一次）\n- \\+ 出现一次或者多次（最少出现一次）\n- \\* 0次或者多次（任意次）\n- {n} 出现n次\n- {n,m} n-m次\n- {n,} 最少出现n次\n\n```\nconsole.log('aabbcc'.replace(/[abc]{2}/g,'A'))//AAA\n```\n\n\n\n### 贪婪模式与非贪婪模式\n- 贪婪模式，js正则默认贪婪模式\n\n```\nconsole.log('aaa'.replace(/a+/g,'A'))//A\n```\n\n- 非贪婪模式，尽可能少的匹配，一旦匹配成功就不再进行尝试\n- 非贪婪模式需要在量词后边加 ?\n\n```\nconsole.log('aaa'.replace(/a+?/g,'A'))//AAA\n```\n\n\n### 分组\n- 使用()可以实现分组\n\n```\nconsole.log('ababc'.replace(/(ab){2}/g,'A'))//Ac\n```\n\n\n### 忽略分组\n- 在分组内加上 ?:\n\n```\nconsole.log('2012-11-01'.replace(/(?:\\d{4})-(\\d{2})-(\\d{2})/,'$3/$2/$1'))//$3/11/2012\n```\n\n\n\n### 或\n- |\n\n```\nconsole.log('abcadc'.replace(/a(b|d)c/g,'A'))//AA\n```\n\n\n\n### 反向引用\n- 分组后使用$1、$2...\n\n```\nconsole.log('2012-11-01'.replace(/(\\d{4})-(\\d{2})-(\\d{2})/,'$3/$2/$1'))//01/11/2012\n```\n\n\n\n\n### 前瞻&后顾\n- 正则表达式从文本头部向尾部解析，文本尾部称为'前'，前瞻就是匹配规则时候向前（尾部方向）检查是否断言\n- js正则不支持后顾\n- exp(?=asset) 正向前瞻（符合断言）\n\n```\nconsole.log('a2aa'.replace(/\\w(?=\\d)/g,'X'))//X2aa\n```\n\n- exp(?!asset) 负向前瞻（不符合断言）\n\n```\nconsole.log('a2aa'.replace(/\\w(?!\\d)/g,'X'))//aXXX\n```\n\n\n\n### 对象属性\n- global\\ignoreCase\\multiline\\lastIndex\\source\n\n```\nlet reg1 = /\\w/igm\nconsole.log(reg1.global)//true\nconsole.log(reg1.ignoreCase)//true\nconsole.log(reg1.multiline)//true\nconsole.log(reg1.lastIndex)//0 当前匹配结果最后一个字符的下一个字符\nconsole.log(reg1.source)//\\w\n```\n\n\n\n---\n\n### 正则表达式方法\n#### test()\n- RegExp.prototype.test(str) 检测字符串参数中是否存在匹配正则表达式模式的字符串\n- 存在返回true不存在返回false\n- 注意如果包含全局匹配g那么结果会受到lastIndex影响\n\n```\nlet reg2 = /\\w/g\nconsole.log(reg2.test('ab'))//true\nconsole.log(reg2.lastIndex)//1\nconsole.log(reg2.test('ab'))//true\nconsole.log(reg2.lastIndex)//2\nconsole.log(reg2.test('ab'))//false\nconsole.log(reg2.lastIndex)//0\n```\n\n#### exec()\n- RegExp.prototype.exec(str)\n- 使用正则表达式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果\n- 如果没有匹配文本返回null，否则返回一个结果的数组\n- 返回的数组有两个属性index声明第一个匹配字符的位置、input存放被检索的字符串string\n- 非全局调用返回的数组：第一项是与正则表达式匹配的文本、第二项（以及以后项）是与分组匹配的文本\n\n```\nlet reg3 = /\\d(\\w)(\\w)\\d/\nlet res1 = reg3.exec('1aa21aa2')//第一次\nconsole.log(res1.index + '\\t' + reg3.lastIndex + '\\t' + res1.toString())//0\t0\t1aa2,a,a\nlet res2 = reg3.exec('1aa21aa2')//第二次，lastIndex没有变化\nconsole.log(res2.index + '\\t' + reg3.lastIndex + '\\t' + res2.toString())//0\t0\t1aa2,a,a\n```\n\n- 全局搜索\n\n```\nlet reg4 = /\\d(\\w)(\\w)\\d/g\nlet r1 = reg4.exec('1aa23bb4')//第一次\nconsole.log(r1.index + '\\t' + reg4.lastIndex + '\\t' + r1.toString())//0\t0\t1aa2,a,a\nlet r2 = reg4.exec('1aa23bb4')//第二次\nconsole.log(r2.index + '\\t' + reg4.lastIndex + '\\t' + r2.toString())//4\t0\t3bb4,b,b\nlet r3 = reg4.exec('1aa23bb4')//第三次\nconsole.log(reg4.lastIndex,r3)//0 null\n```\n\n\n---\n### 字符串对象的方法\n#### search()\n- String.prototype.search(reg)，返回第一个匹配结果的index，查找不到返回-1，忽略g标志，总是从开始匹配\n\n```\nconsole.log('abc'.search(/[abc]/g))//0\nconsole.log('abc'.search(/[abc]/g))//0\n```\n\n#### match()\n- String.prototype.match(reg) 检索字符串，以找到一个或者多个与正则匹配的文本 是否有标志g对结果影响很大\n- 非全局调用，返回数组第一个元素存放匹配的文本，其余元素是与正则的子表达式匹配的文本，还有两个对象属性index、input\n\n```\nlet str1 = '1aa21aa2'\nlet reg5 = /\\d(\\w)(\\w)\\d/\nlet re1 = str1.match(reg5)//第一次\nconsole.log(re1.index + '\\t' + reg5.lastIndex + '\\t' + re1.toString())//0\t0\t1aa2,a,a\nlet re2 = str1.match(reg5)//第二次\nconsole.log(re2.index + '\\t' + reg5.lastIndex + '\\t' + re2.toString())//0\t0\t1aa2,a,a\n```\n\n- 全局调用，返回数组中包含所有匹配的字符串，没有找到返回null，没有index、input属性\n\n```\nlet str2 = '1aa21aa2'\nlet reg6 = /\\d(\\w)(\\w)\\d/g\nlet re3 = str1.match(reg6)\nconsole.log(re3.index + '\\t' + reg6.lastIndex + '\\t' + re3.toString())//undefined\t0\t1aa2,1aa2\n```\n\n#### split()\n- String.prototype.split(reg)\n\n```\nconsole.log('1a2b3c4d'.split(/\\d/g))//['',a,b,c,d]\n```\n\n#### replace()\n- String.prototype.replace(reg)\n\n```\nconsole.log('aabc'.replace('a','1'))//1abc 转换为/a/正则\nconsole.log('aabc'.replace(/a/g,'1'))//11bc\n```\n\n- 传第二个函数参数function有四个参数：匹配字符串、正则表达式分组内容(没有分组就没这个参数)、匹配项的index、原字符串\n\n```\nconsole.log('a1b2c3d4'.replace(/\\d/g,function (match,index,str) {\n    return parseInt(match) + 1\n}))//a2b3c4d5\nconsole.log('a1b2c3d4'.replace(/(\\d)/g,function (match,group,index,str) {\n    console.log(group)\n    return parseInt(match) + 1\n}))//a2b3c4d5\n```\n","source":"_posts/js正则表达式.md","raw":"---\ntitle: js正则表达式\ndate: 2018-11-21 22:24:41\ntags: [js,正则表达式]\ncategories: js\n---\n\n### 修饰符\n- g全局匹配\n- i不区分大小写，默认大小写敏感\n- m匹配多行\n\n```\nlet str =\n`aA\nA\n`.replace(/a/igm,'B')\nconsole.log(str)\n// `BB\n// b`\n```\n\n\n### 元字符\n- \\t 水平制表符tab\n- \\v 垂直制表符\n- \\n 换行符\n- \\r 回车符\n- \\0 空字符\n- \\f 换页符\n- \\cX ctrl+X\n\n### 字符类\n- 使用[]创建一个字符类\n\n```\nconsole.log('1b2'.replace(/[abc]/g,'3'))//132\n```\n- 使用^符号字符类取反\n\n```\nconsole.log('1b2'.replace(/[^abc]/g,'3'))//3b3\n```\n\n\n### 范围类\n- [a-zA-Z0-9]\n- 范围类中想包含-符号[a-z-]\n\n```\nconsole.log('a-'.replace(/[a-z-]/g,'1'))//11\n```\n\n\n### 预定义的范围类\n- . 除了回车和换行符之外的所有字符--[^\\n\\r]\n- \\d 数字字符--[0-9]\n- \\D 非数字字符--[^0-9]\n- \\s 空白符--[\\t\\n\\x0B\\f\\r]\n- \\S 非空白符--[^\\t\\n\\x0B\\f\\r]\n- \\w 单词字符，字母、数字、下划线--[a-zA-Z_0-9]\n- \\W 非单词字符--[^a-zA-Z_0-9]\n\n### 边界\n- ^ 以XXX开始\n```\nconsole.log('abc'.replace(/^[abc]/,'A'))//Abc\n```\n- $ 以XXX结束\n```\nconsole.log('abc'.replace(/[abc]$/,'A'))//abA\n```\n- \\b 单词边界\n```\nconsole.log('Are you youOK'.replace(/you\\b/,'YOU'))//Are YOU youOK\n```\n- \\B 非单词边界\n```\nconsole.log('Are you youOK'.replace(/you\\B/,'YOU'))//Are you YOUOK\n```\n\n\n### 量词\n- ? 出现0次或者一次（最多一次）\n- \\+ 出现一次或者多次（最少出现一次）\n- \\* 0次或者多次（任意次）\n- {n} 出现n次\n- {n,m} n-m次\n- {n,} 最少出现n次\n\n```\nconsole.log('aabbcc'.replace(/[abc]{2}/g,'A'))//AAA\n```\n\n\n\n### 贪婪模式与非贪婪模式\n- 贪婪模式，js正则默认贪婪模式\n\n```\nconsole.log('aaa'.replace(/a+/g,'A'))//A\n```\n\n- 非贪婪模式，尽可能少的匹配，一旦匹配成功就不再进行尝试\n- 非贪婪模式需要在量词后边加 ?\n\n```\nconsole.log('aaa'.replace(/a+?/g,'A'))//AAA\n```\n\n\n### 分组\n- 使用()可以实现分组\n\n```\nconsole.log('ababc'.replace(/(ab){2}/g,'A'))//Ac\n```\n\n\n### 忽略分组\n- 在分组内加上 ?:\n\n```\nconsole.log('2012-11-01'.replace(/(?:\\d{4})-(\\d{2})-(\\d{2})/,'$3/$2/$1'))//$3/11/2012\n```\n\n\n\n### 或\n- |\n\n```\nconsole.log('abcadc'.replace(/a(b|d)c/g,'A'))//AA\n```\n\n\n\n### 反向引用\n- 分组后使用$1、$2...\n\n```\nconsole.log('2012-11-01'.replace(/(\\d{4})-(\\d{2})-(\\d{2})/,'$3/$2/$1'))//01/11/2012\n```\n\n\n\n\n### 前瞻&后顾\n- 正则表达式从文本头部向尾部解析，文本尾部称为'前'，前瞻就是匹配规则时候向前（尾部方向）检查是否断言\n- js正则不支持后顾\n- exp(?=asset) 正向前瞻（符合断言）\n\n```\nconsole.log('a2aa'.replace(/\\w(?=\\d)/g,'X'))//X2aa\n```\n\n- exp(?!asset) 负向前瞻（不符合断言）\n\n```\nconsole.log('a2aa'.replace(/\\w(?!\\d)/g,'X'))//aXXX\n```\n\n\n\n### 对象属性\n- global\\ignoreCase\\multiline\\lastIndex\\source\n\n```\nlet reg1 = /\\w/igm\nconsole.log(reg1.global)//true\nconsole.log(reg1.ignoreCase)//true\nconsole.log(reg1.multiline)//true\nconsole.log(reg1.lastIndex)//0 当前匹配结果最后一个字符的下一个字符\nconsole.log(reg1.source)//\\w\n```\n\n\n\n---\n\n### 正则表达式方法\n#### test()\n- RegExp.prototype.test(str) 检测字符串参数中是否存在匹配正则表达式模式的字符串\n- 存在返回true不存在返回false\n- 注意如果包含全局匹配g那么结果会受到lastIndex影响\n\n```\nlet reg2 = /\\w/g\nconsole.log(reg2.test('ab'))//true\nconsole.log(reg2.lastIndex)//1\nconsole.log(reg2.test('ab'))//true\nconsole.log(reg2.lastIndex)//2\nconsole.log(reg2.test('ab'))//false\nconsole.log(reg2.lastIndex)//0\n```\n\n#### exec()\n- RegExp.prototype.exec(str)\n- 使用正则表达式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果\n- 如果没有匹配文本返回null，否则返回一个结果的数组\n- 返回的数组有两个属性index声明第一个匹配字符的位置、input存放被检索的字符串string\n- 非全局调用返回的数组：第一项是与正则表达式匹配的文本、第二项（以及以后项）是与分组匹配的文本\n\n```\nlet reg3 = /\\d(\\w)(\\w)\\d/\nlet res1 = reg3.exec('1aa21aa2')//第一次\nconsole.log(res1.index + '\\t' + reg3.lastIndex + '\\t' + res1.toString())//0\t0\t1aa2,a,a\nlet res2 = reg3.exec('1aa21aa2')//第二次，lastIndex没有变化\nconsole.log(res2.index + '\\t' + reg3.lastIndex + '\\t' + res2.toString())//0\t0\t1aa2,a,a\n```\n\n- 全局搜索\n\n```\nlet reg4 = /\\d(\\w)(\\w)\\d/g\nlet r1 = reg4.exec('1aa23bb4')//第一次\nconsole.log(r1.index + '\\t' + reg4.lastIndex + '\\t' + r1.toString())//0\t0\t1aa2,a,a\nlet r2 = reg4.exec('1aa23bb4')//第二次\nconsole.log(r2.index + '\\t' + reg4.lastIndex + '\\t' + r2.toString())//4\t0\t3bb4,b,b\nlet r3 = reg4.exec('1aa23bb4')//第三次\nconsole.log(reg4.lastIndex,r3)//0 null\n```\n\n\n---\n### 字符串对象的方法\n#### search()\n- String.prototype.search(reg)，返回第一个匹配结果的index，查找不到返回-1，忽略g标志，总是从开始匹配\n\n```\nconsole.log('abc'.search(/[abc]/g))//0\nconsole.log('abc'.search(/[abc]/g))//0\n```\n\n#### match()\n- String.prototype.match(reg) 检索字符串，以找到一个或者多个与正则匹配的文本 是否有标志g对结果影响很大\n- 非全局调用，返回数组第一个元素存放匹配的文本，其余元素是与正则的子表达式匹配的文本，还有两个对象属性index、input\n\n```\nlet str1 = '1aa21aa2'\nlet reg5 = /\\d(\\w)(\\w)\\d/\nlet re1 = str1.match(reg5)//第一次\nconsole.log(re1.index + '\\t' + reg5.lastIndex + '\\t' + re1.toString())//0\t0\t1aa2,a,a\nlet re2 = str1.match(reg5)//第二次\nconsole.log(re2.index + '\\t' + reg5.lastIndex + '\\t' + re2.toString())//0\t0\t1aa2,a,a\n```\n\n- 全局调用，返回数组中包含所有匹配的字符串，没有找到返回null，没有index、input属性\n\n```\nlet str2 = '1aa21aa2'\nlet reg6 = /\\d(\\w)(\\w)\\d/g\nlet re3 = str1.match(reg6)\nconsole.log(re3.index + '\\t' + reg6.lastIndex + '\\t' + re3.toString())//undefined\t0\t1aa2,1aa2\n```\n\n#### split()\n- String.prototype.split(reg)\n\n```\nconsole.log('1a2b3c4d'.split(/\\d/g))//['',a,b,c,d]\n```\n\n#### replace()\n- String.prototype.replace(reg)\n\n```\nconsole.log('aabc'.replace('a','1'))//1abc 转换为/a/正则\nconsole.log('aabc'.replace(/a/g,'1'))//11bc\n```\n\n- 传第二个函数参数function有四个参数：匹配字符串、正则表达式分组内容(没有分组就没这个参数)、匹配项的index、原字符串\n\n```\nconsole.log('a1b2c3d4'.replace(/\\d/g,function (match,index,str) {\n    return parseInt(match) + 1\n}))//a2b3c4d5\nconsole.log('a1b2c3d4'.replace(/(\\d)/g,function (match,group,index,str) {\n    console.log(group)\n    return parseInt(match) + 1\n}))//a2b3c4d5\n```\n","slug":"js正则表达式","published":1,"updated":"2018-11-21T14:25:44.694Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob6y001le0jclgn7ur0n","content":"<h3 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h3><ul>\n<li>g全局匹配</li>\n<li>i不区分大小写，默认大小写敏感</li>\n<li>m匹配多行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str =</span><br><span class=\"line\">`aA</span><br><span class=\"line\">A</span><br><span class=\"line\">`.replace(/a/igm,&apos;B&apos;)</span><br><span class=\"line\">console.log(str)</span><br><span class=\"line\">// `BB</span><br><span class=\"line\">// b`</span><br></pre></td></tr></table></figure>\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><ul>\n<li>\\t 水平制表符tab</li>\n<li>\\v 垂直制表符</li>\n<li>\\n 换行符</li>\n<li>\\r 回车符</li>\n<li>\\0 空字符</li>\n<li>\\f 换页符</li>\n<li>\\cX ctrl+X</li>\n</ul>\n<h3 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h3><ul>\n<li>使用[]创建一个字符类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;1b2&apos;.replace(/[abc]/g,&apos;3&apos;))//132</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用^符号字符类取反</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;1b2&apos;.replace(/[^abc]/g,&apos;3&apos;))//3b3</span><br></pre></td></tr></table></figure>\n<h3 id=\"范围类\"><a href=\"#范围类\" class=\"headerlink\" title=\"范围类\"></a>范围类</h3><ul>\n<li>[a-zA-Z0-9]</li>\n<li>范围类中想包含-符号[a-z-]</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;a-&apos;.replace(/[a-z-]/g,&apos;1&apos;))//11</span><br></pre></td></tr></table></figure>\n<h3 id=\"预定义的范围类\"><a href=\"#预定义的范围类\" class=\"headerlink\" title=\"预定义的范围类\"></a>预定义的范围类</h3><ul>\n<li>. 除了回车和换行符之外的所有字符–[^\\n\\r]</li>\n<li>\\d 数字字符–[0-9]</li>\n<li>\\D 非数字字符–[^0-9]</li>\n<li>\\s 空白符–[\\t\\n\\x0B\\f\\r]</li>\n<li>\\S 非空白符–[^\\t\\n\\x0B\\f\\r]</li>\n<li>\\w 单词字符，字母、数字、下划线–[a-zA-Z_0-9]</li>\n<li>\\W 非单词字符–[^a-zA-Z_0-9]</li>\n</ul>\n<h3 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h3><ul>\n<li><p>^ 以XXX开始</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;abc&apos;.replace(/^[abc]/,&apos;A&apos;))//Abc</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>$ 以XXX结束</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;abc&apos;.replace(/[abc]$/,&apos;A&apos;))//abA</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>\\b 单词边界</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;Are you youOK&apos;.replace(/you\\b/,&apos;YOU&apos;))//Are YOU youOK</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>\\B 非单词边界</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;Are you youOK&apos;.replace(/you\\B/,&apos;YOU&apos;))//Are you YOUOK</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h3><ul>\n<li>? 出现0次或者一次（最多一次）</li>\n<li>+ 出现一次或者多次（最少出现一次）</li>\n<li>* 0次或者多次（任意次）</li>\n<li>{n} 出现n次</li>\n<li>{n,m} n-m次</li>\n<li>{n,} 最少出现n次</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;aabbcc&apos;.replace(/[abc]&#123;2&#125;/g,&apos;A&apos;))//AAA</span><br></pre></td></tr></table></figure>\n<h3 id=\"贪婪模式与非贪婪模式\"><a href=\"#贪婪模式与非贪婪模式\" class=\"headerlink\" title=\"贪婪模式与非贪婪模式\"></a>贪婪模式与非贪婪模式</h3><ul>\n<li>贪婪模式，js正则默认贪婪模式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;aaa&apos;.replace(/a+/g,&apos;A&apos;))//A</span><br></pre></td></tr></table></figure>\n<ul>\n<li>非贪婪模式，尽可能少的匹配，一旦匹配成功就不再进行尝试</li>\n<li>非贪婪模式需要在量词后边加 ?</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;aaa&apos;.replace(/a+?/g,&apos;A&apos;))//AAA</span><br></pre></td></tr></table></figure>\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><ul>\n<li>使用()可以实现分组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;ababc&apos;.replace(/(ab)&#123;2&#125;/g,&apos;A&apos;))//Ac</span><br></pre></td></tr></table></figure>\n<h3 id=\"忽略分组\"><a href=\"#忽略分组\" class=\"headerlink\" title=\"忽略分组\"></a>忽略分组</h3><ul>\n<li>在分组内加上 ?:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;2012-11-01&apos;.replace(/(?:\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/,&apos;$3/$2/$1&apos;))//$3/11/2012</span><br></pre></td></tr></table></figure>\n<h3 id=\"或\"><a href=\"#或\" class=\"headerlink\" title=\"或\"></a>或</h3><ul>\n<li>|</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;abcadc&apos;.replace(/a(b|d)c/g,&apos;A&apos;))//AA</span><br></pre></td></tr></table></figure>\n<h3 id=\"反向引用\"><a href=\"#反向引用\" class=\"headerlink\" title=\"反向引用\"></a>反向引用</h3><ul>\n<li>分组后使用$1、$2…</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;2012-11-01&apos;.replace(/(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/,&apos;$3/$2/$1&apos;))//01/11/2012</span><br></pre></td></tr></table></figure>\n<h3 id=\"前瞻-amp-后顾\"><a href=\"#前瞻-amp-后顾\" class=\"headerlink\" title=\"前瞻&amp;后顾\"></a>前瞻&amp;后顾</h3><ul>\n<li>正则表达式从文本头部向尾部解析，文本尾部称为’前’，前瞻就是匹配规则时候向前（尾部方向）检查是否断言</li>\n<li>js正则不支持后顾</li>\n<li>exp(?=asset) 正向前瞻（符合断言）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;a2aa&apos;.replace(/\\w(?=\\d)/g,&apos;X&apos;))//X2aa</span><br></pre></td></tr></table></figure>\n<ul>\n<li>exp(?!asset) 负向前瞻（不符合断言）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;a2aa&apos;.replace(/\\w(?!\\d)/g,&apos;X&apos;))//aXXX</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象属性\"><a href=\"#对象属性\" class=\"headerlink\" title=\"对象属性\"></a>对象属性</h3><ul>\n<li>global\\ignoreCase\\multiline\\lastIndex\\source</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg1 = /\\w/igm</span><br><span class=\"line\">console.log(reg1.global)//true</span><br><span class=\"line\">console.log(reg1.ignoreCase)//true</span><br><span class=\"line\">console.log(reg1.multiline)//true</span><br><span class=\"line\">console.log(reg1.lastIndex)//0 当前匹配结果最后一个字符的下一个字符</span><br><span class=\"line\">console.log(reg1.source)//\\w</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"正则表达式方法\"><a href=\"#正则表达式方法\" class=\"headerlink\" title=\"正则表达式方法\"></a>正则表达式方法</h3><h4 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test()\"></a>test()</h4><ul>\n<li>RegExp.prototype.test(str) 检测字符串参数中是否存在匹配正则表达式模式的字符串</li>\n<li>存在返回true不存在返回false</li>\n<li>注意如果包含全局匹配g那么结果会受到lastIndex影响</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg2 = /\\w/g</span><br><span class=\"line\">console.log(reg2.test(&apos;ab&apos;))//true</span><br><span class=\"line\">console.log(reg2.lastIndex)//1</span><br><span class=\"line\">console.log(reg2.test(&apos;ab&apos;))//true</span><br><span class=\"line\">console.log(reg2.lastIndex)//2</span><br><span class=\"line\">console.log(reg2.test(&apos;ab&apos;))//false</span><br><span class=\"line\">console.log(reg2.lastIndex)//0</span><br></pre></td></tr></table></figure>\n<h4 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec()\"></a>exec()</h4><ul>\n<li>RegExp.prototype.exec(str)</li>\n<li>使用正则表达式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果</li>\n<li>如果没有匹配文本返回null，否则返回一个结果的数组</li>\n<li>返回的数组有两个属性index声明第一个匹配字符的位置、input存放被检索的字符串string</li>\n<li>非全局调用返回的数组：第一项是与正则表达式匹配的文本、第二项（以及以后项）是与分组匹配的文本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg3 = /\\d(\\w)(\\w)\\d/</span><br><span class=\"line\">let res1 = reg3.exec(&apos;1aa21aa2&apos;)//第一次</span><br><span class=\"line\">console.log(res1.index + &apos;\\t&apos; + reg3.lastIndex + &apos;\\t&apos; + res1.toString())//0\t0\t1aa2,a,a</span><br><span class=\"line\">let res2 = reg3.exec(&apos;1aa21aa2&apos;)//第二次，lastIndex没有变化</span><br><span class=\"line\">console.log(res2.index + &apos;\\t&apos; + reg3.lastIndex + &apos;\\t&apos; + res2.toString())//0\t0\t1aa2,a,a</span><br></pre></td></tr></table></figure>\n<ul>\n<li>全局搜索</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg4 = /\\d(\\w)(\\w)\\d/g</span><br><span class=\"line\">let r1 = reg4.exec(&apos;1aa23bb4&apos;)//第一次</span><br><span class=\"line\">console.log(r1.index + &apos;\\t&apos; + reg4.lastIndex + &apos;\\t&apos; + r1.toString())//0\t0\t1aa2,a,a</span><br><span class=\"line\">let r2 = reg4.exec(&apos;1aa23bb4&apos;)//第二次</span><br><span class=\"line\">console.log(r2.index + &apos;\\t&apos; + reg4.lastIndex + &apos;\\t&apos; + r2.toString())//4\t0\t3bb4,b,b</span><br><span class=\"line\">let r3 = reg4.exec(&apos;1aa23bb4&apos;)//第三次</span><br><span class=\"line\">console.log(reg4.lastIndex,r3)//0 null</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"字符串对象的方法\"><a href=\"#字符串对象的方法\" class=\"headerlink\" title=\"字符串对象的方法\"></a>字符串对象的方法</h3><h4 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search()\"></a>search()</h4><ul>\n<li>String.prototype.search(reg)，返回第一个匹配结果的index，查找不到返回-1，忽略g标志，总是从开始匹配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;abc&apos;.search(/[abc]/g))//0</span><br><span class=\"line\">console.log(&apos;abc&apos;.search(/[abc]/g))//0</span><br></pre></td></tr></table></figure>\n<h4 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match()\"></a>match()</h4><ul>\n<li>String.prototype.match(reg) 检索字符串，以找到一个或者多个与正则匹配的文本 是否有标志g对结果影响很大</li>\n<li>非全局调用，返回数组第一个元素存放匹配的文本，其余元素是与正则的子表达式匹配的文本，还有两个对象属性index、input</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str1 = &apos;1aa21aa2&apos;</span><br><span class=\"line\">let reg5 = /\\d(\\w)(\\w)\\d/</span><br><span class=\"line\">let re1 = str1.match(reg5)//第一次</span><br><span class=\"line\">console.log(re1.index + &apos;\\t&apos; + reg5.lastIndex + &apos;\\t&apos; + re1.toString())//0\t0\t1aa2,a,a</span><br><span class=\"line\">let re2 = str1.match(reg5)//第二次</span><br><span class=\"line\">console.log(re2.index + &apos;\\t&apos; + reg5.lastIndex + &apos;\\t&apos; + re2.toString())//0\t0\t1aa2,a,a</span><br></pre></td></tr></table></figure>\n<ul>\n<li>全局调用，返回数组中包含所有匹配的字符串，没有找到返回null，没有index、input属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str2 = &apos;1aa21aa2&apos;</span><br><span class=\"line\">let reg6 = /\\d(\\w)(\\w)\\d/g</span><br><span class=\"line\">let re3 = str1.match(reg6)</span><br><span class=\"line\">console.log(re3.index + &apos;\\t&apos; + reg6.lastIndex + &apos;\\t&apos; + re3.toString())//undefined\t0\t1aa2,1aa2</span><br></pre></td></tr></table></figure>\n<h4 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h4><ul>\n<li>String.prototype.split(reg)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;1a2b3c4d&apos;.split(/\\d/g))//[&apos;&apos;,a,b,c,d]</span><br></pre></td></tr></table></figure>\n<h4 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace()\"></a>replace()</h4><ul>\n<li>String.prototype.replace(reg)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;aabc&apos;.replace(&apos;a&apos;,&apos;1&apos;))//1abc 转换为/a/正则</span><br><span class=\"line\">console.log(&apos;aabc&apos;.replace(/a/g,&apos;1&apos;))//11bc</span><br></pre></td></tr></table></figure>\n<ul>\n<li>传第二个函数参数function有四个参数：匹配字符串、正则表达式分组内容(没有分组就没这个参数)、匹配项的index、原字符串</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;a1b2c3d4&apos;.replace(/\\d/g,function (match,index,str) &#123;</span><br><span class=\"line\">    return parseInt(match) + 1</span><br><span class=\"line\">&#125;))//a2b3c4d5</span><br><span class=\"line\">console.log(&apos;a1b2c3d4&apos;.replace(/(\\d)/g,function (match,group,index,str) &#123;</span><br><span class=\"line\">    console.log(group)</span><br><span class=\"line\">    return parseInt(match) + 1</span><br><span class=\"line\">&#125;))//a2b3c4d5</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"修饰符\"><a href=\"#修饰符\" class=\"headerlink\" title=\"修饰符\"></a>修饰符</h3><ul>\n<li>g全局匹配</li>\n<li>i不区分大小写，默认大小写敏感</li>\n<li>m匹配多行</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str =</span><br><span class=\"line\">`aA</span><br><span class=\"line\">A</span><br><span class=\"line\">`.replace(/a/igm,&apos;B&apos;)</span><br><span class=\"line\">console.log(str)</span><br><span class=\"line\">// `BB</span><br><span class=\"line\">// b`</span><br></pre></td></tr></table></figure>\n<h3 id=\"元字符\"><a href=\"#元字符\" class=\"headerlink\" title=\"元字符\"></a>元字符</h3><ul>\n<li>\\t 水平制表符tab</li>\n<li>\\v 垂直制表符</li>\n<li>\\n 换行符</li>\n<li>\\r 回车符</li>\n<li>\\0 空字符</li>\n<li>\\f 换页符</li>\n<li>\\cX ctrl+X</li>\n</ul>\n<h3 id=\"字符类\"><a href=\"#字符类\" class=\"headerlink\" title=\"字符类\"></a>字符类</h3><ul>\n<li>使用[]创建一个字符类</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;1b2&apos;.replace(/[abc]/g,&apos;3&apos;))//132</span><br></pre></td></tr></table></figure>\n<ul>\n<li>使用^符号字符类取反</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;1b2&apos;.replace(/[^abc]/g,&apos;3&apos;))//3b3</span><br></pre></td></tr></table></figure>\n<h3 id=\"范围类\"><a href=\"#范围类\" class=\"headerlink\" title=\"范围类\"></a>范围类</h3><ul>\n<li>[a-zA-Z0-9]</li>\n<li>范围类中想包含-符号[a-z-]</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;a-&apos;.replace(/[a-z-]/g,&apos;1&apos;))//11</span><br></pre></td></tr></table></figure>\n<h3 id=\"预定义的范围类\"><a href=\"#预定义的范围类\" class=\"headerlink\" title=\"预定义的范围类\"></a>预定义的范围类</h3><ul>\n<li>. 除了回车和换行符之外的所有字符–[^\\n\\r]</li>\n<li>\\d 数字字符–[0-9]</li>\n<li>\\D 非数字字符–[^0-9]</li>\n<li>\\s 空白符–[\\t\\n\\x0B\\f\\r]</li>\n<li>\\S 非空白符–[^\\t\\n\\x0B\\f\\r]</li>\n<li>\\w 单词字符，字母、数字、下划线–[a-zA-Z_0-9]</li>\n<li>\\W 非单词字符–[^a-zA-Z_0-9]</li>\n</ul>\n<h3 id=\"边界\"><a href=\"#边界\" class=\"headerlink\" title=\"边界\"></a>边界</h3><ul>\n<li><p>^ 以XXX开始</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;abc&apos;.replace(/^[abc]/,&apos;A&apos;))//Abc</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>$ 以XXX结束</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;abc&apos;.replace(/[abc]$/,&apos;A&apos;))//abA</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>\\b 单词边界</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;Are you youOK&apos;.replace(/you\\b/,&apos;YOU&apos;))//Are YOU youOK</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>\\B 非单词边界</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;Are you youOK&apos;.replace(/you\\B/,&apos;YOU&apos;))//Are you YOUOK</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"量词\"><a href=\"#量词\" class=\"headerlink\" title=\"量词\"></a>量词</h3><ul>\n<li>? 出现0次或者一次（最多一次）</li>\n<li>+ 出现一次或者多次（最少出现一次）</li>\n<li>* 0次或者多次（任意次）</li>\n<li>{n} 出现n次</li>\n<li>{n,m} n-m次</li>\n<li>{n,} 最少出现n次</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;aabbcc&apos;.replace(/[abc]&#123;2&#125;/g,&apos;A&apos;))//AAA</span><br></pre></td></tr></table></figure>\n<h3 id=\"贪婪模式与非贪婪模式\"><a href=\"#贪婪模式与非贪婪模式\" class=\"headerlink\" title=\"贪婪模式与非贪婪模式\"></a>贪婪模式与非贪婪模式</h3><ul>\n<li>贪婪模式，js正则默认贪婪模式</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;aaa&apos;.replace(/a+/g,&apos;A&apos;))//A</span><br></pre></td></tr></table></figure>\n<ul>\n<li>非贪婪模式，尽可能少的匹配，一旦匹配成功就不再进行尝试</li>\n<li>非贪婪模式需要在量词后边加 ?</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;aaa&apos;.replace(/a+?/g,&apos;A&apos;))//AAA</span><br></pre></td></tr></table></figure>\n<h3 id=\"分组\"><a href=\"#分组\" class=\"headerlink\" title=\"分组\"></a>分组</h3><ul>\n<li>使用()可以实现分组</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;ababc&apos;.replace(/(ab)&#123;2&#125;/g,&apos;A&apos;))//Ac</span><br></pre></td></tr></table></figure>\n<h3 id=\"忽略分组\"><a href=\"#忽略分组\" class=\"headerlink\" title=\"忽略分组\"></a>忽略分组</h3><ul>\n<li>在分组内加上 ?:</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;2012-11-01&apos;.replace(/(?:\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/,&apos;$3/$2/$1&apos;))//$3/11/2012</span><br></pre></td></tr></table></figure>\n<h3 id=\"或\"><a href=\"#或\" class=\"headerlink\" title=\"或\"></a>或</h3><ul>\n<li>|</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;abcadc&apos;.replace(/a(b|d)c/g,&apos;A&apos;))//AA</span><br></pre></td></tr></table></figure>\n<h3 id=\"反向引用\"><a href=\"#反向引用\" class=\"headerlink\" title=\"反向引用\"></a>反向引用</h3><ul>\n<li>分组后使用$1、$2…</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;2012-11-01&apos;.replace(/(\\d&#123;4&#125;)-(\\d&#123;2&#125;)-(\\d&#123;2&#125;)/,&apos;$3/$2/$1&apos;))//01/11/2012</span><br></pre></td></tr></table></figure>\n<h3 id=\"前瞻-amp-后顾\"><a href=\"#前瞻-amp-后顾\" class=\"headerlink\" title=\"前瞻&amp;后顾\"></a>前瞻&amp;后顾</h3><ul>\n<li>正则表达式从文本头部向尾部解析，文本尾部称为’前’，前瞻就是匹配规则时候向前（尾部方向）检查是否断言</li>\n<li>js正则不支持后顾</li>\n<li>exp(?=asset) 正向前瞻（符合断言）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;a2aa&apos;.replace(/\\w(?=\\d)/g,&apos;X&apos;))//X2aa</span><br></pre></td></tr></table></figure>\n<ul>\n<li>exp(?!asset) 负向前瞻（不符合断言）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;a2aa&apos;.replace(/\\w(?!\\d)/g,&apos;X&apos;))//aXXX</span><br></pre></td></tr></table></figure>\n<h3 id=\"对象属性\"><a href=\"#对象属性\" class=\"headerlink\" title=\"对象属性\"></a>对象属性</h3><ul>\n<li>global\\ignoreCase\\multiline\\lastIndex\\source</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg1 = /\\w/igm</span><br><span class=\"line\">console.log(reg1.global)//true</span><br><span class=\"line\">console.log(reg1.ignoreCase)//true</span><br><span class=\"line\">console.log(reg1.multiline)//true</span><br><span class=\"line\">console.log(reg1.lastIndex)//0 当前匹配结果最后一个字符的下一个字符</span><br><span class=\"line\">console.log(reg1.source)//\\w</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"正则表达式方法\"><a href=\"#正则表达式方法\" class=\"headerlink\" title=\"正则表达式方法\"></a>正则表达式方法</h3><h4 id=\"test\"><a href=\"#test\" class=\"headerlink\" title=\"test()\"></a>test()</h4><ul>\n<li>RegExp.prototype.test(str) 检测字符串参数中是否存在匹配正则表达式模式的字符串</li>\n<li>存在返回true不存在返回false</li>\n<li>注意如果包含全局匹配g那么结果会受到lastIndex影响</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg2 = /\\w/g</span><br><span class=\"line\">console.log(reg2.test(&apos;ab&apos;))//true</span><br><span class=\"line\">console.log(reg2.lastIndex)//1</span><br><span class=\"line\">console.log(reg2.test(&apos;ab&apos;))//true</span><br><span class=\"line\">console.log(reg2.lastIndex)//2</span><br><span class=\"line\">console.log(reg2.test(&apos;ab&apos;))//false</span><br><span class=\"line\">console.log(reg2.lastIndex)//0</span><br></pre></td></tr></table></figure>\n<h4 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec()\"></a>exec()</h4><ul>\n<li>RegExp.prototype.exec(str)</li>\n<li>使用正则表达式对字符串执行搜索，并将更新全局RegExp对象的属性以反映匹配结果</li>\n<li>如果没有匹配文本返回null，否则返回一个结果的数组</li>\n<li>返回的数组有两个属性index声明第一个匹配字符的位置、input存放被检索的字符串string</li>\n<li>非全局调用返回的数组：第一项是与正则表达式匹配的文本、第二项（以及以后项）是与分组匹配的文本</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg3 = /\\d(\\w)(\\w)\\d/</span><br><span class=\"line\">let res1 = reg3.exec(&apos;1aa21aa2&apos;)//第一次</span><br><span class=\"line\">console.log(res1.index + &apos;\\t&apos; + reg3.lastIndex + &apos;\\t&apos; + res1.toString())//0\t0\t1aa2,a,a</span><br><span class=\"line\">let res2 = reg3.exec(&apos;1aa21aa2&apos;)//第二次，lastIndex没有变化</span><br><span class=\"line\">console.log(res2.index + &apos;\\t&apos; + reg3.lastIndex + &apos;\\t&apos; + res2.toString())//0\t0\t1aa2,a,a</span><br></pre></td></tr></table></figure>\n<ul>\n<li>全局搜索</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let reg4 = /\\d(\\w)(\\w)\\d/g</span><br><span class=\"line\">let r1 = reg4.exec(&apos;1aa23bb4&apos;)//第一次</span><br><span class=\"line\">console.log(r1.index + &apos;\\t&apos; + reg4.lastIndex + &apos;\\t&apos; + r1.toString())//0\t0\t1aa2,a,a</span><br><span class=\"line\">let r2 = reg4.exec(&apos;1aa23bb4&apos;)//第二次</span><br><span class=\"line\">console.log(r2.index + &apos;\\t&apos; + reg4.lastIndex + &apos;\\t&apos; + r2.toString())//4\t0\t3bb4,b,b</span><br><span class=\"line\">let r3 = reg4.exec(&apos;1aa23bb4&apos;)//第三次</span><br><span class=\"line\">console.log(reg4.lastIndex,r3)//0 null</span><br></pre></td></tr></table></figure>\n<hr>\n<h3 id=\"字符串对象的方法\"><a href=\"#字符串对象的方法\" class=\"headerlink\" title=\"字符串对象的方法\"></a>字符串对象的方法</h3><h4 id=\"search\"><a href=\"#search\" class=\"headerlink\" title=\"search()\"></a>search()</h4><ul>\n<li>String.prototype.search(reg)，返回第一个匹配结果的index，查找不到返回-1，忽略g标志，总是从开始匹配</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;abc&apos;.search(/[abc]/g))//0</span><br><span class=\"line\">console.log(&apos;abc&apos;.search(/[abc]/g))//0</span><br></pre></td></tr></table></figure>\n<h4 id=\"match\"><a href=\"#match\" class=\"headerlink\" title=\"match()\"></a>match()</h4><ul>\n<li>String.prototype.match(reg) 检索字符串，以找到一个或者多个与正则匹配的文本 是否有标志g对结果影响很大</li>\n<li>非全局调用，返回数组第一个元素存放匹配的文本，其余元素是与正则的子表达式匹配的文本，还有两个对象属性index、input</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str1 = &apos;1aa21aa2&apos;</span><br><span class=\"line\">let reg5 = /\\d(\\w)(\\w)\\d/</span><br><span class=\"line\">let re1 = str1.match(reg5)//第一次</span><br><span class=\"line\">console.log(re1.index + &apos;\\t&apos; + reg5.lastIndex + &apos;\\t&apos; + re1.toString())//0\t0\t1aa2,a,a</span><br><span class=\"line\">let re2 = str1.match(reg5)//第二次</span><br><span class=\"line\">console.log(re2.index + &apos;\\t&apos; + reg5.lastIndex + &apos;\\t&apos; + re2.toString())//0\t0\t1aa2,a,a</span><br></pre></td></tr></table></figure>\n<ul>\n<li>全局调用，返回数组中包含所有匹配的字符串，没有找到返回null，没有index、input属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let str2 = &apos;1aa21aa2&apos;</span><br><span class=\"line\">let reg6 = /\\d(\\w)(\\w)\\d/g</span><br><span class=\"line\">let re3 = str1.match(reg6)</span><br><span class=\"line\">console.log(re3.index + &apos;\\t&apos; + reg6.lastIndex + &apos;\\t&apos; + re3.toString())//undefined\t0\t1aa2,1aa2</span><br></pre></td></tr></table></figure>\n<h4 id=\"split\"><a href=\"#split\" class=\"headerlink\" title=\"split()\"></a>split()</h4><ul>\n<li>String.prototype.split(reg)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;1a2b3c4d&apos;.split(/\\d/g))//[&apos;&apos;,a,b,c,d]</span><br></pre></td></tr></table></figure>\n<h4 id=\"replace\"><a href=\"#replace\" class=\"headerlink\" title=\"replace()\"></a>replace()</h4><ul>\n<li>String.prototype.replace(reg)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;aabc&apos;.replace(&apos;a&apos;,&apos;1&apos;))//1abc 转换为/a/正则</span><br><span class=\"line\">console.log(&apos;aabc&apos;.replace(/a/g,&apos;1&apos;))//11bc</span><br></pre></td></tr></table></figure>\n<ul>\n<li>传第二个函数参数function有四个参数：匹配字符串、正则表达式分组内容(没有分组就没这个参数)、匹配项的index、原字符串</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(&apos;a1b2c3d4&apos;.replace(/\\d/g,function (match,index,str) &#123;</span><br><span class=\"line\">    return parseInt(match) + 1</span><br><span class=\"line\">&#125;))//a2b3c4d5</span><br><span class=\"line\">console.log(&apos;a1b2c3d4&apos;.replace(/(\\d)/g,function (match,group,index,str) &#123;</span><br><span class=\"line\">    console.log(group)</span><br><span class=\"line\">    return parseInt(match) + 1</span><br><span class=\"line\">&#125;))//a2b3c4d5</span><br></pre></td></tr></table></figure>\n"},{"title":"js-节流与防抖","date":"2018-11-15T00:14:29.000Z","_content":"\n### 节流(throttle)\n- 在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。\n1. 简单的一定时间内只执行一次\n```\nfunction throttle(fn, interval = 2000) {\n    let lastTime = 0\n    return function () {\n        let context = this\n        let args = arguments\n        let nowTime = +new Date()\n\n        if (nowTime - lastTime > interval) {\n            fn.apply(context, args)\n            lastTime = nowTime\n        }\n    }\n}\n```\n2. 添加leading参数，配置true在周期开始执行，false在周期结束执行\n```\nfunction throttle(fn, interval = 2000, leading = true) {\n    let lastTime = 0\n    return function () {\n        let context = this\n        let args = arguments\n        let nowTime = +new Date()\n\n        if (nowTime - lastTime > interval) {\n            if (leading) {\n                fn.apply(context, args)\n            } else {\n                setTimeout(() => {\n                    fn.apply(context, args)\n                }, interval)\n            }\n            lastTime = nowTime\n        }\n    }\n}\n```\n### 防抖\n- 在某段时间内，如果有新的出发那么更新时间，不管你触发了多少次回调，我都只认最后一次。\n1. 简单的\n```\n//2秒内只要有事件，就重新计时\nfunction debounce(fn, delay = 2000) {\n    let timer = null\n    return function () {\n        let context = this\n        let args = arguments\n\n        if (timer) {\n            clearTimeout(timer)\n        }\n        timer = setTimeout(() => {\n            fn.apply(context, args)\n        }, delay)\n    }\n}\n```\n2. 添加leading参数，配置true在周期开始执行，false在周期结束执行\n```\nfunction debounce(fn, delay = 2000, leading = true) {\n    let timer = null\n    let leadOpen = null\n    return function () {\n        let context = this\n        let args = arguments\n\n        if (leading) {\n            if (!leadOpen) {\n                leadOpen = true\n                fn.apply(context, args)\n            } else {\n                clearTimeout(timer)\n            }\n            timer = setTimeout(() => {\n                leadOpen = false\n            }, delay)\n        } else {\n            if (timer) {\n                clearTimeout(timer)\n            }\n            timer = setTimeout(() => {\n                fn.apply(context, args)\n            }, delay)\n        }\n    }\n}\n```\n3. 添加 maxWait 参数，maxWait 时间一定执行一次\n```\nfunction debounceWithMaxWait(fn, delay = 2000, maxWait = 3000, leading = true) {\n    let timer = null\n    let lastTime = null\n    let leadOpen = null\n    return function () {\n        let context = this\n        let args = arguments\n\n        if (!lastTime) {\n            lastTime = +new Date()\n        }\n\n        let newTime = +new Date()\n\n        if(leading){\n            if (newTime - lastTime < maxWait) {\n                if (!leadOpen) {\n                    leadOpen = true\n                    fn.apply(context, args)\n                } else {\n                    clearTimeout(timer)\n                }\n                timer = setTimeout(() => {\n                    lastTime = null\n                    leadOpen = false\n                }, delay)\n            } else {\n                lastTime = null\n                leadOpen = false\n                clearTimeout(timer)\n            }\n        }else {\n            if (newTime - lastTime < maxWait) {\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                timer = setTimeout(() => {\n                    lastTime = null\n                    fn.apply(context, args)\n                }, delay)\n            } else {\n                lastTime = null\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                fn.apply(context, args)\n            }\n        }\n    }\n}\n```\n### lodash的使用\n1. throttle\n```\ndocument.querySelector('#lodash_throttle').addEventListener('click', _.throttle(() => {\n    console.log('lodash throttle')\n}, 2000, {\n    leading: false,\n    // trailing: true\n}))\n```\n2. debounce\n```\ndocument.querySelector('#lodash_debounce').addEventListener('click', _.debounce(() => {\n    console.log('lodash debounce')\n}, 2000, {\n    maxWait: 3000,\n    leading: false,\n    // trailing: true\n}))\n```\n","source":"_posts/js-节流与防抖.md","raw":"---\ntitle: js-节流与防抖\ndate: 2018-11-15 08:14:29\ntags: [js,节流与防抖]\ncategories: js\n---\n\n### 节流(throttle)\n- 在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。\n1. 简单的一定时间内只执行一次\n```\nfunction throttle(fn, interval = 2000) {\n    let lastTime = 0\n    return function () {\n        let context = this\n        let args = arguments\n        let nowTime = +new Date()\n\n        if (nowTime - lastTime > interval) {\n            fn.apply(context, args)\n            lastTime = nowTime\n        }\n    }\n}\n```\n2. 添加leading参数，配置true在周期开始执行，false在周期结束执行\n```\nfunction throttle(fn, interval = 2000, leading = true) {\n    let lastTime = 0\n    return function () {\n        let context = this\n        let args = arguments\n        let nowTime = +new Date()\n\n        if (nowTime - lastTime > interval) {\n            if (leading) {\n                fn.apply(context, args)\n            } else {\n                setTimeout(() => {\n                    fn.apply(context, args)\n                }, interval)\n            }\n            lastTime = nowTime\n        }\n    }\n}\n```\n### 防抖\n- 在某段时间内，如果有新的出发那么更新时间，不管你触发了多少次回调，我都只认最后一次。\n1. 简单的\n```\n//2秒内只要有事件，就重新计时\nfunction debounce(fn, delay = 2000) {\n    let timer = null\n    return function () {\n        let context = this\n        let args = arguments\n\n        if (timer) {\n            clearTimeout(timer)\n        }\n        timer = setTimeout(() => {\n            fn.apply(context, args)\n        }, delay)\n    }\n}\n```\n2. 添加leading参数，配置true在周期开始执行，false在周期结束执行\n```\nfunction debounce(fn, delay = 2000, leading = true) {\n    let timer = null\n    let leadOpen = null\n    return function () {\n        let context = this\n        let args = arguments\n\n        if (leading) {\n            if (!leadOpen) {\n                leadOpen = true\n                fn.apply(context, args)\n            } else {\n                clearTimeout(timer)\n            }\n            timer = setTimeout(() => {\n                leadOpen = false\n            }, delay)\n        } else {\n            if (timer) {\n                clearTimeout(timer)\n            }\n            timer = setTimeout(() => {\n                fn.apply(context, args)\n            }, delay)\n        }\n    }\n}\n```\n3. 添加 maxWait 参数，maxWait 时间一定执行一次\n```\nfunction debounceWithMaxWait(fn, delay = 2000, maxWait = 3000, leading = true) {\n    let timer = null\n    let lastTime = null\n    let leadOpen = null\n    return function () {\n        let context = this\n        let args = arguments\n\n        if (!lastTime) {\n            lastTime = +new Date()\n        }\n\n        let newTime = +new Date()\n\n        if(leading){\n            if (newTime - lastTime < maxWait) {\n                if (!leadOpen) {\n                    leadOpen = true\n                    fn.apply(context, args)\n                } else {\n                    clearTimeout(timer)\n                }\n                timer = setTimeout(() => {\n                    lastTime = null\n                    leadOpen = false\n                }, delay)\n            } else {\n                lastTime = null\n                leadOpen = false\n                clearTimeout(timer)\n            }\n        }else {\n            if (newTime - lastTime < maxWait) {\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                timer = setTimeout(() => {\n                    lastTime = null\n                    fn.apply(context, args)\n                }, delay)\n            } else {\n                lastTime = null\n                if (timer) {\n                    clearTimeout(timer)\n                }\n                fn.apply(context, args)\n            }\n        }\n    }\n}\n```\n### lodash的使用\n1. throttle\n```\ndocument.querySelector('#lodash_throttle').addEventListener('click', _.throttle(() => {\n    console.log('lodash throttle')\n}, 2000, {\n    leading: false,\n    // trailing: true\n}))\n```\n2. debounce\n```\ndocument.querySelector('#lodash_debounce').addEventListener('click', _.debounce(() => {\n    console.log('lodash debounce')\n}, 2000, {\n    maxWait: 3000,\n    leading: false,\n    // trailing: true\n}))\n```\n","slug":"js-节流与防抖","published":1,"updated":"2019-01-02T12:15:44.710Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob70001qe0jcso5e1b04","content":"<h3 id=\"节流-throttle\"><a href=\"#节流-throttle\" class=\"headerlink\" title=\"节流(throttle)\"></a>节流(throttle)</h3><ul>\n<li>在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。</li>\n</ul>\n<ol>\n<li><p>简单的一定时间内只执行一次</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(fn, interval = 2000) &#123;</span><br><span class=\"line\">    let lastTime = 0</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context = this</span><br><span class=\"line\">        let args = arguments</span><br><span class=\"line\">        let nowTime = +new Date()</span><br><span class=\"line\"></span><br><span class=\"line\">        if (nowTime - lastTime &gt; interval) &#123;</span><br><span class=\"line\">            fn.apply(context, args)</span><br><span class=\"line\">            lastTime = nowTime</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加leading参数，配置true在周期开始执行，false在周期结束执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(fn, interval = 2000, leading = true) &#123;</span><br><span class=\"line\">    let lastTime = 0</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context = this</span><br><span class=\"line\">        let args = arguments</span><br><span class=\"line\">        let nowTime = +new Date()</span><br><span class=\"line\"></span><br><span class=\"line\">        if (nowTime - lastTime &gt; interval) &#123;</span><br><span class=\"line\">            if (leading) &#123;</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                    fn.apply(context, args)</span><br><span class=\"line\">                &#125;, interval)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            lastTime = nowTime</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><ul>\n<li>在某段时间内，如果有新的出发那么更新时间，不管你触发了多少次回调，我都只认最后一次。</li>\n</ul>\n<ol>\n<li><p>简单的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//2秒内只要有事件，就重新计时</span><br><span class=\"line\">function debounce(fn, delay = 2000) &#123;</span><br><span class=\"line\">    let timer = null</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context = this</span><br><span class=\"line\">        let args = arguments</span><br><span class=\"line\"></span><br><span class=\"line\">        if (timer) &#123;</span><br><span class=\"line\">            clearTimeout(timer)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            fn.apply(context, args)</span><br><span class=\"line\">        &#125;, delay)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加leading参数，配置true在周期开始执行，false在周期结束执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(fn, delay = 2000, leading = true) &#123;</span><br><span class=\"line\">    let timer = null</span><br><span class=\"line\">    let leadOpen = null</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context = this</span><br><span class=\"line\">        let args = arguments</span><br><span class=\"line\"></span><br><span class=\"line\">        if (leading) &#123;</span><br><span class=\"line\">            if (!leadOpen) &#123;</span><br><span class=\"line\">                leadOpen = true</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                clearTimeout(timer)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                leadOpen = false</span><br><span class=\"line\">            &#125;, delay)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (timer) &#123;</span><br><span class=\"line\">                clearTimeout(timer)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125;, delay)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加 maxWait 参数，maxWait 时间一定执行一次</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounceWithMaxWait(fn, delay = 2000, maxWait = 3000, leading = true) &#123;</span><br><span class=\"line\">    let timer = null</span><br><span class=\"line\">    let lastTime = null</span><br><span class=\"line\">    let leadOpen = null</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context = this</span><br><span class=\"line\">        let args = arguments</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!lastTime) &#123;</span><br><span class=\"line\">            lastTime = +new Date()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        let newTime = +new Date()</span><br><span class=\"line\"></span><br><span class=\"line\">        if(leading)&#123;</span><br><span class=\"line\">            if (newTime - lastTime &lt; maxWait) &#123;</span><br><span class=\"line\">                if (!leadOpen) &#123;</span><br><span class=\"line\">                    leadOpen = true</span><br><span class=\"line\">                    fn.apply(context, args)</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    clearTimeout(timer)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                    lastTime = null</span><br><span class=\"line\">                    leadOpen = false</span><br><span class=\"line\">                &#125;, delay)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                lastTime = null</span><br><span class=\"line\">                leadOpen = false</span><br><span class=\"line\">                clearTimeout(timer)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            if (newTime - lastTime &lt; maxWait) &#123;</span><br><span class=\"line\">                if (timer) &#123;</span><br><span class=\"line\">                    clearTimeout(timer)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                    lastTime = null</span><br><span class=\"line\">                    fn.apply(context, args)</span><br><span class=\"line\">                &#125;, delay)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                lastTime = null</span><br><span class=\"line\">                if (timer) &#123;</span><br><span class=\"line\">                    clearTimeout(timer)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"lodash的使用\"><a href=\"#lodash的使用\" class=\"headerlink\" title=\"lodash的使用\"></a>lodash的使用</h3><ol>\n<li><p>throttle</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.querySelector(&apos;#lodash_throttle&apos;).addEventListener(&apos;click&apos;, _.throttle(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;lodash throttle&apos;)</span><br><span class=\"line\">&#125;, 2000, &#123;</span><br><span class=\"line\">    leading: false,</span><br><span class=\"line\">    // trailing: true</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>debounce</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.querySelector(&apos;#lodash_debounce&apos;).addEventListener(&apos;click&apos;, _.debounce(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;lodash debounce&apos;)</span><br><span class=\"line\">&#125;, 2000, &#123;</span><br><span class=\"line\">    maxWait: 3000,</span><br><span class=\"line\">    leading: false,</span><br><span class=\"line\">    // trailing: true</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"节流-throttle\"><a href=\"#节流-throttle\" class=\"headerlink\" title=\"节流(throttle)\"></a>节流(throttle)</h3><ul>\n<li>在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。</li>\n</ul>\n<ol>\n<li><p>简单的一定时间内只执行一次</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(fn, interval = 2000) &#123;</span><br><span class=\"line\">    let lastTime = 0</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context = this</span><br><span class=\"line\">        let args = arguments</span><br><span class=\"line\">        let nowTime = +new Date()</span><br><span class=\"line\"></span><br><span class=\"line\">        if (nowTime - lastTime &gt; interval) &#123;</span><br><span class=\"line\">            fn.apply(context, args)</span><br><span class=\"line\">            lastTime = nowTime</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加leading参数，配置true在周期开始执行，false在周期结束执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function throttle(fn, interval = 2000, leading = true) &#123;</span><br><span class=\"line\">    let lastTime = 0</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context = this</span><br><span class=\"line\">        let args = arguments</span><br><span class=\"line\">        let nowTime = +new Date()</span><br><span class=\"line\"></span><br><span class=\"line\">        if (nowTime - lastTime &gt; interval) &#123;</span><br><span class=\"line\">            if (leading) &#123;</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                    fn.apply(context, args)</span><br><span class=\"line\">                &#125;, interval)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            lastTime = nowTime</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"防抖\"><a href=\"#防抖\" class=\"headerlink\" title=\"防抖\"></a>防抖</h3><ul>\n<li>在某段时间内，如果有新的出发那么更新时间，不管你触发了多少次回调，我都只认最后一次。</li>\n</ul>\n<ol>\n<li><p>简单的</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//2秒内只要有事件，就重新计时</span><br><span class=\"line\">function debounce(fn, delay = 2000) &#123;</span><br><span class=\"line\">    let timer = null</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context = this</span><br><span class=\"line\">        let args = arguments</span><br><span class=\"line\"></span><br><span class=\"line\">        if (timer) &#123;</span><br><span class=\"line\">            clearTimeout(timer)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">            fn.apply(context, args)</span><br><span class=\"line\">        &#125;, delay)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加leading参数，配置true在周期开始执行，false在周期结束执行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounce(fn, delay = 2000, leading = true) &#123;</span><br><span class=\"line\">    let timer = null</span><br><span class=\"line\">    let leadOpen = null</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context = this</span><br><span class=\"line\">        let args = arguments</span><br><span class=\"line\"></span><br><span class=\"line\">        if (leading) &#123;</span><br><span class=\"line\">            if (!leadOpen) &#123;</span><br><span class=\"line\">                leadOpen = true</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                clearTimeout(timer)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                leadOpen = false</span><br><span class=\"line\">            &#125;, delay)</span><br><span class=\"line\">        &#125; else &#123;</span><br><span class=\"line\">            if (timer) &#123;</span><br><span class=\"line\">                clearTimeout(timer)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125;, delay)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加 maxWait 参数，maxWait 时间一定执行一次</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function debounceWithMaxWait(fn, delay = 2000, maxWait = 3000, leading = true) &#123;</span><br><span class=\"line\">    let timer = null</span><br><span class=\"line\">    let lastTime = null</span><br><span class=\"line\">    let leadOpen = null</span><br><span class=\"line\">    return function () &#123;</span><br><span class=\"line\">        let context = this</span><br><span class=\"line\">        let args = arguments</span><br><span class=\"line\"></span><br><span class=\"line\">        if (!lastTime) &#123;</span><br><span class=\"line\">            lastTime = +new Date()</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        let newTime = +new Date()</span><br><span class=\"line\"></span><br><span class=\"line\">        if(leading)&#123;</span><br><span class=\"line\">            if (newTime - lastTime &lt; maxWait) &#123;</span><br><span class=\"line\">                if (!leadOpen) &#123;</span><br><span class=\"line\">                    leadOpen = true</span><br><span class=\"line\">                    fn.apply(context, args)</span><br><span class=\"line\">                &#125; else &#123;</span><br><span class=\"line\">                    clearTimeout(timer)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                    lastTime = null</span><br><span class=\"line\">                    leadOpen = false</span><br><span class=\"line\">                &#125;, delay)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                lastTime = null</span><br><span class=\"line\">                leadOpen = false</span><br><span class=\"line\">                clearTimeout(timer)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;else &#123;</span><br><span class=\"line\">            if (newTime - lastTime &lt; maxWait) &#123;</span><br><span class=\"line\">                if (timer) &#123;</span><br><span class=\"line\">                    clearTimeout(timer)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                timer = setTimeout(() =&gt; &#123;</span><br><span class=\"line\">                    lastTime = null</span><br><span class=\"line\">                    fn.apply(context, args)</span><br><span class=\"line\">                &#125;, delay)</span><br><span class=\"line\">            &#125; else &#123;</span><br><span class=\"line\">                lastTime = null</span><br><span class=\"line\">                if (timer) &#123;</span><br><span class=\"line\">                    clearTimeout(timer)</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                fn.apply(context, args)</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"lodash的使用\"><a href=\"#lodash的使用\" class=\"headerlink\" title=\"lodash的使用\"></a>lodash的使用</h3><ol>\n<li><p>throttle</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.querySelector(&apos;#lodash_throttle&apos;).addEventListener(&apos;click&apos;, _.throttle(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;lodash throttle&apos;)</span><br><span class=\"line\">&#125;, 2000, &#123;</span><br><span class=\"line\">    leading: false,</span><br><span class=\"line\">    // trailing: true</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>debounce</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">document.querySelector(&apos;#lodash_debounce&apos;).addEventListener(&apos;click&apos;, _.debounce(() =&gt; &#123;</span><br><span class=\"line\">    console.log(&apos;lodash debounce&apos;)</span><br><span class=\"line\">&#125;, 2000, &#123;</span><br><span class=\"line\">    maxWait: 3000,</span><br><span class=\"line\">    leading: false,</span><br><span class=\"line\">    // trailing: true</span><br><span class=\"line\">&#125;))</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"postcss相关","date":"2019-01-31T12:02:45.000Z","_content":"#### postcss做了什么\n1. postcss 将你的 css 文件转变成 JS 对象\n2. postcss 插件会遍历生成的js对象添加/删除/修改 选择器或属性\n3. postcss 将该对象转换成 css 文件\n#### webpack配置postcss\n```\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'postcss-loader'],\n      },\n      {\n        test: /\\.jsx?$/,\n        use: ['babel-loader', 'astroturf/loader'],\n      }\n    ]\n  }\n}\n```\n#### 常用postcss插件\n##### autoprefixer\n- 添加浏览器前缀\n##### postcss-import\n- 解析@import路径用\n- https://github.com/postcss/postcss-import\n##### postcss-url\n- 解析url()，可以改路径、转换base64、复制加hash\n- https://github.com/postcss/postcss-url\n##### postcss-plugin-px2rem\n- 转换px为rem\n- https://github.com/pigcan/postcss-plugin-px2rem\n#### .postcssrc.js文件配置\n```\nmodule.exports = {\n    \"plugins\": {\n        \"postcss-import\": {},\n        \"postcss-url\": {},\n        \"postcss-plugin-px2rem\": {\n            //设计稿尺寸/10\n            rootValue: 37.5,\n            //屏蔽的属性\n            propBlackList: ['border'],\n            //屏蔽的路径\n            exclude: /src/,\n        },\n        \"autoprefixer\": {}\n    }\n}\n```\n","source":"_posts/postcss相关.md","raw":"---\ntitle: postcss相关\ndate: 2019-01-31 20:02:45\ntags: [css,postcss]\ncategories: postcss\n---\n#### postcss做了什么\n1. postcss 将你的 css 文件转变成 JS 对象\n2. postcss 插件会遍历生成的js对象添加/删除/修改 选择器或属性\n3. postcss 将该对象转换成 css 文件\n#### webpack配置postcss\n```\nmodule.exports = {\n  module: {\n    rules: [\n      {\n        test: /\\.css$/,\n        use: ['style-loader', 'postcss-loader'],\n      },\n      {\n        test: /\\.jsx?$/,\n        use: ['babel-loader', 'astroturf/loader'],\n      }\n    ]\n  }\n}\n```\n#### 常用postcss插件\n##### autoprefixer\n- 添加浏览器前缀\n##### postcss-import\n- 解析@import路径用\n- https://github.com/postcss/postcss-import\n##### postcss-url\n- 解析url()，可以改路径、转换base64、复制加hash\n- https://github.com/postcss/postcss-url\n##### postcss-plugin-px2rem\n- 转换px为rem\n- https://github.com/pigcan/postcss-plugin-px2rem\n#### .postcssrc.js文件配置\n```\nmodule.exports = {\n    \"plugins\": {\n        \"postcss-import\": {},\n        \"postcss-url\": {},\n        \"postcss-plugin-px2rem\": {\n            //设计稿尺寸/10\n            rootValue: 37.5,\n            //屏蔽的属性\n            propBlackList: ['border'],\n            //屏蔽的路径\n            exclude: /src/,\n        },\n        \"autoprefixer\": {}\n    }\n}\n```\n","slug":"postcss相关","published":1,"updated":"2019-01-31T12:29:54.527Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob72001te0jc4jhoadtd","content":"<h4 id=\"postcss做了什么\"><a href=\"#postcss做了什么\" class=\"headerlink\" title=\"postcss做了什么\"></a>postcss做了什么</h4><ol>\n<li>postcss 将你的 css 文件转变成 JS 对象</li>\n<li>postcss 插件会遍历生成的js对象添加/删除/修改 选择器或属性</li>\n<li>postcss 将该对象转换成 css 文件<h4 id=\"webpack配置postcss\"><a href=\"#webpack配置postcss\" class=\"headerlink\" title=\"webpack配置postcss\"></a>webpack配置postcss</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        use: [&apos;style-loader&apos;, &apos;postcss-loader&apos;],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.jsx?$/,</span><br><span class=\"line\">        use: [&apos;babel-loader&apos;, &apos;astroturf/loader&apos;],</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"常用postcss插件\"><a href=\"#常用postcss插件\" class=\"headerlink\" title=\"常用postcss插件\"></a>常用postcss插件</h4><h5 id=\"autoprefixer\"><a href=\"#autoprefixer\" class=\"headerlink\" title=\"autoprefixer\"></a>autoprefixer</h5><ul>\n<li>添加浏览器前缀<h5 id=\"postcss-import\"><a href=\"#postcss-import\" class=\"headerlink\" title=\"postcss-import\"></a>postcss-import</h5></li>\n<li>解析@import路径用</li>\n<li><a href=\"https://github.com/postcss/postcss-import\">https://github.com/postcss/postcss-import</a><h5 id=\"postcss-url\"><a href=\"#postcss-url\" class=\"headerlink\" title=\"postcss-url\"></a>postcss-url</h5></li>\n<li>解析url()，可以改路径、转换base64、复制加hash</li>\n<li><a href=\"https://github.com/postcss/postcss-url\">https://github.com/postcss/postcss-url</a><h5 id=\"postcss-plugin-px2rem\"><a href=\"#postcss-plugin-px2rem\" class=\"headerlink\" title=\"postcss-plugin-px2rem\"></a>postcss-plugin-px2rem</h5></li>\n<li>转换px为rem</li>\n<li><a href=\"https://github.com/pigcan/postcss-plugin-px2rem\">https://github.com/pigcan/postcss-plugin-px2rem</a><h4 id=\"postcssrc-js文件配置\"><a href=\"#postcssrc-js文件配置\" class=\"headerlink\" title=\".postcssrc.js文件配置\"></a>.postcssrc.js文件配置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    &quot;plugins&quot;: &#123;</span><br><span class=\"line\">        &quot;postcss-import&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-url&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-plugin-px2rem&quot;: &#123;</span><br><span class=\"line\">            //设计稿尺寸/10</span><br><span class=\"line\">            rootValue: 37.5,</span><br><span class=\"line\">            //屏蔽的属性</span><br><span class=\"line\">            propBlackList: [&apos;border&apos;],</span><br><span class=\"line\">            //屏蔽的路径</span><br><span class=\"line\">            exclude: /src/,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;autoprefixer&quot;: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"postcss做了什么\"><a href=\"#postcss做了什么\" class=\"headerlink\" title=\"postcss做了什么\"></a>postcss做了什么</h4><ol>\n<li>postcss 将你的 css 文件转变成 JS 对象</li>\n<li>postcss 插件会遍历生成的js对象添加/删除/修改 选择器或属性</li>\n<li>postcss 将该对象转换成 css 文件<h4 id=\"webpack配置postcss\"><a href=\"#webpack配置postcss\" class=\"headerlink\" title=\"webpack配置postcss\"></a>webpack配置postcss</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">  module: &#123;</span><br><span class=\"line\">    rules: [</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.css$/,</span><br><span class=\"line\">        use: [&apos;style-loader&apos;, &apos;postcss-loader&apos;],</span><br><span class=\"line\">      &#125;,</span><br><span class=\"line\">      &#123;</span><br><span class=\"line\">        test: /\\.jsx?$/,</span><br><span class=\"line\">        use: [&apos;babel-loader&apos;, &apos;astroturf/loader&apos;],</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"常用postcss插件\"><a href=\"#常用postcss插件\" class=\"headerlink\" title=\"常用postcss插件\"></a>常用postcss插件</h4><h5 id=\"autoprefixer\"><a href=\"#autoprefixer\" class=\"headerlink\" title=\"autoprefixer\"></a>autoprefixer</h5><ul>\n<li>添加浏览器前缀<h5 id=\"postcss-import\"><a href=\"#postcss-import\" class=\"headerlink\" title=\"postcss-import\"></a>postcss-import</h5></li>\n<li>解析@import路径用</li>\n<li><a href=\"https://github.com/postcss/postcss-import\">https://github.com/postcss/postcss-import</a><h5 id=\"postcss-url\"><a href=\"#postcss-url\" class=\"headerlink\" title=\"postcss-url\"></a>postcss-url</h5></li>\n<li>解析url()，可以改路径、转换base64、复制加hash</li>\n<li><a href=\"https://github.com/postcss/postcss-url\">https://github.com/postcss/postcss-url</a><h5 id=\"postcss-plugin-px2rem\"><a href=\"#postcss-plugin-px2rem\" class=\"headerlink\" title=\"postcss-plugin-px2rem\"></a>postcss-plugin-px2rem</h5></li>\n<li>转换px为rem</li>\n<li><a href=\"https://github.com/pigcan/postcss-plugin-px2rem\">https://github.com/pigcan/postcss-plugin-px2rem</a><h4 id=\"postcssrc-js文件配置\"><a href=\"#postcssrc-js文件配置\" class=\"headerlink\" title=\".postcssrc.js文件配置\"></a>.postcssrc.js文件配置</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    &quot;plugins&quot;: &#123;</span><br><span class=\"line\">        &quot;postcss-import&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-url&quot;: &#123;&#125;,</span><br><span class=\"line\">        &quot;postcss-plugin-px2rem&quot;: &#123;</span><br><span class=\"line\">            //设计稿尺寸/10</span><br><span class=\"line\">            rootValue: 37.5,</span><br><span class=\"line\">            //屏蔽的属性</span><br><span class=\"line\">            propBlackList: [&apos;border&apos;],</span><br><span class=\"line\">            //屏蔽的路径</span><br><span class=\"line\">            exclude: /src/,</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &quot;autoprefixer&quot;: &#123;&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"translateY()实现列表hover的box-shadow动画","date":"2018-10-02T12:08:30.000Z","_content":"[demo](https://codepen.io/crazyaguai/pen/gQvBdY)\n\n```\n<style>\n    .container{\n        transition: box-shadow .28s cubic-bezier(.4,0,.2,1);\n        box-shadow: 0 1px 4px 0 rgba(10,16,20,.37);\n    }\n    .item{\n        color: #1a2326;\n        border: 1px solid transparent;\n        margin: 0;\n        padding: 16px 23px;\n        position: relative;\n        text-decoration: none;\n        transition: .3s;\n        height: 60px;\n    }\n    .item:hover{\n        cursor: pointer;\n        border-color: #2b85e7;\n        border-radius: 4px;\n        box-shadow: 0 8px 8px rgba(1,67,163,.24), 0 0 8px rgba(1,67,163,.12), 0 6px 18px rgba(43,133,231,.12);\n        transform: translateY(-2px);\n    }\n</style>\n<body>\n<div class=\"container\">\n    <div class=\"item\">1</div>\n    <div class=\"item\">2</div>\n    <div class=\"item\">3</div>\n    <div class=\"item\">4</div>\n    <div class=\"item\">5</div>\n</div>\n</body>\n```\n","source":"_posts/translateY-实现列表hover的box-shadow动画.md","raw":"---\ntitle: translateY()实现列表hover的box-shadow动画\ndate: 2018-10-02 20:08:30\ntags: [css,css动画]\ncategories: css\n---\n[demo](https://codepen.io/crazyaguai/pen/gQvBdY)\n\n```\n<style>\n    .container{\n        transition: box-shadow .28s cubic-bezier(.4,0,.2,1);\n        box-shadow: 0 1px 4px 0 rgba(10,16,20,.37);\n    }\n    .item{\n        color: #1a2326;\n        border: 1px solid transparent;\n        margin: 0;\n        padding: 16px 23px;\n        position: relative;\n        text-decoration: none;\n        transition: .3s;\n        height: 60px;\n    }\n    .item:hover{\n        cursor: pointer;\n        border-color: #2b85e7;\n        border-radius: 4px;\n        box-shadow: 0 8px 8px rgba(1,67,163,.24), 0 0 8px rgba(1,67,163,.12), 0 6px 18px rgba(43,133,231,.12);\n        transform: translateY(-2px);\n    }\n</style>\n<body>\n<div class=\"container\">\n    <div class=\"item\">1</div>\n    <div class=\"item\">2</div>\n    <div class=\"item\">3</div>\n    <div class=\"item\">4</div>\n    <div class=\"item\">5</div>\n</div>\n</body>\n```\n","slug":"translateY-实现列表hover的box-shadow动画","published":1,"updated":"2019-01-02T12:10:16.410Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob73001xe0jcd7lwwa0o","content":"<p><a href=\"https://codepen.io/crazyaguai/pen/gQvBdY\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .container&#123;</span><br><span class=\"line\">        transition: box-shadow .28s cubic-bezier(.4,0,.2,1);</span><br><span class=\"line\">        box-shadow: 0 1px 4px 0 rgba(10,16,20,.37);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .item&#123;</span><br><span class=\"line\">        color: #1a2326;</span><br><span class=\"line\">        border: 1px solid transparent;</span><br><span class=\"line\">        margin: 0;</span><br><span class=\"line\">        padding: 16px 23px;</span><br><span class=\"line\">        position: relative;</span><br><span class=\"line\">        text-decoration: none;</span><br><span class=\"line\">        transition: .3s;</span><br><span class=\"line\">        height: 60px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .item:hover&#123;</span><br><span class=\"line\">        cursor: pointer;</span><br><span class=\"line\">        border-color: #2b85e7;</span><br><span class=\"line\">        border-radius: 4px;</span><br><span class=\"line\">        box-shadow: 0 8px 8px rgba(1,67,163,.24), 0 0 8px rgba(1,67,163,.12), 0 6px 18px rgba(43,133,231,.12);</span><br><span class=\"line\">        transform: translateY(-2px);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item&quot;&gt;3&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item&quot;&gt;4&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item&quot;&gt;5&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://codepen.io/crazyaguai/pen/gQvBdY\" target=\"_blank\" rel=\"noopener\">demo</a></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;style&gt;</span><br><span class=\"line\">    .container&#123;</span><br><span class=\"line\">        transition: box-shadow .28s cubic-bezier(.4,0,.2,1);</span><br><span class=\"line\">        box-shadow: 0 1px 4px 0 rgba(10,16,20,.37);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .item&#123;</span><br><span class=\"line\">        color: #1a2326;</span><br><span class=\"line\">        border: 1px solid transparent;</span><br><span class=\"line\">        margin: 0;</span><br><span class=\"line\">        padding: 16px 23px;</span><br><span class=\"line\">        position: relative;</span><br><span class=\"line\">        text-decoration: none;</span><br><span class=\"line\">        transition: .3s;</span><br><span class=\"line\">        height: 60px;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    .item:hover&#123;</span><br><span class=\"line\">        cursor: pointer;</span><br><span class=\"line\">        border-color: #2b85e7;</span><br><span class=\"line\">        border-radius: 4px;</span><br><span class=\"line\">        box-shadow: 0 8px 8px rgba(1,67,163,.24), 0 0 8px rgba(1,67,163,.12), 0 6px 18px rgba(43,133,231,.12);</span><br><span class=\"line\">        transform: translateY(-2px);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&lt;/style&gt;</span><br><span class=\"line\">&lt;body&gt;</span><br><span class=\"line\">&lt;div class=&quot;container&quot;&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item&quot;&gt;1&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item&quot;&gt;2&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item&quot;&gt;3&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item&quot;&gt;4&lt;/div&gt;</span><br><span class=\"line\">    &lt;div class=&quot;item&quot;&gt;5&lt;/div&gt;</span><br><span class=\"line\">&lt;/div&gt;</span><br><span class=\"line\">&lt;/body&gt;</span><br></pre></td></tr></table></figure>\n"},{"title":"webpack-CommonsChunkPlugin与optimization.splitChunks","date":"2019-01-15T07:53:43.000Z","_content":"### CommonsChunkPlugin\n- 配置文档：https://www.webpackjs.com/plugins/commons-chunk-plugin/\n- 例子\n```\n//打包node_modules的公共代码\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'vendor',\n    chunks: commonChunks,//所有入口集合，如果不添加（文档里面说默认是所有入口），但是实际使用过程中不会打包所有入口公共代码，多以还是要添加为所有入口集合。\n    minChunks(module, count) {\n        return (\n            module.resource &&\n            /\\.js$/.test(module.resource) && module.resource.indexOf(\n                path.join(__dirname, '../node_modules')) === 0 && count >= 2\n        )\n    }\n}),\n//打包src下的公共代码\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'commonChunk',\n    chunks: commonChunks,\n    minChunks: function (module, count) {\n        // 保证commonChunk中的内容都是js且是scr下面调用的\n        return (\n            module.resource && /\\.js$/.test(module.resource) &&\n            module.resource.indexOf(\n                path.join(__dirname, '../src')\n            ) === 0 && count >= config.build.minChunks\n        )\n    }\n}),\n// webpackComonsChunk的执行环境，包含module的映射信息，会经常变化\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'manifest',\n    minChunks: Infinity\n}),\n```\n### optimization.splitChunks\n- 配置文档：https://webpack.js.org/plugins/split-chunks-plugin/\n```\noptimization: {\n    minimize: false,\n    splitChunks: {\n        minSize: 0,\n        // automaticNameDelimiter: '-',//文件名称分隔符默认'~'\n        chunks: \"all\",//选择哪些块进行优化，可选值：all、async和initial\n        cacheGroups: {\n            //拆分a入口文件node_modules引入的模块\n            vendorA: {\n                name: 'vendors-a',\n                test (module, chunks) {//匹配\n                    let res = (\n                        module.resource &&\n                        /\\.js$/.test(module.resource) &&\n                        module.resource.indexOf(path.join(__dirname, '../node_modules')) === 0 &&\n                        chunks.length == 1 &&\n                        chunks[0].name == 'a'\n                    )\n                    return res\n                },\n                // priority: 1,//打包首选优先级更高的缓存组，默认组的优先级为负，配置enforce会选择所有组\n                chunks: 'all',\n                minSize: 0,\n                enforce: true,//需要设置为true，否则会根据priority（优先级）等其他配置打包\n                minChunks: 1\n            },\n            //所有入口src下公共模块\n            commons: {\n                name: 'commons',\n                test (module, chunks) {\n                    let res = (\n                        module.resource &&\n                        /\\.js$/.test(module.resource) &&\n                        module.resource.indexOf(path.join(__dirname, '../src')) === 0 &&\n                        chunks.length >= 2\n                    )\n                    return res\n                },\n                chunks: 'all',\n                minSize: 0,\n                enforce: true,\n                minChunks: 1\n            },\n            //所有入口node_modules下公共模块\n            vendor: {\n                name: 'vendors',\n                test (module, chunks) {\n                    let res = (\n                        module.resource &&\n                        /\\.js$/.test(module.resource) &&\n                        module.resource.indexOf(path.join(__dirname, '../node_modules')) === 0 &&\n                        chunks.length >= 2\n                    )\n                    return res\n                },\n                chunks: 'all',\n                minSize: 0,\n                enforce: true,\n                minChunks: 1\n            }\n        },\n    },\n    //webpack运行文件\n    runtimeChunk: {\n        name: \"manifest\"\n    },\n},\n```\n","source":"_posts/webpack-CommonsChunkPlugin与optimization-splitChunks.md","raw":"---\ntitle: webpack-CommonsChunkPlugin与optimization.splitChunks\ndate: 2019-01-15 15:53:43\ntags: [webpack]\ncategories: webpack\n---\n### CommonsChunkPlugin\n- 配置文档：https://www.webpackjs.com/plugins/commons-chunk-plugin/\n- 例子\n```\n//打包node_modules的公共代码\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'vendor',\n    chunks: commonChunks,//所有入口集合，如果不添加（文档里面说默认是所有入口），但是实际使用过程中不会打包所有入口公共代码，多以还是要添加为所有入口集合。\n    minChunks(module, count) {\n        return (\n            module.resource &&\n            /\\.js$/.test(module.resource) && module.resource.indexOf(\n                path.join(__dirname, '../node_modules')) === 0 && count >= 2\n        )\n    }\n}),\n//打包src下的公共代码\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'commonChunk',\n    chunks: commonChunks,\n    minChunks: function (module, count) {\n        // 保证commonChunk中的内容都是js且是scr下面调用的\n        return (\n            module.resource && /\\.js$/.test(module.resource) &&\n            module.resource.indexOf(\n                path.join(__dirname, '../src')\n            ) === 0 && count >= config.build.minChunks\n        )\n    }\n}),\n// webpackComonsChunk的执行环境，包含module的映射信息，会经常变化\nnew webpack.optimize.CommonsChunkPlugin({\n    name: 'manifest',\n    minChunks: Infinity\n}),\n```\n### optimization.splitChunks\n- 配置文档：https://webpack.js.org/plugins/split-chunks-plugin/\n```\noptimization: {\n    minimize: false,\n    splitChunks: {\n        minSize: 0,\n        // automaticNameDelimiter: '-',//文件名称分隔符默认'~'\n        chunks: \"all\",//选择哪些块进行优化，可选值：all、async和initial\n        cacheGroups: {\n            //拆分a入口文件node_modules引入的模块\n            vendorA: {\n                name: 'vendors-a',\n                test (module, chunks) {//匹配\n                    let res = (\n                        module.resource &&\n                        /\\.js$/.test(module.resource) &&\n                        module.resource.indexOf(path.join(__dirname, '../node_modules')) === 0 &&\n                        chunks.length == 1 &&\n                        chunks[0].name == 'a'\n                    )\n                    return res\n                },\n                // priority: 1,//打包首选优先级更高的缓存组，默认组的优先级为负，配置enforce会选择所有组\n                chunks: 'all',\n                minSize: 0,\n                enforce: true,//需要设置为true，否则会根据priority（优先级）等其他配置打包\n                minChunks: 1\n            },\n            //所有入口src下公共模块\n            commons: {\n                name: 'commons',\n                test (module, chunks) {\n                    let res = (\n                        module.resource &&\n                        /\\.js$/.test(module.resource) &&\n                        module.resource.indexOf(path.join(__dirname, '../src')) === 0 &&\n                        chunks.length >= 2\n                    )\n                    return res\n                },\n                chunks: 'all',\n                minSize: 0,\n                enforce: true,\n                minChunks: 1\n            },\n            //所有入口node_modules下公共模块\n            vendor: {\n                name: 'vendors',\n                test (module, chunks) {\n                    let res = (\n                        module.resource &&\n                        /\\.js$/.test(module.resource) &&\n                        module.resource.indexOf(path.join(__dirname, '../node_modules')) === 0 &&\n                        chunks.length >= 2\n                    )\n                    return res\n                },\n                chunks: 'all',\n                minSize: 0,\n                enforce: true,\n                minChunks: 1\n            }\n        },\n    },\n    //webpack运行文件\n    runtimeChunk: {\n        name: \"manifest\"\n    },\n},\n```\n","slug":"webpack-CommonsChunkPlugin与optimization-splitChunks","published":1,"updated":"2019-01-15T07:54:05.562Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob760021e0jc7cnv7d1f","content":"<h3 id=\"CommonsChunkPlugin\"><a href=\"#CommonsChunkPlugin\" class=\"headerlink\" title=\"CommonsChunkPlugin\"></a>CommonsChunkPlugin</h3><ul>\n<li>配置文档：<a href=\"https://www.webpackjs.com/plugins/commons-chunk-plugin/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/plugins/commons-chunk-plugin/</a></li>\n<li>例子<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//打包node_modules的公共代码</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: &apos;vendor&apos;,</span><br><span class=\"line\">    chunks: commonChunks,//所有入口集合，如果不添加（文档里面说默认是所有入口），但是实际使用过程中不会打包所有入口公共代码，多以还是要添加为所有入口集合。</span><br><span class=\"line\">    minChunks(module, count) &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            module.resource &amp;&amp;</span><br><span class=\"line\">            /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf(</span><br><span class=\"line\">                path.join(__dirname, &apos;../node_modules&apos;)) === 0 &amp;&amp; count &gt;= 2</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\">//打包src下的公共代码</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: &apos;commonChunk&apos;,</span><br><span class=\"line\">    chunks: commonChunks,</span><br><span class=\"line\">    minChunks: function (module, count) &#123;</span><br><span class=\"line\">        // 保证commonChunk中的内容都是js且是scr下面调用的</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp;</span><br><span class=\"line\">            module.resource.indexOf(</span><br><span class=\"line\">                path.join(__dirname, &apos;../src&apos;)</span><br><span class=\"line\">            ) === 0 &amp;&amp; count &gt;= config.build.minChunks</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\">// webpackComonsChunk的执行环境，包含module的映射信息，会经常变化</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: &apos;manifest&apos;,</span><br><span class=\"line\">    minChunks: Infinity</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"optimization-splitChunks\"><a href=\"#optimization-splitChunks\" class=\"headerlink\" title=\"optimization.splitChunks\"></a>optimization.splitChunks</h3><ul>\n<li>配置文档：<a href=\"https://webpack.js.org/plugins/split-chunks-plugin/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/plugins/split-chunks-plugin/</a><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">optimization: &#123;</span><br><span class=\"line\">    minimize: false,</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">        minSize: 0,</span><br><span class=\"line\">        // automaticNameDelimiter: &apos;-&apos;,//文件名称分隔符默认&apos;~&apos;</span><br><span class=\"line\">        chunks: &quot;all&quot;,//选择哪些块进行优化，可选值：all、async和initial</span><br><span class=\"line\">        cacheGroups: &#123;</span><br><span class=\"line\">            //拆分a入口文件node_modules引入的模块</span><br><span class=\"line\">            vendorA: &#123;</span><br><span class=\"line\">                name: &apos;vendors-a&apos;,</span><br><span class=\"line\">                test (module, chunks) &#123;//匹配</span><br><span class=\"line\">                    let res = (</span><br><span class=\"line\">                        module.resource &amp;&amp;</span><br><span class=\"line\">                        /\\.js$/.test(module.resource) &amp;&amp;</span><br><span class=\"line\">                        module.resource.indexOf(path.join(__dirname, &apos;../node_modules&apos;)) === 0 &amp;&amp;</span><br><span class=\"line\">                        chunks.length == 1 &amp;&amp;</span><br><span class=\"line\">                        chunks[0].name == &apos;a&apos;</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                    return res</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                // priority: 1,//打包首选优先级更高的缓存组，默认组的优先级为负，配置enforce会选择所有组</span><br><span class=\"line\">                chunks: &apos;all&apos;,</span><br><span class=\"line\">                minSize: 0,</span><br><span class=\"line\">                enforce: true,//需要设置为true，否则会根据priority（优先级）等其他配置打包</span><br><span class=\"line\">                minChunks: 1</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            //所有入口src下公共模块</span><br><span class=\"line\">            commons: &#123;</span><br><span class=\"line\">                name: &apos;commons&apos;,</span><br><span class=\"line\">                test (module, chunks) &#123;</span><br><span class=\"line\">                    let res = (</span><br><span class=\"line\">                        module.resource &amp;&amp;</span><br><span class=\"line\">                        /\\.js$/.test(module.resource) &amp;&amp;</span><br><span class=\"line\">                        module.resource.indexOf(path.join(__dirname, &apos;../src&apos;)) === 0 &amp;&amp;</span><br><span class=\"line\">                        chunks.length &gt;= 2</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                    return res</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                chunks: &apos;all&apos;,</span><br><span class=\"line\">                minSize: 0,</span><br><span class=\"line\">                enforce: true,</span><br><span class=\"line\">                minChunks: 1</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            //所有入口node_modules下公共模块</span><br><span class=\"line\">            vendor: &#123;</span><br><span class=\"line\">                name: &apos;vendors&apos;,</span><br><span class=\"line\">                test (module, chunks) &#123;</span><br><span class=\"line\">                    let res = (</span><br><span class=\"line\">                        module.resource &amp;&amp;</span><br><span class=\"line\">                        /\\.js$/.test(module.resource) &amp;&amp;</span><br><span class=\"line\">                        module.resource.indexOf(path.join(__dirname, &apos;../node_modules&apos;)) === 0 &amp;&amp;</span><br><span class=\"line\">                        chunks.length &gt;= 2</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                    return res</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                chunks: &apos;all&apos;,</span><br><span class=\"line\">                minSize: 0,</span><br><span class=\"line\">                enforce: true,</span><br><span class=\"line\">                minChunks: 1</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //webpack运行文件</span><br><span class=\"line\">    runtimeChunk: &#123;</span><br><span class=\"line\">        name: &quot;manifest&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"CommonsChunkPlugin\"><a href=\"#CommonsChunkPlugin\" class=\"headerlink\" title=\"CommonsChunkPlugin\"></a>CommonsChunkPlugin</h3><ul>\n<li>配置文档：<a href=\"https://www.webpackjs.com/plugins/commons-chunk-plugin/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/plugins/commons-chunk-plugin/</a></li>\n<li>例子<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//打包node_modules的公共代码</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: &apos;vendor&apos;,</span><br><span class=\"line\">    chunks: commonChunks,//所有入口集合，如果不添加（文档里面说默认是所有入口），但是实际使用过程中不会打包所有入口公共代码，多以还是要添加为所有入口集合。</span><br><span class=\"line\">    minChunks(module, count) &#123;</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            module.resource &amp;&amp;</span><br><span class=\"line\">            /\\.js$/.test(module.resource) &amp;&amp; module.resource.indexOf(</span><br><span class=\"line\">                path.join(__dirname, &apos;../node_modules&apos;)) === 0 &amp;&amp; count &gt;= 2</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\">//打包src下的公共代码</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: &apos;commonChunk&apos;,</span><br><span class=\"line\">    chunks: commonChunks,</span><br><span class=\"line\">    minChunks: function (module, count) &#123;</span><br><span class=\"line\">        // 保证commonChunk中的内容都是js且是scr下面调用的</span><br><span class=\"line\">        return (</span><br><span class=\"line\">            module.resource &amp;&amp; /\\.js$/.test(module.resource) &amp;&amp;</span><br><span class=\"line\">            module.resource.indexOf(</span><br><span class=\"line\">                path.join(__dirname, &apos;../src&apos;)</span><br><span class=\"line\">            ) === 0 &amp;&amp; count &gt;= config.build.minChunks</span><br><span class=\"line\">        )</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;),</span><br><span class=\"line\">// webpackComonsChunk的执行环境，包含module的映射信息，会经常变化</span><br><span class=\"line\">new webpack.optimize.CommonsChunkPlugin(&#123;</span><br><span class=\"line\">    name: &apos;manifest&apos;,</span><br><span class=\"line\">    minChunks: Infinity</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"optimization-splitChunks\"><a href=\"#optimization-splitChunks\" class=\"headerlink\" title=\"optimization.splitChunks\"></a>optimization.splitChunks</h3><ul>\n<li>配置文档：<a href=\"https://webpack.js.org/plugins/split-chunks-plugin/\" target=\"_blank\" rel=\"noopener\">https://webpack.js.org/plugins/split-chunks-plugin/</a><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">optimization: &#123;</span><br><span class=\"line\">    minimize: false,</span><br><span class=\"line\">    splitChunks: &#123;</span><br><span class=\"line\">        minSize: 0,</span><br><span class=\"line\">        // automaticNameDelimiter: &apos;-&apos;,//文件名称分隔符默认&apos;~&apos;</span><br><span class=\"line\">        chunks: &quot;all&quot;,//选择哪些块进行优化，可选值：all、async和initial</span><br><span class=\"line\">        cacheGroups: &#123;</span><br><span class=\"line\">            //拆分a入口文件node_modules引入的模块</span><br><span class=\"line\">            vendorA: &#123;</span><br><span class=\"line\">                name: &apos;vendors-a&apos;,</span><br><span class=\"line\">                test (module, chunks) &#123;//匹配</span><br><span class=\"line\">                    let res = (</span><br><span class=\"line\">                        module.resource &amp;&amp;</span><br><span class=\"line\">                        /\\.js$/.test(module.resource) &amp;&amp;</span><br><span class=\"line\">                        module.resource.indexOf(path.join(__dirname, &apos;../node_modules&apos;)) === 0 &amp;&amp;</span><br><span class=\"line\">                        chunks.length == 1 &amp;&amp;</span><br><span class=\"line\">                        chunks[0].name == &apos;a&apos;</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                    return res</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                // priority: 1,//打包首选优先级更高的缓存组，默认组的优先级为负，配置enforce会选择所有组</span><br><span class=\"line\">                chunks: &apos;all&apos;,</span><br><span class=\"line\">                minSize: 0,</span><br><span class=\"line\">                enforce: true,//需要设置为true，否则会根据priority（优先级）等其他配置打包</span><br><span class=\"line\">                minChunks: 1</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            //所有入口src下公共模块</span><br><span class=\"line\">            commons: &#123;</span><br><span class=\"line\">                name: &apos;commons&apos;,</span><br><span class=\"line\">                test (module, chunks) &#123;</span><br><span class=\"line\">                    let res = (</span><br><span class=\"line\">                        module.resource &amp;&amp;</span><br><span class=\"line\">                        /\\.js$/.test(module.resource) &amp;&amp;</span><br><span class=\"line\">                        module.resource.indexOf(path.join(__dirname, &apos;../src&apos;)) === 0 &amp;&amp;</span><br><span class=\"line\">                        chunks.length &gt;= 2</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                    return res</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                chunks: &apos;all&apos;,</span><br><span class=\"line\">                minSize: 0,</span><br><span class=\"line\">                enforce: true,</span><br><span class=\"line\">                minChunks: 1</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">            //所有入口node_modules下公共模块</span><br><span class=\"line\">            vendor: &#123;</span><br><span class=\"line\">                name: &apos;vendors&apos;,</span><br><span class=\"line\">                test (module, chunks) &#123;</span><br><span class=\"line\">                    let res = (</span><br><span class=\"line\">                        module.resource &amp;&amp;</span><br><span class=\"line\">                        /\\.js$/.test(module.resource) &amp;&amp;</span><br><span class=\"line\">                        module.resource.indexOf(path.join(__dirname, &apos;../node_modules&apos;)) === 0 &amp;&amp;</span><br><span class=\"line\">                        chunks.length &gt;= 2</span><br><span class=\"line\">                    )</span><br><span class=\"line\">                    return res</span><br><span class=\"line\">                &#125;,</span><br><span class=\"line\">                chunks: &apos;all&apos;,</span><br><span class=\"line\">                minSize: 0,</span><br><span class=\"line\">                enforce: true,</span><br><span class=\"line\">                minChunks: 1</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    //webpack运行文件</span><br><span class=\"line\">    runtimeChunk: &#123;</span><br><span class=\"line\">        name: &quot;manifest&quot;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">&#125;,</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"webpack-打包文件相关","date":"2018-12-21T07:34:10.000Z","_content":"\n#### 打包js\n- 命令行：webpack entry<entry> output\n```\nwebpack index.js bundle.js\n```\n- webpack配置文件\n#### 打包ES6\n- babel-loader：https://www.webpackjs.com/loaders/babel-loader/\n- babel配置：https://crazyaguai.github.io/2018/11/14/Babel%E9%85%8D%E7%BD%AE/\n```\n{\n    test: /\\.js$/,\n    exclude: /(node_modules|bower_components)/,\n    use: {\n        loader: 'babel-loader'\n    }\n}\n```\n#### 打包ts\n#### 处理css\n- 处理css并提取公共代码\n- style-loader 创建style标签写入html中\n- css-loader js可以引入css\n1. loader\n```\n{\n    test: /\\.css$/,\n    use: ExtractTextPlugin.extract(\n        {\n            fallback: [{\n                loader: 'style-loader'\n            }],\n            use: [\n                {\n                    loader: 'css-loader',\n                    options: {\n                        minimize: true,//是否压缩\n                        module: false,//是否使用css Module\n                    }\n                },{\n                    loader: 'postcss-loader',\n                    options: {\n                        ident: 'postcss',\n                        plugins: [\n                            require('autoprefixer')()\n                        ]\n                    }\n                }\n            ]\n        }\n    )\n}\n```\n2. plugin\n```\nnew ExtractTextPlugin({\n    filename: 'css/[name][hash].min.css',\n    allChunks: false,//默认false，指定提取范围，设置为true时异步加载的也会被提取出来\n})\n```\n#### 处理sass\n- 安装依赖\n```\nnpm install sass-loader node-sass --save-dev\n```\n1. loader\n```\n{\n    test: /\\.scss$/,\n    use: [\n        {\n            loader: 'style-loader',\n            options: {\n                // singletion: true,//放在一个style中，开启后sourceMap会失效\n                sourceMap: true\n            }\n        },\n        {\n            loader: 'css-loader',\n            options: {\n                // minimize: true,\n                sourceMap: true\n            }\n        }, {\n            loader: 'postcss-loader',\n            options: {\n                ident: 'postcss',\n                sourceMap: true,\n                plugins: [\n                    require('postcss-sprites')({\n                        spritePath: 'dist/img/',\n                        retina: true,//处理视网膜屏两倍大图,图片需要以@2x结尾\n                    }),\n                    require('autoprefixer')(),\n                ]\n            }\n        },{\n            loader: 'sass-loader'\n        }\n    ]\n}\n```\n2. 压缩提取的css并且删除重复内容\n```\n new OptimizeCSSPlugin({\n    cssProcessorOptions: {\n        safe: true\n    }\n}),\n```\n3. css tree-shaking(对于变量css无法使用)\n```\nnew PurifyCss({\n    paths: glob.sync([\n        path.resolve(__dirname,'../src/a.js'),\n        path.resolve(__dirname,'../index.html')\n    ])\n}),\n```\n#### PostCss\n- 安装\n```\nnpm install postcss postcss-loader autoprefixer --save-dev\n```\n- Autoprefixer 添加浏览器前缀\n- css-nano 压缩css\n- css-next 使用css新语法（css Variables\\custom selectors\\calc）\n- postcss-sprites 转换雪碧图\n- 在sass-loader和css-loader之间使用\n```\n{\n    loader: 'postcss-loader',\n    options: {\n        ident: 'postcss',\n        sourceMap: true,\n        plugins: [\n            require('postcss-sprites')({\n                spritePath: 'dist/img/',\n                retina: true,//处理视网膜屏两倍大图,图片需要以@2x结尾\n            }),\n            require('autoprefixer')(),\n        ]\n    }\n}\n```\n### Tree Shaking\n#### js Tree Shaking\n- 使用场景：常规优化、使用第三方库的某一个功能\n- https://www.webpackjs.com/guides/tree-shaking/\n- lodash 需要配置babel babel-plugin-lodash插件\n```\nnew webpack.optimize.UglifyJsPlugin()\n```\n#### css Tree Shaking\n- 安装 purifycss-webpack\n- glob-all 支持多路径\n```\nnew PurifyCss({\n    paths: glob.sync([\n        path.resolve(__dirname,'../src/a.js'),\n        path.resolve(__dirname,'../index.html')\n    ])\n})\n```\n#### 图片处理\n- file-loader\n- url-loader\n- img-loader\n- postcss-sprites\n```\n{\n    test: /\\.(png|jpg|jpeg|gif)$/,\n    use: [\n        // {\n        //     loader: 'file-loader',\n        //     options: {\n        //         publicPath: '',\n        //         name: 'img/[name][hash].[ext]',\n        //         // useRelativePath: true,\n        //         outputPath: ''\n        //     }\n        // },\n        {\n            loader: 'url-loader',//转换base64\n            options: {\n                limit: 100,\n                // publicPath: '',\n                name: 'img/[name][hash].[ext]',\n                outputPath: ''\n            }\n        },{\n            loader: 'img-loader',//压缩图片(3.x版本参数不同)\n            options: {\n                pngquant: {\n                    quality: 80\n                }\n            }\n        }\n    ]\n}\n```\n#### 字体文件处理\n```\n{\n    test: /\\.(eot|woff2?|ttf|svg|otf)$/,\n    use: [\n        {\n            loader: 'url-loader',\n            options: {\n                limit: 100,//配置是否生成单独文件\n                // publicPath: '../',\n                name: 'fonts/[name][hash].[ext]',\n                outputPath: ''\n            }\n        }\n    ]\n}\n```\n#### 第三方js库\n- webpack.providePlugin 不用在文件中import，webpack会注入\n```\nwebpack.providePlugin({\n    $: 'jquery',\n})\n```\n- 使用别名引入非node_modules文件 https://www.webpackjs.com/configuration/resolve/， 然后再配置providePlugin\n```\nresolve: {\n    alias: {\n        jquery$: path.resolve(__dirname,'src/jquery.js')\n    }\n}\n```\n- imports-loader\n```\n{\n    test: path.resolve(__dirname,src/index.js),\n    use:[{\n        loader: 'imports-loader',\n        options: {\n            $: 'jqury'\n        }\n    }]\n}\n```\n\n#### 提前加载webpack代码\n- 将webpack代码插入html中\n- inline-manifest-webpack-plugin 提取manifest文件到html中，减少浏览器请求，与htmlwebpackplugin搭配可能会有BUG，推荐使用下边的\n- html-webpack-inline-chunk-plugin\n```\nnew HtmlInlineChunkPlugin({\n    name: 'manifest'\n})\n```\n","source":"_posts/webpack-打包文件相关.md","raw":"---\ntitle: webpack-打包文件相关\ndate: 2018-12-21 15:34:10\ntags: [webpack]\ncategories: webpack\n---\n\n#### 打包js\n- 命令行：webpack entry<entry> output\n```\nwebpack index.js bundle.js\n```\n- webpack配置文件\n#### 打包ES6\n- babel-loader：https://www.webpackjs.com/loaders/babel-loader/\n- babel配置：https://crazyaguai.github.io/2018/11/14/Babel%E9%85%8D%E7%BD%AE/\n```\n{\n    test: /\\.js$/,\n    exclude: /(node_modules|bower_components)/,\n    use: {\n        loader: 'babel-loader'\n    }\n}\n```\n#### 打包ts\n#### 处理css\n- 处理css并提取公共代码\n- style-loader 创建style标签写入html中\n- css-loader js可以引入css\n1. loader\n```\n{\n    test: /\\.css$/,\n    use: ExtractTextPlugin.extract(\n        {\n            fallback: [{\n                loader: 'style-loader'\n            }],\n            use: [\n                {\n                    loader: 'css-loader',\n                    options: {\n                        minimize: true,//是否压缩\n                        module: false,//是否使用css Module\n                    }\n                },{\n                    loader: 'postcss-loader',\n                    options: {\n                        ident: 'postcss',\n                        plugins: [\n                            require('autoprefixer')()\n                        ]\n                    }\n                }\n            ]\n        }\n    )\n}\n```\n2. plugin\n```\nnew ExtractTextPlugin({\n    filename: 'css/[name][hash].min.css',\n    allChunks: false,//默认false，指定提取范围，设置为true时异步加载的也会被提取出来\n})\n```\n#### 处理sass\n- 安装依赖\n```\nnpm install sass-loader node-sass --save-dev\n```\n1. loader\n```\n{\n    test: /\\.scss$/,\n    use: [\n        {\n            loader: 'style-loader',\n            options: {\n                // singletion: true,//放在一个style中，开启后sourceMap会失效\n                sourceMap: true\n            }\n        },\n        {\n            loader: 'css-loader',\n            options: {\n                // minimize: true,\n                sourceMap: true\n            }\n        }, {\n            loader: 'postcss-loader',\n            options: {\n                ident: 'postcss',\n                sourceMap: true,\n                plugins: [\n                    require('postcss-sprites')({\n                        spritePath: 'dist/img/',\n                        retina: true,//处理视网膜屏两倍大图,图片需要以@2x结尾\n                    }),\n                    require('autoprefixer')(),\n                ]\n            }\n        },{\n            loader: 'sass-loader'\n        }\n    ]\n}\n```\n2. 压缩提取的css并且删除重复内容\n```\n new OptimizeCSSPlugin({\n    cssProcessorOptions: {\n        safe: true\n    }\n}),\n```\n3. css tree-shaking(对于变量css无法使用)\n```\nnew PurifyCss({\n    paths: glob.sync([\n        path.resolve(__dirname,'../src/a.js'),\n        path.resolve(__dirname,'../index.html')\n    ])\n}),\n```\n#### PostCss\n- 安装\n```\nnpm install postcss postcss-loader autoprefixer --save-dev\n```\n- Autoprefixer 添加浏览器前缀\n- css-nano 压缩css\n- css-next 使用css新语法（css Variables\\custom selectors\\calc）\n- postcss-sprites 转换雪碧图\n- 在sass-loader和css-loader之间使用\n```\n{\n    loader: 'postcss-loader',\n    options: {\n        ident: 'postcss',\n        sourceMap: true,\n        plugins: [\n            require('postcss-sprites')({\n                spritePath: 'dist/img/',\n                retina: true,//处理视网膜屏两倍大图,图片需要以@2x结尾\n            }),\n            require('autoprefixer')(),\n        ]\n    }\n}\n```\n### Tree Shaking\n#### js Tree Shaking\n- 使用场景：常规优化、使用第三方库的某一个功能\n- https://www.webpackjs.com/guides/tree-shaking/\n- lodash 需要配置babel babel-plugin-lodash插件\n```\nnew webpack.optimize.UglifyJsPlugin()\n```\n#### css Tree Shaking\n- 安装 purifycss-webpack\n- glob-all 支持多路径\n```\nnew PurifyCss({\n    paths: glob.sync([\n        path.resolve(__dirname,'../src/a.js'),\n        path.resolve(__dirname,'../index.html')\n    ])\n})\n```\n#### 图片处理\n- file-loader\n- url-loader\n- img-loader\n- postcss-sprites\n```\n{\n    test: /\\.(png|jpg|jpeg|gif)$/,\n    use: [\n        // {\n        //     loader: 'file-loader',\n        //     options: {\n        //         publicPath: '',\n        //         name: 'img/[name][hash].[ext]',\n        //         // useRelativePath: true,\n        //         outputPath: ''\n        //     }\n        // },\n        {\n            loader: 'url-loader',//转换base64\n            options: {\n                limit: 100,\n                // publicPath: '',\n                name: 'img/[name][hash].[ext]',\n                outputPath: ''\n            }\n        },{\n            loader: 'img-loader',//压缩图片(3.x版本参数不同)\n            options: {\n                pngquant: {\n                    quality: 80\n                }\n            }\n        }\n    ]\n}\n```\n#### 字体文件处理\n```\n{\n    test: /\\.(eot|woff2?|ttf|svg|otf)$/,\n    use: [\n        {\n            loader: 'url-loader',\n            options: {\n                limit: 100,//配置是否生成单独文件\n                // publicPath: '../',\n                name: 'fonts/[name][hash].[ext]',\n                outputPath: ''\n            }\n        }\n    ]\n}\n```\n#### 第三方js库\n- webpack.providePlugin 不用在文件中import，webpack会注入\n```\nwebpack.providePlugin({\n    $: 'jquery',\n})\n```\n- 使用别名引入非node_modules文件 https://www.webpackjs.com/configuration/resolve/， 然后再配置providePlugin\n```\nresolve: {\n    alias: {\n        jquery$: path.resolve(__dirname,'src/jquery.js')\n    }\n}\n```\n- imports-loader\n```\n{\n    test: path.resolve(__dirname,src/index.js),\n    use:[{\n        loader: 'imports-loader',\n        options: {\n            $: 'jqury'\n        }\n    }]\n}\n```\n\n#### 提前加载webpack代码\n- 将webpack代码插入html中\n- inline-manifest-webpack-plugin 提取manifest文件到html中，减少浏览器请求，与htmlwebpackplugin搭配可能会有BUG，推荐使用下边的\n- html-webpack-inline-chunk-plugin\n```\nnew HtmlInlineChunkPlugin({\n    name: 'manifest'\n})\n```\n","slug":"webpack-打包文件相关","published":1,"updated":"2019-01-06T03:03:05.129Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob780025e0jccj54c6m3","content":"<h4 id=\"打包js\"><a href=\"#打包js\" class=\"headerlink\" title=\"打包js\"></a>打包js</h4><ul>\n<li><p>命令行：webpack entry<entry> output</entry></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack index.js bundle.js</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>webpack配置文件</p>\n<h4 id=\"打包ES6\"><a href=\"#打包ES6\" class=\"headerlink\" title=\"打包ES6\"></a>打包ES6</h4></li>\n<li>babel-loader：<a href=\"https://www.webpackjs.com/loaders/babel-loader/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/loaders/babel-loader/</a></li>\n<li>babel配置：<a href=\"https://crazyaguai.github.io/2018/11/14/Babel%E9%85%8D%E7%BD%AE/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2018/11/14/Babel%E9%85%8D%E7%BD%AE/</a><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: /\\.js$/,</span><br><span class=\"line\">    exclude: /(node_modules|bower_components)/,</span><br><span class=\"line\">    use: &#123;</span><br><span class=\"line\">        loader: &apos;babel-loader&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"打包ts\"><a href=\"#打包ts\" class=\"headerlink\" title=\"打包ts\"></a>打包ts</h4><h4 id=\"处理css\"><a href=\"#处理css\" class=\"headerlink\" title=\"处理css\"></a>处理css</h4><ul>\n<li>处理css并提取公共代码</li>\n<li>style-loader 创建style标签写入html中</li>\n<li>css-loader js可以引入css</li>\n</ul>\n<ol>\n<li><p>loader</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: /\\.css$/,</span><br><span class=\"line\">    use: ExtractTextPlugin.extract(</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fallback: [&#123;</span><br><span class=\"line\">                loader: &apos;style-loader&apos;</span><br><span class=\"line\">            &#125;],</span><br><span class=\"line\">            use: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    loader: &apos;css-loader&apos;,</span><br><span class=\"line\">                    options: &#123;</span><br><span class=\"line\">                        minimize: true,//是否压缩</span><br><span class=\"line\">                        module: false,//是否使用css Module</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,&#123;</span><br><span class=\"line\">                    loader: &apos;postcss-loader&apos;,</span><br><span class=\"line\">                    options: &#123;</span><br><span class=\"line\">                        ident: &apos;postcss&apos;,</span><br><span class=\"line\">                        plugins: [</span><br><span class=\"line\">                            require(&apos;autoprefixer&apos;)()</span><br><span class=\"line\">                        ]</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>plugin</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new ExtractTextPlugin(&#123;</span><br><span class=\"line\">    filename: &apos;css/[name][hash].min.css&apos;,</span><br><span class=\"line\">    allChunks: false,//默认false，指定提取范围，设置为true时异步加载的也会被提取出来</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"处理sass\"><a href=\"#处理sass\" class=\"headerlink\" title=\"处理sass\"></a>处理sass</h4><ul>\n<li>安装依赖<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install sass-loader node-sass --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li><p>loader</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: /\\.scss$/,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &apos;style-loader&apos;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                // singletion: true,//放在一个style中，开启后sourceMap会失效</span><br><span class=\"line\">                sourceMap: true</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &apos;css-loader&apos;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                // minimize: true,</span><br><span class=\"line\">                sourceMap: true</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, &#123;</span><br><span class=\"line\">            loader: &apos;postcss-loader&apos;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                ident: &apos;postcss&apos;,</span><br><span class=\"line\">                sourceMap: true,</span><br><span class=\"line\">                plugins: [</span><br><span class=\"line\">                    require(&apos;postcss-sprites&apos;)(&#123;</span><br><span class=\"line\">                        spritePath: &apos;dist/img/&apos;,</span><br><span class=\"line\">                        retina: true,//处理视网膜屏两倍大图,图片需要以@2x结尾</span><br><span class=\"line\">                    &#125;),</span><br><span class=\"line\">                    require(&apos;autoprefixer&apos;)(),</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,&#123;</span><br><span class=\"line\">            loader: &apos;sass-loader&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>压缩提取的css并且删除重复内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> new OptimizeCSSPlugin(&#123;</span><br><span class=\"line\">    cssProcessorOptions: &#123;</span><br><span class=\"line\">        safe: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>css tree-shaking(对于变量css无法使用)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new PurifyCss(&#123;</span><br><span class=\"line\">    paths: glob.sync([</span><br><span class=\"line\">        path.resolve(__dirname,&apos;../src/a.js&apos;),</span><br><span class=\"line\">        path.resolve(__dirname,&apos;../index.html&apos;)</span><br><span class=\"line\">    ])</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"PostCss\"><a href=\"#PostCss\" class=\"headerlink\" title=\"PostCss\"></a>PostCss</h4><ul>\n<li><p>安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install postcss postcss-loader autoprefixer --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Autoprefixer 添加浏览器前缀</p>\n</li>\n<li>css-nano 压缩css</li>\n<li>css-next 使用css新语法（css Variables\\custom selectors\\calc）</li>\n<li>postcss-sprites 转换雪碧图</li>\n<li>在sass-loader和css-loader之间使用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    loader: &apos;postcss-loader&apos;,</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">        ident: &apos;postcss&apos;,</span><br><span class=\"line\">        sourceMap: true,</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">            require(&apos;postcss-sprites&apos;)(&#123;</span><br><span class=\"line\">                spritePath: &apos;dist/img/&apos;,</span><br><span class=\"line\">                retina: true,//处理视网膜屏两倍大图,图片需要以@2x结尾</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">            require(&apos;autoprefixer&apos;)(),</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Tree-Shaking\"><a href=\"#Tree-Shaking\" class=\"headerlink\" title=\"Tree Shaking\"></a>Tree Shaking</h3><h4 id=\"js-Tree-Shaking\"><a href=\"#js-Tree-Shaking\" class=\"headerlink\" title=\"js Tree Shaking\"></a>js Tree Shaking</h4><ul>\n<li>使用场景：常规优化、使用第三方库的某一个功能</li>\n<li><a href=\"https://www.webpackjs.com/guides/tree-shaking/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/guides/tree-shaking/</a></li>\n<li>lodash 需要配置babel babel-plugin-lodash插件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new webpack.optimize.UglifyJsPlugin()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"css-Tree-Shaking\"><a href=\"#css-Tree-Shaking\" class=\"headerlink\" title=\"css Tree Shaking\"></a>css Tree Shaking</h4><ul>\n<li>安装 purifycss-webpack</li>\n<li>glob-all 支持多路径<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new PurifyCss(&#123;</span><br><span class=\"line\">    paths: glob.sync([</span><br><span class=\"line\">        path.resolve(__dirname,&apos;../src/a.js&apos;),</span><br><span class=\"line\">        path.resolve(__dirname,&apos;../index.html&apos;)</span><br><span class=\"line\">    ])</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"图片处理\"><a href=\"#图片处理\" class=\"headerlink\" title=\"图片处理\"></a>图片处理</h4><ul>\n<li>file-loader</li>\n<li>url-loader</li>\n<li>img-loader</li>\n<li>postcss-sprites<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: /\\.(png|jpg|jpeg|gif)$/,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">        // &#123;</span><br><span class=\"line\">        //     loader: &apos;file-loader&apos;,</span><br><span class=\"line\">        //     options: &#123;</span><br><span class=\"line\">        //         publicPath: &apos;&apos;,</span><br><span class=\"line\">        //         name: &apos;img/[name][hash].[ext]&apos;,</span><br><span class=\"line\">        //         // useRelativePath: true,</span><br><span class=\"line\">        //         outputPath: &apos;&apos;</span><br><span class=\"line\">        //     &#125;</span><br><span class=\"line\">        // &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &apos;url-loader&apos;,//转换base64</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                limit: 100,</span><br><span class=\"line\">                // publicPath: &apos;&apos;,</span><br><span class=\"line\">                name: &apos;img/[name][hash].[ext]&apos;,</span><br><span class=\"line\">                outputPath: &apos;&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,&#123;</span><br><span class=\"line\">            loader: &apos;img-loader&apos;,//压缩图片(3.x版本参数不同)</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                pngquant: &#123;</span><br><span class=\"line\">                    quality: 80</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"字体文件处理\"><a href=\"#字体文件处理\" class=\"headerlink\" title=\"字体文件处理\"></a>字体文件处理</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: /\\.(eot|woff2?|ttf|svg|otf)$/,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &apos;url-loader&apos;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                limit: 100,//配置是否生成单独文件</span><br><span class=\"line\">                // publicPath: &apos;../&apos;,</span><br><span class=\"line\">                name: &apos;fonts/[name][hash].[ext]&apos;,</span><br><span class=\"line\">                outputPath: &apos;&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三方js库\"><a href=\"#第三方js库\" class=\"headerlink\" title=\"第三方js库\"></a>第三方js库</h4><ul>\n<li><p>webpack.providePlugin 不用在文件中import，webpack会注入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack.providePlugin(&#123;</span><br><span class=\"line\">    $: &apos;jquery&apos;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用别名引入非node_modules文件 <a href=\"https://www.webpackjs.com/configuration/resolve/，\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/configuration/resolve/，</a> 然后再配置providePlugin</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: &#123;</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">        jquery$: path.resolve(__dirname,&apos;src/jquery.js&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>imports-loader</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: path.resolve(__dirname,src/index.js),</span><br><span class=\"line\">    use:[&#123;</span><br><span class=\"line\">        loader: &apos;imports-loader&apos;,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">            $: &apos;jqury&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"提前加载webpack代码\"><a href=\"#提前加载webpack代码\" class=\"headerlink\" title=\"提前加载webpack代码\"></a>提前加载webpack代码</h4><ul>\n<li>将webpack代码插入html中</li>\n<li>inline-manifest-webpack-plugin 提取manifest文件到html中，减少浏览器请求，与htmlwebpackplugin搭配可能会有BUG，推荐使用下边的</li>\n<li>html-webpack-inline-chunk-plugin<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new HtmlInlineChunkPlugin(&#123;</span><br><span class=\"line\">    name: &apos;manifest&apos;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"打包js\"><a href=\"#打包js\" class=\"headerlink\" title=\"打包js\"></a>打包js</h4><ul>\n<li><p>命令行：webpack entry<entry> output</entry></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack index.js bundle.js</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>webpack配置文件</p>\n<h4 id=\"打包ES6\"><a href=\"#打包ES6\" class=\"headerlink\" title=\"打包ES6\"></a>打包ES6</h4></li>\n<li>babel-loader：<a href=\"https://www.webpackjs.com/loaders/babel-loader/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/loaders/babel-loader/</a></li>\n<li>babel配置：<a href=\"https://crazyaguai.github.io/2018/11/14/Babel%E9%85%8D%E7%BD%AE/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2018/11/14/Babel%E9%85%8D%E7%BD%AE/</a><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: /\\.js$/,</span><br><span class=\"line\">    exclude: /(node_modules|bower_components)/,</span><br><span class=\"line\">    use: &#123;</span><br><span class=\"line\">        loader: &apos;babel-loader&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"打包ts\"><a href=\"#打包ts\" class=\"headerlink\" title=\"打包ts\"></a>打包ts</h4><h4 id=\"处理css\"><a href=\"#处理css\" class=\"headerlink\" title=\"处理css\"></a>处理css</h4><ul>\n<li>处理css并提取公共代码</li>\n<li>style-loader 创建style标签写入html中</li>\n<li>css-loader js可以引入css</li>\n</ul>\n<ol>\n<li><p>loader</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: /\\.css$/,</span><br><span class=\"line\">    use: ExtractTextPlugin.extract(</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            fallback: [&#123;</span><br><span class=\"line\">                loader: &apos;style-loader&apos;</span><br><span class=\"line\">            &#125;],</span><br><span class=\"line\">            use: [</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                    loader: &apos;css-loader&apos;,</span><br><span class=\"line\">                    options: &#123;</span><br><span class=\"line\">                        minimize: true,//是否压缩</span><br><span class=\"line\">                        module: false,//是否使用css Module</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;,&#123;</span><br><span class=\"line\">                    loader: &apos;postcss-loader&apos;,</span><br><span class=\"line\">                    options: &#123;</span><br><span class=\"line\">                        ident: &apos;postcss&apos;,</span><br><span class=\"line\">                        plugins: [</span><br><span class=\"line\">                            require(&apos;autoprefixer&apos;)()</span><br><span class=\"line\">                        ]</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    )</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>plugin</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new ExtractTextPlugin(&#123;</span><br><span class=\"line\">    filename: &apos;css/[name][hash].min.css&apos;,</span><br><span class=\"line\">    allChunks: false,//默认false，指定提取范围，设置为true时异步加载的也会被提取出来</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"处理sass\"><a href=\"#处理sass\" class=\"headerlink\" title=\"处理sass\"></a>处理sass</h4><ul>\n<li>安装依赖<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install sass-loader node-sass --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol>\n<li><p>loader</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: /\\.scss$/,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &apos;style-loader&apos;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                // singletion: true,//放在一个style中，开启后sourceMap会失效</span><br><span class=\"line\">                sourceMap: true</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &apos;css-loader&apos;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                // minimize: true,</span><br><span class=\"line\">                sourceMap: true</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;, &#123;</span><br><span class=\"line\">            loader: &apos;postcss-loader&apos;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                ident: &apos;postcss&apos;,</span><br><span class=\"line\">                sourceMap: true,</span><br><span class=\"line\">                plugins: [</span><br><span class=\"line\">                    require(&apos;postcss-sprites&apos;)(&#123;</span><br><span class=\"line\">                        spritePath: &apos;dist/img/&apos;,</span><br><span class=\"line\">                        retina: true,//处理视网膜屏两倍大图,图片需要以@2x结尾</span><br><span class=\"line\">                    &#125;),</span><br><span class=\"line\">                    require(&apos;autoprefixer&apos;)(),</span><br><span class=\"line\">                ]</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,&#123;</span><br><span class=\"line\">            loader: &apos;sass-loader&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>压缩提取的css并且删除重复内容</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> new OptimizeCSSPlugin(&#123;</span><br><span class=\"line\">    cssProcessorOptions: &#123;</span><br><span class=\"line\">        safe: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>css tree-shaking(对于变量css无法使用)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new PurifyCss(&#123;</span><br><span class=\"line\">    paths: glob.sync([</span><br><span class=\"line\">        path.resolve(__dirname,&apos;../src/a.js&apos;),</span><br><span class=\"line\">        path.resolve(__dirname,&apos;../index.html&apos;)</span><br><span class=\"line\">    ])</span><br><span class=\"line\">&#125;),</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"PostCss\"><a href=\"#PostCss\" class=\"headerlink\" title=\"PostCss\"></a>PostCss</h4><ul>\n<li><p>安装</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install postcss postcss-loader autoprefixer --save-dev</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>Autoprefixer 添加浏览器前缀</p>\n</li>\n<li>css-nano 压缩css</li>\n<li>css-next 使用css新语法（css Variables\\custom selectors\\calc）</li>\n<li>postcss-sprites 转换雪碧图</li>\n<li>在sass-loader和css-loader之间使用<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    loader: &apos;postcss-loader&apos;,</span><br><span class=\"line\">    options: &#123;</span><br><span class=\"line\">        ident: &apos;postcss&apos;,</span><br><span class=\"line\">        sourceMap: true,</span><br><span class=\"line\">        plugins: [</span><br><span class=\"line\">            require(&apos;postcss-sprites&apos;)(&#123;</span><br><span class=\"line\">                spritePath: &apos;dist/img/&apos;,</span><br><span class=\"line\">                retina: true,//处理视网膜屏两倍大图,图片需要以@2x结尾</span><br><span class=\"line\">            &#125;),</span><br><span class=\"line\">            require(&apos;autoprefixer&apos;)(),</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"Tree-Shaking\"><a href=\"#Tree-Shaking\" class=\"headerlink\" title=\"Tree Shaking\"></a>Tree Shaking</h3><h4 id=\"js-Tree-Shaking\"><a href=\"#js-Tree-Shaking\" class=\"headerlink\" title=\"js Tree Shaking\"></a>js Tree Shaking</h4><ul>\n<li>使用场景：常规优化、使用第三方库的某一个功能</li>\n<li><a href=\"https://www.webpackjs.com/guides/tree-shaking/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/guides/tree-shaking/</a></li>\n<li>lodash 需要配置babel babel-plugin-lodash插件<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new webpack.optimize.UglifyJsPlugin()</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"css-Tree-Shaking\"><a href=\"#css-Tree-Shaking\" class=\"headerlink\" title=\"css Tree Shaking\"></a>css Tree Shaking</h4><ul>\n<li>安装 purifycss-webpack</li>\n<li>glob-all 支持多路径<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new PurifyCss(&#123;</span><br><span class=\"line\">    paths: glob.sync([</span><br><span class=\"line\">        path.resolve(__dirname,&apos;../src/a.js&apos;),</span><br><span class=\"line\">        path.resolve(__dirname,&apos;../index.html&apos;)</span><br><span class=\"line\">    ])</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"图片处理\"><a href=\"#图片处理\" class=\"headerlink\" title=\"图片处理\"></a>图片处理</h4><ul>\n<li>file-loader</li>\n<li>url-loader</li>\n<li>img-loader</li>\n<li>postcss-sprites<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: /\\.(png|jpg|jpeg|gif)$/,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">        // &#123;</span><br><span class=\"line\">        //     loader: &apos;file-loader&apos;,</span><br><span class=\"line\">        //     options: &#123;</span><br><span class=\"line\">        //         publicPath: &apos;&apos;,</span><br><span class=\"line\">        //         name: &apos;img/[name][hash].[ext]&apos;,</span><br><span class=\"line\">        //         // useRelativePath: true,</span><br><span class=\"line\">        //         outputPath: &apos;&apos;</span><br><span class=\"line\">        //     &#125;</span><br><span class=\"line\">        // &#125;,</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &apos;url-loader&apos;,//转换base64</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                limit: 100,</span><br><span class=\"line\">                // publicPath: &apos;&apos;,</span><br><span class=\"line\">                name: &apos;img/[name][hash].[ext]&apos;,</span><br><span class=\"line\">                outputPath: &apos;&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;,&#123;</span><br><span class=\"line\">            loader: &apos;img-loader&apos;,//压缩图片(3.x版本参数不同)</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                pngquant: &#123;</span><br><span class=\"line\">                    quality: 80</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"字体文件处理\"><a href=\"#字体文件处理\" class=\"headerlink\" title=\"字体文件处理\"></a>字体文件处理</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: /\\.(eot|woff2?|ttf|svg|otf)$/,</span><br><span class=\"line\">    use: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            loader: &apos;url-loader&apos;,</span><br><span class=\"line\">            options: &#123;</span><br><span class=\"line\">                limit: 100,//配置是否生成单独文件</span><br><span class=\"line\">                // publicPath: &apos;../&apos;,</span><br><span class=\"line\">                name: &apos;fonts/[name][hash].[ext]&apos;,</span><br><span class=\"line\">                outputPath: &apos;&apos;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"第三方js库\"><a href=\"#第三方js库\" class=\"headerlink\" title=\"第三方js库\"></a>第三方js库</h4><ul>\n<li><p>webpack.providePlugin 不用在文件中import，webpack会注入</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack.providePlugin(&#123;</span><br><span class=\"line\">    $: &apos;jquery&apos;,</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>使用别名引入非node_modules文件 <a href=\"https://www.webpackjs.com/configuration/resolve/，\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/configuration/resolve/，</a> 然后再配置providePlugin</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">resolve: &#123;</span><br><span class=\"line\">    alias: &#123;</span><br><span class=\"line\">        jquery$: path.resolve(__dirname,&apos;src/jquery.js&apos;)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>imports-loader</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    test: path.resolve(__dirname,src/index.js),</span><br><span class=\"line\">    use:[&#123;</span><br><span class=\"line\">        loader: &apos;imports-loader&apos;,</span><br><span class=\"line\">        options: &#123;</span><br><span class=\"line\">            $: &apos;jqury&apos;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"提前加载webpack代码\"><a href=\"#提前加载webpack代码\" class=\"headerlink\" title=\"提前加载webpack代码\"></a>提前加载webpack代码</h4><ul>\n<li>将webpack代码插入html中</li>\n<li>inline-manifest-webpack-plugin 提取manifest文件到html中，减少浏览器请求，与htmlwebpackplugin搭配可能会有BUG，推荐使用下边的</li>\n<li>html-webpack-inline-chunk-plugin<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new HtmlInlineChunkPlugin(&#123;</span><br><span class=\"line\">    name: &apos;manifest&apos;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"webpack-搭建环境以及相关优化","date":"2018-12-21T09:39:22.000Z","_content":"\n### webpack watch mode\n- 使用方式\n```\nwebpack -watch\nwebpack -w\n```\n- 不会建立web服务器\n### webpack-dev-server\n- live reloading (重新刷新浏览器)\n- 路径重定向\n- https\n- 在浏览器显示编译错误\n- 接口代理\n- 模块热更新（不刷新浏览器更新代码）https://www.webpackjs.com/guides/hot-module-replacement/\n- 基本配置 https://www.webpackjs.com/configuration/dev-server/\n### express + webpack-dev-middleware\n\n### 开启source-map\n#### js开启source-map\n- Devtool\n1. 开发环境使用 cheap-module-source-map\\source-map\n2. 生产环境使用 一般不用，如果修改问题可以配置为source-map\n- 生产环境uglify压缩时需要开启配置\n- webpack.SourceMapDevToolPlugin\n- webpack.EvalSourceMapDevToolPlugin\n#### css开启source-map\n- 开启相关loader的sourcemap配置\n### 开发环境和生产环境的区别\n#### 开发环境\n1. 模块热更新\n2. sourceMap\n3. 接口代理\n4. 代码规范检查\n#### 生产环境\n1. 提取公共代码\n2. 压缩混淆\n3. 文件压缩或base64编码\n4. 去除无用代码 tree-shaking\n5. 分离css\n6. 打包代码配置\n### 打包结果分析\n- 官方 Offical Analyse Tool\n1. 命令\n```\nwebpack --profile --json >stats.json\nwebpack --profile --json | Out-file 'stats.json' - Encoding //windows下命令\n```\n2. 官方分析地址 http://webpack.github.io/analyse/\n- webpack-bundle-analyzer\n1. 抵用插件BundleAnalyzerPlugin https://www.npmjs.com/package/webpack-bundle-analyzer\n2. 命令行\n```\nwebpack-bundle-analyzer stats.json\n```\n\n### 优化打包速度\n1. 分开vendor与app（第三方与开发文件）使用Dllplugin与DllReferencePlugin\n2. UglifyJsPlugin 配置参数 parallel:true（并行处理压缩）\n3. UglifyJsPlugin cache缓存\n4. HappyPach 并行处理 loader\n5. babel-loader 配置 cacheDirectory开启缓存、配置include exlude规定范围\n6. 其他\n- 减少 resolve\n- 去除 source-map\n- cache-loader\n- 升级 node\\webpack\n### 长缓存优化\n#### 场景1：app改变vendor也改变了\n1. 提取vendor\n2. 解决hash变化问题：hash->chunkhash(将打包的hash变为代码快的hash)，将output[hash]改为[chunkhash]\n3. 提取 manifest 文件（提取webpack runtime 代码）\n#### 场景2：引入新的模块，模块顺序发生变化，vendor hash变化了（因为chunkId变了）\n1. NameChunksPlugin 改变chunk名\n2. 保持moduleId稳定 NameModulesPlugin （如果想看打包module name命令行添加 --display-modules）\n3. 或者使用HashedModuleIdsPlugin 保持moduleId稳定\n- vue配置\n```\n// 保持chunkId不变\nnew webpack.NamedChunksPlugin(),\n// 保持moduleID稳定\nnew webpack.HashedModuleIdsPlugin(),\n```\n#### 场景3：动态引入时vendor hash发生变化（异步加载的包改变）\n1. 在动态引入的代码中添加 异步module名称\n```\nimport(/* webpackChunkName: \"print\" */ './print')\n```\n#### 总结优化打包\n1. 独立打包vendor\n2. 抽出manifest\n3. NameChunksPlugin\\NameModulesPlugin\\HashedModuleIdsPlugin\n4. 动态加载模块设置名称\n","source":"_posts/webpack-搭建环境以及相关优化.md","raw":"---\ntitle: webpack-搭建环境以及相关优化\ndate: 2018-12-21 17:39:22\ntags: [webpack]\ncategories: webpack\n---\n\n### webpack watch mode\n- 使用方式\n```\nwebpack -watch\nwebpack -w\n```\n- 不会建立web服务器\n### webpack-dev-server\n- live reloading (重新刷新浏览器)\n- 路径重定向\n- https\n- 在浏览器显示编译错误\n- 接口代理\n- 模块热更新（不刷新浏览器更新代码）https://www.webpackjs.com/guides/hot-module-replacement/\n- 基本配置 https://www.webpackjs.com/configuration/dev-server/\n### express + webpack-dev-middleware\n\n### 开启source-map\n#### js开启source-map\n- Devtool\n1. 开发环境使用 cheap-module-source-map\\source-map\n2. 生产环境使用 一般不用，如果修改问题可以配置为source-map\n- 生产环境uglify压缩时需要开启配置\n- webpack.SourceMapDevToolPlugin\n- webpack.EvalSourceMapDevToolPlugin\n#### css开启source-map\n- 开启相关loader的sourcemap配置\n### 开发环境和生产环境的区别\n#### 开发环境\n1. 模块热更新\n2. sourceMap\n3. 接口代理\n4. 代码规范检查\n#### 生产环境\n1. 提取公共代码\n2. 压缩混淆\n3. 文件压缩或base64编码\n4. 去除无用代码 tree-shaking\n5. 分离css\n6. 打包代码配置\n### 打包结果分析\n- 官方 Offical Analyse Tool\n1. 命令\n```\nwebpack --profile --json >stats.json\nwebpack --profile --json | Out-file 'stats.json' - Encoding //windows下命令\n```\n2. 官方分析地址 http://webpack.github.io/analyse/\n- webpack-bundle-analyzer\n1. 抵用插件BundleAnalyzerPlugin https://www.npmjs.com/package/webpack-bundle-analyzer\n2. 命令行\n```\nwebpack-bundle-analyzer stats.json\n```\n\n### 优化打包速度\n1. 分开vendor与app（第三方与开发文件）使用Dllplugin与DllReferencePlugin\n2. UglifyJsPlugin 配置参数 parallel:true（并行处理压缩）\n3. UglifyJsPlugin cache缓存\n4. HappyPach 并行处理 loader\n5. babel-loader 配置 cacheDirectory开启缓存、配置include exlude规定范围\n6. 其他\n- 减少 resolve\n- 去除 source-map\n- cache-loader\n- 升级 node\\webpack\n### 长缓存优化\n#### 场景1：app改变vendor也改变了\n1. 提取vendor\n2. 解决hash变化问题：hash->chunkhash(将打包的hash变为代码快的hash)，将output[hash]改为[chunkhash]\n3. 提取 manifest 文件（提取webpack runtime 代码）\n#### 场景2：引入新的模块，模块顺序发生变化，vendor hash变化了（因为chunkId变了）\n1. NameChunksPlugin 改变chunk名\n2. 保持moduleId稳定 NameModulesPlugin （如果想看打包module name命令行添加 --display-modules）\n3. 或者使用HashedModuleIdsPlugin 保持moduleId稳定\n- vue配置\n```\n// 保持chunkId不变\nnew webpack.NamedChunksPlugin(),\n// 保持moduleID稳定\nnew webpack.HashedModuleIdsPlugin(),\n```\n#### 场景3：动态引入时vendor hash发生变化（异步加载的包改变）\n1. 在动态引入的代码中添加 异步module名称\n```\nimport(/* webpackChunkName: \"print\" */ './print')\n```\n#### 总结优化打包\n1. 独立打包vendor\n2. 抽出manifest\n3. NameChunksPlugin\\NameModulesPlugin\\HashedModuleIdsPlugin\n4. 动态加载模块设置名称\n","slug":"webpack-搭建环境以及相关优化","published":1,"updated":"2019-01-06T03:04:03.459Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob790028e0jcbw0jmovd","content":"<h3 id=\"webpack-watch-mode\"><a href=\"#webpack-watch-mode\" class=\"headerlink\" title=\"webpack watch mode\"></a>webpack watch mode</h3><ul>\n<li><p>使用方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack -watch</span><br><span class=\"line\">webpack -w</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不会建立web服务器</p>\n<h3 id=\"webpack-dev-server\"><a href=\"#webpack-dev-server\" class=\"headerlink\" title=\"webpack-dev-server\"></a>webpack-dev-server</h3></li>\n<li>live reloading (重新刷新浏览器)</li>\n<li>路径重定向</li>\n<li>https</li>\n<li>在浏览器显示编译错误</li>\n<li>接口代理</li>\n<li>模块热更新（不刷新浏览器更新代码）<a href=\"https://www.webpackjs.com/guides/hot-module-replacement/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/guides/hot-module-replacement/</a></li>\n<li>基本配置 <a href=\"https://www.webpackjs.com/configuration/dev-server/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/configuration/dev-server/</a><h3 id=\"express-webpack-dev-middleware\"><a href=\"#express-webpack-dev-middleware\" class=\"headerlink\" title=\"express + webpack-dev-middleware\"></a>express + webpack-dev-middleware</h3></li>\n</ul>\n<h3 id=\"开启source-map\"><a href=\"#开启source-map\" class=\"headerlink\" title=\"开启source-map\"></a>开启source-map</h3><h4 id=\"js开启source-map\"><a href=\"#js开启source-map\" class=\"headerlink\" title=\"js开启source-map\"></a>js开启source-map</h4><ul>\n<li>Devtool</li>\n</ul>\n<ol>\n<li>开发环境使用 cheap-module-source-map\\source-map</li>\n<li>生产环境使用 一般不用，如果修改问题可以配置为source-map</li>\n</ol>\n<ul>\n<li>生产环境uglify压缩时需要开启配置</li>\n<li>webpack.SourceMapDevToolPlugin</li>\n<li>webpack.EvalSourceMapDevToolPlugin<h4 id=\"css开启source-map\"><a href=\"#css开启source-map\" class=\"headerlink\" title=\"css开启source-map\"></a>css开启source-map</h4></li>\n<li>开启相关loader的sourcemap配置<h3 id=\"开发环境和生产环境的区别\"><a href=\"#开发环境和生产环境的区别\" class=\"headerlink\" title=\"开发环境和生产环境的区别\"></a>开发环境和生产环境的区别</h3><h4 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h4></li>\n</ul>\n<ol>\n<li>模块热更新</li>\n<li>sourceMap</li>\n<li>接口代理</li>\n<li>代码规范检查<h4 id=\"生产环境\"><a href=\"#生产环境\" class=\"headerlink\" title=\"生产环境\"></a>生产环境</h4></li>\n<li>提取公共代码</li>\n<li>压缩混淆</li>\n<li>文件压缩或base64编码</li>\n<li>去除无用代码 tree-shaking</li>\n<li>分离css</li>\n<li>打包代码配置<h3 id=\"打包结果分析\"><a href=\"#打包结果分析\" class=\"headerlink\" title=\"打包结果分析\"></a>打包结果分析</h3></li>\n</ol>\n<ul>\n<li>官方 Offical Analyse Tool</li>\n</ul>\n<ol>\n<li><p>命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack --profile --json &gt;stats.json</span><br><span class=\"line\">webpack --profile --json | Out-file &apos;stats.json&apos; - Encoding //windows下命令</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>官方分析地址 <a href=\"http://webpack.github.io/analyse/\" target=\"_blank\" rel=\"noopener\">http://webpack.github.io/analyse/</a></p>\n</li>\n</ol>\n<ul>\n<li>webpack-bundle-analyzer</li>\n</ul>\n<ol>\n<li>抵用插件BundleAnalyzerPlugin <a href=\"https://www.npmjs.com/package/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/webpack-bundle-analyzer</a></li>\n<li>命令行<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack-bundle-analyzer stats.json</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"优化打包速度\"><a href=\"#优化打包速度\" class=\"headerlink\" title=\"优化打包速度\"></a>优化打包速度</h3><ol>\n<li>分开vendor与app（第三方与开发文件）使用Dllplugin与DllReferencePlugin</li>\n<li>UglifyJsPlugin 配置参数 parallel:true（并行处理压缩）</li>\n<li>UglifyJsPlugin cache缓存</li>\n<li>HappyPach 并行处理 loader</li>\n<li>babel-loader 配置 cacheDirectory开启缓存、配置include exlude规定范围</li>\n<li>其他</li>\n</ol>\n<ul>\n<li>减少 resolve</li>\n<li>去除 source-map</li>\n<li>cache-loader</li>\n<li>升级 node\\webpack<h3 id=\"长缓存优化\"><a href=\"#长缓存优化\" class=\"headerlink\" title=\"长缓存优化\"></a>长缓存优化</h3><h4 id=\"场景1：app改变vendor也改变了\"><a href=\"#场景1：app改变vendor也改变了\" class=\"headerlink\" title=\"场景1：app改变vendor也改变了\"></a>场景1：app改变vendor也改变了</h4></li>\n</ul>\n<ol>\n<li>提取vendor</li>\n<li>解决hash变化问题：hash-&gt;chunkhash(将打包的hash变为代码快的hash)，将output[hash]改为[chunkhash]</li>\n<li>提取 manifest 文件（提取webpack runtime 代码）<h4 id=\"场景2：引入新的模块，模块顺序发生变化，vendor-hash变化了（因为chunkId变了）\"><a href=\"#场景2：引入新的模块，模块顺序发生变化，vendor-hash变化了（因为chunkId变了）\" class=\"headerlink\" title=\"场景2：引入新的模块，模块顺序发生变化，vendor hash变化了（因为chunkId变了）\"></a>场景2：引入新的模块，模块顺序发生变化，vendor hash变化了（因为chunkId变了）</h4></li>\n<li>NameChunksPlugin 改变chunk名</li>\n<li>保持moduleId稳定 NameModulesPlugin （如果想看打包module name命令行添加 –display-modules）</li>\n<li>或者使用HashedModuleIdsPlugin 保持moduleId稳定</li>\n</ol>\n<ul>\n<li>vue配置<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 保持chunkId不变</span><br><span class=\"line\">new webpack.NamedChunksPlugin(),</span><br><span class=\"line\">// 保持moduleID稳定</span><br><span class=\"line\">new webpack.HashedModuleIdsPlugin(),</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"场景3：动态引入时vendor-hash发生变化（异步加载的包改变）\"><a href=\"#场景3：动态引入时vendor-hash发生变化（异步加载的包改变）\" class=\"headerlink\" title=\"场景3：动态引入时vendor hash发生变化（异步加载的包改变）\"></a>场景3：动态引入时vendor hash发生变化（异步加载的包改变）</h4><ol>\n<li>在动态引入的代码中添加 异步module名称<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import(/* webpackChunkName: &quot;print&quot; */ &apos;./print&apos;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"总结优化打包\"><a href=\"#总结优化打包\" class=\"headerlink\" title=\"总结优化打包\"></a>总结优化打包</h4><ol>\n<li>独立打包vendor</li>\n<li>抽出manifest</li>\n<li>NameChunksPlugin\\NameModulesPlugin\\HashedModuleIdsPlugin</li>\n<li>动态加载模块设置名称</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"webpack-watch-mode\"><a href=\"#webpack-watch-mode\" class=\"headerlink\" title=\"webpack watch mode\"></a>webpack watch mode</h3><ul>\n<li><p>使用方式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack -watch</span><br><span class=\"line\">webpack -w</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>不会建立web服务器</p>\n<h3 id=\"webpack-dev-server\"><a href=\"#webpack-dev-server\" class=\"headerlink\" title=\"webpack-dev-server\"></a>webpack-dev-server</h3></li>\n<li>live reloading (重新刷新浏览器)</li>\n<li>路径重定向</li>\n<li>https</li>\n<li>在浏览器显示编译错误</li>\n<li>接口代理</li>\n<li>模块热更新（不刷新浏览器更新代码）<a href=\"https://www.webpackjs.com/guides/hot-module-replacement/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/guides/hot-module-replacement/</a></li>\n<li>基本配置 <a href=\"https://www.webpackjs.com/configuration/dev-server/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/configuration/dev-server/</a><h3 id=\"express-webpack-dev-middleware\"><a href=\"#express-webpack-dev-middleware\" class=\"headerlink\" title=\"express + webpack-dev-middleware\"></a>express + webpack-dev-middleware</h3></li>\n</ul>\n<h3 id=\"开启source-map\"><a href=\"#开启source-map\" class=\"headerlink\" title=\"开启source-map\"></a>开启source-map</h3><h4 id=\"js开启source-map\"><a href=\"#js开启source-map\" class=\"headerlink\" title=\"js开启source-map\"></a>js开启source-map</h4><ul>\n<li>Devtool</li>\n</ul>\n<ol>\n<li>开发环境使用 cheap-module-source-map\\source-map</li>\n<li>生产环境使用 一般不用，如果修改问题可以配置为source-map</li>\n</ol>\n<ul>\n<li>生产环境uglify压缩时需要开启配置</li>\n<li>webpack.SourceMapDevToolPlugin</li>\n<li>webpack.EvalSourceMapDevToolPlugin<h4 id=\"css开启source-map\"><a href=\"#css开启source-map\" class=\"headerlink\" title=\"css开启source-map\"></a>css开启source-map</h4></li>\n<li>开启相关loader的sourcemap配置<h3 id=\"开发环境和生产环境的区别\"><a href=\"#开发环境和生产环境的区别\" class=\"headerlink\" title=\"开发环境和生产环境的区别\"></a>开发环境和生产环境的区别</h3><h4 id=\"开发环境\"><a href=\"#开发环境\" class=\"headerlink\" title=\"开发环境\"></a>开发环境</h4></li>\n</ul>\n<ol>\n<li>模块热更新</li>\n<li>sourceMap</li>\n<li>接口代理</li>\n<li>代码规范检查<h4 id=\"生产环境\"><a href=\"#生产环境\" class=\"headerlink\" title=\"生产环境\"></a>生产环境</h4></li>\n<li>提取公共代码</li>\n<li>压缩混淆</li>\n<li>文件压缩或base64编码</li>\n<li>去除无用代码 tree-shaking</li>\n<li>分离css</li>\n<li>打包代码配置<h3 id=\"打包结果分析\"><a href=\"#打包结果分析\" class=\"headerlink\" title=\"打包结果分析\"></a>打包结果分析</h3></li>\n</ol>\n<ul>\n<li>官方 Offical Analyse Tool</li>\n</ul>\n<ol>\n<li><p>命令</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack --profile --json &gt;stats.json</span><br><span class=\"line\">webpack --profile --json | Out-file &apos;stats.json&apos; - Encoding //windows下命令</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>官方分析地址 <a href=\"http://webpack.github.io/analyse/\" target=\"_blank\" rel=\"noopener\">http://webpack.github.io/analyse/</a></p>\n</li>\n</ol>\n<ul>\n<li>webpack-bundle-analyzer</li>\n</ul>\n<ol>\n<li>抵用插件BundleAnalyzerPlugin <a href=\"https://www.npmjs.com/package/webpack-bundle-analyzer\" target=\"_blank\" rel=\"noopener\">https://www.npmjs.com/package/webpack-bundle-analyzer</a></li>\n<li>命令行<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">webpack-bundle-analyzer stats.json</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h3 id=\"优化打包速度\"><a href=\"#优化打包速度\" class=\"headerlink\" title=\"优化打包速度\"></a>优化打包速度</h3><ol>\n<li>分开vendor与app（第三方与开发文件）使用Dllplugin与DllReferencePlugin</li>\n<li>UglifyJsPlugin 配置参数 parallel:true（并行处理压缩）</li>\n<li>UglifyJsPlugin cache缓存</li>\n<li>HappyPach 并行处理 loader</li>\n<li>babel-loader 配置 cacheDirectory开启缓存、配置include exlude规定范围</li>\n<li>其他</li>\n</ol>\n<ul>\n<li>减少 resolve</li>\n<li>去除 source-map</li>\n<li>cache-loader</li>\n<li>升级 node\\webpack<h3 id=\"长缓存优化\"><a href=\"#长缓存优化\" class=\"headerlink\" title=\"长缓存优化\"></a>长缓存优化</h3><h4 id=\"场景1：app改变vendor也改变了\"><a href=\"#场景1：app改变vendor也改变了\" class=\"headerlink\" title=\"场景1：app改变vendor也改变了\"></a>场景1：app改变vendor也改变了</h4></li>\n</ul>\n<ol>\n<li>提取vendor</li>\n<li>解决hash变化问题：hash-&gt;chunkhash(将打包的hash变为代码快的hash)，将output[hash]改为[chunkhash]</li>\n<li>提取 manifest 文件（提取webpack runtime 代码）<h4 id=\"场景2：引入新的模块，模块顺序发生变化，vendor-hash变化了（因为chunkId变了）\"><a href=\"#场景2：引入新的模块，模块顺序发生变化，vendor-hash变化了（因为chunkId变了）\" class=\"headerlink\" title=\"场景2：引入新的模块，模块顺序发生变化，vendor hash变化了（因为chunkId变了）\"></a>场景2：引入新的模块，模块顺序发生变化，vendor hash变化了（因为chunkId变了）</h4></li>\n<li>NameChunksPlugin 改变chunk名</li>\n<li>保持moduleId稳定 NameModulesPlugin （如果想看打包module name命令行添加 –display-modules）</li>\n<li>或者使用HashedModuleIdsPlugin 保持moduleId稳定</li>\n</ol>\n<ul>\n<li>vue配置<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">// 保持chunkId不变</span><br><span class=\"line\">new webpack.NamedChunksPlugin(),</span><br><span class=\"line\">// 保持moduleID稳定</span><br><span class=\"line\">new webpack.HashedModuleIdsPlugin(),</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"场景3：动态引入时vendor-hash发生变化（异步加载的包改变）\"><a href=\"#场景3：动态引入时vendor-hash发生变化（异步加载的包改变）\" class=\"headerlink\" title=\"场景3：动态引入时vendor hash发生变化（异步加载的包改变）\"></a>场景3：动态引入时vendor hash发生变化（异步加载的包改变）</h4><ol>\n<li>在动态引入的代码中添加 异步module名称<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import(/* webpackChunkName: &quot;print&quot; */ &apos;./print&apos;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"总结优化打包\"><a href=\"#总结优化打包\" class=\"headerlink\" title=\"总结优化打包\"></a>总结优化打包</h4><ol>\n<li>独立打包vendor</li>\n<li>抽出manifest</li>\n<li>NameChunksPlugin\\NameModulesPlugin\\HashedModuleIdsPlugin</li>\n<li>动态加载模块设置名称</li>\n</ol>\n"},{"title":"webpack配置全局常量","date":"2018-09-26T06:04:10.000Z","_content":"\n需求：进行项目打包时需要配置不同的服务url，手动去更改容易出错，因此将不同url打包写入程序，根据webpack配置不同打包命令。需要用到全局常量的配置。\n## webpack配置文件中的全局常量\n使用 [cross-env](https://www.npmjs.com/package/cross-env) 库可以配置webpack配置文件中的全局常量。\n首先安装这个库：\n\n```\nnpm install --save-dev cross-env\n```\n修改package.json中的命令：\n\n```\n\"scripts\": {\n    \"build-qa\": \"cross-env OUTPUT_DATA=qa node webpack/build.js\"\n}\n```\n此时，执行npm run build-qa命令时可以在webpack配置文件中获取相关常量：\n\n```\n//webpack.prod.conf.js文件中\nconsole.log(process.env.OUTPUT_DATA)//qa\n```\n\n## 配置打包代码中的全局常量\n使用 [DefinePlugin](https://www.webpackjs.com/plugins/define-plugin/) 可以配置打包代码中的常量：\n具体配置：\n\n```\nnew webpack.DefinePlugin({\n    'process.env': {\n        NODE_ENV: '\"production\"',\n        OUTPUT_DATA: process.env.OUTPUT_DATA == 'qa' ? '\"qa\"' : '\"\"'\n    }\n})\n```\n注意，因为这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 '\"production\"', 或者使用 JSON.stringify('production')。\n\n配置之后，webpack会将项目代码中的process.env.OUTPUT_DATA、process.env.NODE_ENV 变量替换为对应的常量。\n\n结合以上两种方式，就可以控制webpack打包的常量了。\n\n\n\n","source":"_posts/webpack配置全局常量.md","raw":"---\ntitle: webpack配置全局常量\ndate: 2018-09-26 14:04:10\ntags: [webpack]\ncategories: webpack\n---\n\n需求：进行项目打包时需要配置不同的服务url，手动去更改容易出错，因此将不同url打包写入程序，根据webpack配置不同打包命令。需要用到全局常量的配置。\n## webpack配置文件中的全局常量\n使用 [cross-env](https://www.npmjs.com/package/cross-env) 库可以配置webpack配置文件中的全局常量。\n首先安装这个库：\n\n```\nnpm install --save-dev cross-env\n```\n修改package.json中的命令：\n\n```\n\"scripts\": {\n    \"build-qa\": \"cross-env OUTPUT_DATA=qa node webpack/build.js\"\n}\n```\n此时，执行npm run build-qa命令时可以在webpack配置文件中获取相关常量：\n\n```\n//webpack.prod.conf.js文件中\nconsole.log(process.env.OUTPUT_DATA)//qa\n```\n\n## 配置打包代码中的全局常量\n使用 [DefinePlugin](https://www.webpackjs.com/plugins/define-plugin/) 可以配置打包代码中的常量：\n具体配置：\n\n```\nnew webpack.DefinePlugin({\n    'process.env': {\n        NODE_ENV: '\"production\"',\n        OUTPUT_DATA: process.env.OUTPUT_DATA == 'qa' ? '\"qa\"' : '\"\"'\n    }\n})\n```\n注意，因为这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 '\"production\"', 或者使用 JSON.stringify('production')。\n\n配置之后，webpack会将项目代码中的process.env.OUTPUT_DATA、process.env.NODE_ENV 变量替换为对应的常量。\n\n结合以上两种方式，就可以控制webpack打包的常量了。\n\n\n\n","slug":"webpack配置全局常量","published":1,"updated":"2018-09-26T06:24:41.823Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob7c002ce0jcfpoi4j3f","content":"<p>需求：进行项目打包时需要配置不同的服务url，手动去更改容易出错，因此将不同url打包写入程序，根据webpack配置不同打包命令。需要用到全局常量的配置。</p>\n<h2 id=\"webpack配置文件中的全局常量\"><a href=\"#webpack配置文件中的全局常量\" class=\"headerlink\" title=\"webpack配置文件中的全局常量\"></a>webpack配置文件中的全局常量</h2><p>使用 <a href=\"https://www.npmjs.com/package/cross-env\" target=\"_blank\" rel=\"noopener\">cross-env</a> 库可以配置webpack配置文件中的全局常量。<br>首先安装这个库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev cross-env</span><br></pre></td></tr></table></figure>\n<p>修改package.json中的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;build-qa&quot;: &quot;cross-env OUTPUT_DATA=qa node webpack/build.js&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时，执行npm run build-qa命令时可以在webpack配置文件中获取相关常量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//webpack.prod.conf.js文件中</span><br><span class=\"line\">console.log(process.env.OUTPUT_DATA)//qa</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置打包代码中的全局常量\"><a href=\"#配置打包代码中的全局常量\" class=\"headerlink\" title=\"配置打包代码中的全局常量\"></a>配置打包代码中的全局常量</h2><p>使用 <a href=\"https://www.webpackjs.com/plugins/define-plugin/\" target=\"_blank\" rel=\"noopener\">DefinePlugin</a> 可以配置打包代码中的常量：<br>具体配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new webpack.DefinePlugin(&#123;</span><br><span class=\"line\">    &apos;process.env&apos;: &#123;</span><br><span class=\"line\">        NODE_ENV: &apos;&quot;production&quot;&apos;,</span><br><span class=\"line\">        OUTPUT_DATA: process.env.OUTPUT_DATA == &apos;qa&apos; ? &apos;&quot;qa&quot;&apos; : &apos;&quot;&quot;&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>注意，因为这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 ‘“production”‘, 或者使用 JSON.stringify(‘production’)。</p>\n<p>配置之后，webpack会将项目代码中的process.env.OUTPUT_DATA、process.env.NODE_ENV 变量替换为对应的常量。</p>\n<p>结合以上两种方式，就可以控制webpack打包的常量了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>需求：进行项目打包时需要配置不同的服务url，手动去更改容易出错，因此将不同url打包写入程序，根据webpack配置不同打包命令。需要用到全局常量的配置。</p>\n<h2 id=\"webpack配置文件中的全局常量\"><a href=\"#webpack配置文件中的全局常量\" class=\"headerlink\" title=\"webpack配置文件中的全局常量\"></a>webpack配置文件中的全局常量</h2><p>使用 <a href=\"https://www.npmjs.com/package/cross-env\" target=\"_blank\" rel=\"noopener\">cross-env</a> 库可以配置webpack配置文件中的全局常量。<br>首先安装这个库：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install --save-dev cross-env</span><br></pre></td></tr></table></figure>\n<p>修改package.json中的命令：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;scripts&quot;: &#123;</span><br><span class=\"line\">    &quot;build-qa&quot;: &quot;cross-env OUTPUT_DATA=qa node webpack/build.js&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>此时，执行npm run build-qa命令时可以在webpack配置文件中获取相关常量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//webpack.prod.conf.js文件中</span><br><span class=\"line\">console.log(process.env.OUTPUT_DATA)//qa</span><br></pre></td></tr></table></figure>\n<h2 id=\"配置打包代码中的全局常量\"><a href=\"#配置打包代码中的全局常量\" class=\"headerlink\" title=\"配置打包代码中的全局常量\"></a>配置打包代码中的全局常量</h2><p>使用 <a href=\"https://www.webpackjs.com/plugins/define-plugin/\" target=\"_blank\" rel=\"noopener\">DefinePlugin</a> 可以配置打包代码中的常量：<br>具体配置：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">new webpack.DefinePlugin(&#123;</span><br><span class=\"line\">    &apos;process.env&apos;: &#123;</span><br><span class=\"line\">        NODE_ENV: &apos;&quot;production&quot;&apos;,</span><br><span class=\"line\">        OUTPUT_DATA: process.env.OUTPUT_DATA == &apos;qa&apos; ? &apos;&quot;qa&quot;&apos; : &apos;&quot;&quot;&apos;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<p>注意，因为这个插件直接执行文本替换，给定的值必须包含字符串本身内的实际引号。通常，有两种方式来达到这个效果，使用 ‘“production”‘, 或者使用 JSON.stringify(‘production’)。</p>\n<p>配置之后，webpack会将项目代码中的process.env.OUTPUT_DATA、process.env.NODE_ENV 变量替换为对应的常量。</p>\n<p>结合以上两种方式，就可以控制webpack打包的常量了。</p>\n"},{"title":"webpack-简介以及相关概念","date":"2018-12-19T06:04:10.000Z","_content":"\n#### 作者为什么要开发webpack\n为了实现代码分割功能\n#### 为什么要构建\n- 开发分工变化：单页面应用、越来越复杂、文件越来越多\n- 框架演变：由js库变为前端框架、模块化开发、新的语法特性、逻辑分层、MVVM框架\n- 语言的发展：HTML(W3C)、css->less\\sass\\stylus预处理工具、js->ts\\模块化\\ES6\n- 环境的变化：前端代码可以使用node环境服务\n- 社区变化：github、npm 包管理需要构建\n- 工具的变化：grunt\\gulp\\webpack\\rollup\n- #### 为什么要webpack\n- Vue-cli\\React-starter\\Angular-cli 都是webpack构建的\n- 支持Code-Spliting(代码分割)\n- 支持模块化\n### 模块化开发\n#### JS模块化\n- 命名空间->commonjs(只能在nodejs服务端使用)->AMD|CMD|UMD->ES6 module\n- 命名空间\n```\nvar NameSpace = {}\nNameSpace.type = NameSpace.type || {}\nNameSpace.type.method = function(){}\n```\n- commonjs\n1. 一个文件是一个模块\n2. 通过 module.exports 暴露模块接口\n- AMD\n1. 使用 define 定义模块、使用 require 加载模块\n2. RequireJS\n3. 依赖前置，提前执行\n```\ndefine(['jquery'], function ($) {\n    //    methods\n    function myFunc(){};\n\n    //    exposed public methods\n    return myFunc;\n});\n```\n- CMD\n1. SeaJS\n2. 尽可能懒执行\n```\ndefine(function (require, exports, module) {\n    // load dependence\n    var $ = require('jquery');\n\n    //    methods\n    function myFunc(){};\n\n    //    exposed public methods\n    return myFunc;\n})\n```\n- UMD(Universal Module Definition)通用模块解决方案\n1. 判断是否支持AMD\n2. 判断是否支持commonJS\n3. 如果都没有，使用全局变量\n```\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['jquery'], factory);\n    } else if (typeof exports === 'object') {\n        // Node, CommonJS-like\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.jQuery);\n    }\n}(this, function ($) {\n    //    methods\n    function myFunc(){};\n\n    //    exposed public method\n    return myFunc;\n}));\n```\n- ESM\n1. 一个文件一个模块 export/import\n#### webpack支持的模块化\n- AMD\\ES Module(推荐)\\CommonJS\n#### css模块化\n- CSS设计模式：OOCSS\\SMACSS\\Atomic css\\MCSS\\AMCSS\\BEM\n- CSS Module：\n### webpack简介\n#### 功能进化\n- v2版本\n1. Tree Shaking\n2. ES Module\n3. 动态 import\n4. 新的文档\n- v3版本\n1. Scope Hoisting（作用于提升）打包后代码性能提升\n2. Magic Comments (配合动态import使用) 指定打包后的文件名\n- v4版本\n#### 核心概念\n- entry\n1. 代码入口、打包入口、单个或者多个\n```\nmodule.exports = {\n    entry: {\n        index: 'index.js',\n        vendor: ['jquery']\n    }\n}\n```\n- output\n1. 对打包生成文件的描述、一个或者多个\n2. https://www.webpackjs.com/configuration/output/\n- Loaders\n1. 处理文件、转化为模块\n2. https://www.webpackjs.com/loaders/\n- Plugins\n1. 参与整个打包过程\n2. https://www.webpackjs.com/plugins/\n#### 名词\n- chunk 代码块\n- Bundle 打包后的文件\n- Module 模块\n","source":"_posts/webpack-简介以及相关概念.md","raw":"---\ntitle: webpack-简介以及相关概念\ndate: 2018-12-19 14:04:10\ntags: [webpack]\ncategories: webpack\n---\n\n#### 作者为什么要开发webpack\n为了实现代码分割功能\n#### 为什么要构建\n- 开发分工变化：单页面应用、越来越复杂、文件越来越多\n- 框架演变：由js库变为前端框架、模块化开发、新的语法特性、逻辑分层、MVVM框架\n- 语言的发展：HTML(W3C)、css->less\\sass\\stylus预处理工具、js->ts\\模块化\\ES6\n- 环境的变化：前端代码可以使用node环境服务\n- 社区变化：github、npm 包管理需要构建\n- 工具的变化：grunt\\gulp\\webpack\\rollup\n- #### 为什么要webpack\n- Vue-cli\\React-starter\\Angular-cli 都是webpack构建的\n- 支持Code-Spliting(代码分割)\n- 支持模块化\n### 模块化开发\n#### JS模块化\n- 命名空间->commonjs(只能在nodejs服务端使用)->AMD|CMD|UMD->ES6 module\n- 命名空间\n```\nvar NameSpace = {}\nNameSpace.type = NameSpace.type || {}\nNameSpace.type.method = function(){}\n```\n- commonjs\n1. 一个文件是一个模块\n2. 通过 module.exports 暴露模块接口\n- AMD\n1. 使用 define 定义模块、使用 require 加载模块\n2. RequireJS\n3. 依赖前置，提前执行\n```\ndefine(['jquery'], function ($) {\n    //    methods\n    function myFunc(){};\n\n    //    exposed public methods\n    return myFunc;\n});\n```\n- CMD\n1. SeaJS\n2. 尽可能懒执行\n```\ndefine(function (require, exports, module) {\n    // load dependence\n    var $ = require('jquery');\n\n    //    methods\n    function myFunc(){};\n\n    //    exposed public methods\n    return myFunc;\n})\n```\n- UMD(Universal Module Definition)通用模块解决方案\n1. 判断是否支持AMD\n2. 判断是否支持commonJS\n3. 如果都没有，使用全局变量\n```\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['jquery'], factory);\n    } else if (typeof exports === 'object') {\n        // Node, CommonJS-like\n        module.exports = factory(require('jquery'));\n    } else {\n        // Browser globals (root is window)\n        root.returnExports = factory(root.jQuery);\n    }\n}(this, function ($) {\n    //    methods\n    function myFunc(){};\n\n    //    exposed public method\n    return myFunc;\n}));\n```\n- ESM\n1. 一个文件一个模块 export/import\n#### webpack支持的模块化\n- AMD\\ES Module(推荐)\\CommonJS\n#### css模块化\n- CSS设计模式：OOCSS\\SMACSS\\Atomic css\\MCSS\\AMCSS\\BEM\n- CSS Module：\n### webpack简介\n#### 功能进化\n- v2版本\n1. Tree Shaking\n2. ES Module\n3. 动态 import\n4. 新的文档\n- v3版本\n1. Scope Hoisting（作用于提升）打包后代码性能提升\n2. Magic Comments (配合动态import使用) 指定打包后的文件名\n- v4版本\n#### 核心概念\n- entry\n1. 代码入口、打包入口、单个或者多个\n```\nmodule.exports = {\n    entry: {\n        index: 'index.js',\n        vendor: ['jquery']\n    }\n}\n```\n- output\n1. 对打包生成文件的描述、一个或者多个\n2. https://www.webpackjs.com/configuration/output/\n- Loaders\n1. 处理文件、转化为模块\n2. https://www.webpackjs.com/loaders/\n- Plugins\n1. 参与整个打包过程\n2. https://www.webpackjs.com/plugins/\n#### 名词\n- chunk 代码块\n- Bundle 打包后的文件\n- Module 模块\n","slug":"webpack-简介以及相关概念","published":1,"updated":"2019-01-06T03:01:56.337Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob7e002ge0jcwsgdenoj","content":"<h4 id=\"作者为什么要开发webpack\"><a href=\"#作者为什么要开发webpack\" class=\"headerlink\" title=\"作者为什么要开发webpack\"></a>作者为什么要开发webpack</h4><p>为了实现代码分割功能</p>\n<h4 id=\"为什么要构建\"><a href=\"#为什么要构建\" class=\"headerlink\" title=\"为什么要构建\"></a>为什么要构建</h4><ul>\n<li>开发分工变化：单页面应用、越来越复杂、文件越来越多</li>\n<li>框架演变：由js库变为前端框架、模块化开发、新的语法特性、逻辑分层、MVVM框架</li>\n<li>语言的发展：HTML(W3C)、css-&gt;less\\sass\\stylus预处理工具、js-&gt;ts\\模块化\\ES6</li>\n<li>环境的变化：前端代码可以使用node环境服务</li>\n<li>社区变化：github、npm 包管理需要构建</li>\n<li>工具的变化：grunt\\gulp\\webpack\\rollup</li>\n<li><h4 id=\"为什么要webpack\"><a href=\"#为什么要webpack\" class=\"headerlink\" title=\"为什么要webpack\"></a>为什么要webpack</h4></li>\n<li>Vue-cli\\React-starter\\Angular-cli 都是webpack构建的</li>\n<li>支持Code-Spliting(代码分割)</li>\n<li>支持模块化<h3 id=\"模块化开发\"><a href=\"#模块化开发\" class=\"headerlink\" title=\"模块化开发\"></a>模块化开发</h3><h4 id=\"JS模块化\"><a href=\"#JS模块化\" class=\"headerlink\" title=\"JS模块化\"></a>JS模块化</h4></li>\n<li>命名空间-&gt;commonjs(只能在nodejs服务端使用)-&gt;AMD|CMD|UMD-&gt;ES6 module</li>\n<li><p>命名空间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var NameSpace = &#123;&#125;</span><br><span class=\"line\">NameSpace.type = NameSpace.type || &#123;&#125;</span><br><span class=\"line\">NameSpace.type.method = function()&#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>commonjs</p>\n</li>\n</ul>\n<ol>\n<li>一个文件是一个模块</li>\n<li>通过 module.exports 暴露模块接口</li>\n</ol>\n<ul>\n<li>AMD</li>\n</ul>\n<ol>\n<li>使用 define 定义模块、使用 require 加载模块</li>\n<li>RequireJS</li>\n<li>依赖前置，提前执行<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([&apos;jquery&apos;], function ($) &#123;</span><br><span class=\"line\">    //    methods</span><br><span class=\"line\">    function myFunc()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    //    exposed public methods</span><br><span class=\"line\">    return myFunc;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>CMD</li>\n</ul>\n<ol>\n<li>SeaJS</li>\n<li>尽可能懒执行<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(function (require, exports, module) &#123;</span><br><span class=\"line\">    // load dependence</span><br><span class=\"line\">    var $ = require(&apos;jquery&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //    methods</span><br><span class=\"line\">    function myFunc()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    //    exposed public methods</span><br><span class=\"line\">    return myFunc;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>UMD(Universal Module Definition)通用模块解决方案</li>\n</ul>\n<ol>\n<li>判断是否支持AMD</li>\n<li>判断是否支持commonJS</li>\n<li>如果都没有，使用全局变量<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function (root, factory) &#123;</span><br><span class=\"line\">    if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">        // AMD</span><br><span class=\"line\">        define([&apos;jquery&apos;], factory);</span><br><span class=\"line\">    &#125; else if (typeof exports === &apos;object&apos;) &#123;</span><br><span class=\"line\">        // Node, CommonJS-like</span><br><span class=\"line\">        module.exports = factory(require(&apos;jquery&apos;));</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        // Browser globals (root is window)</span><br><span class=\"line\">        root.returnExports = factory(root.jQuery);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(this, function ($) &#123;</span><br><span class=\"line\">    //    methods</span><br><span class=\"line\">    function myFunc()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    //    exposed public method</span><br><span class=\"line\">    return myFunc;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>ESM</li>\n</ul>\n<ol>\n<li>一个文件一个模块 export/import<h4 id=\"webpack支持的模块化\"><a href=\"#webpack支持的模块化\" class=\"headerlink\" title=\"webpack支持的模块化\"></a>webpack支持的模块化</h4></li>\n</ol>\n<ul>\n<li>AMD\\ES Module(推荐)\\CommonJS<h4 id=\"css模块化\"><a href=\"#css模块化\" class=\"headerlink\" title=\"css模块化\"></a>css模块化</h4></li>\n<li>CSS设计模式：OOCSS\\SMACSS\\Atomic css\\MCSS\\AMCSS\\BEM</li>\n<li>CSS Module：<h3 id=\"webpack简介\"><a href=\"#webpack简介\" class=\"headerlink\" title=\"webpack简介\"></a>webpack简介</h3><h4 id=\"功能进化\"><a href=\"#功能进化\" class=\"headerlink\" title=\"功能进化\"></a>功能进化</h4></li>\n<li>v2版本</li>\n</ul>\n<ol>\n<li>Tree Shaking</li>\n<li>ES Module</li>\n<li>动态 import</li>\n<li>新的文档</li>\n</ol>\n<ul>\n<li>v3版本</li>\n</ul>\n<ol>\n<li>Scope Hoisting（作用于提升）打包后代码性能提升</li>\n<li>Magic Comments (配合动态import使用) 指定打包后的文件名</li>\n</ol>\n<ul>\n<li>v4版本<h4 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h4></li>\n<li>entry</li>\n</ul>\n<ol>\n<li>代码入口、打包入口、单个或者多个<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        index: &apos;index.js&apos;,</span><br><span class=\"line\">        vendor: [&apos;jquery&apos;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>output</li>\n</ul>\n<ol>\n<li>对打包生成文件的描述、一个或者多个</li>\n<li><a href=\"https://www.webpackjs.com/configuration/output/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/configuration/output/</a></li>\n</ol>\n<ul>\n<li>Loaders</li>\n</ul>\n<ol>\n<li>处理文件、转化为模块</li>\n<li><a href=\"https://www.webpackjs.com/loaders/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/loaders/</a></li>\n</ol>\n<ul>\n<li>Plugins</li>\n</ul>\n<ol>\n<li>参与整个打包过程</li>\n<li><a href=\"https://www.webpackjs.com/plugins/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/plugins/</a><h4 id=\"名词\"><a href=\"#名词\" class=\"headerlink\" title=\"名词\"></a>名词</h4></li>\n</ol>\n<ul>\n<li>chunk 代码块</li>\n<li>Bundle 打包后的文件</li>\n<li>Module 模块</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"作者为什么要开发webpack\"><a href=\"#作者为什么要开发webpack\" class=\"headerlink\" title=\"作者为什么要开发webpack\"></a>作者为什么要开发webpack</h4><p>为了实现代码分割功能</p>\n<h4 id=\"为什么要构建\"><a href=\"#为什么要构建\" class=\"headerlink\" title=\"为什么要构建\"></a>为什么要构建</h4><ul>\n<li>开发分工变化：单页面应用、越来越复杂、文件越来越多</li>\n<li>框架演变：由js库变为前端框架、模块化开发、新的语法特性、逻辑分层、MVVM框架</li>\n<li>语言的发展：HTML(W3C)、css-&gt;less\\sass\\stylus预处理工具、js-&gt;ts\\模块化\\ES6</li>\n<li>环境的变化：前端代码可以使用node环境服务</li>\n<li>社区变化：github、npm 包管理需要构建</li>\n<li>工具的变化：grunt\\gulp\\webpack\\rollup</li>\n<li><h4 id=\"为什么要webpack\"><a href=\"#为什么要webpack\" class=\"headerlink\" title=\"为什么要webpack\"></a>为什么要webpack</h4></li>\n<li>Vue-cli\\React-starter\\Angular-cli 都是webpack构建的</li>\n<li>支持Code-Spliting(代码分割)</li>\n<li>支持模块化<h3 id=\"模块化开发\"><a href=\"#模块化开发\" class=\"headerlink\" title=\"模块化开发\"></a>模块化开发</h3><h4 id=\"JS模块化\"><a href=\"#JS模块化\" class=\"headerlink\" title=\"JS模块化\"></a>JS模块化</h4></li>\n<li>命名空间-&gt;commonjs(只能在nodejs服务端使用)-&gt;AMD|CMD|UMD-&gt;ES6 module</li>\n<li><p>命名空间</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">var NameSpace = &#123;&#125;</span><br><span class=\"line\">NameSpace.type = NameSpace.type || &#123;&#125;</span><br><span class=\"line\">NameSpace.type.method = function()&#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>commonjs</p>\n</li>\n</ul>\n<ol>\n<li>一个文件是一个模块</li>\n<li>通过 module.exports 暴露模块接口</li>\n</ol>\n<ul>\n<li>AMD</li>\n</ul>\n<ol>\n<li>使用 define 定义模块、使用 require 加载模块</li>\n<li>RequireJS</li>\n<li>依赖前置，提前执行<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define([&apos;jquery&apos;], function ($) &#123;</span><br><span class=\"line\">    //    methods</span><br><span class=\"line\">    function myFunc()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    //    exposed public methods</span><br><span class=\"line\">    return myFunc;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>CMD</li>\n</ul>\n<ol>\n<li>SeaJS</li>\n<li>尽可能懒执行<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">define(function (require, exports, module) &#123;</span><br><span class=\"line\">    // load dependence</span><br><span class=\"line\">    var $ = require(&apos;jquery&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">    //    methods</span><br><span class=\"line\">    function myFunc()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    //    exposed public methods</span><br><span class=\"line\">    return myFunc;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>UMD(Universal Module Definition)通用模块解决方案</li>\n</ul>\n<ol>\n<li>判断是否支持AMD</li>\n<li>判断是否支持commonJS</li>\n<li>如果都没有，使用全局变量<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(function (root, factory) &#123;</span><br><span class=\"line\">    if (typeof define === &apos;function&apos; &amp;&amp; define.amd) &#123;</span><br><span class=\"line\">        // AMD</span><br><span class=\"line\">        define([&apos;jquery&apos;], factory);</span><br><span class=\"line\">    &#125; else if (typeof exports === &apos;object&apos;) &#123;</span><br><span class=\"line\">        // Node, CommonJS-like</span><br><span class=\"line\">        module.exports = factory(require(&apos;jquery&apos;));</span><br><span class=\"line\">    &#125; else &#123;</span><br><span class=\"line\">        // Browser globals (root is window)</span><br><span class=\"line\">        root.returnExports = factory(root.jQuery);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(this, function ($) &#123;</span><br><span class=\"line\">    //    methods</span><br><span class=\"line\">    function myFunc()&#123;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">    //    exposed public method</span><br><span class=\"line\">    return myFunc;</span><br><span class=\"line\">&#125;));</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>ESM</li>\n</ul>\n<ol>\n<li>一个文件一个模块 export/import<h4 id=\"webpack支持的模块化\"><a href=\"#webpack支持的模块化\" class=\"headerlink\" title=\"webpack支持的模块化\"></a>webpack支持的模块化</h4></li>\n</ol>\n<ul>\n<li>AMD\\ES Module(推荐)\\CommonJS<h4 id=\"css模块化\"><a href=\"#css模块化\" class=\"headerlink\" title=\"css模块化\"></a>css模块化</h4></li>\n<li>CSS设计模式：OOCSS\\SMACSS\\Atomic css\\MCSS\\AMCSS\\BEM</li>\n<li>CSS Module：<h3 id=\"webpack简介\"><a href=\"#webpack简介\" class=\"headerlink\" title=\"webpack简介\"></a>webpack简介</h3><h4 id=\"功能进化\"><a href=\"#功能进化\" class=\"headerlink\" title=\"功能进化\"></a>功能进化</h4></li>\n<li>v2版本</li>\n</ul>\n<ol>\n<li>Tree Shaking</li>\n<li>ES Module</li>\n<li>动态 import</li>\n<li>新的文档</li>\n</ol>\n<ul>\n<li>v3版本</li>\n</ul>\n<ol>\n<li>Scope Hoisting（作用于提升）打包后代码性能提升</li>\n<li>Magic Comments (配合动态import使用) 指定打包后的文件名</li>\n</ol>\n<ul>\n<li>v4版本<h4 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h4></li>\n<li>entry</li>\n</ul>\n<ol>\n<li>代码入口、打包入口、单个或者多个<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">module.exports = &#123;</span><br><span class=\"line\">    entry: &#123;</span><br><span class=\"line\">        index: &apos;index.js&apos;,</span><br><span class=\"line\">        vendor: [&apos;jquery&apos;]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>output</li>\n</ul>\n<ol>\n<li>对打包生成文件的描述、一个或者多个</li>\n<li><a href=\"https://www.webpackjs.com/configuration/output/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/configuration/output/</a></li>\n</ol>\n<ul>\n<li>Loaders</li>\n</ul>\n<ol>\n<li>处理文件、转化为模块</li>\n<li><a href=\"https://www.webpackjs.com/loaders/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/loaders/</a></li>\n</ol>\n<ul>\n<li>Plugins</li>\n</ul>\n<ol>\n<li>参与整个打包过程</li>\n<li><a href=\"https://www.webpackjs.com/plugins/\" target=\"_blank\" rel=\"noopener\">https://www.webpackjs.com/plugins/</a><h4 id=\"名词\"><a href=\"#名词\" class=\"headerlink\" title=\"名词\"></a>名词</h4></li>\n</ol>\n<ul>\n<li>chunk 代码块</li>\n<li>Bundle 打包后的文件</li>\n<li>Module 模块</li>\n</ul>\n"},{"title":"你不知道的js学习笔记","date":"2018-11-27T15:55:37.000Z","_content":"### 词法作用域\n- 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。词法作用域意味着作用域是由书写代码时函数声明的位置来决定。\n```\nlet c = 2\nfunction a() {\n    let c = 1\n    b()//2\n}\nfunction b() {\n    console.log(c)\n}\nb()//2\na()\n```\n- 在严格模式的程序中，eval(..)在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。\n```\nfunction c(str) {\n    eval(str)\n    console.log(b)//1\n}\nc('var b = 1')\nfunction a(str) {\n    'use strict'\n    eval(str)\n    console.log(b)//ReferenceError\n}\na('var b = 1')\n```\n- setTimeout(..)和setInterval(..)的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。\n- with 使用注意\n```\nfunction f1(obj) {\n    with (obj){\n        a = 2\n    }\n}\nvar o1 = {\n    a: 1\n}\nvar o2 = {\n    b: 1\n}\nf1(o1)\nf1(o2)\nconsole.log(o1)//{a:2}\nconsole.log(o2)//{b:1}\nconsole.log(a)//2,因为o2中没有a，所以a被泄露到全局了\n//o2的作用域、foo(..)的作用域和全局作用域中都没有找到标识符a，因此当a＝2执行时，自动创建了一个全局变量（因为是非严格模式）。\n```\n### 作用域\n- 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。\n- 区分函数声明和表达式最简单的方法是function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。\n- 提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使let进行的声明不会在块作用域中进行提升。\n### 作用域提升\n- 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。\n```\nconsole.log(a)//undefined\nvar a = 1\n```\n- 函数声明会被提升，但是函数表达式却不会被提升。\n```\nf1()//1\nf2()//TypeError: f2 is not a function\nfunction f1() {\n    console.log(1)\n}\nvar f2 = function () {\n    console.log(2)\n}\n```\n- 即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中。\n```\nf1()//TypeError\nf2()//ReferenceError\nvar f1 = function f2() {\n}\n//可以理解为\n// var f1\n// f1()\n// f2()\n// f1 = function () {\n//     var f2 = ...self...\n// }\n```\n- 函数优先提升，一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。\n```\na()//1\nvar a = 1\nfunction a() {\n    console.log(1)\n}\n```\n- 尽管重复var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。\n```\na()//2\nfunction a() {\n    console.log(1)\n}\nfunction a() {\n    console.log(2)\n}\n```\n- 一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下的代码暗示的那样可以被条件判断所控制。**但是需要注意这个行为并不可靠，JavaScript未来的版本中有可能发生改变，因此应该尽可能避免在块内部声明函数。**\n```\na()//TypeError: a is not a function,**这个demo和书里面的就不一样了书里面说会log 2**\nvar b = true\nif(b){\n    function a() {\n        console.log(1)\n    }\n}else {\n    function a() {\n        console.log(2)\n    }\n}\n```\n### 闭包\n- 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。\n- 模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。\n### this\n- 学this的第一步是明this既不指向函数自身也不指向函数的词法作用域，\n- this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。\n#### 调用位置\n- 调用位置就是函数在代码中被调用的位置（而不是声明的位置）。\n#### this绑定规则\n1. 默认规则\n- 独立函数调用，，函数调用时应用this的默认绑定，因this指向全局对象。\n- 严格模式下this为undefined\n2. 隐式绑定\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\nvar obj = {\n    data: 2,\n    fn: a\n}\na()//1\nobj.fn()//2\n```\n- 隐式丢失\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\nvar obj = {\n    data: 2,\n    fn: a\n}\nvar fn1 = obj.fn\nfn1()//1\nvar f2\n(f2 = obj.fn)()//2\n```\n3. 显示绑定\n- JavaScript提供的绝大多数函数以及你自己创建的所有函数都可以使call(..)apply(..)bind(...)方法。\n4. new绑定使\n- new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。\n- 1.创建（或者说构造）一个全新的对象。\n- 2.这个新对象会被执[[原]]连接。\n- 3.这个新对象会绑定到函数调用this。\n- 4.如果函数没有返回其他对象，那new表达式中的函数调用会自动返回这个新对象。\n#### 优先级\n- new > 显示 > 隐式 > 默认\n#### 被忽略的this\n- 如果你null或undefined作this的绑定对象传call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\na.apply(null)//1\n```\n- 更安全的this\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\nvar ø = Object.create(null)\na.apply(ø)//1\n```\n#### 软绑定\n```\nif (!Function.prototype.softBind) {\n    Function.prototype.softBind = function (obj) {\n        var fn = this;\n        // 捕获所有 curried 参数\n        var curried = [].slice.call(arguments, 1);\n        var bound = function () {\n            return fn.apply(\n                (!this || this === (window || global)) ? obj : this,\n                curried.concat.apply(curried, arguments)\n            )\n        };\n        bound.prototype = Object.create(fn.prototype);\n        return bound;\n    };\n}\nvar data = 2\n\nfunction a() {\n    console.log(data)\n}\n\nvar b = a.softBind({data: 1})\na()//2\nb()//1\n```\n#### 箭头函数\n- 。箭头函数不使this的四种标准规则，而是根据外层（函数或者全局）作用域来决this。\n```\nfunction a() {\n    //返回箭头函数\n    return ()=>{\n        //this继承自a()\n        console.log(this.data)\n    }\n\n    //ES5的实现\n    // let self = this\n    // return function () {\n    //     console.log(self.data)\n    // }\n}\nlet b = a.call({data:1})\nb.call({data:2})//1\n```\n","source":"_posts/你不知道的js学习笔记.md","raw":"---\ntitle: 你不知道的js学习笔记\ndate: 2018-11-27 23:55:37\ntags: [js]\ncategories: js\n---\n### 词法作用域\n- 无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。词法作用域意味着作用域是由书写代码时函数声明的位置来决定。\n```\nlet c = 2\nfunction a() {\n    let c = 1\n    b()//2\n}\nfunction b() {\n    console.log(c)\n}\nb()//2\na()\n```\n- 在严格模式的程序中，eval(..)在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。\n```\nfunction c(str) {\n    eval(str)\n    console.log(b)//1\n}\nc('var b = 1')\nfunction a(str) {\n    'use strict'\n    eval(str)\n    console.log(b)//ReferenceError\n}\na('var b = 1')\n```\n- setTimeout(..)和setInterval(..)的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。\n- with 使用注意\n```\nfunction f1(obj) {\n    with (obj){\n        a = 2\n    }\n}\nvar o1 = {\n    a: 1\n}\nvar o2 = {\n    b: 1\n}\nf1(o1)\nf1(o2)\nconsole.log(o1)//{a:2}\nconsole.log(o2)//{b:1}\nconsole.log(a)//2,因为o2中没有a，所以a被泄露到全局了\n//o2的作用域、foo(..)的作用域和全局作用域中都没有找到标识符a，因此当a＝2执行时，自动创建了一个全局变量（因为是非严格模式）。\n```\n### 作用域\n- 函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。\n- 区分函数声明和表达式最简单的方法是function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。\n- 提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使let进行的声明不会在块作用域中进行提升。\n### 作用域提升\n- 只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。\n```\nconsole.log(a)//undefined\nvar a = 1\n```\n- 函数声明会被提升，但是函数表达式却不会被提升。\n```\nf1()//1\nf2()//TypeError: f2 is not a function\nfunction f1() {\n    console.log(1)\n}\nvar f2 = function () {\n    console.log(2)\n}\n```\n- 即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中。\n```\nf1()//TypeError\nf2()//ReferenceError\nvar f1 = function f2() {\n}\n//可以理解为\n// var f1\n// f1()\n// f2()\n// f1 = function () {\n//     var f2 = ...self...\n// }\n```\n- 函数优先提升，一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。\n```\na()//1\nvar a = 1\nfunction a() {\n    console.log(1)\n}\n```\n- 尽管重复var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。\n```\na()//2\nfunction a() {\n    console.log(1)\n}\nfunction a() {\n    console.log(2)\n}\n```\n- 一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下的代码暗示的那样可以被条件判断所控制。**但是需要注意这个行为并不可靠，JavaScript未来的版本中有可能发生改变，因此应该尽可能避免在块内部声明函数。**\n```\na()//TypeError: a is not a function,**这个demo和书里面的就不一样了书里面说会log 2**\nvar b = true\nif(b){\n    function a() {\n        console.log(1)\n    }\n}else {\n    function a() {\n        console.log(2)\n    }\n}\n```\n### 闭包\n- 当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。\n- 模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。\n### this\n- 学this的第一步是明this既不指向函数自身也不指向函数的词法作用域，\n- this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。\n#### 调用位置\n- 调用位置就是函数在代码中被调用的位置（而不是声明的位置）。\n#### this绑定规则\n1. 默认规则\n- 独立函数调用，，函数调用时应用this的默认绑定，因this指向全局对象。\n- 严格模式下this为undefined\n2. 隐式绑定\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\nvar obj = {\n    data: 2,\n    fn: a\n}\na()//1\nobj.fn()//2\n```\n- 隐式丢失\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\nvar obj = {\n    data: 2,\n    fn: a\n}\nvar fn1 = obj.fn\nfn1()//1\nvar f2\n(f2 = obj.fn)()//2\n```\n3. 显示绑定\n- JavaScript提供的绝大多数函数以及你自己创建的所有函数都可以使call(..)apply(..)bind(...)方法。\n4. new绑定使\n- new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。\n- 1.创建（或者说构造）一个全新的对象。\n- 2.这个新对象会被执[[原]]连接。\n- 3.这个新对象会绑定到函数调用this。\n- 4.如果函数没有返回其他对象，那new表达式中的函数调用会自动返回这个新对象。\n#### 优先级\n- new > 显示 > 隐式 > 默认\n#### 被忽略的this\n- 如果你null或undefined作this的绑定对象传call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\na.apply(null)//1\n```\n- 更安全的this\n```\nfunction a() {\n    console.log(this.data)\n}\nvar data = 1\nvar ø = Object.create(null)\na.apply(ø)//1\n```\n#### 软绑定\n```\nif (!Function.prototype.softBind) {\n    Function.prototype.softBind = function (obj) {\n        var fn = this;\n        // 捕获所有 curried 参数\n        var curried = [].slice.call(arguments, 1);\n        var bound = function () {\n            return fn.apply(\n                (!this || this === (window || global)) ? obj : this,\n                curried.concat.apply(curried, arguments)\n            )\n        };\n        bound.prototype = Object.create(fn.prototype);\n        return bound;\n    };\n}\nvar data = 2\n\nfunction a() {\n    console.log(data)\n}\n\nvar b = a.softBind({data: 1})\na()//2\nb()//1\n```\n#### 箭头函数\n- 。箭头函数不使this的四种标准规则，而是根据外层（函数或者全局）作用域来决this。\n```\nfunction a() {\n    //返回箭头函数\n    return ()=>{\n        //this继承自a()\n        console.log(this.data)\n    }\n\n    //ES5的实现\n    // let self = this\n    // return function () {\n    //     console.log(self.data)\n    // }\n}\nlet b = a.call({data:1})\nb.call({data:2})//1\n```\n","slug":"你不知道的js学习笔记","published":1,"updated":"2019-01-02T12:21:49.447Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob7g002ke0jc7jusc2f9","content":"<h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3><ul>\n<li><p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。词法作用域意味着作用域是由书写代码时函数声明的位置来决定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let c = 2</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    let c = 1</span><br><span class=\"line\">    b()//2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function b() &#123;</span><br><span class=\"line\">    console.log(c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">b()//2</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在严格模式的程序中，eval(..)在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function c(str) &#123;</span><br><span class=\"line\">    eval(str)</span><br><span class=\"line\">    console.log(b)//1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">c(&apos;var b = 1&apos;)</span><br><span class=\"line\">function a(str) &#123;</span><br><span class=\"line\">    &apos;use strict&apos;</span><br><span class=\"line\">    eval(str)</span><br><span class=\"line\">    console.log(b)//ReferenceError</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(&apos;var b = 1&apos;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>setTimeout(..)和setInterval(..)的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。</p>\n</li>\n<li>with 使用注意<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1(obj) &#123;</span><br><span class=\"line\">    with (obj)&#123;</span><br><span class=\"line\">        a = 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var o1 = &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var o2 = &#123;</span><br><span class=\"line\">    b: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f1(o1)</span><br><span class=\"line\">f1(o2)</span><br><span class=\"line\">console.log(o1)//&#123;a:2&#125;</span><br><span class=\"line\">console.log(o2)//&#123;b:1&#125;</span><br><span class=\"line\">console.log(a)//2,因为o2中没有a，所以a被泄露到全局了</span><br><span class=\"line\">//o2的作用域、foo(..)的作用域和全局作用域中都没有找到标识符a，因此当a＝2执行时，自动创建了一个全局变量（因为是非严格模式）。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><ul>\n<li>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。</li>\n<li>区分函数声明和表达式最简单的方法是function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</li>\n<li>提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使let进行的声明不会在块作用域中进行提升。<h3 id=\"作用域提升\"><a href=\"#作用域提升\" class=\"headerlink\" title=\"作用域提升\"></a>作用域提升</h3></li>\n<li><p>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a)//undefined</span><br><span class=\"line\">var a = 1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数声明会被提升，但是函数表达式却不会被提升。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1()//1</span><br><span class=\"line\">f2()//TypeError: f2 is not a function</span><br><span class=\"line\">function f1() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var f2 = function () &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1()//TypeError</span><br><span class=\"line\">f2()//ReferenceError</span><br><span class=\"line\">var f1 = function f2() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//可以理解为</span><br><span class=\"line\">// var f1</span><br><span class=\"line\">// f1()</span><br><span class=\"line\">// f2()</span><br><span class=\"line\">// f1 = function () &#123;</span><br><span class=\"line\">//     var f2 = ...self...</span><br><span class=\"line\">// &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数优先提升，一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a()//1</span><br><span class=\"line\">var a = 1</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>尽管重复var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a()//2</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下的代码暗示的那样可以被条件判断所控制。<strong>但是需要注意这个行为并不可靠，JavaScript未来的版本中有可能发生改变，因此应该尽可能避免在块内部声明函数。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a()//TypeError: a is not a function,**这个demo和书里面的就不一样了书里面说会log 2**</span><br><span class=\"line\">var b = true</span><br><span class=\"line\">if(b)&#123;</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\">        console.log(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;else &#123;</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\">        console.log(2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><ul>\n<li>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</li>\n<li>模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h3></li>\n<li>学this的第一步是明this既不指向函数自身也不指向函数的词法作用域，</li>\n<li>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。<h4 id=\"调用位置\"><a href=\"#调用位置\" class=\"headerlink\" title=\"调用位置\"></a>调用位置</h4></li>\n<li>调用位置就是函数在代码中被调用的位置（而不是声明的位置）。<h4 id=\"this绑定规则\"><a href=\"#this绑定规则\" class=\"headerlink\" title=\"this绑定规则\"></a>this绑定规则</h4></li>\n</ul>\n<ol>\n<li>默认规则</li>\n</ol>\n<ul>\n<li>独立函数调用，，函数调用时应用this的默认绑定，因this指向全局对象。</li>\n<li>严格模式下this为undefined</li>\n</ul>\n<ol start=\"2\">\n<li>隐式绑定<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data = 1</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    data: 2,</span><br><span class=\"line\">    fn: a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()//1</span><br><span class=\"line\">obj.fn()//2</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>隐式丢失<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data = 1</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    data: 2,</span><br><span class=\"line\">    fn: a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var fn1 = obj.fn</span><br><span class=\"line\">fn1()//1</span><br><span class=\"line\">var f2</span><br><span class=\"line\">(f2 = obj.fn)()//2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"3\">\n<li>显示绑定</li>\n</ol>\n<ul>\n<li>JavaScript提供的绝大多数函数以及你自己创建的所有函数都可以使call(..)apply(..)bind(…)方法。</li>\n</ul>\n<ol start=\"4\">\n<li>new绑定使</li>\n</ol>\n<ul>\n<li>new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</li>\n<li>1.创建（或者说构造）一个全新的对象。</li>\n<li>2.这个新对象会被执[[原]]连接。</li>\n<li>3.这个新对象会绑定到函数调用this。</li>\n<li>4.如果函数没有返回其他对象，那new表达式中的函数调用会自动返回这个新对象。<h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4></li>\n<li>new &gt; 显示 &gt; 隐式 &gt; 默认<h4 id=\"被忽略的this\"><a href=\"#被忽略的this\" class=\"headerlink\" title=\"被忽略的this\"></a>被忽略的this</h4></li>\n<li><p>如果你null或undefined作this的绑定对象传call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data = 1</span><br><span class=\"line\">a.apply(null)//1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更安全的this</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data = 1</span><br><span class=\"line\">var ø = Object.create(null)</span><br><span class=\"line\">a.apply(ø)//1</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"软绑定\"><a href=\"#软绑定\" class=\"headerlink\" title=\"软绑定\"></a>软绑定</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!Function.prototype.softBind) &#123;</span><br><span class=\"line\">    Function.prototype.softBind = function (obj) &#123;</span><br><span class=\"line\">        var fn = this;</span><br><span class=\"line\">        // 捕获所有 curried 参数</span><br><span class=\"line\">        var curried = [].slice.call(arguments, 1);</span><br><span class=\"line\">        var bound = function () &#123;</span><br><span class=\"line\">            return fn.apply(</span><br><span class=\"line\">                (!this || this === (window || global)) ? obj : this,</span><br><span class=\"line\">                curried.concat.apply(curried, arguments)</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        bound.prototype = Object.create(fn.prototype);</span><br><span class=\"line\">        return bound;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data = 2</span><br><span class=\"line\"></span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = a.softBind(&#123;data: 1&#125;)</span><br><span class=\"line\">a()//2</span><br><span class=\"line\">b()//1</span><br></pre></td></tr></table></figure>\n<h4 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h4><ul>\n<li>。箭头函数不使this的四种标准规则，而是根据外层（函数或者全局）作用域来决this。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    //返回箭头函数</span><br><span class=\"line\">    return ()=&gt;&#123;</span><br><span class=\"line\">        //this继承自a()</span><br><span class=\"line\">        console.log(this.data)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //ES5的实现</span><br><span class=\"line\">    // let self = this</span><br><span class=\"line\">    // return function () &#123;</span><br><span class=\"line\">    //     console.log(self.data)</span><br><span class=\"line\">    // &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let b = a.call(&#123;data:1&#125;)</span><br><span class=\"line\">b.call(&#123;data:2&#125;)//1</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"词法作用域\"><a href=\"#词法作用域\" class=\"headerlink\" title=\"词法作用域\"></a>词法作用域</h3><ul>\n<li><p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。词法作用域意味着作用域是由书写代码时函数声明的位置来决定。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let c = 2</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    let c = 1</span><br><span class=\"line\">    b()//2</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function b() &#123;</span><br><span class=\"line\">    console.log(c)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">b()//2</span><br><span class=\"line\">a()</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>在严格模式的程序中，eval(..)在运行时有其自己的词法作用域，意味着其中的声明无法修改所在的作用域。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function c(str) &#123;</span><br><span class=\"line\">    eval(str)</span><br><span class=\"line\">    console.log(b)//1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">c(&apos;var b = 1&apos;)</span><br><span class=\"line\">function a(str) &#123;</span><br><span class=\"line\">    &apos;use strict&apos;</span><br><span class=\"line\">    eval(str)</span><br><span class=\"line\">    console.log(b)//ReferenceError</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a(&apos;var b = 1&apos;)</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>setTimeout(..)和setInterval(..)的第一个参数可以是字符串，字符串的内容可以被解释为一段动态生成的函数代码。</p>\n</li>\n<li>with 使用注意<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function f1(obj) &#123;</span><br><span class=\"line\">    with (obj)&#123;</span><br><span class=\"line\">        a = 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var o1 = &#123;</span><br><span class=\"line\">    a: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var o2 = &#123;</span><br><span class=\"line\">    b: 1</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">f1(o1)</span><br><span class=\"line\">f1(o2)</span><br><span class=\"line\">console.log(o1)//&#123;a:2&#125;</span><br><span class=\"line\">console.log(o2)//&#123;b:1&#125;</span><br><span class=\"line\">console.log(a)//2,因为o2中没有a，所以a被泄露到全局了</span><br><span class=\"line\">//o2的作用域、foo(..)的作用域和全局作用域中都没有找到标识符a，因此当a＝2执行时，自动创建了一个全局变量（因为是非严格模式）。</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h3><ul>\n<li>函数作用域的含义是指，属于这个函数的全部变量都可以在整个函数的范围内使用及复用（事实上在嵌套的作用域中也可以使用）。</li>\n<li>区分函数声明和表达式最简单的方法是function关键字出现在声明中的位置（不仅仅是一行代码，而是整个声明中的位置）。如function是声明中的第一个词，那么就是一个函数声明，否则就是一个函数表达式。</li>\n<li>提升是指声明会被视为存在于其所出现的作用域的整个范围内。但是使let进行的声明不会在块作用域中进行提升。<h3 id=\"作用域提升\"><a href=\"#作用域提升\" class=\"headerlink\" title=\"作用域提升\"></a>作用域提升</h3></li>\n<li><p>只有声明本身会被提升，而赋值或其他运行逻辑会留在原地。如果提升改变了代码执行的顺序，会造成非常严重的破坏。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">console.log(a)//undefined</span><br><span class=\"line\">var a = 1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数声明会被提升，但是函数表达式却不会被提升。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1()//1</span><br><span class=\"line\">f2()//TypeError: f2 is not a function</span><br><span class=\"line\">function f1() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var f2 = function () &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>即使是具名的函数表达式，名称标识符在赋值之前也无法在所在作用域中。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1()//TypeError</span><br><span class=\"line\">f2()//ReferenceError</span><br><span class=\"line\">var f1 = function f2() &#123;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//可以理解为</span><br><span class=\"line\">// var f1</span><br><span class=\"line\">// f1()</span><br><span class=\"line\">// f2()</span><br><span class=\"line\">// f1 = function () &#123;</span><br><span class=\"line\">//     var f2 = ...self...</span><br><span class=\"line\">// &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>函数优先提升，一个值得注意的细节（这个细节可以出现在有多个“重复”声明的代码中）是函数会首先被提升，然后才是变量。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a()//1</span><br><span class=\"line\">var a = 1</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>尽管重复var声明会被忽略掉，但出现在后面的函数声明还是可以覆盖前面的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a()//2</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(1)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(2)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下的代码暗示的那样可以被条件判断所控制。<strong>但是需要注意这个行为并不可靠，JavaScript未来的版本中有可能发生改变，因此应该尽可能避免在块内部声明函数。</strong></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a()//TypeError: a is not a function,**这个demo和书里面的就不一样了书里面说会log 2**</span><br><span class=\"line\">var b = true</span><br><span class=\"line\">if(b)&#123;</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\">        console.log(1)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;else &#123;</span><br><span class=\"line\">    function a() &#123;</span><br><span class=\"line\">        console.log(2)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h3 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h3><ul>\n<li>当函数可以记住并访问所在的词法作用域，即使函数是在当前词法作用域之外执行，这时就产生了闭包。</li>\n<li>模块有两个主要特征：（1）为创建内部作用域而调用了一个包装函数；（2）包装函数的返回值必须至少包括一个对内部函数的引用，这样就会创建涵盖整个包装函数内部作用域的闭包。<h3 id=\"this\"><a href=\"#this\" class=\"headerlink\" title=\"this\"></a>this</h3></li>\n<li>学this的第一步是明this既不指向函数自身也不指向函数的词法作用域，</li>\n<li>this实际上是在函数被调用时发生的绑定，它指向什么完全取决于函数在哪里被调用。<h4 id=\"调用位置\"><a href=\"#调用位置\" class=\"headerlink\" title=\"调用位置\"></a>调用位置</h4></li>\n<li>调用位置就是函数在代码中被调用的位置（而不是声明的位置）。<h4 id=\"this绑定规则\"><a href=\"#this绑定规则\" class=\"headerlink\" title=\"this绑定规则\"></a>this绑定规则</h4></li>\n</ul>\n<ol>\n<li>默认规则</li>\n</ol>\n<ul>\n<li>独立函数调用，，函数调用时应用this的默认绑定，因this指向全局对象。</li>\n<li>严格模式下this为undefined</li>\n</ul>\n<ol start=\"2\">\n<li>隐式绑定<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data = 1</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    data: 2,</span><br><span class=\"line\">    fn: a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a()//1</span><br><span class=\"line\">obj.fn()//2</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>隐式丢失<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data = 1</span><br><span class=\"line\">var obj = &#123;</span><br><span class=\"line\">    data: 2,</span><br><span class=\"line\">    fn: a</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var fn1 = obj.fn</span><br><span class=\"line\">fn1()//1</span><br><span class=\"line\">var f2</span><br><span class=\"line\">(f2 = obj.fn)()//2</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<ol start=\"3\">\n<li>显示绑定</li>\n</ol>\n<ul>\n<li>JavaScript提供的绝大多数函数以及你自己创建的所有函数都可以使call(..)apply(..)bind(…)方法。</li>\n</ul>\n<ol start=\"4\">\n<li>new绑定使</li>\n</ol>\n<ul>\n<li>new来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。</li>\n<li>1.创建（或者说构造）一个全新的对象。</li>\n<li>2.这个新对象会被执[[原]]连接。</li>\n<li>3.这个新对象会绑定到函数调用this。</li>\n<li>4.如果函数没有返回其他对象，那new表达式中的函数调用会自动返回这个新对象。<h4 id=\"优先级\"><a href=\"#优先级\" class=\"headerlink\" title=\"优先级\"></a>优先级</h4></li>\n<li>new &gt; 显示 &gt; 隐式 &gt; 默认<h4 id=\"被忽略的this\"><a href=\"#被忽略的this\" class=\"headerlink\" title=\"被忽略的this\"></a>被忽略的this</h4></li>\n<li><p>如果你null或undefined作this的绑定对象传call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data = 1</span><br><span class=\"line\">a.apply(null)//1</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>更安全的this</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(this.data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data = 1</span><br><span class=\"line\">var ø = Object.create(null)</span><br><span class=\"line\">a.apply(ø)//1</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"软绑定\"><a href=\"#软绑定\" class=\"headerlink\" title=\"软绑定\"></a>软绑定</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">if (!Function.prototype.softBind) &#123;</span><br><span class=\"line\">    Function.prototype.softBind = function (obj) &#123;</span><br><span class=\"line\">        var fn = this;</span><br><span class=\"line\">        // 捕获所有 curried 参数</span><br><span class=\"line\">        var curried = [].slice.call(arguments, 1);</span><br><span class=\"line\">        var bound = function () &#123;</span><br><span class=\"line\">            return fn.apply(</span><br><span class=\"line\">                (!this || this === (window || global)) ? obj : this,</span><br><span class=\"line\">                curried.concat.apply(curried, arguments)</span><br><span class=\"line\">            )</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        bound.prototype = Object.create(fn.prototype);</span><br><span class=\"line\">        return bound;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">var data = 2</span><br><span class=\"line\"></span><br><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    console.log(data)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">var b = a.softBind(&#123;data: 1&#125;)</span><br><span class=\"line\">a()//2</span><br><span class=\"line\">b()//1</span><br></pre></td></tr></table></figure>\n<h4 id=\"箭头函数\"><a href=\"#箭头函数\" class=\"headerlink\" title=\"箭头函数\"></a>箭头函数</h4><ul>\n<li>。箭头函数不使this的四种标准规则，而是根据外层（函数或者全局）作用域来决this。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function a() &#123;</span><br><span class=\"line\">    //返回箭头函数</span><br><span class=\"line\">    return ()=&gt;&#123;</span><br><span class=\"line\">        //this继承自a()</span><br><span class=\"line\">        console.log(this.data)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    //ES5的实现</span><br><span class=\"line\">    // let self = this</span><br><span class=\"line\">    // return function () &#123;</span><br><span class=\"line\">    //     console.log(self.data)</span><br><span class=\"line\">    // &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let b = a.call(&#123;data:1&#125;)</span><br><span class=\"line\">b.call(&#123;data:2&#125;)//1</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n"},{"title":"创建Hexo+github博客流程","date":"2018-08-20T01:45:53.000Z","_content":"\nHEXO快速、简单且功能强大的 Node.js 博客框架。\nhttps://hexo.io/zh-cn/\n## 安装\n1.全局安装git以及nodeJs\n2.全局安装hexo\n```\nnpm install -g hexo\n```\n3.新建项目文件夹\n```\nmkdir hexo-project\n```\n4.进入项目文件夹，初始化hexo\n```\ncd hexo-project\nhexo init\n```\n5.安装依赖\n```\nnpm install\n```\n6.启动服务\n```\nhexo server || hexo s\n```\n访问 http://127.0.0.1:4000/\n\n7.此时可以在本地访问服务，下面进行提交代码到git的步骤，首先在 github (https://github.com/) 上创建项目，注意项目名字有格式要求必须为：[github用户名].github.io，否则不能使用，参考：https://github.com/crazyaguai/crazyaguai.github.io 名称。\n\n8.安装hexo-deployer-git提交代码到git用，在项目中执行\n```\nnpm install hexo-deployer-git --save\n```\n9.配置根路径_config.yml文件\n```\ndeploy:\n  type: git\n  repo: https://github.com/crazyaguai/crazyaguai.github.io(你的项目地址)\n  branch: master\n```\n10.配置完成就可以将Hexo博客提交代码到github上了，执行\n```\nhexo clean && hexo generate && hexo deploy || hexo c && hexo g && hexo d\n```\n11.打开你的github hexo项目地址查看，例如 https://crazyaguai.github.io/\n\n\n\n\n## 目录结构\n- _config.yml：全局配置文件\n- package.json：依赖\n- scaffolds：文章脚手架，根据文件夹下的配置构建文章\n- source：新建文章保存在这个文件夹下，在此修改文章\n- themes：主题目录\n\n\n\n\n## _config.yml文件配置\n### 根路径_config.yml配置\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n# Site 这里的配置，哪项配置反映在哪里，可以参考我的博客\ntitle:  #站点名，站点左上角\nsubtitle:  #副标题，站点左上角\ndescription:  #给搜索引擎看的，对站点的描述，可以自定义\nauthor:  #默认在站点左下角可以看到\nemail: #邮箱\nlanguage: zh-CN #语言包设置。\n# URL #访问地址等信息设置，可根据需要自己修改。\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: #访问域名\nroot: /\npermalink: :year/:month/:day/:title/ #具体内容页的存储路径结构\ntag_dir: tags #标签目录名\narchive_dir: archives #归档目录名\ncategory_dir: categories #分类目录名\n# Directory #默认文章和生成目录设置\nsource_dir: source\npublic_dir: public\n# Writing 文章布局、写作格式的定义\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\nauto_spacing: false # Add spaces between asian characters and western characters\ntitlecase: false # Transform title into titlecase\nmax_open_file: 100\nfilename_case: 0\nhighlight:\n  enable: true\n  backtick_code_block: true\n  line_number: true\n  tab_replace:\n# Category & Tag 分类和标签设置\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n# Archives 默认值为2，如果这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n# Server 本地预览服务信息，默认端口是4000，有需要的话可以自己修改\n## Hexo uses Connect as a server\n## You can customize the logger format as defined in\n## http://www.senchalabs.org/connect/logger.html\nport: 4000\nlogger: false\nlogger_format:\n# Date / Time format 日期格式\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: MMM D YYYY\ntime_format: H:mm:ss\n# Pagination 每页显示文章数，可以自定义\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page\n# Disqus Disqus 插件，我们会替换成“多说”\ndisqus_shortname:\n# Extensions 这里配置站点所用主题和插件\n## Plugins: https://github.com/hexojs/hexo/wiki/Plugins\n## Themes: https://github.com/hexojs/hexo/wiki/Themes\ntheme: light\nexclude_generator:\n# Deployment 站点部署到github要配置\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: github\n  repository:\n  branch: master\n```\n\n### 主题_config.yml配置\n```\nmenu: #右上角导航菜单，冒号前面是菜单名，后面是访问路径。\n  Home: /\n  Archives: /archives\n  About: /about\n\nwidgets: #站点右边栏，可以调整顺序和增减内容，会自动调用主题layout/_widget目录下的同名文件。\n- search\n- category\n- tagcloud\nexcerpt_link: Read More #列表页里Read more链接名称，可以替换成’查看更多‘等。\nplugins:\ntwitter: #右边栏要显示twitter展示的话，需要在此设置\n  username:\n  show_replies: false\n  tweet_count: 5\naddthis: #分享设置\n  enable: true\n  pubid:\n  facebook: true\n  twitter: true\n  google: true\n  pinterest: true\nfancybox: true #图片效果，默认\ngoogle_analytics: #google_analytics统计ID\nrss:  #生成RSS路径\n```\n\n## 常用命令\n- hexo new \"postName\" #新建文章\n- hexo new page \"pageName\" #新建页面\n- hexo clean #清除缓存\n- hexo generate #生成静态页面至public目录\n- hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n- hexo deploy #将.deploy目录部署到GitHub\n### 命令简写\n- hexo n \"我的博客\" == hexo new \"我的博客\" #新建文章\n- hexo p == hexo publish\n- hexo g == hexo generate#生成\n- hexo s == hexo server #启动服务预览\n- hexo d == hexo deploy#部署\n\n\n## Hexo主题相关\n参考：http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/\n\n\n## 添加搜索\n参考：https://www.jianshu.com/p/2010ad07d960\n\n\n## 分类和标签设置\n参考：http://ijiaober.github.io/2014/08/05/hexo/hexo-04/、\nhttps://www.jianshu.com/p/3d2e7b3ec182\n\n\n","source":"_posts/创建Hexo-github博客流程.md","raw":"---\ntitle: 创建Hexo+github博客流程\ndate: 2018-08-20 09:45:53\ntags: [hexo]\ncategories: hexo\n---\n\nHEXO快速、简单且功能强大的 Node.js 博客框架。\nhttps://hexo.io/zh-cn/\n## 安装\n1.全局安装git以及nodeJs\n2.全局安装hexo\n```\nnpm install -g hexo\n```\n3.新建项目文件夹\n```\nmkdir hexo-project\n```\n4.进入项目文件夹，初始化hexo\n```\ncd hexo-project\nhexo init\n```\n5.安装依赖\n```\nnpm install\n```\n6.启动服务\n```\nhexo server || hexo s\n```\n访问 http://127.0.0.1:4000/\n\n7.此时可以在本地访问服务，下面进行提交代码到git的步骤，首先在 github (https://github.com/) 上创建项目，注意项目名字有格式要求必须为：[github用户名].github.io，否则不能使用，参考：https://github.com/crazyaguai/crazyaguai.github.io 名称。\n\n8.安装hexo-deployer-git提交代码到git用，在项目中执行\n```\nnpm install hexo-deployer-git --save\n```\n9.配置根路径_config.yml文件\n```\ndeploy:\n  type: git\n  repo: https://github.com/crazyaguai/crazyaguai.github.io(你的项目地址)\n  branch: master\n```\n10.配置完成就可以将Hexo博客提交代码到github上了，执行\n```\nhexo clean && hexo generate && hexo deploy || hexo c && hexo g && hexo d\n```\n11.打开你的github hexo项目地址查看，例如 https://crazyaguai.github.io/\n\n\n\n\n## 目录结构\n- _config.yml：全局配置文件\n- package.json：依赖\n- scaffolds：文章脚手架，根据文件夹下的配置构建文章\n- source：新建文章保存在这个文件夹下，在此修改文章\n- themes：主题目录\n\n\n\n\n## _config.yml文件配置\n### 根路径_config.yml配置\n```\n# Hexo Configuration\n## Docs: http://hexo.io/docs/configuration.html\n## Source: https://github.com/hexojs/hexo/\n# Site 这里的配置，哪项配置反映在哪里，可以参考我的博客\ntitle:  #站点名，站点左上角\nsubtitle:  #副标题，站点左上角\ndescription:  #给搜索引擎看的，对站点的描述，可以自定义\nauthor:  #默认在站点左下角可以看到\nemail: #邮箱\nlanguage: zh-CN #语言包设置。\n# URL #访问地址等信息设置，可根据需要自己修改。\n## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'\nurl: #访问域名\nroot: /\npermalink: :year/:month/:day/:title/ #具体内容页的存储路径结构\ntag_dir: tags #标签目录名\narchive_dir: archives #归档目录名\ncategory_dir: categories #分类目录名\n# Directory #默认文章和生成目录设置\nsource_dir: source\npublic_dir: public\n# Writing 文章布局、写作格式的定义\nnew_post_name: :title.md # File name of new posts\ndefault_layout: post\nauto_spacing: false # Add spaces between asian characters and western characters\ntitlecase: false # Transform title into titlecase\nmax_open_file: 100\nfilename_case: 0\nhighlight:\n  enable: true\n  backtick_code_block: true\n  line_number: true\n  tab_replace:\n# Category & Tag 分类和标签设置\ndefault_category: uncategorized\ncategory_map:\ntag_map:\n# Archives 默认值为2，如果这里都修改为1，相应页面就只会列出标题，而非全文\n## 2: Enable pagination\n## 1: Disable pagination\n## 0: Fully Disable\narchive: 1\ncategory: 1\ntag: 1\n# Server 本地预览服务信息，默认端口是4000，有需要的话可以自己修改\n## Hexo uses Connect as a server\n## You can customize the logger format as defined in\n## http://www.senchalabs.org/connect/logger.html\nport: 4000\nlogger: false\nlogger_format:\n# Date / Time format 日期格式\n## Hexo uses Moment.js to parse and display date\n## You can customize the date format as defined in\n## http://momentjs.com/docs/#/displaying/format/\ndate_format: MMM D YYYY\ntime_format: H:mm:ss\n# Pagination 每页显示文章数，可以自定义\n## Set per_page to 0 to disable pagination\nper_page: 5\npagination_dir: page\n# Disqus Disqus 插件，我们会替换成“多说”\ndisqus_shortname:\n# Extensions 这里配置站点所用主题和插件\n## Plugins: https://github.com/hexojs/hexo/wiki/Plugins\n## Themes: https://github.com/hexojs/hexo/wiki/Themes\ntheme: light\nexclude_generator:\n# Deployment 站点部署到github要配置\n## Docs: http://hexo.io/docs/deployment.html\ndeploy:\n  type: github\n  repository:\n  branch: master\n```\n\n### 主题_config.yml配置\n```\nmenu: #右上角导航菜单，冒号前面是菜单名，后面是访问路径。\n  Home: /\n  Archives: /archives\n  About: /about\n\nwidgets: #站点右边栏，可以调整顺序和增减内容，会自动调用主题layout/_widget目录下的同名文件。\n- search\n- category\n- tagcloud\nexcerpt_link: Read More #列表页里Read more链接名称，可以替换成’查看更多‘等。\nplugins:\ntwitter: #右边栏要显示twitter展示的话，需要在此设置\n  username:\n  show_replies: false\n  tweet_count: 5\naddthis: #分享设置\n  enable: true\n  pubid:\n  facebook: true\n  twitter: true\n  google: true\n  pinterest: true\nfancybox: true #图片效果，默认\ngoogle_analytics: #google_analytics统计ID\nrss:  #生成RSS路径\n```\n\n## 常用命令\n- hexo new \"postName\" #新建文章\n- hexo new page \"pageName\" #新建页面\n- hexo clean #清除缓存\n- hexo generate #生成静态页面至public目录\n- hexo server #开启预览访问端口（默认端口4000，'ctrl + c'关闭server）\n- hexo deploy #将.deploy目录部署到GitHub\n### 命令简写\n- hexo n \"我的博客\" == hexo new \"我的博客\" #新建文章\n- hexo p == hexo publish\n- hexo g == hexo generate#生成\n- hexo s == hexo server #启动服务预览\n- hexo d == hexo deploy#部署\n\n\n## Hexo主题相关\n参考：http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/\n\n\n## 添加搜索\n参考：https://www.jianshu.com/p/2010ad07d960\n\n\n## 分类和标签设置\n参考：http://ijiaober.github.io/2014/08/05/hexo/hexo-04/、\nhttps://www.jianshu.com/p/3d2e7b3ec182\n\n\n","slug":"创建Hexo-github博客流程","published":1,"updated":"2018-08-20T23:55:19.214Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob7h002ne0jch85dnx6j","content":"<p>HEXO快速、简单且功能强大的 Node.js 博客框架。<br><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>1.全局安装git以及nodeJs<br>2.全局安装hexo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo</span><br></pre></td></tr></table></figure></p>\n<p>3.新建项目文件夹<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir hexo-project</span><br></pre></td></tr></table></figure></p>\n<p>4.进入项目文件夹，初始化hexo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo-project</span><br><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure></p>\n<p>5.安装依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure></p>\n<p>6.启动服务<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server || hexo s</span><br></pre></td></tr></table></figure></p>\n<p>访问 <a href=\"http://127.0.0.1:4000/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:4000/</a></p>\n<p>7.此时可以在本地访问服务，下面进行提交代码到git的步骤，首先在 github (<a href=\"https://github.com/\">https://github.com/</a>) 上创建项目，注意项目名字有格式要求必须为：[github用户名].github.io，否则不能使用，参考：<a href=\"https://github.com/crazyaguai/crazyaguai.github.io\">https://github.com/crazyaguai/crazyaguai.github.io</a> 名称。</p>\n<p>8.安装hexo-deployer-git提交代码到git用，在项目中执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>9.配置根路径_config.yml文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/crazyaguai/crazyaguai.github.io(你的项目地址)</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></p>\n<p>10.配置完成就可以将Hexo博客提交代码到github上了，执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy || hexo c &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></p>\n<p>11.打开你的github hexo项目地址查看，例如 <a href=\"https://crazyaguai.github.io/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/</a></p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><ul>\n<li>_config.yml：全局配置文件</li>\n<li>package.json：依赖</li>\n<li>scaffolds：文章脚手架，根据文件夹下的配置构建文章</li>\n<li>source：新建文章保存在这个文件夹下，在此修改文章</li>\n<li>themes：主题目录</li>\n</ul>\n<h2 id=\"config-yml文件配置\"><a href=\"#config-yml文件配置\" class=\"headerlink\" title=\"_config.yml文件配置\"></a>_config.yml文件配置</h2><h3 id=\"根路径-config-yml配置\"><a href=\"#根路径-config-yml配置\" class=\"headerlink\" title=\"根路径_config.yml配置\"></a>根路径_config.yml配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Hexo Configuration</span><br><span class=\"line\">## Docs: http://hexo.io/docs/configuration.html</span><br><span class=\"line\">## Source: https://github.com/hexojs/hexo/</span><br><span class=\"line\"># Site 这里的配置，哪项配置反映在哪里，可以参考我的博客</span><br><span class=\"line\">title:  #站点名，站点左上角</span><br><span class=\"line\">subtitle:  #副标题，站点左上角</span><br><span class=\"line\">description:  #给搜索引擎看的，对站点的描述，可以自定义</span><br><span class=\"line\">author:  #默认在站点左下角可以看到</span><br><span class=\"line\">email: #邮箱</span><br><span class=\"line\">language: zh-CN #语言包设置。</span><br><span class=\"line\"># URL #访问地址等信息设置，可根据需要自己修改。</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class=\"line\">url: #访问域名</span><br><span class=\"line\">root: /</span><br><span class=\"line\">permalink: :year/:month/:day/:title/ #具体内容页的存储路径结构</span><br><span class=\"line\">tag_dir: tags #标签目录名</span><br><span class=\"line\">archive_dir: archives #归档目录名</span><br><span class=\"line\">category_dir: categories #分类目录名</span><br><span class=\"line\"># Directory #默认文章和生成目录设置</span><br><span class=\"line\">source_dir: source</span><br><span class=\"line\">public_dir: public</span><br><span class=\"line\"># Writing 文章布局、写作格式的定义</span><br><span class=\"line\">new_post_name: :title.md # File name of new posts</span><br><span class=\"line\">default_layout: post</span><br><span class=\"line\">auto_spacing: false # Add spaces between asian characters and western characters</span><br><span class=\"line\">titlecase: false # Transform title into titlecase</span><br><span class=\"line\">max_open_file: 100</span><br><span class=\"line\">filename_case: 0</span><br><span class=\"line\">highlight:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  backtick_code_block: true</span><br><span class=\"line\">  line_number: true</span><br><span class=\"line\">  tab_replace:</span><br><span class=\"line\"># Category &amp; Tag 分类和标签设置</span><br><span class=\"line\">default_category: uncategorized</span><br><span class=\"line\">category_map:</span><br><span class=\"line\">tag_map:</span><br><span class=\"line\"># Archives 默认值为2，如果这里都修改为1，相应页面就只会列出标题，而非全文</span><br><span class=\"line\">## 2: Enable pagination</span><br><span class=\"line\">## 1: Disable pagination</span><br><span class=\"line\">## 0: Fully Disable</span><br><span class=\"line\">archive: 1</span><br><span class=\"line\">category: 1</span><br><span class=\"line\">tag: 1</span><br><span class=\"line\"># Server 本地预览服务信息，默认端口是4000，有需要的话可以自己修改</span><br><span class=\"line\">## Hexo uses Connect as a server</span><br><span class=\"line\">## You can customize the logger format as defined in</span><br><span class=\"line\">## http://www.senchalabs.org/connect/logger.html</span><br><span class=\"line\">port: 4000</span><br><span class=\"line\">logger: false</span><br><span class=\"line\">logger_format:</span><br><span class=\"line\"># Date / Time format 日期格式</span><br><span class=\"line\">## Hexo uses Moment.js to parse and display date</span><br><span class=\"line\">## You can customize the date format as defined in</span><br><span class=\"line\">## http://momentjs.com/docs/#/displaying/format/</span><br><span class=\"line\">date_format: MMM D YYYY</span><br><span class=\"line\">time_format: H:mm:ss</span><br><span class=\"line\"># Pagination 每页显示文章数，可以自定义</span><br><span class=\"line\">## Set per_page to 0 to disable pagination</span><br><span class=\"line\">per_page: 5</span><br><span class=\"line\">pagination_dir: page</span><br><span class=\"line\"># Disqus Disqus 插件，我们会替换成“多说”</span><br><span class=\"line\">disqus_shortname:</span><br><span class=\"line\"># Extensions 这里配置站点所用主题和插件</span><br><span class=\"line\">## Plugins: https://github.com/hexojs/hexo/wiki/Plugins</span><br><span class=\"line\">## Themes: https://github.com/hexojs/hexo/wiki/Themes</span><br><span class=\"line\">theme: light</span><br><span class=\"line\">exclude_generator:</span><br><span class=\"line\"># Deployment 站点部署到github要配置</span><br><span class=\"line\">## Docs: http://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: github</span><br><span class=\"line\">  repository:</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<h3 id=\"主题-config-yml配置\"><a href=\"#主题-config-yml配置\" class=\"headerlink\" title=\"主题_config.yml配置\"></a>主题_config.yml配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu: #右上角导航菜单，冒号前面是菜单名，后面是访问路径。</span><br><span class=\"line\">  Home: /</span><br><span class=\"line\">  Archives: /archives</span><br><span class=\"line\">  About: /about</span><br><span class=\"line\"></span><br><span class=\"line\">widgets: #站点右边栏，可以调整顺序和增减内容，会自动调用主题layout/_widget目录下的同名文件。</span><br><span class=\"line\">- search</span><br><span class=\"line\">- category</span><br><span class=\"line\">- tagcloud</span><br><span class=\"line\">excerpt_link: Read More #列表页里Read more链接名称，可以替换成’查看更多‘等。</span><br><span class=\"line\">plugins:</span><br><span class=\"line\">twitter: #右边栏要显示twitter展示的话，需要在此设置</span><br><span class=\"line\">  username:</span><br><span class=\"line\">  show_replies: false</span><br><span class=\"line\">  tweet_count: 5</span><br><span class=\"line\">addthis: #分享设置</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  pubid:</span><br><span class=\"line\">  facebook: true</span><br><span class=\"line\">  twitter: true</span><br><span class=\"line\">  google: true</span><br><span class=\"line\">  pinterest: true</span><br><span class=\"line\">fancybox: true #图片效果，默认</span><br><span class=\"line\">google_analytics: #google_analytics统计ID</span><br><span class=\"line\">rss:  #生成RSS路径</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><ul>\n<li>hexo new “postName” #新建文章</li>\n<li>hexo new page “pageName” #新建页面</li>\n<li>hexo clean #清除缓存</li>\n<li>hexo generate #生成静态页面至public目录</li>\n<li>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</li>\n<li>hexo deploy #将.deploy目录部署到GitHub<h3 id=\"命令简写\"><a href=\"#命令简写\" class=\"headerlink\" title=\"命令简写\"></a>命令简写</h3></li>\n<li>hexo n “我的博客” == hexo new “我的博客” #新建文章</li>\n<li>hexo p == hexo publish</li>\n<li>hexo g == hexo generate#生成</li>\n<li>hexo s == hexo server #启动服务预览</li>\n<li>hexo d == hexo deploy#部署</li>\n</ul>\n<h2 id=\"Hexo主题相关\"><a href=\"#Hexo主题相关\" class=\"headerlink\" title=\"Hexo主题相关\"></a>Hexo主题相关</h2><p>参考：<a href=\"http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/\" target=\"_blank\" rel=\"noopener\">http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/</a></p>\n<h2 id=\"添加搜索\"><a href=\"#添加搜索\" class=\"headerlink\" title=\"添加搜索\"></a>添加搜索</h2><p>参考：<a href=\"https://www.jianshu.com/p/2010ad07d960\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/2010ad07d960</a></p>\n<h2 id=\"分类和标签设置\"><a href=\"#分类和标签设置\" class=\"headerlink\" title=\"分类和标签设置\"></a>分类和标签设置</h2><p>参考：<a href=\"http://ijiaober.github.io/2014/08/05/hexo/hexo-04/、\" target=\"_blank\" rel=\"noopener\">http://ijiaober.github.io/2014/08/05/hexo/hexo-04/、</a><br><a href=\"https://www.jianshu.com/p/3d2e7b3ec182\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/3d2e7b3ec182</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>HEXO快速、简单且功能强大的 Node.js 博客框架。<br><a href=\"https://hexo.io/zh-cn/\" target=\"_blank\" rel=\"noopener\">https://hexo.io/zh-cn/</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>1.全局安装git以及nodeJs<br>2.全局安装hexo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install -g hexo</span><br></pre></td></tr></table></figure></p>\n<p>3.新建项目文件夹<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir hexo-project</span><br></pre></td></tr></table></figure></p>\n<p>4.进入项目文件夹，初始化hexo<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd hexo-project</span><br><span class=\"line\">hexo init</span><br></pre></td></tr></table></figure></p>\n<p>5.安装依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install</span><br></pre></td></tr></table></figure></p>\n<p>6.启动服务<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo server || hexo s</span><br></pre></td></tr></table></figure></p>\n<p>访问 <a href=\"http://127.0.0.1:4000/\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:4000/</a></p>\n<p>7.此时可以在本地访问服务，下面进行提交代码到git的步骤，首先在 github (<a href=\"https://github.com/\">https://github.com/</a>) 上创建项目，注意项目名字有格式要求必须为：[github用户名].github.io，否则不能使用，参考：<a href=\"https://github.com/crazyaguai/crazyaguai.github.io\">https://github.com/crazyaguai/crazyaguai.github.io</a> 名称。</p>\n<p>8.安装hexo-deployer-git提交代码到git用，在项目中执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></p>\n<p>9.配置根路径_config.yml文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  type: git</span><br><span class=\"line\">  repo: https://github.com/crazyaguai/crazyaguai.github.io(你的项目地址)</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure></p>\n<p>10.配置完成就可以将Hexo博客提交代码到github上了，执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy || hexo c &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure></p>\n<p>11.打开你的github hexo项目地址查看，例如 <a href=\"https://crazyaguai.github.io/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/</a></p>\n<h2 id=\"目录结构\"><a href=\"#目录结构\" class=\"headerlink\" title=\"目录结构\"></a>目录结构</h2><ul>\n<li>_config.yml：全局配置文件</li>\n<li>package.json：依赖</li>\n<li>scaffolds：文章脚手架，根据文件夹下的配置构建文章</li>\n<li>source：新建文章保存在这个文件夹下，在此修改文章</li>\n<li>themes：主题目录</li>\n</ul>\n<h2 id=\"config-yml文件配置\"><a href=\"#config-yml文件配置\" class=\"headerlink\" title=\"_config.yml文件配置\"></a>_config.yml文件配置</h2><h3 id=\"根路径-config-yml配置\"><a href=\"#根路径-config-yml配置\" class=\"headerlink\" title=\"根路径_config.yml配置\"></a>根路径_config.yml配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># Hexo Configuration</span><br><span class=\"line\">## Docs: http://hexo.io/docs/configuration.html</span><br><span class=\"line\">## Source: https://github.com/hexojs/hexo/</span><br><span class=\"line\"># Site 这里的配置，哪项配置反映在哪里，可以参考我的博客</span><br><span class=\"line\">title:  #站点名，站点左上角</span><br><span class=\"line\">subtitle:  #副标题，站点左上角</span><br><span class=\"line\">description:  #给搜索引擎看的，对站点的描述，可以自定义</span><br><span class=\"line\">author:  #默认在站点左下角可以看到</span><br><span class=\"line\">email: #邮箱</span><br><span class=\"line\">language: zh-CN #语言包设置。</span><br><span class=\"line\"># URL #访问地址等信息设置，可根据需要自己修改。</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;</span><br><span class=\"line\">url: #访问域名</span><br><span class=\"line\">root: /</span><br><span class=\"line\">permalink: :year/:month/:day/:title/ #具体内容页的存储路径结构</span><br><span class=\"line\">tag_dir: tags #标签目录名</span><br><span class=\"line\">archive_dir: archives #归档目录名</span><br><span class=\"line\">category_dir: categories #分类目录名</span><br><span class=\"line\"># Directory #默认文章和生成目录设置</span><br><span class=\"line\">source_dir: source</span><br><span class=\"line\">public_dir: public</span><br><span class=\"line\"># Writing 文章布局、写作格式的定义</span><br><span class=\"line\">new_post_name: :title.md # File name of new posts</span><br><span class=\"line\">default_layout: post</span><br><span class=\"line\">auto_spacing: false # Add spaces between asian characters and western characters</span><br><span class=\"line\">titlecase: false # Transform title into titlecase</span><br><span class=\"line\">max_open_file: 100</span><br><span class=\"line\">filename_case: 0</span><br><span class=\"line\">highlight:</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  backtick_code_block: true</span><br><span class=\"line\">  line_number: true</span><br><span class=\"line\">  tab_replace:</span><br><span class=\"line\"># Category &amp; Tag 分类和标签设置</span><br><span class=\"line\">default_category: uncategorized</span><br><span class=\"line\">category_map:</span><br><span class=\"line\">tag_map:</span><br><span class=\"line\"># Archives 默认值为2，如果这里都修改为1，相应页面就只会列出标题，而非全文</span><br><span class=\"line\">## 2: Enable pagination</span><br><span class=\"line\">## 1: Disable pagination</span><br><span class=\"line\">## 0: Fully Disable</span><br><span class=\"line\">archive: 1</span><br><span class=\"line\">category: 1</span><br><span class=\"line\">tag: 1</span><br><span class=\"line\"># Server 本地预览服务信息，默认端口是4000，有需要的话可以自己修改</span><br><span class=\"line\">## Hexo uses Connect as a server</span><br><span class=\"line\">## You can customize the logger format as defined in</span><br><span class=\"line\">## http://www.senchalabs.org/connect/logger.html</span><br><span class=\"line\">port: 4000</span><br><span class=\"line\">logger: false</span><br><span class=\"line\">logger_format:</span><br><span class=\"line\"># Date / Time format 日期格式</span><br><span class=\"line\">## Hexo uses Moment.js to parse and display date</span><br><span class=\"line\">## You can customize the date format as defined in</span><br><span class=\"line\">## http://momentjs.com/docs/#/displaying/format/</span><br><span class=\"line\">date_format: MMM D YYYY</span><br><span class=\"line\">time_format: H:mm:ss</span><br><span class=\"line\"># Pagination 每页显示文章数，可以自定义</span><br><span class=\"line\">## Set per_page to 0 to disable pagination</span><br><span class=\"line\">per_page: 5</span><br><span class=\"line\">pagination_dir: page</span><br><span class=\"line\"># Disqus Disqus 插件，我们会替换成“多说”</span><br><span class=\"line\">disqus_shortname:</span><br><span class=\"line\"># Extensions 这里配置站点所用主题和插件</span><br><span class=\"line\">## Plugins: https://github.com/hexojs/hexo/wiki/Plugins</span><br><span class=\"line\">## Themes: https://github.com/hexojs/hexo/wiki/Themes</span><br><span class=\"line\">theme: light</span><br><span class=\"line\">exclude_generator:</span><br><span class=\"line\"># Deployment 站点部署到github要配置</span><br><span class=\"line\">## Docs: http://hexo.io/docs/deployment.html</span><br><span class=\"line\">deploy:</span><br><span class=\"line\">  type: github</span><br><span class=\"line\">  repository:</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n<h3 id=\"主题-config-yml配置\"><a href=\"#主题-config-yml配置\" class=\"headerlink\" title=\"主题_config.yml配置\"></a>主题_config.yml配置</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">menu: #右上角导航菜单，冒号前面是菜单名，后面是访问路径。</span><br><span class=\"line\">  Home: /</span><br><span class=\"line\">  Archives: /archives</span><br><span class=\"line\">  About: /about</span><br><span class=\"line\"></span><br><span class=\"line\">widgets: #站点右边栏，可以调整顺序和增减内容，会自动调用主题layout/_widget目录下的同名文件。</span><br><span class=\"line\">- search</span><br><span class=\"line\">- category</span><br><span class=\"line\">- tagcloud</span><br><span class=\"line\">excerpt_link: Read More #列表页里Read more链接名称，可以替换成’查看更多‘等。</span><br><span class=\"line\">plugins:</span><br><span class=\"line\">twitter: #右边栏要显示twitter展示的话，需要在此设置</span><br><span class=\"line\">  username:</span><br><span class=\"line\">  show_replies: false</span><br><span class=\"line\">  tweet_count: 5</span><br><span class=\"line\">addthis: #分享设置</span><br><span class=\"line\">  enable: true</span><br><span class=\"line\">  pubid:</span><br><span class=\"line\">  facebook: true</span><br><span class=\"line\">  twitter: true</span><br><span class=\"line\">  google: true</span><br><span class=\"line\">  pinterest: true</span><br><span class=\"line\">fancybox: true #图片效果，默认</span><br><span class=\"line\">google_analytics: #google_analytics统计ID</span><br><span class=\"line\">rss:  #生成RSS路径</span><br></pre></td></tr></table></figure>\n<h2 id=\"常用命令\"><a href=\"#常用命令\" class=\"headerlink\" title=\"常用命令\"></a>常用命令</h2><ul>\n<li>hexo new “postName” #新建文章</li>\n<li>hexo new page “pageName” #新建页面</li>\n<li>hexo clean #清除缓存</li>\n<li>hexo generate #生成静态页面至public目录</li>\n<li>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</li>\n<li>hexo deploy #将.deploy目录部署到GitHub<h3 id=\"命令简写\"><a href=\"#命令简写\" class=\"headerlink\" title=\"命令简写\"></a>命令简写</h3></li>\n<li>hexo n “我的博客” == hexo new “我的博客” #新建文章</li>\n<li>hexo p == hexo publish</li>\n<li>hexo g == hexo generate#生成</li>\n<li>hexo s == hexo server #启动服务预览</li>\n<li>hexo d == hexo deploy#部署</li>\n</ul>\n<h2 id=\"Hexo主题相关\"><a href=\"#Hexo主题相关\" class=\"headerlink\" title=\"Hexo主题相关\"></a>Hexo主题相关</h2><p>参考：<a href=\"http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/\" target=\"_blank\" rel=\"noopener\">http://www.ahonn.me/2016/12/15/create-a-hexo-theme-from-scratch/</a></p>\n<h2 id=\"添加搜索\"><a href=\"#添加搜索\" class=\"headerlink\" title=\"添加搜索\"></a>添加搜索</h2><p>参考：<a href=\"https://www.jianshu.com/p/2010ad07d960\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/2010ad07d960</a></p>\n<h2 id=\"分类和标签设置\"><a href=\"#分类和标签设置\" class=\"headerlink\" title=\"分类和标签设置\"></a>分类和标签设置</h2><p>参考：<a href=\"http://ijiaober.github.io/2014/08/05/hexo/hexo-04/、\" target=\"_blank\" rel=\"noopener\">http://ijiaober.github.io/2014/08/05/hexo/hexo-04/、</a><br><a href=\"https://www.jianshu.com/p/3d2e7b3ec182\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/3d2e7b3ec182</a></p>\n"},{"title":"性能优化","date":"2019-02-13T03:06:38.000Z","_content":"\n#### http优化\n1. 减少单次请求时间\n2. 减少请求次数\n\n#### webpack优化\n1. 提高构建速度\n- bable-loader中使用 include 或 exclude 来帮我们避免不必要的转译，比如排除node_modules文件夹\n2. 使用DLLPlugin打包第三方库\n3. Happypack将 loader 由单进程转为多进程\n4. 使用tree-shaking删除冗余代码，UglifyJsPlugin\n5. webpack按需加载\n6. 使用CommonsChunkPlugin拆分公共代码，webpack4使用optimization.splitChunks\n- https://crazyaguai.github.io/2019/01/15/webpack-CommonsChunkPlugin%E4%B8%8Eoptimization-splitChunks/\n7. 生产环境关闭source-map\n8. 压缩混淆代码，UglifyJsPlugin\n9. 长缓存优化\n- https://crazyaguai.github.io/2018/12/21/webpack-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/#%E9%95%BF%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96\n10. html-webpack-inline-chunk-plugin提前加载manifest.js\n#### 服务器开启gzip\n#### 图片优化\n- 一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。\n1. JPEG/JPG：有损压缩、体积小、加载快、不支持透明\n- 优点：有损压缩，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。\n- 使用场景：JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG图片经常作为大的背景图、轮播图或 Banner 图出现。\n- 缺点：处理矢量图形和 Logo等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。JPEG 图像不支持透明度处理。\n2. PNG-8 与 PNG-24：无损压缩、质量高、体积大、支持透明\n- 使用场景：呈现小的 Logo、颜色简单且对比强烈的图片或背景等。\n3. SVG：文本文件、体积小、不失真、兼容性好\n- 特性：SVG 与 PNG 和 JPG 相比，文件体积更小，可压缩性更强。图片可无限放大而不失真。SVG 是文本文件，可以直接写在html dom中。\n- 局限：渲染成本比较高，有学习成本（是可编程的）。\n- 使用场景：\n4. base64：文本文件、依赖编码、小图标解决方案\n- Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。\n- 应用场景：小图标，更新频率非常低\n- url-loader可配置转换为base64图\n5. WebP\n- Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。\n- WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。\n- 局限性：浏览器支持情况不好，增加服务器的负担（编码同样质量的WebP文件会占用更多的计算资源。）\n#### 浏览器缓存\n1. Memory Cache\n- 指内存中的缓存，从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。\n- Base64 格式的图片，几乎永远可以被塞进 memory cache，体积不大的 JS、CSS文件，也有较大地被写入内存的几率。\n2. Service Worker Cache\n- Service Worker 是一种独立于主线程之外的 Javascript 线程。\n- https://www.jianshu.com/p/62338c038c42\n3. HTTP Cache\n- https://crazyaguai.github.io/2018/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/\n4. Push Cache\n- Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。\n#### 本地存储\n1. cookie\n- 劣势：有体积上限（4KB）,紧跟域名，会带来资源浪费，同一个域名下的所有请求，都会携带 Cookie。\n2. web storage\n- 特性：存储容量大，仅位于浏览器端，不与服务端发生通信。\n- Local Storage 与 Session Storage 的区别：**生命周期**，Local Storage 是持久化的本地存储，Session Storage 是临时性的本地存储。**作用域**，Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享(不同tab页面不能共享)。\n#### 使用CDN缓存\n- CDN 的核心点有两个，一个是缓存，一个是回源（缓存过期向上层服务器请求资源）。\n- CDN 往往被用来存放静态资源。“静态资源”，就是像JS、CSS、图片等不需要业务服务器进行计算即得的资源。\n#### 服务端渲染\n#### 浏览器运行机制\n- 渲染过程：首先基于 HTML 构建一个 DOM 树，这棵 DOM 树与 CSS 解释器解析出的 CSSOM 相结合，就有了布局渲染树。最后浏览器以布局渲染树为蓝本，去计算布局并绘制图像，我们页面的初次渲染就大功告成了。\n1. CSS 优化\n- CSS 选择符是从右到左进行匹配的。\n- 避免使用通配符，只对需要用到的元素进行选择。\n- 关注可以通过继承实现的属性，避免重复匹配重复定义。\n- 少用标签选择器。如果可以，用类选择器替代。\n- 减少选择器嵌套。\n2. CSS与JS加载顺序优化\n- CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。\n- JS 引擎是独立于渲染引擎存在的。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。\n- 通过对JS使用 defer 和 async 来避免不必要的阻塞。\n- async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行。\n- defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。\n- 脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。\n#### DOM优化\n1. DOM操作为什么慢：（1）JS 引擎和渲染引擎（浏览器内核）是独立实现的。用 JS 去操作 DOM 时依赖了桥接接口作为“桥梁”。（2）DOM 的修改引发样式的更迭，会触发回流或重绘。\n2. 回流（重排）：当我们对 DOM 的修改引发了DOM几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）。时\n3. 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时。\n4. 重绘不一定导致回流，回流一定会导致重绘。回流比重绘做的事情更多，带来的开销也更大。\n5. 减少DOM操作\n（1）使用js变量 （2）使用DocumentFragment（表示一个没有父级文件的最小文档对象，不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。）https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment\n```\nlet container = document.getElementById('container')\n// 创建一个DOM Fragment对象作为容器\nlet content = document.createDocumentFragment()\nfor(let count=0;count<10000;count++){\n  let oSpan = document.createElement(\"span\")\n  oSpan.innerHTML = '我是一个小测试'\n  content.appendChild(oSpan)\n}\ncontainer.appendChild(content)\n```\n#### Event Loop 与异步更新\n- https://crazyaguai.github.io/2018/10/20/js-eventLoop/\n#### 回流与重绘\n1. 触发回流：（1）几何属性有 width、height、padding、margin、left、top、border （2）节点的增减、移动等操作。（3）获取一些也定属性的值（需要即时计算），offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight\n2. （1）避免回流与重绘（用js变量将缓存属性值）（2）避免逐条改变样式（通过修改class修改style）(3)将DOM离线，设置display: none，之后再操作\n3. Flush对列\n- 浏览器会缓存flush对列，优化Layout和Paint。\n#### Lazy-Load优化首屏体验\n- 监听屏幕加载页面\n#### 节流（throttle）与防抖（debounce）\n- https://crazyaguai.github.io/2018/11/15/js-%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/\n#### 性能监控\n- chrome Performance面板\n- LightHouse\n","source":"_posts/性能优化.md","raw":"---\ntitle: 性能优化\ndate: 2019-02-13 11:06:38\ntags: [性能优化,浏览器,js]\ncategories: 性能优化\n---\n\n#### http优化\n1. 减少单次请求时间\n2. 减少请求次数\n\n#### webpack优化\n1. 提高构建速度\n- bable-loader中使用 include 或 exclude 来帮我们避免不必要的转译，比如排除node_modules文件夹\n2. 使用DLLPlugin打包第三方库\n3. Happypack将 loader 由单进程转为多进程\n4. 使用tree-shaking删除冗余代码，UglifyJsPlugin\n5. webpack按需加载\n6. 使用CommonsChunkPlugin拆分公共代码，webpack4使用optimization.splitChunks\n- https://crazyaguai.github.io/2019/01/15/webpack-CommonsChunkPlugin%E4%B8%8Eoptimization-splitChunks/\n7. 生产环境关闭source-map\n8. 压缩混淆代码，UglifyJsPlugin\n9. 长缓存优化\n- https://crazyaguai.github.io/2018/12/21/webpack-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/#%E9%95%BF%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96\n10. html-webpack-inline-chunk-plugin提前加载manifest.js\n#### 服务器开启gzip\n#### 图片优化\n- 一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。\n1. JPEG/JPG：有损压缩、体积小、加载快、不支持透明\n- 优点：有损压缩，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。\n- 使用场景：JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG图片经常作为大的背景图、轮播图或 Banner 图出现。\n- 缺点：处理矢量图形和 Logo等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。JPEG 图像不支持透明度处理。\n2. PNG-8 与 PNG-24：无损压缩、质量高、体积大、支持透明\n- 使用场景：呈现小的 Logo、颜色简单且对比强烈的图片或背景等。\n3. SVG：文本文件、体积小、不失真、兼容性好\n- 特性：SVG 与 PNG 和 JPG 相比，文件体积更小，可压缩性更强。图片可无限放大而不失真。SVG 是文本文件，可以直接写在html dom中。\n- 局限：渲染成本比较高，有学习成本（是可编程的）。\n- 使用场景：\n4. base64：文本文件、依赖编码、小图标解决方案\n- Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。\n- 应用场景：小图标，更新频率非常低\n- url-loader可配置转换为base64图\n5. WebP\n- Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。\n- WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。\n- 局限性：浏览器支持情况不好，增加服务器的负担（编码同样质量的WebP文件会占用更多的计算资源。）\n#### 浏览器缓存\n1. Memory Cache\n- 指内存中的缓存，从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。\n- Base64 格式的图片，几乎永远可以被塞进 memory cache，体积不大的 JS、CSS文件，也有较大地被写入内存的几率。\n2. Service Worker Cache\n- Service Worker 是一种独立于主线程之外的 Javascript 线程。\n- https://www.jianshu.com/p/62338c038c42\n3. HTTP Cache\n- https://crazyaguai.github.io/2018/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/\n4. Push Cache\n- Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。\n#### 本地存储\n1. cookie\n- 劣势：有体积上限（4KB）,紧跟域名，会带来资源浪费，同一个域名下的所有请求，都会携带 Cookie。\n2. web storage\n- 特性：存储容量大，仅位于浏览器端，不与服务端发生通信。\n- Local Storage 与 Session Storage 的区别：**生命周期**，Local Storage 是持久化的本地存储，Session Storage 是临时性的本地存储。**作用域**，Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享(不同tab页面不能共享)。\n#### 使用CDN缓存\n- CDN 的核心点有两个，一个是缓存，一个是回源（缓存过期向上层服务器请求资源）。\n- CDN 往往被用来存放静态资源。“静态资源”，就是像JS、CSS、图片等不需要业务服务器进行计算即得的资源。\n#### 服务端渲染\n#### 浏览器运行机制\n- 渲染过程：首先基于 HTML 构建一个 DOM 树，这棵 DOM 树与 CSS 解释器解析出的 CSSOM 相结合，就有了布局渲染树。最后浏览器以布局渲染树为蓝本，去计算布局并绘制图像，我们页面的初次渲染就大功告成了。\n1. CSS 优化\n- CSS 选择符是从右到左进行匹配的。\n- 避免使用通配符，只对需要用到的元素进行选择。\n- 关注可以通过继承实现的属性，避免重复匹配重复定义。\n- 少用标签选择器。如果可以，用类选择器替代。\n- 减少选择器嵌套。\n2. CSS与JS加载顺序优化\n- CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。\n- JS 引擎是独立于渲染引擎存在的。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。\n- 通过对JS使用 defer 和 async 来避免不必要的阻塞。\n- async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行。\n- defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。\n- 脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。\n#### DOM优化\n1. DOM操作为什么慢：（1）JS 引擎和渲染引擎（浏览器内核）是独立实现的。用 JS 去操作 DOM 时依赖了桥接接口作为“桥梁”。（2）DOM 的修改引发样式的更迭，会触发回流或重绘。\n2. 回流（重排）：当我们对 DOM 的修改引发了DOM几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）。时\n3. 重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时。\n4. 重绘不一定导致回流，回流一定会导致重绘。回流比重绘做的事情更多，带来的开销也更大。\n5. 减少DOM操作\n（1）使用js变量 （2）使用DocumentFragment（表示一个没有父级文件的最小文档对象，不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。）https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment\n```\nlet container = document.getElementById('container')\n// 创建一个DOM Fragment对象作为容器\nlet content = document.createDocumentFragment()\nfor(let count=0;count<10000;count++){\n  let oSpan = document.createElement(\"span\")\n  oSpan.innerHTML = '我是一个小测试'\n  content.appendChild(oSpan)\n}\ncontainer.appendChild(content)\n```\n#### Event Loop 与异步更新\n- https://crazyaguai.github.io/2018/10/20/js-eventLoop/\n#### 回流与重绘\n1. 触发回流：（1）几何属性有 width、height、padding、margin、left、top、border （2）节点的增减、移动等操作。（3）获取一些也定属性的值（需要即时计算），offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight\n2. （1）避免回流与重绘（用js变量将缓存属性值）（2）避免逐条改变样式（通过修改class修改style）(3)将DOM离线，设置display: none，之后再操作\n3. Flush对列\n- 浏览器会缓存flush对列，优化Layout和Paint。\n#### Lazy-Load优化首屏体验\n- 监听屏幕加载页面\n#### 节流（throttle）与防抖（debounce）\n- https://crazyaguai.github.io/2018/11/15/js-%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/\n#### 性能监控\n- chrome Performance面板\n- LightHouse\n","slug":"性能优化","published":1,"updated":"2019-02-14T07:57:11.070Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob7k002re0jcwe7gmn1h","content":"<h4 id=\"http优化\"><a href=\"#http优化\" class=\"headerlink\" title=\"http优化\"></a>http优化</h4><ol>\n<li>减少单次请求时间</li>\n<li>减少请求次数</li>\n</ol>\n<h4 id=\"webpack优化\"><a href=\"#webpack优化\" class=\"headerlink\" title=\"webpack优化\"></a>webpack优化</h4><ol>\n<li>提高构建速度</li>\n</ol>\n<ul>\n<li>bable-loader中使用 include 或 exclude 来帮我们避免不必要的转译，比如排除node_modules文件夹</li>\n</ul>\n<ol start=\"2\">\n<li>使用DLLPlugin打包第三方库</li>\n<li>Happypack将 loader 由单进程转为多进程</li>\n<li>使用tree-shaking删除冗余代码，UglifyJsPlugin</li>\n<li>webpack按需加载</li>\n<li>使用CommonsChunkPlugin拆分公共代码，webpack4使用optimization.splitChunks</li>\n</ol>\n<ul>\n<li><a href=\"https://crazyaguai.github.io/2019/01/15/webpack-CommonsChunkPlugin%E4%B8%8Eoptimization-splitChunks/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2019/01/15/webpack-CommonsChunkPlugin%E4%B8%8Eoptimization-splitChunks/</a></li>\n</ul>\n<ol start=\"7\">\n<li>生产环境关闭source-map</li>\n<li>压缩混淆代码，UglifyJsPlugin</li>\n<li>长缓存优化</li>\n</ol>\n<ul>\n<li><a href=\"https://crazyaguai.github.io/2018/12/21/webpack-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/#%E9%95%BF%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2018/12/21/webpack-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/#%E9%95%BF%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96</a></li>\n</ul>\n<ol start=\"10\">\n<li>html-webpack-inline-chunk-plugin提前加载manifest.js<h4 id=\"服务器开启gzip\"><a href=\"#服务器开启gzip\" class=\"headerlink\" title=\"服务器开启gzip\"></a>服务器开启gzip</h4><h4 id=\"图片优化\"><a href=\"#图片优化\" class=\"headerlink\" title=\"图片优化\"></a>图片优化</h4></li>\n</ol>\n<ul>\n<li>一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。</li>\n</ul>\n<ol>\n<li>JPEG/JPG：有损压缩、体积小、加载快、不支持透明</li>\n</ol>\n<ul>\n<li>优点：有损压缩，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。</li>\n<li>使用场景：JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG图片经常作为大的背景图、轮播图或 Banner 图出现。</li>\n<li>缺点：处理矢量图形和 Logo等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。JPEG 图像不支持透明度处理。</li>\n</ul>\n<ol start=\"2\">\n<li>PNG-8 与 PNG-24：无损压缩、质量高、体积大、支持透明</li>\n</ol>\n<ul>\n<li>使用场景：呈现小的 Logo、颜色简单且对比强烈的图片或背景等。</li>\n</ul>\n<ol start=\"3\">\n<li>SVG：文本文件、体积小、不失真、兼容性好</li>\n</ol>\n<ul>\n<li>特性：SVG 与 PNG 和 JPG 相比，文件体积更小，可压缩性更强。图片可无限放大而不失真。SVG 是文本文件，可以直接写在html dom中。</li>\n<li>局限：渲染成本比较高，有学习成本（是可编程的）。</li>\n<li>使用场景：</li>\n</ul>\n<ol start=\"4\">\n<li>base64：文本文件、依赖编码、小图标解决方案</li>\n</ol>\n<ul>\n<li>Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。</li>\n<li>应用场景：小图标，更新频率非常低</li>\n<li>url-loader可配置转换为base64图</li>\n</ul>\n<ol start=\"5\">\n<li>WebP</li>\n</ol>\n<ul>\n<li>Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。</li>\n<li>WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。</li>\n<li>局限性：浏览器支持情况不好，增加服务器的负担（编码同样质量的WebP文件会占用更多的计算资源。）<h4 id=\"浏览器缓存\"><a href=\"#浏览器缓存\" class=\"headerlink\" title=\"浏览器缓存\"></a>浏览器缓存</h4></li>\n</ul>\n<ol>\n<li>Memory Cache</li>\n</ol>\n<ul>\n<li>指内存中的缓存，从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。</li>\n<li>Base64 格式的图片，几乎永远可以被塞进 memory cache，体积不大的 JS、CSS文件，也有较大地被写入内存的几率。</li>\n</ul>\n<ol start=\"2\">\n<li>Service Worker Cache</li>\n</ol>\n<ul>\n<li>Service Worker 是一种独立于主线程之外的 Javascript 线程。</li>\n<li><a href=\"https://www.jianshu.com/p/62338c038c42\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/62338c038c42</a></li>\n</ul>\n<ol start=\"3\">\n<li>HTTP Cache</li>\n</ol>\n<ul>\n<li><a href=\"https://crazyaguai.github.io/2018/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2018/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</a></li>\n</ul>\n<ol start=\"4\">\n<li>Push Cache</li>\n</ol>\n<ul>\n<li>Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。<h4 id=\"本地存储\"><a href=\"#本地存储\" class=\"headerlink\" title=\"本地存储\"></a>本地存储</h4></li>\n</ul>\n<ol>\n<li>cookie</li>\n</ol>\n<ul>\n<li>劣势：有体积上限（4KB）,紧跟域名，会带来资源浪费，同一个域名下的所有请求，都会携带 Cookie。</li>\n</ul>\n<ol start=\"2\">\n<li>web storage</li>\n</ol>\n<ul>\n<li>特性：存储容量大，仅位于浏览器端，不与服务端发生通信。</li>\n<li>Local Storage 与 Session Storage 的区别：<strong>生命周期</strong>，Local Storage 是持久化的本地存储，Session Storage 是临时性的本地存储。<strong>作用域</strong>，Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享(不同tab页面不能共享)。<h4 id=\"使用CDN缓存\"><a href=\"#使用CDN缓存\" class=\"headerlink\" title=\"使用CDN缓存\"></a>使用CDN缓存</h4></li>\n<li>CDN 的核心点有两个，一个是缓存，一个是回源（缓存过期向上层服务器请求资源）。</li>\n<li>CDN 往往被用来存放静态资源。“静态资源”，就是像JS、CSS、图片等不需要业务服务器进行计算即得的资源。<h4 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h4><h4 id=\"浏览器运行机制\"><a href=\"#浏览器运行机制\" class=\"headerlink\" title=\"浏览器运行机制\"></a>浏览器运行机制</h4></li>\n<li>渲染过程：首先基于 HTML 构建一个 DOM 树，这棵 DOM 树与 CSS 解释器解析出的 CSSOM 相结合，就有了布局渲染树。最后浏览器以布局渲染树为蓝本，去计算布局并绘制图像，我们页面的初次渲染就大功告成了。</li>\n</ul>\n<ol>\n<li>CSS 优化</li>\n</ol>\n<ul>\n<li>CSS 选择符是从右到左进行匹配的。</li>\n<li>避免使用通配符，只对需要用到的元素进行选择。</li>\n<li>关注可以通过继承实现的属性，避免重复匹配重复定义。</li>\n<li>少用标签选择器。如果可以，用类选择器替代。</li>\n<li>减少选择器嵌套。</li>\n</ul>\n<ol start=\"2\">\n<li>CSS与JS加载顺序优化</li>\n</ol>\n<ul>\n<li>CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</li>\n<li>JS 引擎是独立于渲染引擎存在的。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。</li>\n<li>通过对JS使用 defer 和 async 来避免不必要的阻塞。</li>\n<li>async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行。</li>\n<li>defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。</li>\n<li>脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。<h4 id=\"DOM优化\"><a href=\"#DOM优化\" class=\"headerlink\" title=\"DOM优化\"></a>DOM优化</h4></li>\n</ul>\n<ol>\n<li>DOM操作为什么慢：（1）JS 引擎和渲染引擎（浏览器内核）是独立实现的。用 JS 去操作 DOM 时依赖了桥接接口作为“桥梁”。（2）DOM 的修改引发样式的更迭，会触发回流或重绘。</li>\n<li>回流（重排）：当我们对 DOM 的修改引发了DOM几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）。时</li>\n<li>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时。</li>\n<li>重绘不一定导致回流，回流一定会导致重绘。回流比重绘做的事情更多，带来的开销也更大。</li>\n<li>减少DOM操作<br>（1）使用js变量 （2）使用DocumentFragment（表示一个没有父级文件的最小文档对象，不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。）<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment</a><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let container = document.getElementById(&apos;container&apos;)</span><br><span class=\"line\">// 创建一个DOM Fragment对象作为容器</span><br><span class=\"line\">let content = document.createDocumentFragment()</span><br><span class=\"line\">for(let count=0;count&lt;10000;count++)&#123;</span><br><span class=\"line\">  let oSpan = document.createElement(&quot;span&quot;)</span><br><span class=\"line\">  oSpan.innerHTML = &apos;我是一个小测试&apos;</span><br><span class=\"line\">  content.appendChild(oSpan)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">container.appendChild(content)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"Event-Loop-与异步更新\"><a href=\"#Event-Loop-与异步更新\" class=\"headerlink\" title=\"Event Loop 与异步更新\"></a>Event Loop 与异步更新</h4><ul>\n<li><a href=\"https://crazyaguai.github.io/2018/10/20/js-eventLoop/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2018/10/20/js-eventLoop/</a><h4 id=\"回流与重绘\"><a href=\"#回流与重绘\" class=\"headerlink\" title=\"回流与重绘\"></a>回流与重绘</h4></li>\n</ul>\n<ol>\n<li>触发回流：（1）几何属性有 width、height、padding、margin、left、top、border （2）节点的增减、移动等操作。（3）获取一些也定属性的值（需要即时计算），offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</li>\n<li>（1）避免回流与重绘（用js变量将缓存属性值）（2）避免逐条改变样式（通过修改class修改style）(3)将DOM离线，设置display: none，之后再操作</li>\n<li>Flush对列</li>\n</ol>\n<ul>\n<li>浏览器会缓存flush对列，优化Layout和Paint。<h4 id=\"Lazy-Load优化首屏体验\"><a href=\"#Lazy-Load优化首屏体验\" class=\"headerlink\" title=\"Lazy-Load优化首屏体验\"></a>Lazy-Load优化首屏体验</h4></li>\n<li>监听屏幕加载页面<h4 id=\"节流（throttle）与防抖（debounce）\"><a href=\"#节流（throttle）与防抖（debounce）\" class=\"headerlink\" title=\"节流（throttle）与防抖（debounce）\"></a>节流（throttle）与防抖（debounce）</h4></li>\n<li><a href=\"https://crazyaguai.github.io/2018/11/15/js-%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2018/11/15/js-%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</a><h4 id=\"性能监控\"><a href=\"#性能监控\" class=\"headerlink\" title=\"性能监控\"></a>性能监控</h4></li>\n<li>chrome Performance面板</li>\n<li>LightHouse</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h4 id=\"http优化\"><a href=\"#http优化\" class=\"headerlink\" title=\"http优化\"></a>http优化</h4><ol>\n<li>减少单次请求时间</li>\n<li>减少请求次数</li>\n</ol>\n<h4 id=\"webpack优化\"><a href=\"#webpack优化\" class=\"headerlink\" title=\"webpack优化\"></a>webpack优化</h4><ol>\n<li>提高构建速度</li>\n</ol>\n<ul>\n<li>bable-loader中使用 include 或 exclude 来帮我们避免不必要的转译，比如排除node_modules文件夹</li>\n</ul>\n<ol start=\"2\">\n<li>使用DLLPlugin打包第三方库</li>\n<li>Happypack将 loader 由单进程转为多进程</li>\n<li>使用tree-shaking删除冗余代码，UglifyJsPlugin</li>\n<li>webpack按需加载</li>\n<li>使用CommonsChunkPlugin拆分公共代码，webpack4使用optimization.splitChunks</li>\n</ol>\n<ul>\n<li><a href=\"https://crazyaguai.github.io/2019/01/15/webpack-CommonsChunkPlugin%E4%B8%8Eoptimization-splitChunks/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2019/01/15/webpack-CommonsChunkPlugin%E4%B8%8Eoptimization-splitChunks/</a></li>\n</ul>\n<ol start=\"7\">\n<li>生产环境关闭source-map</li>\n<li>压缩混淆代码，UglifyJsPlugin</li>\n<li>长缓存优化</li>\n</ol>\n<ul>\n<li><a href=\"https://crazyaguai.github.io/2018/12/21/webpack-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/#%E9%95%BF%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2018/12/21/webpack-%E6%90%AD%E5%BB%BA%E7%8E%AF%E5%A2%83%E4%BB%A5%E5%8F%8A%E7%9B%B8%E5%85%B3%E4%BC%98%E5%8C%96/#%E9%95%BF%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96</a></li>\n</ul>\n<ol start=\"10\">\n<li>html-webpack-inline-chunk-plugin提前加载manifest.js<h4 id=\"服务器开启gzip\"><a href=\"#服务器开启gzip\" class=\"headerlink\" title=\"服务器开启gzip\"></a>服务器开启gzip</h4><h4 id=\"图片优化\"><a href=\"#图片优化\" class=\"headerlink\" title=\"图片优化\"></a>图片优化</h4></li>\n</ol>\n<ul>\n<li>一个像素对应的二进制位数越多，它可以表示的颜色种类就越多，成像效果也就越细腻，文件体积相应也会越大。一个二进制位表示两种颜色（0|1 对应黑|白），如果一种图片格式对应的二进制位数有 n 个，那么它就可以呈现 2^n 种颜色。</li>\n</ul>\n<ol>\n<li>JPEG/JPG：有损压缩、体积小、加载快、不支持透明</li>\n</ol>\n<ul>\n<li>优点：有损压缩，即使被称为“有损”压缩，JPG的压缩方式仍然是一种高质量的压缩方式：当我们把图片体积压缩至原有体积的 50% 以下时，JPG 仍然可以保持住 60% 的品质。</li>\n<li>使用场景：JPG 适用于呈现色彩丰富的图片，在我们日常开发中，JPG图片经常作为大的背景图、轮播图或 Banner 图出现。</li>\n<li>缺点：处理矢量图形和 Logo等线条感较强、颜色对比强烈的图像时，人为压缩导致的图片模糊会相当明显。JPEG 图像不支持透明度处理。</li>\n</ul>\n<ol start=\"2\">\n<li>PNG-8 与 PNG-24：无损压缩、质量高、体积大、支持透明</li>\n</ol>\n<ul>\n<li>使用场景：呈现小的 Logo、颜色简单且对比强烈的图片或背景等。</li>\n</ul>\n<ol start=\"3\">\n<li>SVG：文本文件、体积小、不失真、兼容性好</li>\n</ol>\n<ul>\n<li>特性：SVG 与 PNG 和 JPG 相比，文件体积更小，可压缩性更强。图片可无限放大而不失真。SVG 是文本文件，可以直接写在html dom中。</li>\n<li>局限：渲染成本比较高，有学习成本（是可编程的）。</li>\n<li>使用场景：</li>\n</ul>\n<ol start=\"4\">\n<li>base64：文本文件、依赖编码、小图标解决方案</li>\n</ol>\n<ul>\n<li>Base64 是一种用于传输 8Bit 字节码的编码方式，通过对图片进行 Base64 编码，我们可以直接将编码结果写入 HTML 或者写入 CSS，从而减少 HTTP 请求的次数。</li>\n<li>应用场景：小图标，更新频率非常低</li>\n<li>url-loader可配置转换为base64图</li>\n</ul>\n<ol start=\"5\">\n<li>WebP</li>\n</ol>\n<ul>\n<li>Google 专为 Web 开发的一种旨在加快图片加载速度的图片格式，它支持有损压缩和无损压缩。</li>\n<li>WebP 像 JPEG 一样对细节丰富的图片信手拈来，像 PNG 一样支持透明，像 GIF 一样可以显示动态图片——它集多种图片文件格式的优点于一身。</li>\n<li>局限性：浏览器支持情况不好，增加服务器的负担（编码同样质量的WebP文件会占用更多的计算资源。）<h4 id=\"浏览器缓存\"><a href=\"#浏览器缓存\" class=\"headerlink\" title=\"浏览器缓存\"></a>浏览器缓存</h4></li>\n</ul>\n<ol>\n<li>Memory Cache</li>\n</ol>\n<ul>\n<li>指内存中的缓存，从优先级上来说，它是浏览器最先尝试去命中的一种缓存。从效率上来说，它是响应速度最快的一种缓存。</li>\n<li>Base64 格式的图片，几乎永远可以被塞进 memory cache，体积不大的 JS、CSS文件，也有较大地被写入内存的几率。</li>\n</ul>\n<ol start=\"2\">\n<li>Service Worker Cache</li>\n</ol>\n<ul>\n<li>Service Worker 是一种独立于主线程之外的 Javascript 线程。</li>\n<li><a href=\"https://www.jianshu.com/p/62338c038c42\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/62338c038c42</a></li>\n</ul>\n<ol start=\"3\">\n<li>HTTP Cache</li>\n</ol>\n<ul>\n<li><a href=\"https://crazyaguai.github.io/2018/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2018/09/06/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98/</a></li>\n</ul>\n<ol start=\"4\">\n<li>Push Cache</li>\n</ol>\n<ul>\n<li>Push Cache 是指 HTTP2 在 server push 阶段存在的缓存。<h4 id=\"本地存储\"><a href=\"#本地存储\" class=\"headerlink\" title=\"本地存储\"></a>本地存储</h4></li>\n</ul>\n<ol>\n<li>cookie</li>\n</ol>\n<ul>\n<li>劣势：有体积上限（4KB）,紧跟域名，会带来资源浪费，同一个域名下的所有请求，都会携带 Cookie。</li>\n</ul>\n<ol start=\"2\">\n<li>web storage</li>\n</ol>\n<ul>\n<li>特性：存储容量大，仅位于浏览器端，不与服务端发生通信。</li>\n<li>Local Storage 与 Session Storage 的区别：<strong>生命周期</strong>，Local Storage 是持久化的本地存储，Session Storage 是临时性的本地存储。<strong>作用域</strong>，Local Storage、Session Storage 和 Cookie 都遵循同源策略。但 Session Storage 特别的一点在于，即便是相同域名下的两个页面，只要它们不在同一个浏览器窗口中打开，那么它们的 Session Storage 内容便无法共享(不同tab页面不能共享)。<h4 id=\"使用CDN缓存\"><a href=\"#使用CDN缓存\" class=\"headerlink\" title=\"使用CDN缓存\"></a>使用CDN缓存</h4></li>\n<li>CDN 的核心点有两个，一个是缓存，一个是回源（缓存过期向上层服务器请求资源）。</li>\n<li>CDN 往往被用来存放静态资源。“静态资源”，就是像JS、CSS、图片等不需要业务服务器进行计算即得的资源。<h4 id=\"服务端渲染\"><a href=\"#服务端渲染\" class=\"headerlink\" title=\"服务端渲染\"></a>服务端渲染</h4><h4 id=\"浏览器运行机制\"><a href=\"#浏览器运行机制\" class=\"headerlink\" title=\"浏览器运行机制\"></a>浏览器运行机制</h4></li>\n<li>渲染过程：首先基于 HTML 构建一个 DOM 树，这棵 DOM 树与 CSS 解释器解析出的 CSSOM 相结合，就有了布局渲染树。最后浏览器以布局渲染树为蓝本，去计算布局并绘制图像，我们页面的初次渲染就大功告成了。</li>\n</ul>\n<ol>\n<li>CSS 优化</li>\n</ol>\n<ul>\n<li>CSS 选择符是从右到左进行匹配的。</li>\n<li>避免使用通配符，只对需要用到的元素进行选择。</li>\n<li>关注可以通过继承实现的属性，避免重复匹配重复定义。</li>\n<li>少用标签选择器。如果可以，用类选择器替代。</li>\n<li>减少选择器嵌套。</li>\n</ul>\n<ol start=\"2\">\n<li>CSS与JS加载顺序优化</li>\n</ol>\n<ul>\n<li>CSS 是阻塞的资源。浏览器在构建 CSSOM 的过程中，不会渲染任何已处理的内容。需要将它尽早、尽快地下载到客户端，以便缩短首次渲染的时间。</li>\n<li>JS 引擎是独立于渲染引擎存在的。当 HTML 解析器遇到一个 script 标签时，它会暂停渲染过程，将控制权交给 JS 引擎。JS 引擎对内联的 JS 代码会直接执行，对外部 JS 文件还要先获取到脚本、再进行执行。等 JS 引擎运行完毕，浏览器又会把控制权还给渲染引擎，继续 CSSOM 和 DOM 的构建。</li>\n<li>通过对JS使用 defer 和 async 来避免不必要的阻塞。</li>\n<li>async 模式下，JS 不会阻塞浏览器做任何其它的事情。它的加载是异步的，当它加载结束，JS 脚本会立即执行。</li>\n<li>defer 模式下，JS 的加载是异步的，执行是被推迟的。等整个文档解析完成、DOMContentLoaded 事件即将被触发时，被标记了 defer 的 JS 文件才会开始依次执行。</li>\n<li>脚本与 DOM 元素和其它脚本之间的依赖关系不强时，我们会选用 async；当脚本依赖于 DOM 元素和其它脚本的执行结果时，我们会选用 defer。<h4 id=\"DOM优化\"><a href=\"#DOM优化\" class=\"headerlink\" title=\"DOM优化\"></a>DOM优化</h4></li>\n</ul>\n<ol>\n<li>DOM操作为什么慢：（1）JS 引擎和渲染引擎（浏览器内核）是独立实现的。用 JS 去操作 DOM 时依赖了桥接接口作为“桥梁”。（2）DOM 的修改引发样式的更迭，会触发回流或重绘。</li>\n<li>回流（重排）：当我们对 DOM 的修改引发了DOM几何尺寸的变化（比如修改元素的宽、高或隐藏元素等）。时</li>\n<li>重绘：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时。</li>\n<li>重绘不一定导致回流，回流一定会导致重绘。回流比重绘做的事情更多，带来的开销也更大。</li>\n<li>减少DOM操作<br>（1）使用js变量 （2）使用DocumentFragment（表示一个没有父级文件的最小文档对象，不是真实 DOM 树的一部分，它的变化不会引起 DOM 树的重新渲染的操作（reflow），且不会导致性能等问题。）<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment</a><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let container = document.getElementById(&apos;container&apos;)</span><br><span class=\"line\">// 创建一个DOM Fragment对象作为容器</span><br><span class=\"line\">let content = document.createDocumentFragment()</span><br><span class=\"line\">for(let count=0;count&lt;10000;count++)&#123;</span><br><span class=\"line\">  let oSpan = document.createElement(&quot;span&quot;)</span><br><span class=\"line\">  oSpan.innerHTML = &apos;我是一个小测试&apos;</span><br><span class=\"line\">  content.appendChild(oSpan)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">container.appendChild(content)</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h4 id=\"Event-Loop-与异步更新\"><a href=\"#Event-Loop-与异步更新\" class=\"headerlink\" title=\"Event Loop 与异步更新\"></a>Event Loop 与异步更新</h4><ul>\n<li><a href=\"https://crazyaguai.github.io/2018/10/20/js-eventLoop/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2018/10/20/js-eventLoop/</a><h4 id=\"回流与重绘\"><a href=\"#回流与重绘\" class=\"headerlink\" title=\"回流与重绘\"></a>回流与重绘</h4></li>\n</ul>\n<ol>\n<li>触发回流：（1）几何属性有 width、height、padding、margin、left、top、border （2）节点的增减、移动等操作。（3）获取一些也定属性的值（需要即时计算），offsetTop、offsetLeft、 offsetWidth、offsetHeight、scrollTop、scrollLeft、scrollWidth、scrollHeight、clientTop、clientLeft、clientWidth、clientHeight</li>\n<li>（1）避免回流与重绘（用js变量将缓存属性值）（2）避免逐条改变样式（通过修改class修改style）(3)将DOM离线，设置display: none，之后再操作</li>\n<li>Flush对列</li>\n</ol>\n<ul>\n<li>浏览器会缓存flush对列，优化Layout和Paint。<h4 id=\"Lazy-Load优化首屏体验\"><a href=\"#Lazy-Load优化首屏体验\" class=\"headerlink\" title=\"Lazy-Load优化首屏体验\"></a>Lazy-Load优化首屏体验</h4></li>\n<li>监听屏幕加载页面<h4 id=\"节流（throttle）与防抖（debounce）\"><a href=\"#节流（throttle）与防抖（debounce）\" class=\"headerlink\" title=\"节流（throttle）与防抖（debounce）\"></a>节流（throttle）与防抖（debounce）</h4></li>\n<li><a href=\"https://crazyaguai.github.io/2018/11/15/js-%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/\" target=\"_blank\" rel=\"noopener\">https://crazyaguai.github.io/2018/11/15/js-%E8%8A%82%E6%B5%81%E4%B8%8E%E9%98%B2%E6%8A%96/</a><h4 id=\"性能监控\"><a href=\"#性能监控\" class=\"headerlink\" title=\"性能监控\"></a>性能监控</h4></li>\n<li>chrome Performance面板</li>\n<li>LightHouse</li>\n</ul>\n"},{"title":"浏览器缓存","date":"2018-09-06T14:13:21.000Z","_content":"\n![image](https://crazyaguai.github.io/images/浏览器缓存.png)\n\n## 强制缓存\n当浏览器对某个资源的请求命中了强制缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。\n\n### Expires：\nExpires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：\n\n1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header。\n\n2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；\nExpires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题。\n\n\n### Cache-Control：\nCache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示\n\n#### 参数：\n\n- public：所有内容都将被缓存（客户端和代理服务器都可缓存）\n- private：所有内容只有客户端可以缓存，Cache-Control的默认取值\n- no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n- no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n- max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效\n- s-maxage=xxx：代理服务器的缓存时间\n\n### 缓存原理：\n1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header\n\n2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；\n\n3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。\n\n4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。\n\n### Cache-Control与Expires不同\nCache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。\n\n### Cache-Control优先级高于Expires。\n\n### 启用强制缓存\n\n通常有2种方式来设置是否启用强缓存：\n\n1）通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；\n\n2）通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。\n\n### from memory cache与from disk cache\nfrom memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –> disk。\n\n对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:\n\n#### 内存缓存(from memory cache)：\n\n内存缓存具有两个特点，分别是快速读取和时效性：\n\n- 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。\n\n- 时效性：一旦该进程关闭，则该进程的内存则会清空。\n\n#### 硬盘缓存(from disk cache)：\n硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。\n\n在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；\n\n而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。\n\n## 协商缓存\n\n当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。\n\n协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。\n\n### 【Last-Modified，If-Modified-Since】\n浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间。\n\n浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值。\n\n服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 NotModified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header。\n\n浏览器收到304的响应后，就会从缓存中加载资源。\n\n如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。\n\n### 【ETag、If-None-Match】\n浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题。\n\n浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值。\n\n服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。\n浏览器收到304的响应后，就会从缓存中加载资源。\n\n#### 其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高\n\n#### 注意：\n【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：\n\n分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；\n\n分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；\n\n### 浏览器刷新与缓存方式：\n当ctrl+f5(command+shift+r)强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；\n当f5(commond+r)刷新网页时，跳过强缓存，但是会检查协商缓存\n\n### 参考相关内容：\n- https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA\n\n- https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=402202185&idx=3&sn=abbc03511d2c393d7a4867ff532224ab&scene=21#wechat_redirect\n\n- https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651221145&idx=1&sn=ce8cc0dd80142980026eb156d5b1f269&scene=21#wechat_redirect\n\n- https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651226347&idx=1&sn=6dbccc54406f0b075671884b738b1e88&chksm=bd49596f8a3ed079f79cda4b90ac3cb3b1dbdb5bfb8aade962a16a323563bf26a0c75b0a5d7b&scene=21#wechat_redirect\n","source":"_posts/浏览器缓存.md","raw":"---\ntitle: 浏览器缓存\ndate: 2018-09-06 22:13:21\ntags: [缓存,浏览器]\ncategories: 缓存\n---\n\n![image](https://crazyaguai.github.io/images/浏览器缓存.png)\n\n## 强制缓存\n当浏览器对某个资源的请求命中了强制缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。\n\n### Expires：\nExpires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：\n\n1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header。\n\n2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；\nExpires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题。\n\n\n### Cache-Control：\nCache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示\n\n#### 参数：\n\n- public：所有内容都将被缓存（客户端和代理服务器都可缓存）\n- private：所有内容只有客户端可以缓存，Cache-Control的默认取值\n- no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定\n- no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存\n- max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效\n- s-maxage=xxx：代理服务器的缓存时间\n\n### 缓存原理：\n1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header\n\n2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；\n\n3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。\n\n4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。\n\n### Cache-Control与Expires不同\nCache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。\n\n### Cache-Control优先级高于Expires。\n\n### 启用强制缓存\n\n通常有2种方式来设置是否启用强缓存：\n\n1）通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；\n\n2）通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。\n\n### from memory cache与from disk cache\nfrom memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –> disk。\n\n对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:\n\n#### 内存缓存(from memory cache)：\n\n内存缓存具有两个特点，分别是快速读取和时效性：\n\n- 快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。\n\n- 时效性：一旦该进程关闭，则该进程的内存则会清空。\n\n#### 硬盘缓存(from disk cache)：\n硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。\n\n在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；\n\n而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。\n\n## 协商缓存\n\n当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。\n\n协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。\n\n### 【Last-Modified，If-Modified-Since】\n浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间。\n\n浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值。\n\n服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 NotModified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header。\n\n浏览器收到304的响应后，就会从缓存中加载资源。\n\n如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。\n\n### 【ETag、If-None-Match】\n浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题。\n\n浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值。\n\n服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。\n浏览器收到304的响应后，就会从缓存中加载资源。\n\n#### 其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高\n\n#### 注意：\n【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：\n\n分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；\n\n分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；\n\n### 浏览器刷新与缓存方式：\n当ctrl+f5(command+shift+r)强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；\n当f5(commond+r)刷新网页时，跳过强缓存，但是会检查协商缓存\n\n### 参考相关内容：\n- https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA\n\n- https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=402202185&idx=3&sn=abbc03511d2c393d7a4867ff532224ab&scene=21#wechat_redirect\n\n- https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651221145&idx=1&sn=ce8cc0dd80142980026eb156d5b1f269&scene=21#wechat_redirect\n\n- https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&mid=2651226347&idx=1&sn=6dbccc54406f0b075671884b738b1e88&chksm=bd49596f8a3ed079f79cda4b90ac3cb3b1dbdb5bfb8aade962a16a323563bf26a0c75b0a5d7b&scene=21#wechat_redirect\n","slug":"浏览器缓存","published":1,"updated":"2019-02-11T14:10:33.149Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob7l002ue0jck5pzboou","content":"<p><img src=\"https://crazyaguai.github.io/images/浏览器缓存.png\" alt=\"image\"></p>\n<h2 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h2><p>当浏览器对某个资源的请求命中了强制缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。</p>\n<h3 id=\"Expires：\"><a href=\"#Expires：\" class=\"headerlink\" title=\"Expires：\"></a>Expires：</h3><p>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：</p>\n<p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header。</p>\n<p>2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；<br>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题。</p>\n<h3 id=\"Cache-Control：\"><a href=\"#Cache-Control：\" class=\"headerlink\" title=\"Cache-Control：\"></a>Cache-Control：</h3><p>Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示</p>\n<h4 id=\"参数：\"><a href=\"#参数：\" class=\"headerlink\" title=\"参数：\"></a>参数：</h4><ul>\n<li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li>\n<li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li>\n<li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>\n<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>\n<li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li>\n<li>s-maxage=xxx：代理服务器的缓存时间</li>\n</ul>\n<h3 id=\"缓存原理：\"><a href=\"#缓存原理：\" class=\"headerlink\" title=\"缓存原理：\"></a>缓存原理：</h3><p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header</p>\n<p>2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</p>\n<p>3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p>\n<p>4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</p>\n<h3 id=\"Cache-Control与Expires不同\"><a href=\"#Cache-Control与Expires不同\" class=\"headerlink\" title=\"Cache-Control与Expires不同\"></a>Cache-Control与Expires不同</h3><p>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</p>\n<h3 id=\"Cache-Control优先级高于Expires。\"><a href=\"#Cache-Control优先级高于Expires。\" class=\"headerlink\" title=\"Cache-Control优先级高于Expires。\"></a>Cache-Control优先级高于Expires。</h3><h3 id=\"启用强制缓存\"><a href=\"#启用强制缓存\" class=\"headerlink\" title=\"启用强制缓存\"></a>启用强制缓存</h3><p>通常有2种方式来设置是否启用强缓存：</p>\n<p>1）通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</p>\n<p>2）通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。</p>\n<h3 id=\"from-memory-cache与from-disk-cache\"><a href=\"#from-memory-cache与from-disk-cache\" class=\"headerlink\" title=\"from memory cache与from disk cache\"></a>from memory cache与from disk cache</h3><p>from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</p>\n<p>对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:</p>\n<h4 id=\"内存缓存-from-memory-cache-：\"><a href=\"#内存缓存-from-memory-cache-：\" class=\"headerlink\" title=\"内存缓存(from memory cache)：\"></a>内存缓存(from memory cache)：</h4><p>内存缓存具有两个特点，分别是快速读取和时效性：</p>\n<ul>\n<li><p>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</p>\n</li>\n<li><p>时效性：一旦该进程关闭，则该进程的内存则会清空。</p>\n</li>\n</ul>\n<h4 id=\"硬盘缓存-from-disk-cache-：\"><a href=\"#硬盘缓存-from-disk-cache-：\" class=\"headerlink\" title=\"硬盘缓存(from disk cache)：\"></a>硬盘缓存(from disk cache)：</h4><p>硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</p>\n<p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；</p>\n<p>而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p>\n<h2 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h2><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。</p>\n<p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</p>\n<h3 id=\"【Last-Modified，If-Modified-Since】\"><a href=\"#【Last-Modified，If-Modified-Since】\" class=\"headerlink\" title=\"【Last-Modified，If-Modified-Since】\"></a>【Last-Modified，If-Modified-Since】</h3><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间。</p>\n<p>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值。</p>\n<p>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 NotModified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header。</p>\n<p>浏览器收到304的响应后，就会从缓存中加载资源。</p>\n<p>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</p>\n<h3 id=\"【ETag、If-None-Match】\"><a href=\"#【ETag、If-None-Match】\" class=\"headerlink\" title=\"【ETag、If-None-Match】\"></a>【ETag、If-None-Match】</h3><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题。</p>\n<p>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值。</p>\n<p>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。<br>浏览器收到304的响应后，就会从缓存中加载资源。</p>\n<h4 id=\"其中Etag-If-None-Match的优先级比Last-Modified-If-Modified-Since高\"><a href=\"#其中Etag-If-None-Match的优先级比Last-Modified-If-Modified-Since高\" class=\"headerlink\" title=\"其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高\"></a>其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高</h4><h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><p>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：</p>\n<p>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</p>\n<p>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；</p>\n<h3 id=\"浏览器刷新与缓存方式：\"><a href=\"#浏览器刷新与缓存方式：\" class=\"headerlink\" title=\"浏览器刷新与缓存方式：\"></a>浏览器刷新与缓存方式：</h3><p>当ctrl+f5(command+shift+r)强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；<br>当f5(commond+r)刷新网页时，跳过强缓存，但是会检查协商缓存</p>\n<h3 id=\"参考相关内容：\"><a href=\"#参考相关内容：\" class=\"headerlink\" title=\"参考相关内容：\"></a>参考相关内容：</h3><ul>\n<li><p><a href=\"https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=402202185&amp;idx=3&amp;sn=abbc03511d2c393d7a4867ff532224ab&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=402202185&amp;idx=3&amp;sn=abbc03511d2c393d7a4867ff532224ab&amp;scene=21#wechat_redirect</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651221145&amp;idx=1&amp;sn=ce8cc0dd80142980026eb156d5b1f269&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651221145&amp;idx=1&amp;sn=ce8cc0dd80142980026eb156d5b1f269&amp;scene=21#wechat_redirect</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226347&amp;idx=1&amp;sn=6dbccc54406f0b075671884b738b1e88&amp;chksm=bd49596f8a3ed079f79cda4b90ac3cb3b1dbdb5bfb8aade962a16a323563bf26a0c75b0a5d7b&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226347&amp;idx=1&amp;sn=6dbccc54406f0b075671884b738b1e88&amp;chksm=bd49596f8a3ed079f79cda4b90ac3cb3b1dbdb5bfb8aade962a16a323563bf26a0c75b0a5d7b&amp;scene=21#wechat_redirect</a></p>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p><img src=\"https://crazyaguai.github.io/images/浏览器缓存.png\" alt=\"image\"></p>\n<h2 id=\"强制缓存\"><a href=\"#强制缓存\" class=\"headerlink\" title=\"强制缓存\"></a>强制缓存</h2><p>当浏览器对某个资源的请求命中了强制缓存时，返回的http状态为200，在chrome的开发者工具的network里面size会显示为from cache，强缓存是利用Expires或者Cache-Control这两个http response header实现的，它们都用来表示资源在客户端缓存的有效期。</p>\n<h3 id=\"Expires：\"><a href=\"#Expires：\" class=\"headerlink\" title=\"Expires：\"></a>Expires：</h3><p>Expires是http1.0提出的一个表示资源过期时间的header，它描述的是一个绝对时间，由服务器返回，用GMT格式的字符串表示，如：Expires:Thu, 31 Dec 2037 23:55:55 GMT，它的缓存原理是：</p>\n<p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Expires的header。</p>\n<p>2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来（所以缓存命中的请求返回的header并不是来自服务器，而是来自之前缓存的header）；<br>Expires是较老的强缓存管理header，由于它是服务器返回的一个绝对时间，在服务器时间与客户端时间相差较大时，缓存管理容易出现问题。</p>\n<h3 id=\"Cache-Control：\"><a href=\"#Cache-Control：\" class=\"headerlink\" title=\"Cache-Control：\"></a>Cache-Control：</h3><p>Cache-Control，这是一个相对时间，在配置缓存的时候，以秒为单位，用数值表示</p>\n<h4 id=\"参数：\"><a href=\"#参数：\" class=\"headerlink\" title=\"参数：\"></a>参数：</h4><ul>\n<li>public：所有内容都将被缓存（客户端和代理服务器都可缓存）</li>\n<li>private：所有内容只有客户端可以缓存，Cache-Control的默认取值</li>\n<li>no-cache：客户端缓存内容，但是是否使用缓存则需要经过协商缓存来验证决定</li>\n<li>no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存</li>\n<li>max-age=xxx (xxx is numeric)：缓存内容将在xxx秒后失效</li>\n<li>s-maxage=xxx：代理服务器的缓存时间</li>\n</ul>\n<h3 id=\"缓存原理：\"><a href=\"#缓存原理：\" class=\"headerlink\" title=\"缓存原理：\"></a>缓存原理：</h3><p>1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Cache-Control的header</p>\n<p>2）浏览器在接收到这个资源后，会把这个资源连同所有response header一起缓存下来；</p>\n<p>3）浏览器再请求这个资源时，先从缓存中寻找，找到这个资源后，根据它第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较，如果请求时间在过期时间之前，就能命中缓存，否则就不行。</p>\n<p>4）如果缓存没有命中，浏览器直接从服务器加载资源时，Cache-Control Header在重新加载的时候会被更新。</p>\n<h3 id=\"Cache-Control与Expires不同\"><a href=\"#Cache-Control与Expires不同\" class=\"headerlink\" title=\"Cache-Control与Expires不同\"></a>Cache-Control与Expires不同</h3><p>Cache-Control描述的是一个相对时间，在进行缓存命中的时候，都是利用客户端时间进行判断，所以相比较Expires，Cache-Control的缓存管理更有效，安全一些。</p>\n<h3 id=\"Cache-Control优先级高于Expires。\"><a href=\"#Cache-Control优先级高于Expires。\" class=\"headerlink\" title=\"Cache-Control优先级高于Expires。\"></a>Cache-Control优先级高于Expires。</h3><h3 id=\"启用强制缓存\"><a href=\"#启用强制缓存\" class=\"headerlink\" title=\"启用强制缓存\"></a>启用强制缓存</h3><p>通常有2种方式来设置是否启用强缓存：</p>\n<p>1）通过代码的方式，在web服务器返回的响应中添加Expires和Cache-Control Header；</p>\n<p>2）通过配置web服务器的方式，让web服务器在响应资源的时候统一添加Expires和Cache-Control Header。</p>\n<h3 id=\"from-memory-cache与from-disk-cache\"><a href=\"#from-memory-cache与from-disk-cache\" class=\"headerlink\" title=\"from memory cache与from disk cache\"></a>from memory cache与from disk cache</h3><p>from memory cache代表使用内存中的缓存，from disk cache则代表使用的是硬盘中的缓存，浏览器读取缓存的顺序为memory –&gt; disk。</p>\n<p>对于这个问题，我们需要了解内存缓存(from memory cache)和硬盘缓存(from disk cache)，如下:</p>\n<h4 id=\"内存缓存-from-memory-cache-：\"><a href=\"#内存缓存-from-memory-cache-：\" class=\"headerlink\" title=\"内存缓存(from memory cache)：\"></a>内存缓存(from memory cache)：</h4><p>内存缓存具有两个特点，分别是快速读取和时效性：</p>\n<ul>\n<li><p>快速读取：内存缓存会将编译解析后的文件，直接存入该进程的内存中，占据该进程一定的内存资源，以方便下次运行使用时的快速读取。</p>\n</li>\n<li><p>时效性：一旦该进程关闭，则该进程的内存则会清空。</p>\n</li>\n</ul>\n<h4 id=\"硬盘缓存-from-disk-cache-：\"><a href=\"#硬盘缓存-from-disk-cache-：\" class=\"headerlink\" title=\"硬盘缓存(from disk cache)：\"></a>硬盘缓存(from disk cache)：</h4><p>硬盘缓存则是直接将缓存写入硬盘文件中，读取缓存需要对该缓存存放的硬盘文件进行I/O操作，然后重新解析该缓存内容，读取复杂，速度比内存缓存慢。</p>\n<p>在浏览器中，浏览器会在js和图片等文件解析执行后直接存入内存缓存中，那么当刷新页面时只需直接从内存缓存中读取(from memory cache)；</p>\n<p>而css文件则会存入硬盘文件中，所以每次渲染页面都需要从硬盘读取缓存(from disk cache)。</p>\n<h2 id=\"协商缓存\"><a href=\"#协商缓存\" class=\"headerlink\" title=\"协商缓存\"></a>协商缓存</h2><p>当浏览器对某个资源的请求没有命中强缓存，就会发一个请求到服务器，验证协商缓存是否命中，如果协商缓存命中，请求响应返回的http状态为304并且会显示一个Not Modified的字符串。</p>\n<p>协商缓存是利用的是【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】这两对Header来管理的。</p>\n<h3 id=\"【Last-Modified，If-Modified-Since】\"><a href=\"#【Last-Modified，If-Modified-Since】\" class=\"headerlink\" title=\"【Last-Modified，If-Modified-Since】\"></a>【Last-Modified，If-Modified-Since】</h3><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上Last-Modified的header，这个header表示这个资源在服务器上的最后修改时间。</p>\n<p>浏览器再次跟服务器请求这个资源时，在request的header上加上If-Modified-Since的header，这个header的值就是上一次请求时返回的Last-Modified的值。</p>\n<p>服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 NotModified，但是不会返回资源内容；如果有变化，就正常返回资源内容。当服务器返回304 Not Modified的响应时，response header中不会再添加Last-Modified的header，因为既然资源没有变化，那么Last-Modified也就不会改变，这是服务器返回304时的response header。</p>\n<p>浏览器收到304的响应后，就会从缓存中加载资源。</p>\n<p>如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。</p>\n<h3 id=\"【ETag、If-None-Match】\"><a href=\"#【ETag、If-None-Match】\" class=\"headerlink\" title=\"【ETag、If-None-Match】\"></a>【ETag、If-None-Match】</h3><p>浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在respone的header加上ETag的header，这个header是服务器根据当前请求的资源生成的一个唯一标识，这个唯一标识是一个字符串，只要资源有变化这个串就不同，跟最后修改时间没有关系，所以能很好的补充Last-Modified的问题。</p>\n<p>浏览器再次跟服务器请求这个资源时，在request的header上加上If-None-Match的header，这个header的值就是上一次请求时返回的ETag的值。</p>\n<p>服务器再次收到资源请求时，根据浏览器传过来If-None-Match和然后再根据资源生成一个新的ETag，如果这两个值相同就说明资源没有变化，否则就是有变化；如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回资源内容。与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。<br>浏览器收到304的响应后，就会从缓存中加载资源。</p>\n<h4 id=\"其中Etag-If-None-Match的优先级比Last-Modified-If-Modified-Since高\"><a href=\"#其中Etag-If-None-Match的优先级比Last-Modified-If-Modified-Since高\" class=\"headerlink\" title=\"其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高\"></a>其中Etag / If-None-Match的优先级比Last-Modified / If-Modified-Since高</h4><h4 id=\"注意：\"><a href=\"#注意：\" class=\"headerlink\" title=\"注意：\"></a>注意：</h4><p>【Last-Modified，If-Modified-Since】和【ETag、If-None-Match】一般都是同时启用，这是为了处理Last-Modified不可靠的情况。有一种场景需要注意：</p>\n<p>分布式系统里多台机器间文件的Last-Modified必须保持一致，以免负载均衡到不同机器导致比对失败；</p>\n<p>分布式系统尽量关闭掉ETag(每台机器生成的ETag都会不一样）；</p>\n<h3 id=\"浏览器刷新与缓存方式：\"><a href=\"#浏览器刷新与缓存方式：\" class=\"headerlink\" title=\"浏览器刷新与缓存方式：\"></a>浏览器刷新与缓存方式：</h3><p>当ctrl+f5(command+shift+r)强制刷新网页时，直接从服务器加载，跳过强缓存和协商缓存；<br>当f5(commond+r)刷新网页时，跳过强缓存，但是会检查协商缓存</p>\n<h3 id=\"参考相关内容：\"><a href=\"#参考相关内容：\" class=\"headerlink\" title=\"参考相关内容：\"></a>参考相关内容：</h3><ul>\n<li><p><a href=\"https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s/d2zeGhUptGUGJpB5xHQbOA</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=402202185&amp;idx=3&amp;sn=abbc03511d2c393d7a4867ff532224ab&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=402202185&amp;idx=3&amp;sn=abbc03511d2c393d7a4867ff532224ab&amp;scene=21#wechat_redirect</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651221145&amp;idx=1&amp;sn=ce8cc0dd80142980026eb156d5b1f269&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651221145&amp;idx=1&amp;sn=ce8cc0dd80142980026eb156d5b1f269&amp;scene=21#wechat_redirect</a></p>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226347&amp;idx=1&amp;sn=6dbccc54406f0b075671884b738b1e88&amp;chksm=bd49596f8a3ed079f79cda4b90ac3cb3b1dbdb5bfb8aade962a16a323563bf26a0c75b0a5d7b&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">https://mp.weixin.qq.com/s?__biz=MjM5MTA1MjAxMQ==&amp;mid=2651226347&amp;idx=1&amp;sn=6dbccc54406f0b075671884b738b1e88&amp;chksm=bd49596f8a3ed079f79cda4b90ac3cb3b1dbdb5bfb8aade962a16a323563bf26a0c75b0a5d7b&amp;scene=21#wechat_redirect</a></p>\n</li>\n</ul>\n"},{"title":"视口概念","date":"2019-01-20T14:42:31.000Z","_content":"### 视口\n##### 像素（pixel）\n1. 设备像素：任何屏幕的物理像素数量是固定的\n2. CSS像素：CSS抽象的\n##### 布局视口\n- 概念\n1. CSS中，被称为初始包含块，是所有CSS百分比宽度推算的根源。\n2. PC浏览器布局视口的宽度与浏览器的宽度相同。\n3. 移动端浏览器，布局视口与浏览器屏幕宽度不再相互关联，完全独立。\n- js获取方式\n1. document.documentElement.clientWidth\n2. document.documentElement.clientWidth\n##### 视觉视口\n- 概念\n1. 用户正在看到的网站区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口，布局视口仍会保持原来的宽度。\n2. 移动端视觉视口与设备屏幕一样宽，并且它表示的CSS像素数量会根据缩放改变。\n- js获取方式\n1. window.innerWidth\n2. window.innerHeight\n##### 理想视口\n- 概念\n1. 移动设备上，布局视口的默认宽度不是一个理想的宽度，因此引进理想视口。\n2. 当网站是移动设备使用时理想视口才会生效（meta标签生效）。\n3. 设置布局视口宽度与理想视口宽度一致。\n4. 浏览器厂商决定理想视口。\n```\n<meta name=\"device\" content=\"width=device-width\">\n```\n- js获取方式\n1. screen.width/height 存在严重的兼容性问题，也可能返回浏览器设备像素尺寸。\n##### 视口之间的关系\n1. 桌面浏览器，浏览器窗口就是布局视口。\n2. 手机上，布局视口限制CSS布局，视觉视口决定用户看到的内容。\n3. 理想视口是移动浏览器布局的一个理想尺寸，可以把布局视口尺寸设置为理想视口尺寸，实现响应式布局。\n##### 缩放\n- 缩放行为在手机和桌面上区别很大。\n- 桌面上：\n1. 行为一般是一次性的。\n2. 布局视口会被缩放影响，因为桌面布局视口与视觉视口相同。\n- 移动设备上\n1. 缩放是一个交互过程\n2. 布局视口不会被缩放影响。\n3. 移动端缩放不会导致CSS布局被重新计算。\n4. 移动端浏览器根据理想视口的大小来计算缩放程度。\n5. 拖放\n6. 禁止缩放\n```\n<meta name=\"viewport\" content=\"user-scalable=no\">\n```\n##### 分辨率\n- 物理分辨率\n1. 物理分辨率 = 像素数量 / 英寸单位宽度\n2. 简称DPI\n3. 每英寸像素数量越多显示越清晰\n4. 有些手机可以动过screen.width获取，但是有兼容性问题\n5. 96dpi = 1dppx\n```\n//css使用需要加单位\n@media all and (min-resolution: 192dpi){\n\n}\n```\n- 设备像素比\n1. 设备像素比 = 设备像素个数 / 理想视口\n2. 简称DPR(Device Pixel Ratio)\n3. js属性window.devicePixelRatio\n4. CSS device-pixel-ratio（基于webkit浏览器）和分辨率的媒体查询。\n5. 浏览器厂商决定理想视口，因此DPR也由他们决定。\n6. 单位dppx但是使用时不需要添加。\n7. 96dpi = 1dppx\n```\n//js使用\nif(window.devicePixelRatio>=2){\n\n}\n//css使用\n@media all and (-webkit-min-device-pixel-ratio: 2){\n\n}\n```\n##### meta\n1. width：设置布局视口宽度为特定值。\n2. initial-scale：设置页面初始缩放程度和布局视口的宽度。\n3. minimum-scale\\maximum-scale设置用户最小最大可缩放程度。\n4. user-scalable：是否阻止缩放。\n- 将布局视口设置为设备理想视口\n```\n<meta name=\"viewport\" content=\"width=device-width\">\n```\n- initial-scale\n1. 缩放程度根据理想视口计算。\n2. initial-scale=1时，视觉视口和理想视口尺寸一样。\n3. initial-scale=2时，会放大到200%，此时视觉视口的宽高是理想视口的一半。\n4. 使用initial-scale，同时会将布局视口的尺寸设置为缩放后的尺寸。\n5. initial-scale与width=decice-width效果一样。\n```\n<meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n```\n##### 媒体查询\n- 语法\n1. 媒介类型：media_type: all | aural | braille | handheld | print | projection | screen | tty | tv | embossed\n2. and\n```\n@media tv and (min-width: 700px) and (orientation: landscape) { }\n```\n3. or：使用逗号分隔效果等同于or逻辑操作符\n```\n@media (min-width: 700px), handheld and (orientation: landscape) {}\n```\n4. not：not关键字仅能应用于整个查询，而不能单独应用于一个独立的查询\n```\n//例如\n@media not all and (monochrome) {}\n//等价于\n@media not (all and (monochrome)) {}\n//而不是\n@media (not all) and (monochrome) {}\n```\n```\n@media not screen and (color), print and (color)\n//等价于\n@media (not (screen and (color))), print and (color)\n```\n- [MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries)\n- 媒体查询三种类型：\n1. 媒介查询，是什么类型的设备\n```\n@media print{\n}\n```\n2. 视口相关查询\n```\n//布局视口宽度小于等于400px时生效\n@media all and (max-width: 400){\n}\n```\n```\n//布局视口不超过400px，设备处于横屏，并且devicePixelRatio小于1.5时生效\n@media all and (max-width: 400) and (orientation: potrait) and  ((max-resolution: 144dpi),(-webkit-max-device-pixel-ratio: 1.5)) {}\n```\n3. 特性相关查询，浏览器是否支持某些特性\n```\n@supports ( display: flex ) {\n    .foo { display: flex; }\n}\n```\n\n","source":"_posts/视口概念.md","raw":"---\ntitle: 视口概念\ndate: 2019-01-20 22:42:31\ntags: [视口,h5]\ncategories: 视口\n---\n### 视口\n##### 像素（pixel）\n1. 设备像素：任何屏幕的物理像素数量是固定的\n2. CSS像素：CSS抽象的\n##### 布局视口\n- 概念\n1. CSS中，被称为初始包含块，是所有CSS百分比宽度推算的根源。\n2. PC浏览器布局视口的宽度与浏览器的宽度相同。\n3. 移动端浏览器，布局视口与浏览器屏幕宽度不再相互关联，完全独立。\n- js获取方式\n1. document.documentElement.clientWidth\n2. document.documentElement.clientWidth\n##### 视觉视口\n- 概念\n1. 用户正在看到的网站区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口，布局视口仍会保持原来的宽度。\n2. 移动端视觉视口与设备屏幕一样宽，并且它表示的CSS像素数量会根据缩放改变。\n- js获取方式\n1. window.innerWidth\n2. window.innerHeight\n##### 理想视口\n- 概念\n1. 移动设备上，布局视口的默认宽度不是一个理想的宽度，因此引进理想视口。\n2. 当网站是移动设备使用时理想视口才会生效（meta标签生效）。\n3. 设置布局视口宽度与理想视口宽度一致。\n4. 浏览器厂商决定理想视口。\n```\n<meta name=\"device\" content=\"width=device-width\">\n```\n- js获取方式\n1. screen.width/height 存在严重的兼容性问题，也可能返回浏览器设备像素尺寸。\n##### 视口之间的关系\n1. 桌面浏览器，浏览器窗口就是布局视口。\n2. 手机上，布局视口限制CSS布局，视觉视口决定用户看到的内容。\n3. 理想视口是移动浏览器布局的一个理想尺寸，可以把布局视口尺寸设置为理想视口尺寸，实现响应式布局。\n##### 缩放\n- 缩放行为在手机和桌面上区别很大。\n- 桌面上：\n1. 行为一般是一次性的。\n2. 布局视口会被缩放影响，因为桌面布局视口与视觉视口相同。\n- 移动设备上\n1. 缩放是一个交互过程\n2. 布局视口不会被缩放影响。\n3. 移动端缩放不会导致CSS布局被重新计算。\n4. 移动端浏览器根据理想视口的大小来计算缩放程度。\n5. 拖放\n6. 禁止缩放\n```\n<meta name=\"viewport\" content=\"user-scalable=no\">\n```\n##### 分辨率\n- 物理分辨率\n1. 物理分辨率 = 像素数量 / 英寸单位宽度\n2. 简称DPI\n3. 每英寸像素数量越多显示越清晰\n4. 有些手机可以动过screen.width获取，但是有兼容性问题\n5. 96dpi = 1dppx\n```\n//css使用需要加单位\n@media all and (min-resolution: 192dpi){\n\n}\n```\n- 设备像素比\n1. 设备像素比 = 设备像素个数 / 理想视口\n2. 简称DPR(Device Pixel Ratio)\n3. js属性window.devicePixelRatio\n4. CSS device-pixel-ratio（基于webkit浏览器）和分辨率的媒体查询。\n5. 浏览器厂商决定理想视口，因此DPR也由他们决定。\n6. 单位dppx但是使用时不需要添加。\n7. 96dpi = 1dppx\n```\n//js使用\nif(window.devicePixelRatio>=2){\n\n}\n//css使用\n@media all and (-webkit-min-device-pixel-ratio: 2){\n\n}\n```\n##### meta\n1. width：设置布局视口宽度为特定值。\n2. initial-scale：设置页面初始缩放程度和布局视口的宽度。\n3. minimum-scale\\maximum-scale设置用户最小最大可缩放程度。\n4. user-scalable：是否阻止缩放。\n- 将布局视口设置为设备理想视口\n```\n<meta name=\"viewport\" content=\"width=device-width\">\n```\n- initial-scale\n1. 缩放程度根据理想视口计算。\n2. initial-scale=1时，视觉视口和理想视口尺寸一样。\n3. initial-scale=2时，会放大到200%，此时视觉视口的宽高是理想视口的一半。\n4. 使用initial-scale，同时会将布局视口的尺寸设置为缩放后的尺寸。\n5. initial-scale与width=decice-width效果一样。\n```\n<meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\">\n```\n##### 媒体查询\n- 语法\n1. 媒介类型：media_type: all | aural | braille | handheld | print | projection | screen | tty | tv | embossed\n2. and\n```\n@media tv and (min-width: 700px) and (orientation: landscape) { }\n```\n3. or：使用逗号分隔效果等同于or逻辑操作符\n```\n@media (min-width: 700px), handheld and (orientation: landscape) {}\n```\n4. not：not关键字仅能应用于整个查询，而不能单独应用于一个独立的查询\n```\n//例如\n@media not all and (monochrome) {}\n//等价于\n@media not (all and (monochrome)) {}\n//而不是\n@media (not all) and (monochrome) {}\n```\n```\n@media not screen and (color), print and (color)\n//等价于\n@media (not (screen and (color))), print and (color)\n```\n- [MDN](https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries)\n- 媒体查询三种类型：\n1. 媒介查询，是什么类型的设备\n```\n@media print{\n}\n```\n2. 视口相关查询\n```\n//布局视口宽度小于等于400px时生效\n@media all and (max-width: 400){\n}\n```\n```\n//布局视口不超过400px，设备处于横屏，并且devicePixelRatio小于1.5时生效\n@media all and (max-width: 400) and (orientation: potrait) and  ((max-resolution: 144dpi),(-webkit-max-device-pixel-ratio: 1.5)) {}\n```\n3. 特性相关查询，浏览器是否支持某些特性\n```\n@supports ( display: flex ) {\n    .foo { display: flex; }\n}\n```\n\n","slug":"视口概念","published":1,"updated":"2019-01-20T14:43:19.461Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob7o002ye0jcsdz8vm73","content":"<h3 id=\"视口\"><a href=\"#视口\" class=\"headerlink\" title=\"视口\"></a>视口</h3><h5 id=\"像素（pixel）\"><a href=\"#像素（pixel）\" class=\"headerlink\" title=\"像素（pixel）\"></a>像素（pixel）</h5><ol>\n<li>设备像素：任何屏幕的物理像素数量是固定的</li>\n<li>CSS像素：CSS抽象的<h5 id=\"布局视口\"><a href=\"#布局视口\" class=\"headerlink\" title=\"布局视口\"></a>布局视口</h5></li>\n</ol>\n<ul>\n<li>概念</li>\n</ul>\n<ol>\n<li>CSS中，被称为初始包含块，是所有CSS百分比宽度推算的根源。</li>\n<li>PC浏览器布局视口的宽度与浏览器的宽度相同。</li>\n<li>移动端浏览器，布局视口与浏览器屏幕宽度不再相互关联，完全独立。</li>\n</ol>\n<ul>\n<li>js获取方式</li>\n</ul>\n<ol>\n<li>document.documentElement.clientWidth</li>\n<li>document.documentElement.clientWidth<h5 id=\"视觉视口\"><a href=\"#视觉视口\" class=\"headerlink\" title=\"视觉视口\"></a>视觉视口</h5></li>\n</ol>\n<ul>\n<li>概念</li>\n</ul>\n<ol>\n<li>用户正在看到的网站区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口，布局视口仍会保持原来的宽度。</li>\n<li>移动端视觉视口与设备屏幕一样宽，并且它表示的CSS像素数量会根据缩放改变。</li>\n</ol>\n<ul>\n<li>js获取方式</li>\n</ul>\n<ol>\n<li>window.innerWidth</li>\n<li>window.innerHeight<h5 id=\"理想视口\"><a href=\"#理想视口\" class=\"headerlink\" title=\"理想视口\"></a>理想视口</h5></li>\n</ol>\n<ul>\n<li>概念</li>\n</ul>\n<ol>\n<li>移动设备上，布局视口的默认宽度不是一个理想的宽度，因此引进理想视口。</li>\n<li>当网站是移动设备使用时理想视口才会生效（meta标签生效）。</li>\n<li>设置布局视口宽度与理想视口宽度一致。</li>\n<li>浏览器厂商决定理想视口。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;device&quot; content=&quot;width=device-width&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>js获取方式</li>\n</ul>\n<ol>\n<li>screen.width/height 存在严重的兼容性问题，也可能返回浏览器设备像素尺寸。<h5 id=\"视口之间的关系\"><a href=\"#视口之间的关系\" class=\"headerlink\" title=\"视口之间的关系\"></a>视口之间的关系</h5></li>\n<li>桌面浏览器，浏览器窗口就是布局视口。</li>\n<li>手机上，布局视口限制CSS布局，视觉视口决定用户看到的内容。</li>\n<li>理想视口是移动浏览器布局的一个理想尺寸，可以把布局视口尺寸设置为理想视口尺寸，实现响应式布局。<h5 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h5></li>\n</ol>\n<ul>\n<li>缩放行为在手机和桌面上区别很大。</li>\n<li>桌面上：</li>\n</ul>\n<ol>\n<li>行为一般是一次性的。</li>\n<li>布局视口会被缩放影响，因为桌面布局视口与视觉视口相同。</li>\n</ol>\n<ul>\n<li>移动设备上</li>\n</ul>\n<ol>\n<li>缩放是一个交互过程</li>\n<li>布局视口不会被缩放影响。</li>\n<li>移动端缩放不会导致CSS布局被重新计算。</li>\n<li>移动端浏览器根据理想视口的大小来计算缩放程度。</li>\n<li>拖放</li>\n<li>禁止缩放<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"分辨率\"><a href=\"#分辨率\" class=\"headerlink\" title=\"分辨率\"></a>分辨率</h5><ul>\n<li>物理分辨率</li>\n</ul>\n<ol>\n<li>物理分辨率 = 像素数量 / 英寸单位宽度</li>\n<li>简称DPI</li>\n<li>每英寸像素数量越多显示越清晰</li>\n<li>有些手机可以动过screen.width获取，但是有兼容性问题</li>\n<li>96dpi = 1dppx<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//css使用需要加单位</span><br><span class=\"line\">@media all and (min-resolution: 192dpi)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>设备像素比</li>\n</ul>\n<ol>\n<li>设备像素比 = 设备像素个数 / 理想视口</li>\n<li>简称DPR(Device Pixel Ratio)</li>\n<li>js属性window.devicePixelRatio</li>\n<li>CSS device-pixel-ratio（基于webkit浏览器）和分辨率的媒体查询。</li>\n<li>浏览器厂商决定理想视口，因此DPR也由他们决定。</li>\n<li>单位dppx但是使用时不需要添加。</li>\n<li>96dpi = 1dppx<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//js使用</span><br><span class=\"line\">if(window.devicePixelRatio&gt;=2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//css使用</span><br><span class=\"line\">@media all and (-webkit-min-device-pixel-ratio: 2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"meta\"><a href=\"#meta\" class=\"headerlink\" title=\"meta\"></a>meta</h5><ol>\n<li>width：设置布局视口宽度为特定值。</li>\n<li>initial-scale：设置页面初始缩放程度和布局视口的宽度。</li>\n<li>minimum-scale\\maximum-scale设置用户最小最大可缩放程度。</li>\n<li>user-scalable：是否阻止缩放。</li>\n</ol>\n<ul>\n<li><p>将布局视口设置为设备理想视口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>initial-scale</p>\n</li>\n</ul>\n<ol>\n<li>缩放程度根据理想视口计算。</li>\n<li>initial-scale=1时，视觉视口和理想视口尺寸一样。</li>\n<li>initial-scale=2时，会放大到200%，此时视觉视口的宽高是理想视口的一半。</li>\n<li>使用initial-scale，同时会将布局视口的尺寸设置为缩放后的尺寸。</li>\n<li>initial-scale与width=decice-width效果一样。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"媒体查询\"><a href=\"#媒体查询\" class=\"headerlink\" title=\"媒体查询\"></a>媒体查询</h5><ul>\n<li>语法</li>\n</ul>\n<ol>\n<li>媒介类型：media_type: all | aural | braille | handheld | print | projection | screen | tty | tv | embossed</li>\n<li><p>and</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media tv and (min-width: 700px) and (orientation: landscape) &#123; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>or：使用逗号分隔效果等同于or逻辑操作符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media (min-width: 700px), handheld and (orientation: landscape) &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>not：not关键字仅能应用于整个查询，而不能单独应用于一个独立的查询</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//例如</span><br><span class=\"line\">@media not all and (monochrome) &#123;&#125;</span><br><span class=\"line\">//等价于</span><br><span class=\"line\">@media not (all and (monochrome)) &#123;&#125;</span><br><span class=\"line\">//而不是</span><br><span class=\"line\">@media (not all) and (monochrome) &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media not screen and (color), print and (color)</span><br><span class=\"line\">//等价于</span><br><span class=\"line\">@media (not (screen and (color))), print and (color)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries\" target=\"_blank\" rel=\"noopener\">MDN</a></li>\n<li>媒体查询三种类型：</li>\n</ul>\n<ol>\n<li><p>媒介查询，是什么类型的设备</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media print&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>视口相关查询</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//布局视口宽度小于等于400px时生效</span><br><span class=\"line\">@media all and (max-width: 400)&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//布局视口不超过400px，设备处于横屏，并且devicePixelRatio小于1.5时生效</span><br><span class=\"line\">@media all and (max-width: 400) and (orientation: potrait) and  ((max-resolution: 144dpi),(-webkit-max-device-pixel-ratio: 1.5)) &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>特性相关查询，浏览器是否支持某些特性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@supports ( display: flex ) &#123;</span><br><span class=\"line\">    .foo &#123; display: flex; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"视口\"><a href=\"#视口\" class=\"headerlink\" title=\"视口\"></a>视口</h3><h5 id=\"像素（pixel）\"><a href=\"#像素（pixel）\" class=\"headerlink\" title=\"像素（pixel）\"></a>像素（pixel）</h5><ol>\n<li>设备像素：任何屏幕的物理像素数量是固定的</li>\n<li>CSS像素：CSS抽象的<h5 id=\"布局视口\"><a href=\"#布局视口\" class=\"headerlink\" title=\"布局视口\"></a>布局视口</h5></li>\n</ol>\n<ul>\n<li>概念</li>\n</ul>\n<ol>\n<li>CSS中，被称为初始包含块，是所有CSS百分比宽度推算的根源。</li>\n<li>PC浏览器布局视口的宽度与浏览器的宽度相同。</li>\n<li>移动端浏览器，布局视口与浏览器屏幕宽度不再相互关联，完全独立。</li>\n</ol>\n<ul>\n<li>js获取方式</li>\n</ul>\n<ol>\n<li>document.documentElement.clientWidth</li>\n<li>document.documentElement.clientWidth<h5 id=\"视觉视口\"><a href=\"#视觉视口\" class=\"headerlink\" title=\"视觉视口\"></a>视觉视口</h5></li>\n</ol>\n<ul>\n<li>概念</li>\n</ul>\n<ol>\n<li>用户正在看到的网站区域，用户可以通过缩放操作视觉视口，同时不会影响布局视口，布局视口仍会保持原来的宽度。</li>\n<li>移动端视觉视口与设备屏幕一样宽，并且它表示的CSS像素数量会根据缩放改变。</li>\n</ol>\n<ul>\n<li>js获取方式</li>\n</ul>\n<ol>\n<li>window.innerWidth</li>\n<li>window.innerHeight<h5 id=\"理想视口\"><a href=\"#理想视口\" class=\"headerlink\" title=\"理想视口\"></a>理想视口</h5></li>\n</ol>\n<ul>\n<li>概念</li>\n</ul>\n<ol>\n<li>移动设备上，布局视口的默认宽度不是一个理想的宽度，因此引进理想视口。</li>\n<li>当网站是移动设备使用时理想视口才会生效（meta标签生效）。</li>\n<li>设置布局视口宽度与理想视口宽度一致。</li>\n<li>浏览器厂商决定理想视口。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;device&quot; content=&quot;width=device-width&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>js获取方式</li>\n</ul>\n<ol>\n<li>screen.width/height 存在严重的兼容性问题，也可能返回浏览器设备像素尺寸。<h5 id=\"视口之间的关系\"><a href=\"#视口之间的关系\" class=\"headerlink\" title=\"视口之间的关系\"></a>视口之间的关系</h5></li>\n<li>桌面浏览器，浏览器窗口就是布局视口。</li>\n<li>手机上，布局视口限制CSS布局，视觉视口决定用户看到的内容。</li>\n<li>理想视口是移动浏览器布局的一个理想尺寸，可以把布局视口尺寸设置为理想视口尺寸，实现响应式布局。<h5 id=\"缩放\"><a href=\"#缩放\" class=\"headerlink\" title=\"缩放\"></a>缩放</h5></li>\n</ol>\n<ul>\n<li>缩放行为在手机和桌面上区别很大。</li>\n<li>桌面上：</li>\n</ul>\n<ol>\n<li>行为一般是一次性的。</li>\n<li>布局视口会被缩放影响，因为桌面布局视口与视觉视口相同。</li>\n</ol>\n<ul>\n<li>移动设备上</li>\n</ul>\n<ol>\n<li>缩放是一个交互过程</li>\n<li>布局视口不会被缩放影响。</li>\n<li>移动端缩放不会导致CSS布局被重新计算。</li>\n<li>移动端浏览器根据理想视口的大小来计算缩放程度。</li>\n<li>拖放</li>\n<li>禁止缩放<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"分辨率\"><a href=\"#分辨率\" class=\"headerlink\" title=\"分辨率\"></a>分辨率</h5><ul>\n<li>物理分辨率</li>\n</ul>\n<ol>\n<li>物理分辨率 = 像素数量 / 英寸单位宽度</li>\n<li>简称DPI</li>\n<li>每英寸像素数量越多显示越清晰</li>\n<li>有些手机可以动过screen.width获取，但是有兼容性问题</li>\n<li>96dpi = 1dppx<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//css使用需要加单位</span><br><span class=\"line\">@media all and (min-resolution: 192dpi)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<ul>\n<li>设备像素比</li>\n</ul>\n<ol>\n<li>设备像素比 = 设备像素个数 / 理想视口</li>\n<li>简称DPR(Device Pixel Ratio)</li>\n<li>js属性window.devicePixelRatio</li>\n<li>CSS device-pixel-ratio（基于webkit浏览器）和分辨率的媒体查询。</li>\n<li>浏览器厂商决定理想视口，因此DPR也由他们决定。</li>\n<li>单位dppx但是使用时不需要添加。</li>\n<li>96dpi = 1dppx<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//js使用</span><br><span class=\"line\">if(window.devicePixelRatio&gt;=2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//css使用</span><br><span class=\"line\">@media all and (-webkit-min-device-pixel-ratio: 2)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"meta\"><a href=\"#meta\" class=\"headerlink\" title=\"meta\"></a>meta</h5><ol>\n<li>width：设置布局视口宽度为特定值。</li>\n<li>initial-scale：设置页面初始缩放程度和布局视口的宽度。</li>\n<li>minimum-scale\\maximum-scale设置用户最小最大可缩放程度。</li>\n<li>user-scalable：是否阻止缩放。</li>\n</ol>\n<ul>\n<li><p>将布局视口设置为设备理想视口</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>initial-scale</p>\n</li>\n</ul>\n<ol>\n<li>缩放程度根据理想视口计算。</li>\n<li>initial-scale=1时，视觉视口和理想视口尺寸一样。</li>\n<li>initial-scale=2时，会放大到200%，此时视觉视口的宽高是理想视口的一半。</li>\n<li>使用initial-scale，同时会将布局视口的尺寸设置为缩放后的尺寸。</li>\n<li>initial-scale与width=decice-width效果一样。<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0&quot;&gt;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<h5 id=\"媒体查询\"><a href=\"#媒体查询\" class=\"headerlink\" title=\"媒体查询\"></a>媒体查询</h5><ul>\n<li>语法</li>\n</ul>\n<ol>\n<li>媒介类型：media_type: all | aural | braille | handheld | print | projection | screen | tty | tv | embossed</li>\n<li><p>and</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media tv and (min-width: 700px) and (orientation: landscape) &#123; &#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>or：使用逗号分隔效果等同于or逻辑操作符</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media (min-width: 700px), handheld and (orientation: landscape) &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>not：not关键字仅能应用于整个查询，而不能单独应用于一个独立的查询</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//例如</span><br><span class=\"line\">@media not all and (monochrome) &#123;&#125;</span><br><span class=\"line\">//等价于</span><br><span class=\"line\">@media not (all and (monochrome)) &#123;&#125;</span><br><span class=\"line\">//而不是</span><br><span class=\"line\">@media (not all) and (monochrome) &#123;&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media not screen and (color), print and (color)</span><br><span class=\"line\">//等价于</span><br><span class=\"line\">@media (not (screen and (color))), print and (color)</span><br></pre></td></tr></table></figure>\n<ul>\n<li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Media_queries\" target=\"_blank\" rel=\"noopener\">MDN</a></li>\n<li>媒体查询三种类型：</li>\n</ul>\n<ol>\n<li><p>媒介查询，是什么类型的设备</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@media print&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>视口相关查询</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//布局视口宽度小于等于400px时生效</span><br><span class=\"line\">@media all and (max-width: 400)&#123;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//布局视口不超过400px，设备处于横屏，并且devicePixelRatio小于1.5时生效</span><br><span class=\"line\">@media all and (max-width: 400) and (orientation: potrait) and  ((max-resolution: 144dpi),(-webkit-max-device-pixel-ratio: 1.5)) &#123;&#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>特性相关查询，浏览器是否支持某些特性<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">@supports ( display: flex ) &#123;</span><br><span class=\"line\">    .foo &#123; display: flex; &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ol>\n"},{"title":"ES6-class","date":"2018-08-22T00:12:23.000Z","_content":"\n### 基本的类声明语法\n\n- 注意：类的属性不可以被赋予新值\n\n1. 类声明与let声明类似，不能被提升\n2. 类声明所有代码都将自动运行在严格模式下\n3. 在类中所有方法都不可被枚举，无需通过Object.defineProperty指定\n4. 每个类都有一个[[Construct]]方法,通过new关键字调用不含[[Construct]]方法会报错\n5. 使用除关键字new之外的方式调用类的构造函数会导致程序报错\n\n```\nclass personalClass {\n    constructor(name){\n        //自有属性，不会出现在原型上\n        this.name = name\n    }\n    //等价于personClass.prototype.sayName\n    sayName(){\n        console.log(this.name)\n    }\n}\n```\n\n#### 类的名称\n\n- 类的名称在类中为常量，不能再类的方法中更改但是可以再外部更改\n\n```\nclass Foo {\n    constructor(){\n        Foo = 'bar'//执行时会报错\n    }\n}\nFoo = 'bar'//外部执行不会\n\n// 等价于\nlet Foo1 = (function () {\n    const Foo1 = function (name) {\n        Foo1 = 'bar'\n        this.name = name\n    }\n    Object.defineProperty(Foo1,prototype,'sayName',{\n        value: function () {\n            console.log(this.name)\n        }\n    })\n})()\n\n```\n#### 类表达式\n\n- 类表达式,不需要标识符在类后，除了语法类表达式功能上等价于类声明\n\n```\nlet perClass = class {\n    constructor(){\n    }\n}\n\n```\n\n- 命名类表达式,此时p1Class是const定义，不可更改\n\n```\nlet pClass = class p1Class{\n    constructor(){\n\n    }\n}\n```\n\n- 类可以传入函数，可以从函数返回、并且可以赋值给变量\n\n#### 类立即调用（创建单例）\n\n```\nlet person = new class {\n    constructor(name){\n        this.name = name\n    }\n}('aa')\n```\n\n#### 访问器属性\n\n- 访问器属性，类支持在原型上定义访问器属性\n\n```\nclass getSetClass{\n    constructor(name){\n        this.name = name\n    }\n    get age(){\n\n    }\n    set age(val){\n\n    }\n}\n\n//等价于\nObject.defineProperty(getSetClass.prototype,'age',{\n     get:function () {\n\n     },\n     set:function (val) {\n\n    }\n})\n```\n\n#### 可计算成员名称\n\n```\nlet name = 'aaa'\nclass pp{\n    constructor(){\n\n    }\n    [name](){\n\n    }\n}\n\n```\n\n#### 生成器方法\n\n```\nclass MyClass {\n    *myGenerator(){\n        yield 1\n        yield 2\n    }\n    //定义默认迭代器\n    *[symbol.iterator](){\n        yield 1\n    }\n}\n\n```\n\n#### 静态成员\n\n```\nclass staticClass{\n    constructor(){\n\n    }\n    static create(){\n        return new staticClass()\n    }\n}\n//等价于\nfunction aa() {\n\n}\naa.create = function () {\n    return new aa()\n}\n```\n\n### 继承与派生类\n\n- 继承自其他类的类被称为派生类，如果在派生类中指定了构造函数必须使用super()\n- 如果不使用构造函数，则会自动调用super()并传入所有参数\n- 注意：\n\n1. 只可以在派生类的构造函数中使用super()\n2. 在构造函数访问this之前一定要使用super()，它负责初始化this\n3. 如果不想调用super()唯一的方法是让类的构造函数返回一个对象\n\n```\nclass father {\n    constructor(){\n\n    }\n}\nclass child extends father {\n    constructor(){\n        //等价于father.call(this)\n        super()\n    }\n}\n```\n\n- 类方法遮蔽，派生类中的方法总会覆盖基类的同名方法\n\n```\nclass Super{\n    Fun(){\n\n    }\n}\n\nclass Square extends Super{\n    constructor(){\n        super()\n    }\n    //覆盖并遮蔽基类方法\n    Fun(){\n        //调用基类中的方法，this会被自动正确设置\n        super.Fun()\n    }\n}\n```\n\n- 静态成员继承，如果基类有静态成员，在派生类中也可以使用\n\n#### 派生自表达式的类\n\n```\nfunction bb() {\n\n}\n//bb是一个ES5的构造函数，cc是一个类，由于bb具有[[Construct]]属性和原型，因此可以作为基类\nclass cc extends bb{\n    constructor(){\n        super()\n    }\n}\n```\n\n### mixin\n\n- 首先创建一个base函数，再将每一个mixin的对象属性赋值给base原型\n\n```\nlet m1 = {\n    Fun(){}\n}\nlet m2 = {\n    Fun1(){}\n}\nfunction mixin(...mixins) {\n    var base = function () {\n\n    }\n    Object.assign(base.prototype,...mixins)\n    return base\n}\nclass x extends mixin(m1,m2,){\n\n}\n```\n\n### 内建对象的继承\n\n- ES5,MyArray实际行为与内建Array不一样，因为通过传统JS继承实现的数组继承没有从Array.apply()中活原型中继承相关功能\n\n```\nfunction MyArray() {\n    Array.apply(this,arguments)\n}\nMyArray.prototype = Object.create(Array.prototype,{\n    constructor: {\n        value: MyArray,\n        writable: true,\n        enumerable: false,\n        configurable: true\n    }\n})\nvar colors = new MyArray()\ncolors.push('red')\ncolors.length = 0\nconsole.log(colors)//['red']\n```\n\n#### ES6Class中继承与ES5不同\n\n1. ES5先由派生类创建this，然后调用基类的构造函数，this开始指向的是MyArray的实例，之后被来自Array的其他属性修饰\n2. ES6中继承相反，先由基类创建this值，然后派生类的构造函数再去修改这个值，所以一开始可以通过this调用基类所有的内建功能\n\n```\nclass MyArrayClass extends Array{\n    constructor(){\n        super()\n    }\n}\n```\n\n#### Symbol.species属性\n\n- 如果有一个派生类MyArray继承Array，那么slice()这样的方法返回的数组会继承自MyArray\n- 这是引擎通过Symbol.species属性实现的\n- Symbol.species定义返回函数的静态访问器属性\n- Array\\ArrayBuffer\\Map\\Promise\\RegExp\\Set\\Type arrays都有默认的Symbol.species属性，该属性的返回值为this,也就是总会返回构造函数\n\n```\n//在自定义类中实现Symbol.species\nclass speciesClass {\n    static get [Symbol.species](){\n        return this\n    }\n}\n```\n```\n//在类方法中使用constructor以及Symbol.species\nclass Funnnn{\n    static get [Symbol.species](){\n        //这里返回构造函数,通过定义返回的构造函数，可以改变继承时clone的实例类型\n        return this\n    }\n    constructor(value){\n        this.value = value\n    }\n    clone(){\n        //this.constructor指向Funnn构造函数（类）\n        return new this.constructor[Symbol.species](this.value)\n    }\n}\nlet ff = new Funnnn(11)\nff.clone()\n```\n\n#### new.target\n\n- 在构造函数中使用new.target\n- 简单情况下new.target等于构造函数\n- 类构造函数必须通过new关键字调用\n- 可以使用new.target创造一个抽象基类（不能被直接实例化的类）\n\n```\nclass baseClass {\n    constructor(){\n        if(new.target === baseClass){\n            throw new Error('不能被直接实例化')\n        }\n    }\n}\n```\n","source":"_posts/ES6-class.md","raw":"---\ntitle: ES6-class\ndate: 2018-08-22 08:12:23\ntags: [ES6,js]\ncategories: ES6\n---\n\n### 基本的类声明语法\n\n- 注意：类的属性不可以被赋予新值\n\n1. 类声明与let声明类似，不能被提升\n2. 类声明所有代码都将自动运行在严格模式下\n3. 在类中所有方法都不可被枚举，无需通过Object.defineProperty指定\n4. 每个类都有一个[[Construct]]方法,通过new关键字调用不含[[Construct]]方法会报错\n5. 使用除关键字new之外的方式调用类的构造函数会导致程序报错\n\n```\nclass personalClass {\n    constructor(name){\n        //自有属性，不会出现在原型上\n        this.name = name\n    }\n    //等价于personClass.prototype.sayName\n    sayName(){\n        console.log(this.name)\n    }\n}\n```\n\n#### 类的名称\n\n- 类的名称在类中为常量，不能再类的方法中更改但是可以再外部更改\n\n```\nclass Foo {\n    constructor(){\n        Foo = 'bar'//执行时会报错\n    }\n}\nFoo = 'bar'//外部执行不会\n\n// 等价于\nlet Foo1 = (function () {\n    const Foo1 = function (name) {\n        Foo1 = 'bar'\n        this.name = name\n    }\n    Object.defineProperty(Foo1,prototype,'sayName',{\n        value: function () {\n            console.log(this.name)\n        }\n    })\n})()\n\n```\n#### 类表达式\n\n- 类表达式,不需要标识符在类后，除了语法类表达式功能上等价于类声明\n\n```\nlet perClass = class {\n    constructor(){\n    }\n}\n\n```\n\n- 命名类表达式,此时p1Class是const定义，不可更改\n\n```\nlet pClass = class p1Class{\n    constructor(){\n\n    }\n}\n```\n\n- 类可以传入函数，可以从函数返回、并且可以赋值给变量\n\n#### 类立即调用（创建单例）\n\n```\nlet person = new class {\n    constructor(name){\n        this.name = name\n    }\n}('aa')\n```\n\n#### 访问器属性\n\n- 访问器属性，类支持在原型上定义访问器属性\n\n```\nclass getSetClass{\n    constructor(name){\n        this.name = name\n    }\n    get age(){\n\n    }\n    set age(val){\n\n    }\n}\n\n//等价于\nObject.defineProperty(getSetClass.prototype,'age',{\n     get:function () {\n\n     },\n     set:function (val) {\n\n    }\n})\n```\n\n#### 可计算成员名称\n\n```\nlet name = 'aaa'\nclass pp{\n    constructor(){\n\n    }\n    [name](){\n\n    }\n}\n\n```\n\n#### 生成器方法\n\n```\nclass MyClass {\n    *myGenerator(){\n        yield 1\n        yield 2\n    }\n    //定义默认迭代器\n    *[symbol.iterator](){\n        yield 1\n    }\n}\n\n```\n\n#### 静态成员\n\n```\nclass staticClass{\n    constructor(){\n\n    }\n    static create(){\n        return new staticClass()\n    }\n}\n//等价于\nfunction aa() {\n\n}\naa.create = function () {\n    return new aa()\n}\n```\n\n### 继承与派生类\n\n- 继承自其他类的类被称为派生类，如果在派生类中指定了构造函数必须使用super()\n- 如果不使用构造函数，则会自动调用super()并传入所有参数\n- 注意：\n\n1. 只可以在派生类的构造函数中使用super()\n2. 在构造函数访问this之前一定要使用super()，它负责初始化this\n3. 如果不想调用super()唯一的方法是让类的构造函数返回一个对象\n\n```\nclass father {\n    constructor(){\n\n    }\n}\nclass child extends father {\n    constructor(){\n        //等价于father.call(this)\n        super()\n    }\n}\n```\n\n- 类方法遮蔽，派生类中的方法总会覆盖基类的同名方法\n\n```\nclass Super{\n    Fun(){\n\n    }\n}\n\nclass Square extends Super{\n    constructor(){\n        super()\n    }\n    //覆盖并遮蔽基类方法\n    Fun(){\n        //调用基类中的方法，this会被自动正确设置\n        super.Fun()\n    }\n}\n```\n\n- 静态成员继承，如果基类有静态成员，在派生类中也可以使用\n\n#### 派生自表达式的类\n\n```\nfunction bb() {\n\n}\n//bb是一个ES5的构造函数，cc是一个类，由于bb具有[[Construct]]属性和原型，因此可以作为基类\nclass cc extends bb{\n    constructor(){\n        super()\n    }\n}\n```\n\n### mixin\n\n- 首先创建一个base函数，再将每一个mixin的对象属性赋值给base原型\n\n```\nlet m1 = {\n    Fun(){}\n}\nlet m2 = {\n    Fun1(){}\n}\nfunction mixin(...mixins) {\n    var base = function () {\n\n    }\n    Object.assign(base.prototype,...mixins)\n    return base\n}\nclass x extends mixin(m1,m2,){\n\n}\n```\n\n### 内建对象的继承\n\n- ES5,MyArray实际行为与内建Array不一样，因为通过传统JS继承实现的数组继承没有从Array.apply()中活原型中继承相关功能\n\n```\nfunction MyArray() {\n    Array.apply(this,arguments)\n}\nMyArray.prototype = Object.create(Array.prototype,{\n    constructor: {\n        value: MyArray,\n        writable: true,\n        enumerable: false,\n        configurable: true\n    }\n})\nvar colors = new MyArray()\ncolors.push('red')\ncolors.length = 0\nconsole.log(colors)//['red']\n```\n\n#### ES6Class中继承与ES5不同\n\n1. ES5先由派生类创建this，然后调用基类的构造函数，this开始指向的是MyArray的实例，之后被来自Array的其他属性修饰\n2. ES6中继承相反，先由基类创建this值，然后派生类的构造函数再去修改这个值，所以一开始可以通过this调用基类所有的内建功能\n\n```\nclass MyArrayClass extends Array{\n    constructor(){\n        super()\n    }\n}\n```\n\n#### Symbol.species属性\n\n- 如果有一个派生类MyArray继承Array，那么slice()这样的方法返回的数组会继承自MyArray\n- 这是引擎通过Symbol.species属性实现的\n- Symbol.species定义返回函数的静态访问器属性\n- Array\\ArrayBuffer\\Map\\Promise\\RegExp\\Set\\Type arrays都有默认的Symbol.species属性，该属性的返回值为this,也就是总会返回构造函数\n\n```\n//在自定义类中实现Symbol.species\nclass speciesClass {\n    static get [Symbol.species](){\n        return this\n    }\n}\n```\n```\n//在类方法中使用constructor以及Symbol.species\nclass Funnnn{\n    static get [Symbol.species](){\n        //这里返回构造函数,通过定义返回的构造函数，可以改变继承时clone的实例类型\n        return this\n    }\n    constructor(value){\n        this.value = value\n    }\n    clone(){\n        //this.constructor指向Funnn构造函数（类）\n        return new this.constructor[Symbol.species](this.value)\n    }\n}\nlet ff = new Funnnn(11)\nff.clone()\n```\n\n#### new.target\n\n- 在构造函数中使用new.target\n- 简单情况下new.target等于构造函数\n- 类构造函数必须通过new关键字调用\n- 可以使用new.target创造一个抽象基类（不能被直接实例化的类）\n\n```\nclass baseClass {\n    constructor(){\n        if(new.target === baseClass){\n            throw new Error('不能被直接实例化')\n        }\n    }\n}\n```\n","slug":"ES6-class","published":1,"updated":"2019-02-16T07:17:04.811Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjs76ob7u0032e0jc7mkgblze","content":"<h3 id=\"基本的类声明语法\"><a href=\"#基本的类声明语法\" class=\"headerlink\" title=\"基本的类声明语法\"></a>基本的类声明语法</h3><ul>\n<li>注意：类的属性不可以被赋予新值</li>\n</ul>\n<ol>\n<li>类声明与let声明类似，不能被提升</li>\n<li>类声明所有代码都将自动运行在严格模式下</li>\n<li>在类中所有方法都不可被枚举，无需通过Object.defineProperty指定</li>\n<li>每个类都有一个[[Construct]]方法,通过new关键字调用不含[[Construct]]方法会报错</li>\n<li>使用除关键字new之外的方式调用类的构造函数会导致程序报错</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class personalClass &#123;</span><br><span class=\"line\">    constructor(name)&#123;</span><br><span class=\"line\">        //自有属性，不会出现在原型上</span><br><span class=\"line\">        this.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //等价于personClass.prototype.sayName</span><br><span class=\"line\">    sayName()&#123;</span><br><span class=\"line\">        console.log(this.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"类的名称\"><a href=\"#类的名称\" class=\"headerlink\" title=\"类的名称\"></a>类的名称</h4><ul>\n<li>类的名称在类中为常量，不能再类的方法中更改但是可以再外部更改</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        Foo = &apos;bar&apos;//执行时会报错</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo = &apos;bar&apos;//外部执行不会</span><br><span class=\"line\"></span><br><span class=\"line\">// 等价于</span><br><span class=\"line\">let Foo1 = (function () &#123;</span><br><span class=\"line\">    const Foo1 = function (name) &#123;</span><br><span class=\"line\">        Foo1 = &apos;bar&apos;</span><br><span class=\"line\">        this.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Object.defineProperty(Foo1,prototype,&apos;sayName&apos;,&#123;</span><br><span class=\"line\">        value: function () &#123;</span><br><span class=\"line\">            console.log(this.name)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<h4 id=\"类表达式\"><a href=\"#类表达式\" class=\"headerlink\" title=\"类表达式\"></a>类表达式</h4><ul>\n<li>类表达式,不需要标识符在类后，除了语法类表达式功能上等价于类声明</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let perClass = class &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>命名类表达式,此时p1Class是const定义，不可更改</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let pClass = class p1Class&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类可以传入函数，可以从函数返回、并且可以赋值给变量</li>\n</ul>\n<h4 id=\"类立即调用（创建单例）\"><a href=\"#类立即调用（创建单例）\" class=\"headerlink\" title=\"类立即调用（创建单例）\"></a>类立即调用（创建单例）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let person = new class &#123;</span><br><span class=\"line\">    constructor(name)&#123;</span><br><span class=\"line\">        this.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(&apos;aa&apos;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"访问器属性\"><a href=\"#访问器属性\" class=\"headerlink\" title=\"访问器属性\"></a>访问器属性</h4><ul>\n<li>访问器属性，类支持在原型上定义访问器属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class getSetClass&#123;</span><br><span class=\"line\">    constructor(name)&#123;</span><br><span class=\"line\">        this.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    get age()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    set age(val)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//等价于</span><br><span class=\"line\">Object.defineProperty(getSetClass.prototype,&apos;age&apos;,&#123;</span><br><span class=\"line\">     get:function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     set:function (val) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"可计算成员名称\"><a href=\"#可计算成员名称\" class=\"headerlink\" title=\"可计算成员名称\"></a>可计算成员名称</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = &apos;aaa&apos;</span><br><span class=\"line\">class pp&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [name]()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"生成器方法\"><a href=\"#生成器方法\" class=\"headerlink\" title=\"生成器方法\"></a>生成器方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyClass &#123;</span><br><span class=\"line\">    *myGenerator()&#123;</span><br><span class=\"line\">        yield 1</span><br><span class=\"line\">        yield 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //定义默认迭代器</span><br><span class=\"line\">    *[symbol.iterator]()&#123;</span><br><span class=\"line\">        yield 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"静态成员\"><a href=\"#静态成员\" class=\"headerlink\" title=\"静态成员\"></a>静态成员</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class staticClass&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static create()&#123;</span><br><span class=\"line\">        return new staticClass()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//等价于</span><br><span class=\"line\">function aa() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">aa.create = function () &#123;</span><br><span class=\"line\">    return new aa()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"继承与派生类\"><a href=\"#继承与派生类\" class=\"headerlink\" title=\"继承与派生类\"></a>继承与派生类</h3><ul>\n<li>继承自其他类的类被称为派生类，如果在派生类中指定了构造函数必须使用super()</li>\n<li>如果不使用构造函数，则会自动调用super()并传入所有参数</li>\n<li>注意：</li>\n</ul>\n<ol>\n<li>只可以在派生类的构造函数中使用super()</li>\n<li>在构造函数访问this之前一定要使用super()，它负责初始化this</li>\n<li>如果不想调用super()唯一的方法是让类的构造函数返回一个对象</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class father &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class child extends father &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        //等价于father.call(this)</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类方法遮蔽，派生类中的方法总会覆盖基类的同名方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Super&#123;</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Square extends Super&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //覆盖并遮蔽基类方法</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        //调用基类中的方法，this会被自动正确设置</span><br><span class=\"line\">        super.Fun()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>静态成员继承，如果基类有静态成员，在派生类中也可以使用</li>\n</ul>\n<h4 id=\"派生自表达式的类\"><a href=\"#派生自表达式的类\" class=\"headerlink\" title=\"派生自表达式的类\"></a>派生自表达式的类</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bb() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//bb是一个ES5的构造函数，cc是一个类，由于bb具有[[Construct]]属性和原型，因此可以作为基类</span><br><span class=\"line\">class cc extends bb&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"mixin\"><a href=\"#mixin\" class=\"headerlink\" title=\"mixin\"></a>mixin</h3><ul>\n<li>首先创建一个base函数，再将每一个mixin的对象属性赋值给base原型</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let m1 = &#123;</span><br><span class=\"line\">    Fun()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let m2 = &#123;</span><br><span class=\"line\">    Fun1()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function mixin(...mixins) &#123;</span><br><span class=\"line\">    var base = function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Object.assign(base.prototype,...mixins)</span><br><span class=\"line\">    return base</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class x extends mixin(m1,m2,)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内建对象的继承\"><a href=\"#内建对象的继承\" class=\"headerlink\" title=\"内建对象的继承\"></a>内建对象的继承</h3><ul>\n<li>ES5,MyArray实际行为与内建Array不一样，因为通过传统JS继承实现的数组继承没有从Array.apply()中活原型中继承相关功能</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MyArray() &#123;</span><br><span class=\"line\">    Array.apply(this,arguments)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyArray.prototype = Object.create(Array.prototype,&#123;</span><br><span class=\"line\">    constructor: &#123;</span><br><span class=\"line\">        value: MyArray,</span><br><span class=\"line\">        writable: true,</span><br><span class=\"line\">        enumerable: false,</span><br><span class=\"line\">        configurable: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">var colors = new MyArray()</span><br><span class=\"line\">colors.push(&apos;red&apos;)</span><br><span class=\"line\">colors.length = 0</span><br><span class=\"line\">console.log(colors)//[&apos;red&apos;]</span><br></pre></td></tr></table></figure>\n<h4 id=\"ES6Class中继承与ES5不同\"><a href=\"#ES6Class中继承与ES5不同\" class=\"headerlink\" title=\"ES6Class中继承与ES5不同\"></a>ES6Class中继承与ES5不同</h4><ol>\n<li>ES5先由派生类创建this，然后调用基类的构造函数，this开始指向的是MyArray的实例，之后被来自Array的其他属性修饰</li>\n<li>ES6中继承相反，先由基类创建this值，然后派生类的构造函数再去修改这个值，所以一开始可以通过this调用基类所有的内建功能</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyArrayClass extends Array&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Symbol-species属性\"><a href=\"#Symbol-species属性\" class=\"headerlink\" title=\"Symbol.species属性\"></a>Symbol.species属性</h4><ul>\n<li>如果有一个派生类MyArray继承Array，那么slice()这样的方法返回的数组会继承自MyArray</li>\n<li>这是引擎通过Symbol.species属性实现的</li>\n<li>Symbol.species定义返回函数的静态访问器属性</li>\n<li>Array\\ArrayBuffer\\Map\\Promise\\RegExp\\Set\\Type arrays都有默认的Symbol.species属性，该属性的返回值为this,也就是总会返回构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在自定义类中实现Symbol.species</span><br><span class=\"line\">class speciesClass &#123;</span><br><span class=\"line\">    static get [Symbol.species]()&#123;</span><br><span class=\"line\">        return this</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在类方法中使用constructor以及Symbol.species</span><br><span class=\"line\">class Funnnn&#123;</span><br><span class=\"line\">    static get [Symbol.species]()&#123;</span><br><span class=\"line\">        //这里返回构造函数,通过定义返回的构造函数，可以改变继承时clone的实例类型</span><br><span class=\"line\">        return this</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    constructor(value)&#123;</span><br><span class=\"line\">        this.value = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    clone()&#123;</span><br><span class=\"line\">        //this.constructor指向Funnn构造函数（类）</span><br><span class=\"line\">        return new this.constructor[Symbol.species](this.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let ff = new Funnnn(11)</span><br><span class=\"line\">ff.clone()</span><br></pre></td></tr></table></figure>\n<h4 id=\"new-target\"><a href=\"#new-target\" class=\"headerlink\" title=\"new.target\"></a>new.target</h4><ul>\n<li>在构造函数中使用new.target</li>\n<li>简单情况下new.target等于构造函数</li>\n<li>类构造函数必须通过new关键字调用</li>\n<li>可以使用new.target创造一个抽象基类（不能被直接实例化的类）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class baseClass &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        if(new.target === baseClass)&#123;</span><br><span class=\"line\">            throw new Error(&apos;不能被直接实例化&apos;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"基本的类声明语法\"><a href=\"#基本的类声明语法\" class=\"headerlink\" title=\"基本的类声明语法\"></a>基本的类声明语法</h3><ul>\n<li>注意：类的属性不可以被赋予新值</li>\n</ul>\n<ol>\n<li>类声明与let声明类似，不能被提升</li>\n<li>类声明所有代码都将自动运行在严格模式下</li>\n<li>在类中所有方法都不可被枚举，无需通过Object.defineProperty指定</li>\n<li>每个类都有一个[[Construct]]方法,通过new关键字调用不含[[Construct]]方法会报错</li>\n<li>使用除关键字new之外的方式调用类的构造函数会导致程序报错</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class personalClass &#123;</span><br><span class=\"line\">    constructor(name)&#123;</span><br><span class=\"line\">        //自有属性，不会出现在原型上</span><br><span class=\"line\">        this.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //等价于personClass.prototype.sayName</span><br><span class=\"line\">    sayName()&#123;</span><br><span class=\"line\">        console.log(this.name)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"类的名称\"><a href=\"#类的名称\" class=\"headerlink\" title=\"类的名称\"></a>类的名称</h4><ul>\n<li>类的名称在类中为常量，不能再类的方法中更改但是可以再外部更改</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Foo &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        Foo = &apos;bar&apos;//执行时会报错</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">Foo = &apos;bar&apos;//外部执行不会</span><br><span class=\"line\"></span><br><span class=\"line\">// 等价于</span><br><span class=\"line\">let Foo1 = (function () &#123;</span><br><span class=\"line\">    const Foo1 = function (name) &#123;</span><br><span class=\"line\">        Foo1 = &apos;bar&apos;</span><br><span class=\"line\">        this.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Object.defineProperty(Foo1,prototype,&apos;sayName&apos;,&#123;</span><br><span class=\"line\">        value: function () &#123;</span><br><span class=\"line\">            console.log(this.name)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;)</span><br><span class=\"line\">&#125;)()</span><br></pre></td></tr></table></figure>\n<h4 id=\"类表达式\"><a href=\"#类表达式\" class=\"headerlink\" title=\"类表达式\"></a>类表达式</h4><ul>\n<li>类表达式,不需要标识符在类后，除了语法类表达式功能上等价于类声明</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let perClass = class &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>命名类表达式,此时p1Class是const定义，不可更改</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let pClass = class p1Class&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类可以传入函数，可以从函数返回、并且可以赋值给变量</li>\n</ul>\n<h4 id=\"类立即调用（创建单例）\"><a href=\"#类立即调用（创建单例）\" class=\"headerlink\" title=\"类立即调用（创建单例）\"></a>类立即调用（创建单例）</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let person = new class &#123;</span><br><span class=\"line\">    constructor(name)&#123;</span><br><span class=\"line\">        this.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;(&apos;aa&apos;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"访问器属性\"><a href=\"#访问器属性\" class=\"headerlink\" title=\"访问器属性\"></a>访问器属性</h4><ul>\n<li>访问器属性，类支持在原型上定义访问器属性</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class getSetClass&#123;</span><br><span class=\"line\">    constructor(name)&#123;</span><br><span class=\"line\">        this.name = name</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    get age()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    set age(val)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//等价于</span><br><span class=\"line\">Object.defineProperty(getSetClass.prototype,&apos;age&apos;,&#123;</span><br><span class=\"line\">     get:function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">     &#125;,</span><br><span class=\"line\">     set:function (val) &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br></pre></td></tr></table></figure>\n<h4 id=\"可计算成员名称\"><a href=\"#可计算成员名称\" class=\"headerlink\" title=\"可计算成员名称\"></a>可计算成员名称</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let name = &apos;aaa&apos;</span><br><span class=\"line\">class pp&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    [name]()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"生成器方法\"><a href=\"#生成器方法\" class=\"headerlink\" title=\"生成器方法\"></a>生成器方法</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyClass &#123;</span><br><span class=\"line\">    *myGenerator()&#123;</span><br><span class=\"line\">        yield 1</span><br><span class=\"line\">        yield 2</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //定义默认迭代器</span><br><span class=\"line\">    *[symbol.iterator]()&#123;</span><br><span class=\"line\">        yield 1</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"静态成员\"><a href=\"#静态成员\" class=\"headerlink\" title=\"静态成员\"></a>静态成员</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class staticClass&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    static create()&#123;</span><br><span class=\"line\">        return new staticClass()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//等价于</span><br><span class=\"line\">function aa() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">aa.create = function () &#123;</span><br><span class=\"line\">    return new aa()</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"继承与派生类\"><a href=\"#继承与派生类\" class=\"headerlink\" title=\"继承与派生类\"></a>继承与派生类</h3><ul>\n<li>继承自其他类的类被称为派生类，如果在派生类中指定了构造函数必须使用super()</li>\n<li>如果不使用构造函数，则会自动调用super()并传入所有参数</li>\n<li>注意：</li>\n</ul>\n<ol>\n<li>只可以在派生类的构造函数中使用super()</li>\n<li>在构造函数访问this之前一定要使用super()，它负责初始化this</li>\n<li>如果不想调用super()唯一的方法是让类的构造函数返回一个对象</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class father &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class child extends father &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        //等价于father.call(this)</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>类方法遮蔽，派生类中的方法总会覆盖基类的同名方法</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Super&#123;</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">class Square extends Super&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    //覆盖并遮蔽基类方法</span><br><span class=\"line\">    Fun()&#123;</span><br><span class=\"line\">        //调用基类中的方法，this会被自动正确设置</span><br><span class=\"line\">        super.Fun()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>静态成员继承，如果基类有静态成员，在派生类中也可以使用</li>\n</ul>\n<h4 id=\"派生自表达式的类\"><a href=\"#派生自表达式的类\" class=\"headerlink\" title=\"派生自表达式的类\"></a>派生自表达式的类</h4><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function bb() &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\">//bb是一个ES5的构造函数，cc是一个类，由于bb具有[[Construct]]属性和原型，因此可以作为基类</span><br><span class=\"line\">class cc extends bb&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"mixin\"><a href=\"#mixin\" class=\"headerlink\" title=\"mixin\"></a>mixin</h3><ul>\n<li>首先创建一个base函数，再将每一个mixin的对象属性赋值给base原型</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">let m1 = &#123;</span><br><span class=\"line\">    Fun()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let m2 = &#123;</span><br><span class=\"line\">    Fun1()&#123;&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">function mixin(...mixins) &#123;</span><br><span class=\"line\">    var base = function () &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    Object.assign(base.prototype,...mixins)</span><br><span class=\"line\">    return base</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">class x extends mixin(m1,m2,)&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"内建对象的继承\"><a href=\"#内建对象的继承\" class=\"headerlink\" title=\"内建对象的继承\"></a>内建对象的继承</h3><ul>\n<li>ES5,MyArray实际行为与内建Array不一样，因为通过传统JS继承实现的数组继承没有从Array.apply()中活原型中继承相关功能</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">function MyArray() &#123;</span><br><span class=\"line\">    Array.apply(this,arguments)</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">MyArray.prototype = Object.create(Array.prototype,&#123;</span><br><span class=\"line\">    constructor: &#123;</span><br><span class=\"line\">        value: MyArray,</span><br><span class=\"line\">        writable: true,</span><br><span class=\"line\">        enumerable: false,</span><br><span class=\"line\">        configurable: true</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;)</span><br><span class=\"line\">var colors = new MyArray()</span><br><span class=\"line\">colors.push(&apos;red&apos;)</span><br><span class=\"line\">colors.length = 0</span><br><span class=\"line\">console.log(colors)//[&apos;red&apos;]</span><br></pre></td></tr></table></figure>\n<h4 id=\"ES6Class中继承与ES5不同\"><a href=\"#ES6Class中继承与ES5不同\" class=\"headerlink\" title=\"ES6Class中继承与ES5不同\"></a>ES6Class中继承与ES5不同</h4><ol>\n<li>ES5先由派生类创建this，然后调用基类的构造函数，this开始指向的是MyArray的实例，之后被来自Array的其他属性修饰</li>\n<li>ES6中继承相反，先由基类创建this值，然后派生类的构造函数再去修改这个值，所以一开始可以通过this调用基类所有的内建功能</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class MyArrayClass extends Array&#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        super()</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h4 id=\"Symbol-species属性\"><a href=\"#Symbol-species属性\" class=\"headerlink\" title=\"Symbol.species属性\"></a>Symbol.species属性</h4><ul>\n<li>如果有一个派生类MyArray继承Array，那么slice()这样的方法返回的数组会继承自MyArray</li>\n<li>这是引擎通过Symbol.species属性实现的</li>\n<li>Symbol.species定义返回函数的静态访问器属性</li>\n<li>Array\\ArrayBuffer\\Map\\Promise\\RegExp\\Set\\Type arrays都有默认的Symbol.species属性，该属性的返回值为this,也就是总会返回构造函数</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在自定义类中实现Symbol.species</span><br><span class=\"line\">class speciesClass &#123;</span><br><span class=\"line\">    static get [Symbol.species]()&#123;</span><br><span class=\"line\">        return this</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">//在类方法中使用constructor以及Symbol.species</span><br><span class=\"line\">class Funnnn&#123;</span><br><span class=\"line\">    static get [Symbol.species]()&#123;</span><br><span class=\"line\">        //这里返回构造函数,通过定义返回的构造函数，可以改变继承时clone的实例类型</span><br><span class=\"line\">        return this</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    constructor(value)&#123;</span><br><span class=\"line\">        this.value = value</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    clone()&#123;</span><br><span class=\"line\">        //this.constructor指向Funnn构造函数（类）</span><br><span class=\"line\">        return new this.constructor[Symbol.species](this.value)</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">let ff = new Funnnn(11)</span><br><span class=\"line\">ff.clone()</span><br></pre></td></tr></table></figure>\n<h4 id=\"new-target\"><a href=\"#new-target\" class=\"headerlink\" title=\"new.target\"></a>new.target</h4><ul>\n<li>在构造函数中使用new.target</li>\n<li>简单情况下new.target等于构造函数</li>\n<li>类构造函数必须通过new关键字调用</li>\n<li>可以使用new.target创造一个抽象基类（不能被直接实例化的类）</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class baseClass &#123;</span><br><span class=\"line\">    constructor()&#123;</span><br><span class=\"line\">        if(new.target === baseClass)&#123;</span><br><span class=\"line\">            throw new Error(&apos;不能被直接实例化&apos;)</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjs76ob5i0001e0jc44h6xkoy","category_id":"cjs76ob5o0003e0jc68t9xvtj","_id":"cjs76ob60000de0jcg7ti95fb"},{"post_id":"cjs76ob5u0007e0jcbh4wx8vn","category_id":"cjs76ob5o0003e0jc68t9xvtj","_id":"cjs76ob64000he0jcpfp8rthd"},{"post_id":"cjs76ob5x000ae0jcp2bpmumw","category_id":"cjs76ob5o0003e0jc68t9xvtj","_id":"cjs76ob68000le0jcthj49rbr"},{"post_id":"cjs76ob5m0002e0jcsucih7ex","category_id":"cjs76ob5o0003e0jc68t9xvtj","_id":"cjs76ob6d000pe0jcrj5hxogm"},{"post_id":"cjs76ob5z000be0jc7eqa6hbh","category_id":"cjs76ob5o0003e0jc68t9xvtj","_id":"cjs76ob6e000se0jc0aas95oz"},{"post_id":"cjs76ob62000ge0jctjlj01x5","category_id":"cjs76ob5o0003e0jc68t9xvtj","_id":"cjs76ob6h000we0jcsgr59wcf"},{"post_id":"cjs76ob5r0005e0jcfzoe92kv","category_id":"cjs76ob5o0003e0jc68t9xvtj","_id":"cjs76ob6i000ze0jcwssb8z6c"},{"post_id":"cjs76ob66000je0jcfu5lhax7","category_id":"cjs76ob5o0003e0jc68t9xvtj","_id":"cjs76ob6k0013e0jc4wlbo4b0"},{"post_id":"cjs76ob6a000oe0jcxyxf84o9","category_id":"cjs76ob5o0003e0jc68t9xvtj","_id":"cjs76ob6n0017e0jc5p0b49zp"},{"post_id":"cjs76ob5t0006e0jcpjpenub7","category_id":"cjs76ob67000ke0jc9nb75uwk","_id":"cjs76ob6p001be0jc335iw5nf"},{"post_id":"cjs76ob6d000re0jcpvg66g2s","category_id":"cjs76ob5o0003e0jc68t9xvtj","_id":"cjs76ob6r001fe0jca4hy2kpc"},{"post_id":"cjs76ob6g000ve0jcj0myw39o","category_id":"cjs76ob5o0003e0jc68t9xvtj","_id":"cjs76ob6x001je0jcmn94ln3h"},{"post_id":"cjs76ob6k0012e0jc0emmflez","category_id":"cjs76ob67000ke0jc9nb75uwk","_id":"cjs76ob6z001me0jc1wr31amr"},{"post_id":"cjs76ob6p001ae0jcltsrf5aw","category_id":"cjs76ob67000ke0jc9nb75uwk","_id":"cjs76ob71001re0jcjkadn0b8"},{"post_id":"cjs76ob6h000ye0jcecm6hop3","category_id":"cjs76ob6l0014e0jcvho69une","_id":"cjs76ob73001ue0jcct9ezq7z"},{"post_id":"cjs76ob6u001ie0jcnhfso1ss","category_id":"cjs76ob67000ke0jc9nb75uwk","_id":"cjs76ob74001ye0jc6gdd00s2"},{"post_id":"cjs76ob6m0016e0jcgow1kvhv","category_id":"cjs76ob6r001ee0jc7noxkkdi","_id":"cjs76ob770022e0jc4d8awbag"},{"post_id":"cjs76ob6y001le0jclgn7ur0n","category_id":"cjs76ob67000ke0jc9nb75uwk","_id":"cjs76ob780026e0jczc7cb12t"},{"post_id":"cjs76ob70001qe0jcso5e1b04","category_id":"cjs76ob67000ke0jc9nb75uwk","_id":"cjs76ob7b002ae0jch13n1j2s"},{"post_id":"cjs76ob6q001de0jctpy14fim","category_id":"cjs76ob6z001ne0jccseby8bb","_id":"cjs76ob7d002de0jc5jnvmpry"},{"post_id":"cjs76ob72001te0jc4jhoadtd","category_id":"cjs76ob75001ze0jcas9wftto","_id":"cjs76ob7f002he0jcx5f6mk7v"},{"post_id":"cjs76ob73001xe0jcd7lwwa0o","category_id":"cjs76ob7b0029e0jcxuynkmsu","_id":"cjs76ob7j002oe0jco1zrzfsw"},{"post_id":"cjs76ob7g002ke0jc7jusc2f9","category_id":"cjs76ob67000ke0jc9nb75uwk","_id":"cjs76ob7n002ve0jcmh3z7xea"},{"post_id":"cjs76ob760021e0jc7cnv7d1f","category_id":"cjs76ob7f002ie0jc928xgtlv","_id":"cjs76ob7t002ze0jc3sqsaegg"},{"post_id":"cjs76ob780025e0jccj54c6m3","category_id":"cjs76ob7f002ie0jc928xgtlv","_id":"cjs76ob7w0034e0jcl98uu6kn"},{"post_id":"cjs76ob790028e0jcbw0jmovd","category_id":"cjs76ob7f002ie0jc928xgtlv","_id":"cjs76ob7x0039e0jch8hvjlsd"},{"post_id":"cjs76ob7u0032e0jc7mkgblze","category_id":"cjs76ob5o0003e0jc68t9xvtj","_id":"cjs76ob7y003be0jcrrc91qag"},{"post_id":"cjs76ob7c002ce0jcfpoi4j3f","category_id":"cjs76ob7f002ie0jc928xgtlv","_id":"cjs76ob7z003fe0jco2t868yb"},{"post_id":"cjs76ob7e002ge0jcwsgdenoj","category_id":"cjs76ob7f002ie0jc928xgtlv","_id":"cjs76ob7z003ie0jcbfwu2dn3"},{"post_id":"cjs76ob7h002ne0jch85dnx6j","category_id":"cjs76ob7y003ee0jc48jah2ay","_id":"cjs76ob80003ne0jc9ptb3crl"},{"post_id":"cjs76ob7k002re0jcwe7gmn1h","category_id":"cjs76ob80003ke0jceu0jxlpa","_id":"cjs76ob82003te0jcz9ci90vy"},{"post_id":"cjs76ob7l002ue0jck5pzboou","category_id":"cjs76ob81003qe0jc8ixjfczy","_id":"cjs76ob84003ye0jcer9qsevy"},{"post_id":"cjs76ob7o002ye0jcsdz8vm73","category_id":"cjs76ob82003ve0jcwd131phs","_id":"cjs76ob850042e0jcfbajdm9e"}],"PostTag":[{"post_id":"cjs76ob5x000ae0jcp2bpmumw","tag_id":"cjs76ob5q0004e0jcasjorkgw","_id":"cjs76ob62000fe0jcclluh8sm"},{"post_id":"cjs76ob5x000ae0jcp2bpmumw","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob66000ie0jcnhwvj1mk"},{"post_id":"cjs76ob5z000be0jc7eqa6hbh","tag_id":"cjs76ob5q0004e0jcasjorkgw","_id":"cjs76ob69000ne0jc9w5h4k5a"},{"post_id":"cjs76ob5z000be0jc7eqa6hbh","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob6d000qe0jcpowh1frl"},{"post_id":"cjs76ob5i0001e0jc44h6xkoy","tag_id":"cjs76ob5q0004e0jcasjorkgw","_id":"cjs76ob6f000ue0jcx0r2aazy"},{"post_id":"cjs76ob5i0001e0jc44h6xkoy","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob6h000xe0jc5rl7fjpu"},{"post_id":"cjs76ob5i0001e0jc44h6xkoy","tag_id":"cjs76ob61000ee0jcwd0khhrr","_id":"cjs76ob6j0011e0jcvj4hmwiq"},{"post_id":"cjs76ob66000je0jcfu5lhax7","tag_id":"cjs76ob5q0004e0jcasjorkgw","_id":"cjs76ob6l0015e0jcosyh7zdy"},{"post_id":"cjs76ob66000je0jcfu5lhax7","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob6o0019e0jccj1ogzr5"},{"post_id":"cjs76ob6a000oe0jcxyxf84o9","tag_id":"cjs76ob5q0004e0jcasjorkgw","_id":"cjs76ob6q001ce0jc2chfflqx"},{"post_id":"cjs76ob6a000oe0jcxyxf84o9","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob6s001he0jcfu317ti8"},{"post_id":"cjs76ob6d000re0jcpvg66g2s","tag_id":"cjs76ob5q0004e0jcasjorkgw","_id":"cjs76ob6x001ke0jcfnm43zuy"},{"post_id":"cjs76ob6d000re0jcpvg66g2s","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob70001pe0jcfu9hdjuj"},{"post_id":"cjs76ob6g000ve0jcj0myw39o","tag_id":"cjs76ob5q0004e0jcasjorkgw","_id":"cjs76ob71001se0jczys7swtb"},{"post_id":"cjs76ob6g000ve0jcj0myw39o","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob73001ve0jcx08lypnf"},{"post_id":"cjs76ob5m0002e0jcsucih7ex","tag_id":"cjs76ob5q0004e0jcasjorkgw","_id":"cjs76ob760020e0jc56d66xfb"},{"post_id":"cjs76ob5m0002e0jcsucih7ex","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob770023e0jc9dlrf5oa"},{"post_id":"cjs76ob6k0012e0jc0emmflez","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob790027e0jcll492mwe"},{"post_id":"cjs76ob5r0005e0jcfzoe92kv","tag_id":"cjs76ob5q0004e0jcasjorkgw","_id":"cjs76ob7c002be0jc85ptot0b"},{"post_id":"cjs76ob5r0005e0jcfzoe92kv","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob7e002fe0jcoi2baw68"},{"post_id":"cjs76ob5t0006e0jcpjpenub7","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob7f002je0jcc6vq8f72"},{"post_id":"cjs76ob5t0006e0jcpjpenub7","tag_id":"cjs76ob6z001oe0jc31bkhy1m","_id":"cjs76ob7h002me0jcrdx6uwxc"},{"post_id":"cjs76ob5u0007e0jcbh4wx8vn","tag_id":"cjs76ob5q0004e0jcasjorkgw","_id":"cjs76ob7j002qe0jchk3xrcy1"},{"post_id":"cjs76ob5u0007e0jcbh4wx8vn","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob7l002te0jchbva356o"},{"post_id":"cjs76ob62000ge0jctjlj01x5","tag_id":"cjs76ob5q0004e0jcasjorkgw","_id":"cjs76ob7o002xe0jcb3r01z12"},{"post_id":"cjs76ob62000ge0jctjlj01x5","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob7u0030e0jcm3o4xp9n"},{"post_id":"cjs76ob62000ge0jctjlj01x5","tag_id":"cjs76ob770024e0jcnv8yj7uj","_id":"cjs76ob7w0035e0jct03zno32"},{"post_id":"cjs76ob7g002ke0jc7jusc2f9","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob7w0036e0jcnfbearst"},{"post_id":"cjs76ob6h000ye0jcecm6hop3","tag_id":"cjs76ob7d002ee0jcdc4lz6m1","_id":"cjs76ob7x003ae0jcy43x0sih"},{"post_id":"cjs76ob6h000ye0jcecm6hop3","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob7y003ce0jclx0cjpeq"},{"post_id":"cjs76ob6h000ye0jcecm6hop3","tag_id":"cjs76ob7h002le0jcr5yq9wmb","_id":"cjs76ob7z003ge0jc1i5shq32"},{"post_id":"cjs76ob7u0032e0jc7mkgblze","tag_id":"cjs76ob5q0004e0jcasjorkgw","_id":"cjs76ob7z003he0jcy1ouyv65"},{"post_id":"cjs76ob7u0032e0jc7mkgblze","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob80003le0jcbvdmz5xh"},{"post_id":"cjs76ob6m0016e0jcgow1kvhv","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob80003me0jcabeb14gl"},{"post_id":"cjs76ob6m0016e0jcgow1kvhv","tag_id":"cjs76ob7l002se0jc4dq2otq9","_id":"cjs76ob80003oe0jcv3a3amtc"},{"post_id":"cjs76ob6m0016e0jcgow1kvhv","tag_id":"cjs76ob7u0031e0jcfx1b9vso","_id":"cjs76ob81003re0jcrqsuyxw5"},{"post_id":"cjs76ob6p001ae0jcltsrf5aw","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob81003se0jc6evrvdyg"},{"post_id":"cjs76ob6p001ae0jcltsrf5aw","tag_id":"cjs76ob7x0037e0jctiecghzh","_id":"cjs76ob83003we0jc0386g1d6"},{"post_id":"cjs76ob6q001de0jctpy14fim","tag_id":"cjs76ob7y003de0jch0u5bl5e","_id":"cjs76ob83003xe0jc8omisdg2"},{"post_id":"cjs76ob6q001de0jctpy14fim","tag_id":"cjs76ob7z003je0jcqfwivsul","_id":"cjs76ob840040e0jc1jhkhyg8"},{"post_id":"cjs76ob6u001ie0jcnhfso1ss","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob850041e0jchg3hyldy"},{"post_id":"cjs76ob6u001ie0jcnhfso1ss","tag_id":"cjs76ob80003pe0jc6g7op4pg","_id":"cjs76ob850044e0jcog6we4ab"},{"post_id":"cjs76ob6y001le0jclgn7ur0n","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob860045e0jcyvcfgfyt"},{"post_id":"cjs76ob6y001le0jclgn7ur0n","tag_id":"cjs76ob82003ue0jc7ouro15i","_id":"cjs76ob860046e0jc739lets1"},{"post_id":"cjs76ob70001qe0jcso5e1b04","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob870048e0jc23sm560e"},{"post_id":"cjs76ob70001qe0jcso5e1b04","tag_id":"cjs76ob84003ze0jcsc2a7byf","_id":"cjs76ob870049e0jc027lw2aw"},{"post_id":"cjs76ob72001te0jc4jhoadtd","tag_id":"cjs76ob850043e0jcm9zme30g","_id":"cjs76ob87004be0jcgh80n7vm"},{"post_id":"cjs76ob72001te0jc4jhoadtd","tag_id":"cjs76ob860047e0jcb1igjn0v","_id":"cjs76ob88004ce0jcdwsp6zer"},{"post_id":"cjs76ob73001xe0jcd7lwwa0o","tag_id":"cjs76ob850043e0jcm9zme30g","_id":"cjs76ob88004fe0jcv4ps35iw"},{"post_id":"cjs76ob73001xe0jcd7lwwa0o","tag_id":"cjs76ob88004de0jc0ctq8iz8","_id":"cjs76ob89004ge0jc2jqd4t6o"},{"post_id":"cjs76ob760021e0jc7cnv7d1f","tag_id":"cjs76ob88004ee0jc54brj70h","_id":"cjs76ob89004ie0jcvfzg3ddy"},{"post_id":"cjs76ob780025e0jccj54c6m3","tag_id":"cjs76ob88004ee0jc54brj70h","_id":"cjs76ob8a004ke0jc9nsx0w5z"},{"post_id":"cjs76ob790028e0jcbw0jmovd","tag_id":"cjs76ob88004ee0jc54brj70h","_id":"cjs76ob8b004me0jclmy95z2g"},{"post_id":"cjs76ob7c002ce0jcfpoi4j3f","tag_id":"cjs76ob88004ee0jc54brj70h","_id":"cjs76ob8b004oe0jcdv5m8rf4"},{"post_id":"cjs76ob7e002ge0jcwsgdenoj","tag_id":"cjs76ob88004ee0jc54brj70h","_id":"cjs76ob8c004qe0jc67bpcp4r"},{"post_id":"cjs76ob7h002ne0jch85dnx6j","tag_id":"cjs76ob8b004pe0jc384yx2br","_id":"cjs76ob8c004se0jc9gnayrf6"},{"post_id":"cjs76ob7k002re0jcwe7gmn1h","tag_id":"cjs76ob8c004re0jczmm8nzst","_id":"cjs76ob8d004ve0jcaoxuyfvm"},{"post_id":"cjs76ob7k002re0jcwe7gmn1h","tag_id":"cjs76ob8c004te0jc03yo85vl","_id":"cjs76ob8d004we0jc9szwhuai"},{"post_id":"cjs76ob7k002re0jcwe7gmn1h","tag_id":"cjs76ob5w0009e0jcha10ystc","_id":"cjs76ob8e004ye0jcmi2tveem"},{"post_id":"cjs76ob7l002ue0jck5pzboou","tag_id":"cjs76ob8d004ue0jcybggbxwn","_id":"cjs76ob8e0050e0jc36qs4zvw"},{"post_id":"cjs76ob7l002ue0jck5pzboou","tag_id":"cjs76ob8c004te0jc03yo85vl","_id":"cjs76ob8e0051e0jcgz9kaztz"},{"post_id":"cjs76ob7o002ye0jcsdz8vm73","tag_id":"cjs76ob8e004ze0jcldgbcdxb","_id":"cjs76ob8f0053e0jcr7nyy11w"},{"post_id":"cjs76ob7o002ye0jcsdz8vm73","tag_id":"cjs76ob7z003je0jcqfwivsul","_id":"cjs76ob8f0054e0jcpu46u1rh"}],"Tag":[{"name":"ES6","_id":"cjs76ob5q0004e0jcasjorkgw"},{"name":"js","_id":"cjs76ob5w0009e0jcha10ystc"},{"name":"Babel","_id":"cjs76ob61000ee0jcwd0khhrr"},{"name":"async&await","_id":"cjs76ob6z001oe0jc31bkhy1m"},{"name":"Array","_id":"cjs76ob770024e0jcnv8yj7uj"},{"name":"大数","_id":"cjs76ob7d002ee0jcdc4lz6m1"},{"name":"小数","_id":"cjs76ob7h002le0jcr5yq9wmb"},{"name":"文件","_id":"cjs76ob7l002se0jc4dq2otq9"},{"name":"file","_id":"cjs76ob7u0031e0jcfx1b9vso"},{"name":"深拷贝","_id":"cjs76ob7x0037e0jctiecghzh"},{"name":"flexible","_id":"cjs76ob7y003de0jch0u5bl5e"},{"name":"h5","_id":"cjs76ob7z003je0jcqfwivsul"},{"name":"数据类型检测","_id":"cjs76ob80003pe0jc6g7op4pg"},{"name":"正则表达式","_id":"cjs76ob82003ue0jc7ouro15i"},{"name":"节流与防抖","_id":"cjs76ob84003ze0jcsc2a7byf"},{"name":"css","_id":"cjs76ob850043e0jcm9zme30g"},{"name":"postcss","_id":"cjs76ob860047e0jcb1igjn0v"},{"name":"css动画","_id":"cjs76ob88004de0jc0ctq8iz8"},{"name":"webpack","_id":"cjs76ob88004ee0jc54brj70h"},{"name":"hexo","_id":"cjs76ob8b004pe0jc384yx2br"},{"name":"性能优化","_id":"cjs76ob8c004re0jczmm8nzst"},{"name":"浏览器","_id":"cjs76ob8c004te0jc03yo85vl"},{"name":"缓存","_id":"cjs76ob8d004ue0jcybggbxwn"},{"name":"视口","_id":"cjs76ob8e004ze0jcldgbcdxb"}]}}